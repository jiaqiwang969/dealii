<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_37.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-37 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-37 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_16.html">step-16</a>, <a class="el" href="step_40.html">step-40</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The test case</a>
        <li><a href="#Matrixvectorproductimplementation">Matrix-vector product implementation</a>
        <li><a href="#Combinationwithmultigrid">Combination with multigrid</a>
        <li><a href="#UsingCPUdependentinstructionsvectorization">Using CPU-dependent instructions (vectorization)</a>
        <li><a href="#Runningmultigridonlargescaleparallelcomputers">Running multigrid on large-scale parallel computers</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Matrixfreeimplementation">Matrix-free implementation</a>
      <ul>
        <li><a href="#Computationofcoefficient">Computation of coefficient</a>
        <li><a href="#LocalevaluationofLaplaceoperator">Local evaluation of Laplace operator</a>
      </ul>
        <li><a href="#LaplaceProblemclass">LaplaceProblem class</a>
      <ul>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_rhs">LaplaceProblem::assemble_rhs</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#LaplaceProblemoutput_results">LaplaceProblem::output_results</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
        <li><a href="#Comparisonwithasparsematrix">Comparison with a sparse matrix</a>
        <li><a href="#ResultsforlargescaleparallelcomputationsonSuperMUC"> Results for large-scale parallel computations on SuperMUC</a>
        <li><a href="#Adaptivity"> Adaptivity</a>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions</a>
      <ul>
        <li><a href="#Kellyerrorestimator"> Kelly error estimator </a>
        <li><a href="#Sharedmemoryparallelization"> Shared-memory parallelization</a>
        <li><a href="#InhomogeneousDirichletboundaryconditions"> Inhomogeneous Dirichlet boundary conditions </a>
      <ul>
        <li><a href="#UseFEEvaluationread_dof_values_plaintoavoidresolvingconstraints"> Use FEEvaluation::read_dof_values_plain() to avoid resolving constraints </a>
        <li><a href="#UseLaplaceOperatorwithasecondAffineConstraintsobjectwithoutDirichletconditions"> Use LaplaceOperator with a second AffineConstraints object without Dirichlet conditions </a>
    </ul>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Katharina Kormann and Martin Kronbichler.</em></p>
<p><em>The algorithm for the matrix-vector product is based on the article <a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">A generic interface for parallel cell-based finite element operator application</a> by Martin Kronbichler and Katharina Kormann, Computers and Fluids 63:135&ndash;147, 2012, and the paper &quot;Parallel finite element operator application: Graph partitioning and coloring&quot; by Katharina Kormann and Martin Kronbichler in: Proceedings of the 7th IEEE International Conference on e-Science, 2011.</em></p>
<p><em>This work was partly supported by the German Research Foundation (DFG) through the project "High-order discontinuous Galerkin for the exa-scale" (ExaDG) within the priority program "Software for Exascale Computing" (SPPEXA). The large-scale computations shown in the results section of this tutorial program were supported by Gauss Centre for Supercomputing e.V. (www.gauss-centre.eu) by providing computing time on the GCS Supercomputer SuperMUC at Leibniz Supercomputing Centre (LRZ, www.lrz.de) through project id pr83te. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example shows how to implement a matrix-free method, that is, a method that does not explicitly store the matrix elements, for a second-order Poisson equation with variable coefficients on a hypercube. The linear system will be solved with a multigrid method and uses large-scale parallelism with MPI.</p>
<p>The major motivation for matrix-free methods is the fact that on today's processors access to main memory (i.e., for objects that do not fit in the caches) has become the bottleneck in many solvers for partial differential equations: To perform a matrix-vector product based on matrices, modern CPUs spend far more time waiting for data to arrive from memory than on actually doing the floating point multiplications and additions. Thus, if we could substitute looking up matrix elements in memory by re-computing them &mdash; or rather, the operator represented by these entries &mdash;, we may win in terms of overall run-time even if this requires a significant number of additional floating point operations. That said, to realize this with a trivial implementation is not enough and one needs to really look at the details to gain in performance. This tutorial program and the papers referenced above show how one can implement such a scheme and demonstrates the speedup that can be obtained.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>In this example, we consider the Poisson problem </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot a(\mathbf x) \nabla u &amp;=&amp; 1, \\ u &amp;=&amp; 0 \quad \text{on}\ \partial \Omega \end{eqnarray*}
</p>
<p> where \(a(\mathbf x)\) is a variable coefficient. Below, we explain how to implement a matrix-vector product for this problem without explicitly forming the matrix. The construction can, of course, be done in a similar way for other equations as well.</p>
<p>We choose as domain \(\Omega=[0,1]^3\) and \(a(\mathbf x)=\frac{1}{0.05 + 2\|\mathbf x\|^2}\). Since the coefficient is symmetric around the origin but the domain is not, we will end up with a non-symmetric solution.</p>
<p><a class="anchor" id="Matrixvectorproductimplementation"></a></p><h3>Matrix-vector product implementation</h3>
<p>In order to find out how we can write a code that performs a matrix-vector product, but does not need to store the matrix elements, let us start at looking how a finite element matrix <em>A</em> is assembled: </p><p class="formulaDsp">
\begin{eqnarray*} A = \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_{\mathrm{cell,{loc-glob}}}^T A_{\mathrm{cell}} P_{\mathrm{cell,{loc-glob}}}. \end{eqnarray*}
</p>
<p> In this formula, the matrix <em>P</em><sub>cell,loc-glob</sub> is a rectangular matrix that defines the index mapping from local degrees of freedom in the current cell to the global degrees of freedom. The information from which this operator can be built is usually encoded in the <code>local_dof_indices</code> variable and is used in the assembly calls filling matrices in deal.II. Here, <em>A</em><sub>cell</sub> denotes the cell matrix associated with <em>A</em>.</p>
<p>If we are to perform a matrix-vector product, we can hence use that </p><p class="formulaDsp">
\begin{eqnarray*} y &amp;=&amp; A\cdot u = \left(\sum_{\text{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} P_\mathrm{cell,{loc-glob}}\right) \cdot u \\ &amp;=&amp; \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} u_\mathrm{cell} \\ &amp;=&amp; \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}, \end{eqnarray*}
</p>
<p> where <em>u</em><sub>cell</sub> are the values of <em>u</em> at the degrees of freedom of the respective cell, and <em>v</em><sub>cell</sub>=<em>A</em><sub>cell</sub><em>u</em><sub>cell</sub> correspondingly for the result. A naive attempt to implement the local action of the Laplacian would hence be to use the following code: </p><div class="fragment"><div class="line">Matrixfree&lt;dim&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>|</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_src (dofs_per_cell),</div><div class="line">                       cell_dst (dofs_per_cell);</div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div><div class="line">  std::vector&lt;double&gt; coefficient_values(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a> (cell);</div><div class="line">      coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             coefficient_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i,q) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j,q) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q)*</div><div class="line">                                 coefficient_values[q]);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        cell_src(i) = src(local_dof_indices(i));</div><div class="line"></div><div class="line">      cell_matrix.<a class="code" href="classFullMatrix.html#a65a409eeef6388d99ac15e2bbe8045f6">vmult</a> (cell_dst, cell_src);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        dst(local_dof_indices(i)) += cell_dst;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Here we neglected boundary conditions as well as any hanging nodes we may have, though neither would be very difficult to include using the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class. Note how we first generate the local matrix in the usual way as a sum over all quadrature points for each local matrix entry. To form the actual product as expressed in the above formula, we extract the values of <code>src</code> of the cell-related degrees of freedom (the action of <em>P</em><sub>cell,loc-glob</sub>), multiply by the local matrix (the action of <em>A</em><sub>cell</sub>), and finally add the result to the destination vector <code>dst</code> (the action of <em>P</em><sub>cell,loc-glob</sub><sup>T</sup>, added over all the elements). It is not more difficult than that, in principle.</p>
<p>While this code is completely correct, it is very slow. For every cell, we generate a local matrix, which takes three nested loops with loop length equal to the number of local degrees of freedom to compute. The multiplication itself is then done by two nested loops, which means that it is much cheaper.</p>
<p>One way to improve this is to realize that conceptually the local matrix can be thought of as the product of three matrices, </p><p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell}, \end{eqnarray*}
</p>
<p> where for the example of the Laplace operator the (<em>q</em>*dim+<em>d,i</em>)-th element of <em>B</em><sub>cell</sub> is given by <code>fe_values.shape_grad(i,q)[d]</code>. This matrix consists of <code>dim*n_q_points</code> rows and <code>dofs_per_cell</code> columns. The matrix <em>D</em><sub>cell</sub> is diagonal and contains the values <code>fe_values.JxW(q) * coefficient_values[q]</code> (or, rather, <code>dim</code> copies of each of these values). This kind of representation of finite element matrices can often be found in the engineering literature.</p>
<p>When the cell matrix is applied to a vector, </p><p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell}\cdot u_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell} \cdot u_\mathrm{cell}, \end{eqnarray*}
</p>
<p> one would then not form the matrix-matrix products, but rather multiply one matrix at a time with a vector from right to left so that only three successive matrix-vector products are formed. This approach removes the three nested loops in the calculation of the local matrix, which reduces the complexity of the work on one cell from something like \(\mathcal {O}(\mathrm{dofs\_per\_cell}^3)\) to \(\mathcal {O}(\mathrm{dofs\_per\_cell}^2)\). An interpretation of this algorithm is that we first transform the vector of values on the local DoFs to a vector of gradients on the quadrature points. In the second loop, we multiply these gradients by the integration weight and the coefficient. The third loop applies the second gradient (in transposed form), so that we get back to a vector of (Laplacian) values on the cell dofs.</p>
<p>The bottleneck in the above code is the operations done by the call to <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> for every <code>cell</code>, which take about as much time as the other steps together (at least if the mesh is unstructured; deal.II can recognize that the gradients are often unchanged on structured meshes). That is certainly not ideal and we would like to do better than this. What the reinit function does is to calculate the gradient in real space by transforming the gradient on the reference cell using the Jacobian of the transformation from real to reference cell. This is done for each basis function on the cell, for each quadrature point. The Jacobian does not depend on the basis function, but it is different on different quadrature points in general. If you only build the matrix once as we've done in all previous tutorial programs, there is nothing to be optimized since <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> needs to be called on every cell. In this process, the transformation is applied while computing the local matrix elements.</p>
<p>In a matrix-free implementation, however, we will compute those integrals very often because iterative solvers will apply the matrix many times during the solution process. Therefore, we need to think about whether we may be able to cache some data that gets reused in the operator applications, i.e., integral computations. On the other hand, we realize that we must not cache too much data since otherwise we get back to the situation where memory access becomes the dominating factor. Therefore, we will not store the transformed gradients in the matrix <em>B</em>, as they would in general be different for each basis function and each quadrature point on every element for curved meshes.</p>
<p>The trick is to factor out the Jacobian transformation and first apply the gradient on the reference cell only. This operation interpolates the vector of values on the local dofs to a vector of (unit-coordinate) gradients on the quadrature points. There, we first apply the Jacobian that we factored out from the gradient, then apply the weights of the quadrature, and finally apply the transposed Jacobian for preparing the third loop which tests by the gradients on the unit cell and sums over quadrature points.</p>
<p>Let us again write this in terms of matrices. Let the matrix <em>B</em><sub>cell</sub> denote the cell-related gradient matrix, with each row containing the values on the quadrature points. It is constructed by a matrix-matrix product as </p><p class="formulaDsp">
\begin{eqnarray*} B_\mathrm{cell} = J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell}, \end{eqnarray*}
</p>
<p> where <em>B</em><sub>ref_cell</sub> denotes the gradient on the reference cell and <em>J</em><sup>-T</sup><sub>cell</sub> denotes the inverse transpose Jacobian of the transformation from unit to real cell (in the language of transformations, the operation represented by <em>J</em><sup>-T</sup><sub>cell</sub> represents a covariant transformation). <em>J</em><sup>-T</sup><sub>cell</sub> is block-diagonal, and the blocks size is equal to the dimension of the problem. Each diagonal block is the Jacobian transformation that goes from the reference cell to the real cell.</p>
<p>Putting things together, we find that </p><p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell} = B_\mathrm{cell}^T D B_\mathrm{cell} = B_\mathrm{ref\_cell}^T J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell}, \end{eqnarray*}
</p>
<p> so we calculate the product (starting the local product from the right) </p><p class="formulaDsp">
\begin{eqnarray*} v_\mathrm{cell} = B_\mathrm{ref\_cell}^T J_\mathrm{cell}^{-1} D J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell} u_\mathrm{cell}, \quad v = \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}. \end{eqnarray*}
</p>
 <div class="fragment"><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_reference (fe, quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="namespaceGridGenerator.html#aeb9a83e353f8d69ce49ebdd191a3a51f">reference_cell</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(reference_cell, 0., 1.);</div><div class="line">  fe_values_reference.reinit (reference_cell.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fac654119724aff0c394743170ae949d18">update_inverse_jacobians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a> (cell);</div><div class="line">      coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             coefficient_values);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        cell_src(i) = src(local_dof_indices(i));</div><div class="line"></div><div class="line">      temp_vector = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            temp_vector(q*dim+d) +=</div><div class="line">              fe_values_reference.shape_grad(i,q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] * cell_src(i);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="comment">// apply the transposed inverse Jacobian of the mapping</span></div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> temp;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp[d] = temp_vector(q*dim+d);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            {</div><div class="line">              <span class="keywordtype">double</span> sum = 0;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e=0; e&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div><div class="line">                sum += fe_values.<a class="code" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian</a>(q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] *</div><div class="line">                               temp[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>];</div><div class="line">              temp_vector(q*dim+d) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="comment">// multiply by coefficient and integration weight</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp_vector(q*dim+d) *= fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) * coefficient_values[q];</div><div class="line"></div><div class="line">          <span class="comment">// apply the inverse Jacobian of the mapping</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp[d] = temp_vector(q*dim+d);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            {</div><div class="line">              <span class="keywordtype">double</span> sum = 0;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e=0; e&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div><div class="line">                sum += fe_values.<a class="code" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian</a>(q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>] *</div><div class="line">                       temp[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>];</div><div class="line">              temp_vector(q*dim+d) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell_dst = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            cell_dst(i) += fe_values_reference.shape_grad(i,q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] *</div><div class="line">                                   temp_vector(q*dim+d);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        dst(local_dof_indices(i)) += cell_dst(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Note how we create an additional <a class="el" href="classFEValues.html">FEValues</a> object for the reference cell gradients and how we initialize it to the reference cell. The actual derivative data is then applied by the inverse, transposed Jacobians (deal.II calls the Jacobian matrix from real to unit cell inverse_jacobian, as the forward transformation is from unit to real cell). The factor \(J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T}\) is block-diagonal over quadrature. In this form, one realizes that variable coefficients (possibly expressed through a tensor) and general grid topologies with Jacobian transformations have a similar effect on the coefficient transforming the unit-cell derivatives.</p>
<p>At this point, one might wonder why we store the matrix \(J_\mathrm{cell}^{-\mathrm T}\) and the coefficient separately, rather than only the complete factor \(J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T}\). The latter would use less memory because the tensor is symmetric with six independent values in 3D, whereas for the former we would need nine entries for the inverse transposed Jacobian, one for the quadrature weight and Jacobian determinant, and one for the coefficient, totaling to 11 doubles. The reason is that the former approach allows for implementing generic differential operators through a common framework of cached data, whereas the latter specifically stores the coefficient for the Laplacian. In case applications demand for it, this specialization could pay off and would be worthwhile to consider. Note that the implementation in deal.II is smart enough to detect Cartesian or affine geometries where the Jacobian is constant throughout the cell and needs not be stored for every cell (and indeed often is the same over different cells as well).</p>
<p>The final optimization that is most crucial from an operation count point of view is to make use of the tensor product structure in the basis functions. This is possible because we have factored out the gradient from the reference cell operation described by <em>B</em><sub>ref_cell</sub>, i.e., an interpolation operation over the completely regular data fields of the reference cell. We illustrate the process of complexity reduction in two space dimensions, but the same technique can be used in higher dimensions. On the reference cell, the basis functions are of the tensor product form \(\phi(x,y,z) = \varphi_i(x) \varphi_j(y)\). The part of the matrix <em>B</em><sub>ref_cell</sub> that computes the first component has the form \(B_\mathrm{sub\_cell}^x = B_\mathrm{grad,x} \otimes B_\mathrm{val,y}\), where <em>B</em><sub>grad,x</sub> and <em>B</em><sub>val,y</sub> contain the evaluation of all the 1D basis functions on all the 1D quadrature points. Forming a matrix <em>U</em> with <em>U(j,i)</em> containing the coefficient belonging to basis function \(\varphi_i(x) \varphi_j(y)\), we get \((B_\mathrm{grad,x} \otimes B_\mathrm{val,y})u_\mathrm{cell} = B_\mathrm{val,y} U B_\mathrm{grad,x}\). This reduces the complexity for computing this product from \(p^4\) to \(2 p^3\), where <em>p</em>-1 is the degree of the finite element (i.e., equivalently, <em>p</em> is the number of shape functions in each coordinate direction), or \(p^{2d}\) to \(d p^{d+1}\) in general. The reason why we look at the complexity in terms of the polynomial degree is since we want to be able to go to high degrees and possibly increase the polynomial degree <em>p</em> instead of the grid resolution. Good algorithms for moderate degrees like the ones used here are linear in the polynomial degree independent on the dimension, as opposed to matrix-based schemes or naive evaluation through <a class="el" href="classFEValues.html">FEValues</a>. The techniques used in the implementations of deal.II have been established in the spectral element community since the 1980s.</p>
<p>Implementing a matrix-free and cell-based finite element operator requires a somewhat different program design as compared to the usual matrix assembly codes shown in previous tutorial programs. The data structures for doing this are the <a class="el" href="classMatrixFree.html">MatrixFree</a> class that collects all data and issues a (parallel) loop over all cells and the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class that evaluates finite element basis functions by making use of the tensor product structure.</p>
<p>The implementation of the matrix-free matrix-vector product shown in this tutorial is slower than a matrix-vector product using a sparse matrix for linear elements, but faster for all higher order elements thanks to the reduced complexity due to the tensor product structure and due to less memory transfer during computations. The impact of reduced memory transfer is particularly beneficial when working on a multicore processor where several processing units share access to memory. In that case, an algorithm which is computation bound will show almost perfect parallel speedup (apart from possible changes of the processor's clock frequency through turbo modes depending on how many cores are active), whereas an algorithm that is bound by memory transfer might not achieve similar speedup (even when the work is perfectly parallel and one could expect perfect scaling like in sparse matrix-vector products). An additional gain with this implementation is that we do not have to build the sparse matrix itself, which can also be quite expensive depending on the underlying differential equation. Moreover, the above framework is simple to generalize to nonlinear operations, as we demonstrate in <a class="el" href="step_48.html">step-48</a>.</p>
<p><a class="anchor" id="Combinationwithmultigrid"></a></p><h3>Combination with multigrid</h3>
<p>Above, we have gone to significant lengths to implement a matrix-vector product that does not actually store the matrix elements. In many user codes, however, one wants more than just doing a few matrix-vector products &mdash; one wants to do as few of these operations as possible when solving linear systems. In theory, we could use the CG method without preconditioning; however, that would not be very efficient for the Laplacian. Rather, preconditioners are used for increasing the speed of convergence. Unfortunately, most of the more frequently used preconditioners such as SSOR, ILU or algebraic multigrid (AMG) cannot be used here because their implementation requires knowledge of the elements of the system matrix.</p>
<p>One solution is to use geometric multigrid methods as shown in <a class="el" href="step_16.html">step-16</a>. They are known to be very fast, and they are suitable for our purpose since all ingredients, including the transfer between different grid levels, can be expressed in terms of matrix-vector products related to a collection of cells. All one needs to do is to find a smoother that is based on matrix-vector products rather than all the matrix entries. One such candidate would be a damped Jacobi iteration that requires access to the matrix diagonal, but it is often not sufficiently good in damping all high-frequency errors. The properties of the Jacobi method can be improved by iterating it a few times with the so-called Chebyshev iteration. The Chebyshev iteration is described by a polynomial expression of the matrix-vector product where the coefficients can be chosen to achieve certain properties, in this case to smooth the high-frequency components of the error which are associated to the eigenvalues of the Jacobi-preconditioned matrix. At degree zero, the Jacobi method with optimal damping parameter is retrieved, whereas higher order corrections are used to improve the smoothing properties. The effectiveness of Chebyshev smoothing in multigrid has been demonstrated, e.g., in the article <a href="http://www.sciencedirect.com/science/article/pii/S0021999103001943"><em>M. Adams, M. Brezina, J. Hu, R. Tuminaro. Parallel multigrid smoothers: polynomial versus Gauss&ndash;Seidel, J. Comput. Phys. 188:593&ndash;610, 2003</em></a>. This publication also identifies one more advantage of Chebyshev smoothers that we exploit here, namely that they are easy to parallelize, whereas SOR/Gauss&ndash;Seidel smoothing relies on substitutions, for which a naive parallelization works on diagonal sub-blocks of the matrix, thereby decreases efficiency (for more detail see e.g. Y. Saad, Iterative Methods for Sparse Linear Systems, SIAM, 2nd edition, 2003, chapters 11 &amp; 12).</p>
<p>The implementation into the multigrid framework is then straightforward. The multigrid implementation in this program is similar to <a class="el" href="step_16.html">step-16</a> and includes adaptivity.</p>
<p><a class="anchor" id="UsingCPUdependentinstructionsvectorization"></a></p><h3>Using CPU-dependent instructions (vectorization)</h3>
<p>The computational kernels for evaluation in <a class="el" href="classFEEvaluation.html">FEEvaluation</a> are written in a way to optimally use computational resources. To achieve this, they do not operate on double data types, but something we call <a class="el" href="classVectorizedArray.html">VectorizedArray</a> (check e.g. the return type of <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">FEEvaluationBase::get_value</a>, which is <a class="el" href="classVectorizedArray.html">VectorizedArray</a> for a scalar element and a <a class="el" href="classTensor.html">Tensor</a> of <a class="el" href="classVectorizedArray.html">VectorizedArray</a> for a vector finite element). <a class="el" href="classVectorizedArray.html">VectorizedArray</a> is a short array of doubles or float whose length depends on the particular computer system in use. For example, systems based on x86-64 support the streaming SIMD extensions (SSE), where the processor's vector units can process two doubles (or four single-precision floats) by one CPU instruction. Newer processors (from about 2012 and onwards) support the so-called advanced vector extensions (AVX) with 256 bit operands, which can use four doubles and eight floats, respectively. Vectorization is a single-instruction/multiple-data (SIMD) concept, that is, one CPU instruction is used to process multiple data values at once. Often, finite element programs do not use vectorization explicitly as the benefits of this concept are only in arithmetic intensive operations. The bulk of typical finite element workloads are memory bandwidth limited (operations on sparse matrices and vectors) where the additional computational power is useless.</p>
<p>Behind the scenes, optimized BLAS packages might heavily rely on vectorization, though. Also, optimizing compilers might automatically transform loops involving standard code into more efficient vectorized form (deal.II uses OpenMP SIMD pragmas inside the regular loops of vector updates). However, the data flow must be very regular in order for compilers to produce efficient code. For example, already the automatic vectorization of the prototype operation that benefits from vectorization, matrix-matrix products, fails on most compilers (as of writing this tutorial in early 2012 and updating in late 2016, neither gcc nor the Intel compiler manage to produce useful vectorized code for the <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a> function, and not even on the simpler case where the matrix bounds are compile-time constants instead of run-time constants as in <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a>). The main reason for this is that the information to be processed at the innermost loop (that is where vectorization is applied) is not necessarily a multiple of the vector length, leaving parts of the resources unused. Moreover, the data that can potentially be processed together might not be laid out in a contiguous way in memory or not with the necessary alignment to address boundaries that are needed by the processor. Or the compiler might not be able to prove that data arrays do not overlap when loading several elements at once.</p>
<p>In the matrix-free implementation in deal.II, we have therefore chosen to apply vectorization at the level which is most appropriate for finite element computations: The cell-wise computations are typically exactly the same for all cells (except for indices in the indirect addressing used while reading from and writing to vectors), and hence SIMD can be used to process several cells at once. In all what follows, you can think of a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> to hold data from several cells. Remember that it is not related to the spatial dimension and the number of elements e.g. in a <a class="el" href="classTensor.html">Tensor</a> or <a class="el" href="classPoint.html">Point</a>.</p>
<p>Note that vectorization depends on the CPU the code is running on and for which the code is compiled. In order to generate the fastest kernels of <a class="el" href="classFEEvaluation.html">FEEvaluation</a> for your computer, you should compile deal.II with the so-called <em>native</em> processor variant. When using the gcc compiler, it can be enabled by setting the variable <code>CMAKE_CXX_FLAGS</code> to <code>"-march=native"</code> in the cmake build settings (on the command line, specify <code>-DCMAKE_CXX_FLAGS="-march=native"</code>, see the deal.II README for more information). Similar options exist for other compilers. We output the current vectorization length in the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function of this example.</p>
<p><a class="anchor" id="Runningmultigridonlargescaleparallelcomputers"></a></p><h3>Running multigrid on large-scale parallel computers</h3>
<p>As mentioned above, all components in the matrix-free framework can easily be parallelized with MPI using domain decomposition. Thanks to the easy access to large-scale parallel meshes through p4est (see <a class="el" href="step_40.html">step-40</a> for details) in deal.II, and the fact that cell-based loops with matrix-free evaluation <em>only</em> need a decomposition of the mesh into chunks of roughly equal size on each processor, there is relatively little to do to write a parallel program working with distributed memory. While other tutorial programs using MPI have relied on either PETSc or Trilinos, this program uses deal.II's own parallel vector facilities.</p>
<p>The deal.II parallel vector class, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>, holds the processor-local part of the solution as well as data fields for ghosted DoFs, i.e. DoFs that are owned by a remote processor but accessed by cells that are owned by the present processor. In the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">glossary</a> these degrees of freedom are referred to as locally active degrees of freedom. The function <a class="el" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">MatrixFree::initialize_dof_vector()</a> provides a method that sets this design. Note that hanging nodes can relate to additional ghosted degrees of freedom that must be included in the distributed vector but are not part of the locally active DoFs in the sense of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">glossary</a>. Moreover, the distributed vector holds the MPI metadata for DoFs that are owned locally but needed by other processors. A benefit of the design of this vector class is the way ghosted entries are accessed. In the storage scheme of the vector, the data array extends beyond the processor-local part of the solution with further vector entries available for the ghosted degrees of freedom. This gives a contiguous index range for all locally active degrees of freedom. (Note that the index range depends on the exact configuration of the mesh.) Since matrix-free operations can be thought of doing linear algebra that is performance critical, and performance-critical code cannot waste time on doing MPI-global to MPI-local index translations, the availability of an index spaces local to one MPI rank is fundamental. The way things are accessed here is a direct array access. This is provided through <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">LinearAlgebra::distributed::Vector::local_element()</a>, but it is actually rarely needed because all of this happens internally in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>.</p>
<p>The design of <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> is similar to the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> data types we have used in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_32.html">step-32</a> before, but since we do not need any other parallel functionality of these libraries, we use the <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class of deal.II instead of linking in another large library in this tutorial program. Also note that the PETSc and Trilinos vectors do not provide the fine-grained control over ghost entries with direct array access because they abstract away the necessary implementation details.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First include the necessary files from the deal.II library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>This includes the data structures for the efficient implementation of matrix-free methods or more generic finite element operators with the class <a class="el" href="classMatrixFree.html">MatrixFree</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step37</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>To be efficient, the operations performed in the matrix-free implementation require knowledge of loop lengths at compile time, which are given by the degree of the finite element. Hence, we collect the values of the two template parameters that can be changed at one place in the code. Of course, one could make the degree of the finite element a run-time parameter by compiling the computational kernels for all degrees that are likely (say, between 1 and 6) and selecting the appropriate kernel at run time. Here, we simply choose second order \(Q_2\) elements and choose dimension 3 as standard.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_finite_element = 2;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension             = 3;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>We define a variable coefficient function for the Poisson problem. It is similar to the function in <a class="el" href="step_5.html">step-5</a> but we use the form \(a(\mathbf x)=\frac{1}{0.05 + 2\|\bf x\|^2}\) instead of a discontinuous one. It is merely to demonstrate the possibilities of this implementation, rather than making much sense physically. We define the coefficient in the same way as functions in earlier tutorial programs. There is one new function, namely a <code>value</code> method with template argument <code>number</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">  number <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        component = 0) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>This is the new function mentioned above: Evaluate the coefficient for abstract type <code>number</code>. It might be just a usual double, but it can also be a somewhat more complicated type that we call <a class="el" href="classVectorizedArray.html">VectorizedArray</a>. This data type is essentially a short array of doubles as discussed in the introduction that holds data from several cells. For example, we evaluate the coefficient shown here not on a simple point as usually done, but we hand it a <a class="el" href="classPoint.html">Point</a>&lt;dim,<a class="el" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> &gt; point, which is actually a collection of four points in the case of AVX. Do not confuse the entries in <a class="el" href="classVectorizedArray.html">VectorizedArray</a> with the different coordinates of the point. Indeed, the data is laid out such that <code>p[0]</code> returns a <a class="el" href="classVectorizedArray.html">VectorizedArray</a>, which in turn contains the x-coordinate for the first point and the second point. You may access the coordinates individually using e.g. <code>p[0][j]</code>, j=0,1,2,3, but it is recommended to define operations on a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> as much as possible in order to make use of vectorized operations.</p>
<p>In the function implementation, we assume that the number type overloads basic arithmetic operations, so we just write the code as usual. The base class function <code>value</code> is then computed from the templated function with double type, in order to avoid duplicating code.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">number Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1. / (0.05 + 2. * p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> value&lt;double&gt;(p, component);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Matrixfreeimplementation"></a> </p><h3>Matrix-free implementation</h3>
<p>The following class, called <code>LaplaceOperator</code>, implements the differential operator. For all practical purposes, it is a matrix, i.e., you can ask it for its size (member functions <code>m(), n()</code>) and you can apply it to a vector (the <code>vmult()</code> function). The difference to a real matrix of course lies in the fact that this class does not actually store the <em>elements</em> of the matrix, but only knows how to compute the action of the operator when applied to a vector.</p>
<p>The infrastructure describing the matrix size, the initialization from a <a class="el" href="classMatrixFree.html">MatrixFree</a> object, and the various interfaces to matrix-vector products through vmult() and Tvmult() methods, is provided by the class MatrixFreeOperator::Base from which this class derives. The LaplaceOperator class defined here only has to provide a few interfaces, namely the actual action of the operator through the apply_add() method that gets used in the vmult() functions, and a method to compute the diagonal entries of the underlying matrix. We need the diagonal for the definition of the multigrid smoother. Since we consider a problem with variable coefficient, we further implement a method that can fill the coefficient values.</p>
<p>Note that the file <code>include/deal.II/matrix_free/operators.h</code> already contains an implementation of the Laplacian through the class <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a>. For educational purposes, the operator is re-implemented in this tutorial program, explaining the ingredients and concepts used there.</p>
<p>This program makes use of the data cache for finite element operator application that is integrated in deal.II. This data cache class is called <a class="el" href="classMatrixFree.html">MatrixFree</a>. It contains mapping information (Jacobians) and index relations between local and global degrees of freedom. It also contains constraints like the ones from hanging nodes or Dirichlet boundary conditions. Moreover, it can issue a loop over all cells in parallel, making sure that only cells are worked on that do not share any degree of freedom (this makes the loop thread-safe when writing into destination vectors). This is a more advanced strategy compared to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class described in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> module. Of course, to not destroy thread-safety, we have to be careful when writing into class-global structures.</p>
<p>The class implementing the Laplace operator has three template arguments, one for the dimension (as many deal.II classes carry), one for the degree of the finite element (which we need to enable efficient computations through the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class), and one for the underlying scalar type. We want to use <code>double</code> numbers (i.e., double precision, 64-bit floating point) for the final matrix, but floats (single precision, 32-bit floating point numbers) for the multigrid level matrices (as that is only a preconditioner, and floats can be processed twice as fast). The class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> also takes a template argument for the number of quadrature points in one dimension. In the code below, we hard-code it to <code>fe_degree+1</code>. If we wanted to change it independently of the polynomial degree, we would need to add a template parameter as is done in the <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a> class.</p>
<p>As a sidenote, if we implemented several different operations on the same grid and degrees of freedom (like a mass matrix and a Laplace matrix), we would define two classes like the current one for each of the operators (derived from the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class), and let both of them refer to the same <a class="el" href="classMatrixFree.html">MatrixFree</a> data cache from the general problem class. The interface through <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> requires us to only provide a minimal set of functions. This concept allows for writing complex application codes with many matrix-free operations.</p>
<dl class="section note"><dt>Note</dt><dd>Storing values of type <code>VectorizedArray&lt;number&gt;</code> requires care: Here, we use the deal.II table class which is prepared to hold the data with correct alignment. However, storing e.g. an <code>std::vector&lt;VectorizedArray&lt;number&gt; &gt;</code> is not possible with vectorization: A certain alignment of the data with the memory address boundaries is required (essentially, a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> that is 32 bytes long in case of AVX needs to start at a memory address that is divisible by 32). The table class (as well as the <a class="el" href="classAlignedVector.html">AlignedVector</a> class it is based on) makes sure that this alignment is respected, whereas std::vector does not in general, which may lead to segmentation faults at strange places for some systems or suboptimal performance for other systems.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keyword">class </span>LaplaceOperator</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">      Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">  LaplaceOperator();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_coefficient(<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">              <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">              <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_compute_diagonal(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;              data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp; dst,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                         dummy,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; coefficient;</div><div class="line">};</div></div><!-- fragment --><p>This is the constructor of the <code>LaplaceOperator</code> class. All it does is to call the default constructor of the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, which in turn is based on the <a class="el" href="classSubscriptor.html">Subscriptor</a> class that asserts that this class is not accessed after going out of scope e.g. in a preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">LaplaceOperator&lt;dim, fe_degree, number&gt;::LaplaceOperator()</div><div class="line">  : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                              <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="classVector.html">Vector</a>&lt;number&gt;&gt;()</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">{</div><div class="line">  coefficient.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(0, 0);</div><div class="line">  <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">    clear();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computationofcoefficient"></a> </p><h4>Computation of coefficient</h4>
<p>To initialize the coefficient, we directly give it the Coefficient class defined above and then select the method <code>coefficient_function.value</code> with vectorized number (which the compiler can deduce from the point data type). The use of the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class (and its template arguments) will be explained below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::evaluate_coefficient(</div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;n_cell_batches();</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line">  coefficient.reinit(n_cells, phi.n_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        coefficient(cell, q) =</div><div class="line">          coefficient_function.value(phi.quadrature_point(q));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LocalevaluationofLaplaceoperator"></a> </p><h4>Local evaluation of Laplace operator</h4>
<p>Here comes the main function of this class, the evaluation of the matrix-vector product (or, in general, a finite element operator evaluation). This is done in a function that takes exactly four arguments, the <a class="el" href="classMatrixFree.html">MatrixFree</a> object, the destination and source vectors, and a range of cells that are to be worked on. The method <code>cell_loop</code> in the <a class="el" href="classMatrixFree.html">MatrixFree</a> class will internally call this function with some range of cells that is obtained by checking which cells are possible to work on simultaneously so that write operations do not cause any race condition. Note that the cell range used in the loop is not directly the number of (active) cells in the current mesh, but rather a collection of batches of cells. In other word, "cell" may be the wrong term to begin with, since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> groups data from several cells together. This means that in the loop over quadrature points we are actually seeing a group of quadrature points of several cells as one block. This is done to enable a higher degree of vectorization. The number of such "cells" or "cell batches" is stored in <a class="el" href="classMatrixFree.html">MatrixFree</a> and can be queried through <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a>. Compared to the deal.II cell iterators, in this class all cells are laid out in a plain array with no direct knowledge of level or neighborship relations, which makes it possible to index the cells by unsigned integers.</p>
<p>The implementation of the Laplace operator is quite simple: First, we need to create an object <a class="el" href="classFEEvaluation.html">FEEvaluation</a> that contains the computational kernels and has data fields to store temporary results (e.g. gradients evaluated on all quadrature points on a collection of a few cells). Note that temporary results do not use a lot of memory, and since we specify template arguments with the element order, the data is stored on the stack (without expensive memory allocation). Usually, one only needs to set two template arguments, the dimension as a first argument and the degree of the finite element as the second argument (this is equal to the number of degrees of freedom per dimension minus one for <a class="el" href="classFE__Q.html">FE_Q</a> elements). However, here we also want to be able to use float numbers for the multigrid preconditioner, which is the last (fifth) template argument. Therefore, we cannot rely on the default template arguments and must also fill the third and fourth field, consequently. The third argument specifies the number of quadrature points per direction and has a default value equal to the degree of the element plus one. The fourth argument sets the number of components (one can also evaluate vector-valued functions in systems of PDEs, but the default is a scalar element), and finally the last argument sets the number type.</p>
<p>Next, we loop over the given cell range and then we continue with the actual implementation: </p><ol>
<li>
Tell the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object the (macro) cell we want to work on. </li>
<li>
Read in the values of the source vectors (<code>read_dof_values</code>), including the resolution of constraints. This stores \(u_\mathrm{cell}\) as described in the introduction. </li>
<li>
Compute the unit-cell gradient (the evaluation of finite element functions). Since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> can combine value computations with gradient computations, it uses a unified interface to all kinds of derivatives of order between zero and two. We only want gradients, no values and no second derivatives, so we set the function arguments to true in the gradient slot (second slot), and to false in the values slot (first slot). There is also a third slot for the Hessian which is false by default, so it needs not be given. Note that the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class internally evaluates shape functions in an efficient way where one dimension is worked on at a time (using the tensor product form of shape functions and quadrature points as mentioned in the introduction). This gives complexity equal to \(\mathcal O(d^2 (p+1)^{d+1})\) for polynomial degree \(p\) in \(d\) dimensions, compared to the naive approach with loops over all local degrees of freedom and quadrature points that is used in <a class="el" href="classFEValues.html">FEValues</a> and costs \(\mathcal O(d (p+1)^{2d})\). </li>
<li>
Next comes the application of the Jacobian transformation, the multiplication by the variable coefficient and the quadrature weight. <a class="el" href="classFEEvaluation.html">FEEvaluation</a> has an access function <code>get_gradient</code> that applies the Jacobian and returns the gradient in real space. Then, we just need to multiply by the (scalar) coefficient, and let the function <code>submit_gradient</code> apply the second Jacobian (for the test function) and the quadrature weight and Jacobian determinant (JxW). Note that the submitted gradient is stored in the same data field as where it is read from in <code>get_gradient</code>. Therefore, you need to make sure to not read from the same quadrature point again after having called <code>submit_gradient</code> on that particular quadrature point. In general, it is a good idea to copy the result of <code>get_gradient</code> when it is used more often than once. </li>
<li>
Next follows the summation over quadrature points for all test functions that corresponds to the actual integration step. For the Laplace operator, we just multiply by the gradient, so we call the integrate function with the respective argument set. If you have an equation where you test by both the values of the test functions and the gradients, both template arguments need to be set to true. Calling first the integrate function for values and then gradients in a separate call leads to wrong results, since the second call will internally overwrite the results from the first call. Note that there is no function argument for the second derivative for integrate step. </li>
<li>
Eventually, the local contributions in the vector \(v_\mathrm{cell}\) as mentioned in the introduction need to be added into the result vector (and constraints are applied). This is done with a call to <code>distribute_local_to_global</code>, the same name as the corresponding function in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> (only that we now store the local vector in the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object, as are the indices between local and global degrees of freedom). </li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values(src);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      phi.distribute_local_to_global(dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function implements the loop over all cells for the Base::apply_add() interface. This is done with the <code>cell_loop</code> of the <a class="el" href="classMatrixFree.html">MatrixFree</a> class, which takes the operator() of this class with arguments <a class="el" href="classMatrixFree.html">MatrixFree</a>, OutVector, InVector, cell_range. When working with MPI parallelization (but no threading) as is done in this tutorial program, the cell loop corresponds to the following three lines of code:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">src.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values</a>();</div><div class="line">local_apply(*this-&gt;data, dst, src, std::make_pair(0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>,</div><div class="line">                                                  data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>()));</div><div class="line">dst.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --> </div><p>Here, the two calls update_ghost_values() and <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> perform the data exchange on processor boundaries for MPI, once for the source vector where we need to read from entries owned by remote processors, and once for the destination vector where we have accumulated parts of the residuals that need to be added to the respective entry of the owner processor. However, <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop</a> does not only abstract away those two calls, but also performs some additional optimizations. On the one hand, it will split the update_ghost_values() and <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> calls in a way to allow for overlapping communication and computation. The local_apply function is then called with three cell ranges representing partitions of the cell range from 0 to <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a>. On the other hand, cell_loop also supports thread parallelism in which case the cell ranges are split into smaller chunks and scheduled in an advanced way that avoids access to the same vector entry by several threads. That feature is explained in <a class="el" href="step_48.html">step-48</a>.</p>
<p>Note that after the cell loop, the constrained degrees of freedom need to be touched once more for sensible vmult() operators: Since the assembly loop automatically resolves constraints (just as the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> call does), it does not compute any contribution for constrained degrees of freedom, leaving the respective entries zero. This would represent a matrix that had empty rows and columns for constrained degrees of freedom. However, iterative solvers like CG only work for non-singular matrices. The easiest way to do that is to set the sub-block of the matrix that corresponds to constrained DoFs to an identity matrix, in which case application of the matrix would simply copy the elements of the right hand side vector into the left hand side. Fortunately, the vmult() implementations <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> do this automatically for us outside the apply_add() function, so we do not need to take further action here.</p>
<p>When using the combination of <a class="el" href="classMatrixFree.html">MatrixFree</a> and <a class="el" href="classFEEvaluation.html">FEEvaluation</a> in parallel with MPI, there is one aspect to be careful about &mdash; the indexing used for accessing the vector. For performance reasons, <a class="el" href="classMatrixFree.html">MatrixFree</a> and <a class="el" href="classFEEvaluation.html">FEEvaluation</a> are designed to access vectors in MPI-local index space also when working with multiple processors. Working in local index space means that no index translation needs to be performed at the place the vector access happens, apart from the unavoidable indirect addressing. However, local index spaces are ambiguous: While it is standard convention to access the locally owned range of a vector with indices between 0 and the local size, the numbering is not so clear for the ghosted entries and somewhat arbitrary. For the matrix-vector product, only the indices appearing on locally owned cells (plus those referenced via hanging node constraints) are necessary. However, in deal.II we often set all the degrees of freedom on ghosted elements as ghosted vector entries, called the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs described in the</a> glossary". In that case, the MPI-local index of a ghosted vector entry can in general be different in the two possible ghost sets, despite referring to the same global index. To avoid problems, <a class="el" href="classFEEvaluation.html">FEEvaluation</a> checks that the partitioning of the vector used for the matrix-vector product does indeed match with the partitioning of the indices in <a class="el" href="classMatrixFree.html">MatrixFree</a> by a check called <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1121c9b5aa9c34d0fe36486fecf08b58">LinearAlgebra::distributed::Vector::partitioners_are_compatible</a>. To facilitate things, the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class includes a mechanism to fit the ghost set to the correct layout. This happens in the ghost region of the vector, so keep in mind that the ghost region might be modified in both the destination and source vector after a call to a vmult() method. This is legitimate because the ghost region of a distributed deal.II vector is a mutable section and filled on demand. Vectors used in matrix-vector products must not be ghosted upon entry of vmult() functions, so no information gets lost.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">}</div></div><!-- fragment --><p>The following function implements the computation of the diagonal of the operator. Computing matrix entries of a matrix-free operator evaluation turns out to be more complicated than evaluating the operator. Fundamentally, we could obtain a matrix representation of the operator by applying the operator on <em>all</em> unit vectors. Of course, that would be very inefficient since we would need to perform <em>n</em> operator evaluations to retrieve the whole matrix. Furthermore, this approach would completely ignore the matrix sparsity. On an individual cell, however, this is the way to go and actually not that inefficient as there usually is a coupling between all degrees of freedom inside the cell.</p>
<p>We first initialize the diagonal vector to the correct parallel layout. This vector is encapsulated in a member called inverse_diagonal_entries of type <a class="el" href="classDiagonalMatrix.html">DiagonalMatrix</a> in the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>. This member is a shared pointer that we first need to initialize and then get the vector representing the diagonal entries in the matrix. As to the actual diagonal computation, we again use the cell_loop infrastructure of <a class="el" href="classMatrixFree.html">MatrixFree</a> to invoke a local worker routine called local_compute_diagonal(). Since we will only write into a vector but not have any source vector, we put a dummy argument of type <code>unsigned int</code> in place of the source vector to confirm with the cell_loop interface. After the loop, we need to set the vector entries subject to Dirichlet boundary conditions to one (either those on the boundary described by the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object inside <a class="el" href="classMatrixFree.html">MatrixFree</a> or the indices at the interface between different grid levels in adaptive multigrid). This is done through the function <a class="el" href="classMatrixFreeOperators_1_1Base.html#a11ff9854b4433dc8a7795d1c117de2c3">MatrixFreeOperators::Base::set_constrained_entries_to_one()</a> and matches with the setting in the matrix-vector product provided by the Base operator. Finally, we need to invert the diagonal entries which is the form required by the Chebyshev smoother based on the Jacobi iteration. In the loop, we assert that all entries are non-zero, because they should either have obtained a positive contribution from integrals or be constrained and treated by <code>set_constrained_entries_to_one()</code> following cell_loop.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">LaplaceOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">{</div><div class="line">  this-&gt;inverse_diagonal_entries.reset(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">    this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dummy = 0;</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_compute_diagonal,</div><div class="line">                        <span class="keyword">this</span>,</div><div class="line">                        inverse_diagonal,</div><div class="line">                        dummy);</div><div class="line"></div><div class="line">  this-&gt;set_constrained_entries_to_one(inverse_diagonal);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size</a>(); ++i)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) &gt; 0.,</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No diagonal entry in a positive definite operator &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;should be zero&quot;</span>));</div><div class="line">      inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) =</div><div class="line">        1. / inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the local compute loop, we compute the diagonal by a loop over all columns in the local matrix and putting the entry 1 in the <em>i</em>th slot and a zero entry in all other slots, i.e., we apply the cell-wise differential operator on one unit vector at a time. The inner part invoking <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate</a>, the loop over quadrature points, and FEEvalution::integrate, is exactly the same as in the local_apply function. Afterwards, we pick out the <em>i</em>th entry of the local result and put it to a temporary storage (as we overwrite all entries in the array behind <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">FEEvaluation::get_dof_value()</a> with the next loop iteration). Finally, the temporary storage is written to the destination vector. Note how we use <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">FEEvaluation::get_dof_value()</a> and <a class="el" href="classFEEvaluationBase.html#a3afd9d62f5762c41973aa0f037dc5099">FEEvaluation::submit_dof_value()</a> to read and write to the data field that <a class="el" href="classFEEvaluation.html">FEEvaluation</a> uses for the integration on the one hand and writes into the global vector on the other hand.</p>
<p>Given that we are only interested in the matrix diagonal, we simply throw away all other entries of the local matrix that have been computed along the way. While it might seem wasteful to compute the complete cell matrix and then throw away everything but the diagonal, the integration are so efficient that the computation does not take too much time. Note that the complexity of operator evaluation per element is \(\mathcal O((p+1)^{d+1})\) for polynomial degree \(k\), so computing the whole matrix costs us \(\mathcal O((p+1)^{2d+1})\) operations, not too far away from \(\mathcal O((p+1)^{2d})\) complexity for computing the diagonal with <a class="el" href="classFEValues.html">FEValues</a>. Since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> is also considerably faster due to vectorization and other optimizations, the diagonal computation with this function is actually the fastest (simple) variant. (It would be possible to compute the diagonal with sum factorization techniques in \(\mathcal O((p+1)^{d+1})\) operations involving specifically adapted kernels&mdash;but since such kernels are only useful in that particular context and the diagonal computation is typically not on the critical path, they have not been implemented in deal.II.)</p>
<p>Note that the code that calls distribute_local_to_global on the vector to accumulate the diagonal entries into the global matrix has some limitations. For operators with hanging node constraints that distribute an integral contribution of a constrained DoF to several other entries inside the distribute_local_to_global call, the vector interface used here does not exactly compute the diagonal entries, but lumps some contributions located on the diagonal of the local matrix that would end up in a off-diagonal position of the global matrix to the diagonal. The result is correct up to discretization accuracy as explained in <a href="http://dx.doi.org/10.4208/cicp.101214.021015a">Kormann (2016), section 5.3</a>, but not mathematically equal. In this tutorial program, no harm can happen because the diagonal is only used for the multigrid level matrices where no hanging node constraints appear.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;             data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;dst,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <a class="code" href="classAlignedVector.html">AlignedVector&lt;VectorizedArray&lt;number&gt;</a>&gt; <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>(phi.dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; phi.dofs_per_cell; ++j)</div><div class="line">            phi.submit_dof_value(<a class="code" href="classVectorizedArray.html">VectorizedArray&lt;number&gt;</a>(), j);</div><div class="line">          phi.submit_dof_value(make_vectorized_array&lt;number&gt;(1.), i);</div><div class="line"></div><div class="line">          phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">            phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q),</div><div class="line">                                q);</div><div class="line">          phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">          <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i] = phi.get_dof_value(i);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">        phi.submit_dof_value(<a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i], i);</div><div class="line">      phi.distribute_local_to_global(dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemclass"></a> </p><h3>LaplaceProblem class</h3>
<p>This class is based on the one in <a class="el" href="step_16.html">step-16</a>. However, we replaced the SparseMatrix&lt;double&gt; class by our matrix-free implementation, which means that we can also skip the sparsity patterns. Notice that we define the LaplaceOperator class with the degree of finite element as template argument (the value is defined at the top of the file), and that we use float numbers for the multigrid level matrices.</p>
<p>The class also has a member variable to keep track of all the detailed timings for setting up the entire chain of data before we actually go about solving the problem. In addition, there is an output stream (that is disabled by default) that can be used to output details for the individual setup operations instead of the summary only that is printed out by default.</p>
<p>Since this program is designed to be used with MPI, we also provide the usual <code>pcout</code> output stream that only prints the information of the processor with MPI rank 0. The grid used for this programs can either be a distributed triangulation based on p4est (in case deal.II is configured to use p4est), otherwise it is a serial grid that only runs without MPI.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType =</div><div class="line">      LaplaceOperator&lt;dim, degree_finite_element, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = LaplaceOperator&lt;dim, degree_finite_element, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a> mg_matrices;</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>             setup_time;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> time_details;</div><div class="line">  };</div></div><!-- fragment --><p>When we initialize the finite element, we of course have to use the degree specified at the top of the file as well (otherwise, an exception will be thrown at some point, since the computational kernel defined in the templated LaplaceOperator class and the information from the finite element read out by <a class="el" href="classMatrixFree.html">MatrixFree</a> will not match). The constructor of the triangulation needs to set an additional flag that tells the grid to conform to the 2:1 cell balance over vertices, which is needed for the convergence of the geometric multigrid routines. For the distributed grid, we also need to specifically enable the multigrid hierarchy.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem()</div><div class="line">    :</div><div class="line">#ifdef DEAL_II_WITH_P4EST</div><div class="line">    triangulation(</div><div class="line">      MPI_COMM_WORLD,</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">      <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    ,</div><div class="line">#else</div><div class="line">    triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    ,</div><div class="line">#endif</div><div class="line">    fe(degree_finite_element)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , setup_time(0.)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    ,</div></div><!-- fragment --><p>The LaplaceProblem class holds an additional output stream that collects detailed timings about the setup phase. This stream, called time_details, is disabled by default through the <code>false</code> argument specified here. For detailed timings, removing the <code>false</code> argument prints all the details.</p>
<div class="fragment"><div class="line">  time_details(std::cout,</div><div class="line">               <span class="keyword">false</span> &amp;&amp; <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>The setup stage is in analogy to <a class="el" href="step_16.html">step-16</a> with relevant changes due to the LaplaceOperator class. The first thing to do is to set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, including the degrees of freedom for the multigrid levels, and to initialize constraints from hanging nodes and homogeneous Dirichlet conditions. Since we intend to use this programs in parallel with MPI, we need to make sure that the constraints get to know the locally relevant degrees of freedom, otherwise the storage would explode when using more than a few hundred millions of degrees of freedom, see <a class="el" href="step_40.html">step-40</a>.</p>
<p>Once we have created the multigrid dof_handler and the constraints, we can call the reinit function for the global matrix operator as well as each level of the multigrid scheme. The main action is to set up the <code> <a class="el" href="classMatrixFree.html">MatrixFree</a> </code> instance for the problem. The base class of the <code>LaplaceOperator</code> class, <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, is initialized with a shared pointer to <a class="el" href="classMatrixFree.html">MatrixFree</a> object. This way, we can simply create it here and then pass it on to the system matrix and level matrices, respectively. For setting up <a class="el" href="classMatrixFree.html">MatrixFree</a>, we need to activate the update flag in the AdditionalData field of <a class="el" href="classMatrixFree.html">MatrixFree</a> that enables the storage of quadrature point coordinates in real space (by default, it only caches data for gradients (inverse transposed Jacobians) and JxW values). Note that if we call the reinit function without specifying the level (i.e., giving <code>level = <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>), <a class="el" href="classMatrixFree.html">MatrixFree</a> constructs a loop over the active cells. In this tutorial, we do not use threads in addition to MPI, which is why we explicitly disable it by setting the <a class="el" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">MatrixFree::AdditionalData::tasks_parallel_scheme</a> to <a class="el" href="structMatrixFree_1_1AdditionalData.html#a5b3198735af965d2fc5019543263f927a70ba08215ce330f13a3fd33adbd977a9">MatrixFree::AdditionalData::none</a>. Finally, the coefficient is evaluated and vectors are initialized as explained above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  setup_time = 0;</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  mg_matrices.clear_elements();</div><div class="line"></div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line">  dof_handler.distribute_mg_dofs();</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Distribute DoFs &amp; B.C.     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">      <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::none</a>;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; system_mf_storage(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">    system_mf_storage-&gt;reinit(mapping,</div><div class="line">                              dof_handler,</div><div class="line">                              constraints,</div><div class="line">                              <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                              additional_data);</div><div class="line">    system_matrix.initialize(system_mf_storage);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(solution);</div><div class="line">  system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free system   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div></div><!-- fragment --><p>Next, initialize the matrices for the multigrid method on all the levels. The data structure <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> keeps information about the indices subject to boundary conditions as well as the indices on edges between different refinement levels as described in the <a class="el" href="step_16.html">step-16</a> tutorial program. We then go through the levels of the mesh and construct the constraints and matrices on each level. These follow closely the construction of the system matrix on the original mesh, except the slight difference in naming when accessing information on the levels rather than the active cells.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">  mg_matrices.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">  dirichlet_boundary.insert(0);</div><div class="line">  mg_constrained_dofs.initialize(dof_handler);</div><div class="line">  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                     dirichlet_boundary);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                    level,</div><div class="line">                                                    relevant_dofs);</div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">        mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::none</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">      std::shared_ptr&lt;MatrixFree&lt;dim, float&gt;&gt; mg_mf_storage_level(</div><div class="line">        <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;</a>());</div><div class="line">      mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                  dof_handler,</div><div class="line">                                  level_constraints,</div><div class="line">                                  <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                  additional_data);</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                    mg_constrained_dofs,</div><div class="line">                                    level);</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">    }</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free levels   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_rhs"></a> </p><h4>LaplaceProblem::assemble_rhs</h4>
<p>The assemble function is very simple since all we have to do is to assemble the right hand side. Thanks to <a class="el" href="classFEEvaluation.html">FEEvaluation</a> and all the data cached in the <a class="el" href="classMatrixFree.html">MatrixFree</a> class, which we query from <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, this can be done in a few lines. Since this call is not wrapped into a <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop</a> (which would be an alternative), we must not forget to call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> at the end of the assembly to send all the contributions of the right hand side to the owner of the respective degree of freedom.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line"></div><div class="line">  system_rhs = 0;</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">    *system_matrix.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>The solution process is similar as in <a class="el" href="step_16.html">step-16</a>. We start with the setup of the transfer. For <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>, there is a very fast transfer class called <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> that does the interpolation between the grid levels with the same fast sum factorization kernels that get also used in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a>                            time;</div><div class="line">  <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a> mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG build transfer time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div></div><!-- fragment --><p>As a smoother, this tutorial program uses a Chebyshev iteration instead of SOR in <a class="el" href="step_16.html">step-16</a>. (SOR would be very difficult to implement because we do not have the matrix elements available explicitly, and it is difficult to make it work efficiently in parallel.) The smoother is initialized with our level matrices and the mandatory additional data for the Chebyshev smoother. We use a relatively high degree here (5), since matrix-vector products are comparably cheap. We choose to smooth out a range of \([1.2 \hat{\lambda}_{\max}/15,1.2 \hat{\lambda}_{\max}]\) in the smoother where \(\hat{\lambda}_{\max}\) is an estimate of the largest eigenvalue (the factor 1.2 is applied inside <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>). In order to compute that eigenvalue, the Chebyshev initialization performs a few steps of a CG algorithm without preconditioner. Since the highest eigenvalue is usually the easiest one to find and a rough estimate is enough, we choose 10 iterations. Finally, we also set the inner preconditioner type in the Chebyshev method which is a Jacobi iteration. This is represented by the <a class="el" href="classDiagonalMatrix.html">DiagonalMatrix</a> class that gets the inverse diagonal entry provided by our LaplaceOperator class.</p>
<p>On level zero, we initialize the smoother differently because we want to use the Chebyshev iteration as a solver. <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a> allows the user to switch to solver mode where the number of iterations is internally chosen to the correct value. In the additional data object, this setting is activated by choosing the polynomial degree to <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>. The algorithm will then attack all eigenvalues between the smallest and largest one in the coarse level matrix. The number of steps in the Chebyshev smoother are chosen such that the Chebyshev convergence estimates guarantee to reduce the residual by the number specified in the variable <code>smoothing_range</code>. Note that for solving, <code>smoothing_range</code> is a relative tolerance and chosen smaller than one, in this case, we select three orders of magnitude, whereas it is a number larger than 1 when only selected eigenvalues are smoothed.</p>
<p>From a computational point of view, the Chebyshev iteration is a very attractive coarse grid solver as long as the coarse size is moderate. This is because the Chebyshev method performs only matrix-vector products and vector updates, which typically parallelize better to the largest cluster size with more than a few tens of thousands of cores than inner product involved in other iterative methods. The former involves only local communication between neighbors in the (coarse) mesh, whereas the latter requires global communication over all processors.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> SmootherType =</div><div class="line">  <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                        <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                       LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                     mg_smoother;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">      {</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 5;</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        smoother_data[0].smoothing_range = 1e-3;</div><div class="line">        smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">        smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">      }</div><div class="line">    mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line">    smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">  }</div><div class="line">mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line"><a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">  mg_coarse;</div><div class="line">mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div></div><!-- fragment --><p>The next step is to set up the interface matrices that are needed for the case with hanging nodes. The adaptive multigrid realization in deal.II implements an approach called local smoothing. This means that the smoothing on the finest level only covers the local part of the mesh defined by the fixed (finest) grid level and ignores parts of the computational domain where the terminal cells are coarser than this level. As the method progresses to coarser levels, more and more of the global mesh will be covered. At some coarser level, the whole mesh will be covered. Since all level matrices in the multigrid method cover a single level in the mesh, no hanging nodes appear on the level matrices. At the interface between multigrid levels, homogeneous Dirichlet boundary conditions are set while smoothing. When the residual is transferred to the next coarser level, however, the coupling over the multigrid interface needs to be taken into account. This is done by the so-called interface (or edge) matrices that compute the part of the residual that is missed by the level matrix with homogeneous Dirichlet conditions. We refer to the <a class="el" href="DEALGlossary.html#mg_paper">Multigrid paper by Janssen and Kanschat</a> for more details.</p>
<p>For the implementation of those interface matrices, there is already a pre-defined class <a class="el" href="classMatrixFreeOperators_1_1MGInterfaceOperator.html">MatrixFreeOperators::MGInterfaceOperator</a> that wraps the routines <a class="el" href="classMatrixFreeOperators_1_1Base.html#a21cefa5a5d4cb726180c89962d8ae472">MatrixFreeOperators::Base::vmult_interface_down()</a> and <a class="el" href="classMatrixFreeOperators_1_1Base.html#af4f39d8232619d499709aa6ee968db58">MatrixFreeOperators::Base::vmult_interface_up()</a> in a new class with <code>vmult()</code> and <code>Tvmult()</code> operations (that were originally written for matrices, hence expecting those names). Note that vmult_interface_down is used during the restriction phase of the multigrid V-cycle, whereas vmult_interface_up is used during the prolongation phase.</p>
<p>Once the interface matrix is created, we set up the remaining <a class="el" href="classMultigrid.html">Multigrid</a> preconditioner infrastructure in complete analogy to <a class="el" href="step_16.html">step-16</a> to obtain a <code>preconditioner</code> object that can be applied to a matrix.</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">  mg_matrices);</div><div class="line"></div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">  mg_interface_matrices;</div><div class="line">mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  mg_interface_matrices[level].initialize(mg_matrices[level]);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">  mg_interface_matrices);</div><div class="line"></div><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">               LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">               <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>The setup of the multigrid routines is quite easy and one cannot see any difference in the solve process as compared to <a class="el" href="step_16.html">step-16</a>. All the magic is hidden behind the implementation of the LaplaceOperator::vmult operation. Note that we print out the solve time and the accumulated setup time through standard out, i.e., in any case, whereas detailed times for the setup operations are only printed in case the flag for detail_times in the constructor is changed.</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1e-12 * system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG build smoother time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Total setup time               (wall) &quot;</span> &lt;&lt; setup_time &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line"></div><div class="line">  time.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">  time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a>(solution);</div><div class="line">  cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Time solve (&quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations)&quot;</span></div><div class="line">        &lt;&lt; (solver_control.last_step() &lt; 10 ? <span class="stringliteral">&quot;  &quot;</span> : <span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;(CPU/wall) &quot;</span></div><div class="line">        &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemoutput_results"></a> </p><h4>LaplaceProblem::output_results</h4>
<p>Here is the data output, which is a simplified version of <a class="el" href="step_5.html">step-5</a>. We use the standard VTU (= compressed VTK) output for each grid produced in the refinement process. In addition, we use a compression algorithm that is optimized for speed rather than disk usage. The default setting (which optimizes for disk usage) makes saving the output take about 4 times as long as running the linear solver, while setting <a class="el" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">DataOutBase::VtkFlags::compression_level</a> to <a class="el" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a> lowers this to only one fourth the time of the linear solve.</p>
<p>We disable the output when the mesh gets too large. A variant of this program has been run on hundreds of thousands MPI ranks with as many as 100 billion grid cells, which is not directly accessible to classical visualization tools.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1000000)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  solution.update_ghost_values();</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Time write output          (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>The function that runs the program is very similar to the one in <a class="el" href="step_16.html">step-16</a>. We do few refinement steps in 3D compared to 2D, but that's it.</p>
<p>Before we run the program, we output some information about the detected vectorization level as discussed in the introduction.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(<a class="code" href="classdouble.html">double</a>) * n_vect_doubles;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Vectorization over &quot;</span> &lt;&lt; n_vect_doubles</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; doubles = &quot;</span> &lt;&lt; n_vect_bits &lt;&lt; <span class="stringliteral">&quot; bits (&quot;</span></div><div class="line">            &lt;&lt; <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">          }</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">        setup_system();</div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      };</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step37</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>Apart from the fact that we set up the MPI framework according to <a class="el" href="step_40.html">step-40</a>, there are no surprises in the main function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step37;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;dimension&gt; laplace_problem;</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>Since this example solves the same problem as <a class="el" href="step_5.html">step-5</a> (except for a different coefficient), there is little to say about the solution. We show a picture anyway, illustrating the size of the solution through both isocontours and volume rendering:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.solution.png"/>
</div>
<p>Of more interest is to evaluate some aspects of the multigrid solver. When we run this program in 2D for quadratic ( \(Q_2\)) elements, we get the following output (when run on one core in release mode): </p><div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 81</div><div class="line">Total setup time               (wall) 0.00159788s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000951s/0.000951052s</div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 289</div><div class="line">Total setup time               (wall) 0.00114608s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000935s/0.000934839s</div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 1089</div><div class="line">Total setup time               (wall) 0.00244665s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.00207s/0.002069s</div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 4225</div><div class="line">Total setup time               (wall) 0.00678205s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.005616s/0.00561595s</div><div class="line"></div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 16641</div><div class="line">Total setup time               (wall) 0.0241671s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.019543s/0.0195441s</div><div class="line"></div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 66049</div><div class="line">Total setup time               (wall) 0.0967851s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.07457s/0.0745709s</div><div class="line"></div><div class="line">Cycle 6</div><div class="line">Number of degrees of freedom: 263169</div><div class="line">Total setup time               (wall) 0.346374s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.260042s/0.265033s</div></div><!-- fragment --><p>As in <a class="el" href="step_16.html">step-16</a>, we see that the number of CG iterations remains constant with increasing number of degrees of freedom. A constant number of iterations (together with optimal computational properties) means that the computing time approximately quadruples as the problem size quadruples from one cycle to the next. The code is also very efficient in terms of storage. Around 2-4 million degrees of freedom fit into 1 GB of memory, see also the MPI results below. An interesting fact is that solving one linear system is cheaper than the setup, despite not building a matrix (approximately half of which is spent in the <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a> and <a class="el" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">DoFHandler::distribute_mg_dofs()</a> calls). This shows the high efficiency of this approach, but also that the deal.II data structures are quite expensive to set up and the setup cost must be amortized over several system solves.</p>
<p>Not much changes if we run the program in three spatial dimensions. Since we use uniform mesh refinement, we get eight times as many elements and approximately eight times as many degrees of freedom with each cycle:</p>
<div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 125</div><div class="line">Total setup time               (wall) 0.00231099s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000692s/0.000922918s</div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 729</div><div class="line">Total setup time               (wall) 0.00289083s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.001534s/0.0024128s</div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0143182s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.010785s/0.0107841s</div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.087064s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.063522s/0.06545s</div><div class="line"></div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 0.596306s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.427757s/0.431765s</div><div class="line"></div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 4.96491s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 3.53126s/3.56142s</div></div><!-- fragment --><p>Since it is so easy, we look at what happens if we increase the polynomial degree. When selecting the degree as four in 3D, i.e., on \(\mathcal Q_4\) elements, by changing the line <code>const unsigned int degree_finite_element=4;</code> at the top of the program, we get the following program output:</p>
<div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 729</div><div class="line">Total setup time               (wall) 0.00633097s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.002829s/0.00379395s</div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0174279s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.012255s/0.012254s</div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.082655s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.052362s/0.0523629s</div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 0.507943s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.341811s/0.345788s</div><div class="line"></div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 3.46251s</div><div class="line">Time solve (7 iterations)  (CPU/wall) 3.29638s/3.3265s</div><div class="line"></div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 16974593</div><div class="line">Total setup time               (wall) 27.8989s</div><div class="line">Time solve (7 iterations)  (CPU/wall) 26.3705s/27.1077s</div></div><!-- fragment --><p>Since \(\mathcal Q_4\) elements on a certain mesh correspond to \(\mathcal Q_2\) elements on half the mesh size, we can compare the run time at cycle 4 with fourth degree polynomials with cycle 5 using quadratic polynomials, both at 2.1 million degrees of freedom. The surprising effect is that the solver for \(\mathcal Q_4\) element is actually slightly faster than for the quadratic case, despite using one more linear iteration. The effect that higher-degree polynomials are similarly fast or even faster than lower degree ones is one of the main strengths of matrix-free operator evaluation through sum factorization, see the <a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">matrix-free paper</a>. This is fundamentally different to matrix-based methods that get more expensive per unknown as the polynomial degree increases and the coupling gets denser.</p>
<p>In addition, also the setup gets a bit cheaper for higher order, which is because fewer elements need to be set up.</p>
<p>Finally, let us look at the timings with degree 8, which corresponds to another round of mesh refinement in the lower order methods:</p>
<div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0842004s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.019296s/0.0192959s</div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.327048s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.07517s/0.075999s</div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 2.12335s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.448739s/0.453698s</div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 16.1743s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 3.95003s/3.97717s</div><div class="line"></div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 16974593</div><div class="line">Total setup time               (wall) 130.8s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 31.0316s/31.767s</div></div><!-- fragment --><p>Here, the initialization seems considerably slower than before, which is mainly due to the computation of the diagonal of the matrix, which actually computes a 729 x 729 matrix on each cell and throws away everything but the diagonal. The solver times, however, are again very close to the quartic case, showing that the linear increase with the polynomial degree that is theoretically expected is almost completely offset by better computational characteristics and the fact that higher order methods have a smaller share of degrees of freedom living on several cells that add to the evaluation complexity.</p>
<p><a class="anchor" id="Comparisonwithasparsematrix"></a></p><h3>Comparison with a sparse matrix</h3>
<p>In order to understand the capabilities of the matrix-free implementation, we compare the performance of the 3d example above with a sparse matrix implementation based on <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> by measuring both the computation times for the initialization of the problem (distribute DoFs, setup and assemble matrices, setup multigrid structures) and the actual solution for the matrix-free variant and the variant based on sparse matrices. We base the preconditioner on float numbers and the actual matrix and vectors on double numbers, as shown above. Tests are run on an Intel Core i7-5500U notebook processor (two cores and <a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> support, i.e., four operations on doubles can be done with one CPU instruction, which is heavily used in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>), optimized mode, and two MPI ranks.</p>
<table align="center" class="doxtable">
<tr>
<th>&#160; </th><th colspan="2">Sparse matrix </th><th colspan="2">Matrix-free implementation  </th></tr>
<tr>
<th>n_dofs </th><th>Setup + assemble </th><th>&#160;Solve&#160; </th><th>Setup + assemble </th><th>&#160;Solve&#160;  </th></tr>
<tr>
<td align="right">125 </td><td align="center">0.0042s </td><td align="center">0.0012s </td><td align="center">0.0022s </td><td align="center">0.00095s  </td></tr>
<tr>
<td align="right">729 </td><td align="center">0.012s </td><td align="center">0.0040s </td><td align="center">0.0027s </td><td align="center">0.0021s  </td></tr>
<tr>
<td align="right">4,913 </td><td align="center">0.082s </td><td align="center">0.012s </td><td align="center">0.011s </td><td align="center">0.0057s  </td></tr>
<tr>
<td align="right">35,937 </td><td align="center">0.73s </td><td align="center">0.13s </td><td align="center">0.048s </td><td align="center">0.040s  </td></tr>
<tr>
<td align="right">274,625 </td><td align="center">5.43s </td><td align="center">1.01s </td><td align="center">0.33s </td><td align="center">0.25s  </td></tr>
<tr>
<td align="right">2,146,689 </td><td align="center">43.8s </td><td align="center">8.24s </td><td align="center">2.42s </td><td align="center">2.06s  </td></tr>
</table>
<p>The table clearly shows that the matrix-free implementation is more than twice as fast for the solver, and more than six times as fast when it comes to initialization costs. As the problem size is made a factor 8 larger, we note that the times usually go up by a factor eight, too (as the solver iterations are constant at six). The main deviation is in the sparse matrix between 5k and 36k degrees of freedom, where the time increases by a factor 12. This is the threshold where the (L3) cache in the processor can no longer hold all data necessary for the matrix-vector products and all matrix elements must be fetched from main memory.</p>
<p>Of course, this picture does not necessarily translate to all cases, as there are problems where knowledge of matrix entries enables much better solvers (as happens when the coefficient is varying more strongly than in the above example). Moreover, it also depends on the computer system. The present system has good memory performance, so sparse matrices perform comparably well. Nonetheless, the matrix-free implementation gives a nice speedup already for the <em>Q</em><sub>2</sub> elements used in this example. This becomes particularly apparent for time-dependent or nonlinear problems where sparse matrices would need to be reassembled over and over again, which becomes much easier with this class. And of course, thanks to the better complexity of the products, the method gains increasingly larger advantages when the order of the elements increases (the matrix-free implementation has costs 4<em>d</em><sup>2</sup><em>p</em> per degree of freedom, compared to 2<em>p<sup>d</sup></em> for the sparse matrix, so it will win anyway for order 4 and higher in 3d).</p>
<p><a class="anchor" id="ResultsforlargescaleparallelcomputationsonSuperMUC"></a></p><h3>Results for large-scale parallel computations on SuperMUC</h3>
<p>As explained in the introduction and the in-code comments, this program can be run in parallel with MPI. It turns out that geometric multigrid schemes work really well and can scale to very large machines. To the authors' knowledge, the geometric multigrid results shown here are the largest computations done with deal.II as of late 2016, run on up to 147,456 cores of the <a href="https://www.lrz.de/services/compute/supermuc/systemdescription/">complete SuperMUC Phase 1</a>. The ingredients for scalability beyond 1000 cores are that no data structure that depends on the global problem size is held in its entirety on a single processor and that the communication is not too frequent in order not to run into latency issues of the network. For PDEs solved with iterative solvers, the communication latency is often the limiting factor, rather than the throughput of the network. For the example of the SuperMUC system, the point-to-point latency between two processors is between 1e-6 and 1e-5 seconds, depending on the proximity in the MPI network. The matrix-vector products with <code>LaplaceOperator</code> from this class involves several point-to-point communication steps, interleaved with computations on each core. The resulting latency of a matrix-vector product is around 1e-4 seconds. Global communication, for example an <code>MPI_Allreduce</code> operation that accumulates the sum of a single number per rank over all ranks in the MPI network, has a latency of 1e-4 seconds. The multigrid V-cycle used in this program is also a form of global communication. Think about the coarse grid solve that happens on a single processor: It accumulates the contributions from all processors before it starts. When completed, the coarse grid solution is transferred to finer levels, where more and more processors help in smoothing until the fine grid. Essentially, this is a tree-like pattern over the processors in the network and controlled by the mesh. As opposed to the <code>MPI_Allreduce</code> operations where the tree in the reduction is optimized to the actual links in the MPI network, the multigrid V-cycle does this according to the partitioning of the mesh. Thus, we cannot expect the same optimality. Furthermore, the multigrid cycle is not simply a walk up and down the refinement tree, but also communication on each level when doing the smoothing. In other words, the global communication in multigrid is more challenging and related to the mesh that provides less optimization opportunities. The measured latency of the V-cycle is between 6e-3 and 2e-2 seconds, i.e., the same as 60 to 200 MPI_Allreduce operations.</p>
<p>The following figure shows a scaling experiments on \(\mathcal Q_3\) elements. Along the lines, the problem size is held constant as the number of cores is increasing. When doubling the number of cores, one expects a halving of the computational time, indicated by the dotted gray lines. The results show that the implementation shows almost ideal behavior until an absolute time of around 0.1 seconds is reached. The solver tolerances have been set such that the solver performs five iterations. This way of plotting data is the <b>strong scaling</b> of the algorithm. As we go to very large core counts, the curves flatten out a bit earlier, which is because of the communication network in SuperMUC where communication between processors farther away is slightly slower.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_strong.png"/>
</div>
<p>In addition, the plot also contains results for <b>weak scaling</b> that lists how the algorithm behaves as both the number of processor cores and elements is increased at the same pace. In this situation, we expect that the compute time remains constant. Algorithmically, the number of CG iterations is constant at 5, so we are good from that end. The lines in the plot are arranged such that the top left point in each data series represents the same size per processor, namely 131,072 elements (or approximately 3.5 million degrees of freedom per core). The gray lines indicating ideal strong scaling are by the same factor of 8 apart. The results show again that the scaling is almost ideal. The parallel efficiency when going from 288 cores to 147,456 cores is at around 75% for a local problem size of 750,000 degrees of freedom per core which takes 1.0s on 288 cores, 1.03s on 2304 cores, 1.19s on 18k cores, and 1.35s on 147k cores. The algorithms also reach a very high utilization of the processor. The largest computation on 147k cores reaches around 1.7 PFLOPs/s on SuperMUC out of an arithmetic peak of 3.2 PFLOPs/s. For an iterative PDE solver, this is a very high number and significantly more is often only reached for dense linear algebra. Sparse linear algebra is limited to a tenth of this value.</p>
<p>As mentioned in the introduction, the matrix-free method reduces the memory consumption of the data structures. Besides the higher performance due to less memory transfer, the algorithms also allow for very large problems to fit into memory. The figure below shows the computational time as we increase the problem size until an upper limit where the computation exhausts memory. We do this for 1k cores, 8k cores, and 65k cores and see that the problem size can be varied over almost two orders of magnitude with ideal scaling. The largest computation shown in this picture involves 292 billion ( \(2.92 \cdot 10^{11}\)) degrees of freedom. On a DG computation of 147k cores, the above algorithms were also run involving up to 549 billion (2^39) DoFs.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_size.png"/>
</div>
<p>Finally, we note that while performing the tests on the large-scale system shown above, improvements of the multigrid algorithms in deal.II have been developed. The original version contained the sub-optimal code based on <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> where some MPI_Allreduce commands (checking whether all vector entries are zero) were done on each smoothing operation on each level, which only became apparent on 65k cores and more. However, the following picture shows that the improvement already pay off on a smaller scale, here shown on computations on up to 14,336 cores for \(\mathcal Q_5\) elements:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_oldnew.png"/>
</div>
<p><a class="anchor" id="Adaptivity"></a></p><h3>Adaptivity</h3>
<p>As explained in the code, the algorithm presented here is prepared to run on adaptively refined meshes. If only part of the mesh is refined, the multigrid cycle will run with local smoothing and impose Dirichlet conditions along the interfaces which differ in refinement level for smoothing through the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class. Due to the way the degrees of freedom are distributed over levels, relating the owner of the level cells to the owner of the first descendant active cell, there can be an imbalance between different processors in MPI, which limits scalability by a factor of around two to five.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Kellyerrorestimator"></a></p><h4>Kelly error estimator </h4>
<p>As mentioned above the code is ready for locally adaptive h-refinement. For the Poisson equation one can employ the Kelly error indicator, implemented in the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class. However one needs to be careful with the ghost indices of parallel vectors. In order to evaluate the jump terms in the error indicator, each MPI process needs to know locally relevant DoFs. However <a class="el" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">MatrixFree::initialize_dof_vector()</a> function initializes the vector only with some locally relevant DoFs. The ghost indices made available in the vector are a tight set of only those indices that are touched in the cell integrals (including constraint resolution). This choice has performance reasons, because sending all locally relevant degrees of freedom would be too expensive compared to the matrix-vector product. Consequently the solution vector as-is is not suitable for the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class. The trick is to change the ghost part of the partition, for example using a temporary vector and <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab792ddb04b95a220e489f2d7f9eee990">LinearAlgebra::distributed::Vector::copy_locally_owned_data_from()</a> as shown below.</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"><a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> copy_vec(solution);</div><div class="line">solution.reinit(dof_handler.locally_owned_dofs(),</div><div class="line">                locally_relevant_dofs,</div><div class="line">                triangulation.<a class="code" href="classTriangulation.html#a0a2bf98c3056379a2b132ad62266f780">get_communicator</a>());</div><div class="line">solution.copy_locally_owned_data_from(copy_vec);</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">solution.update_ghost_values();</div></div><!-- fragment --><p><a class="anchor" id="Sharedmemoryparallelization"></a></p><h4>Shared-memory parallelization</h4>
<p>This program is parallelized with MPI only. As an alternative, the <a class="el" href="classMatrixFree.html">MatrixFree</a> loop can also be issued in hybrid mode, for example by using MPI parallelizing over the nodes of a cluster and with threads through Intel TBB within the shared memory region of one node. To use this, one would need to both set the number of threads in the MPI_InitFinalize data structure in the main function, and set the <a class="el" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">MatrixFree::AdditionalData::tasks_parallel_scheme</a> to partition_color to actually do the loop in parallel. This use case is discussed in <a class="el" href="step_48.html">step-48</a>.</p>
<p><a class="anchor" id="InhomogeneousDirichletboundaryconditions"></a></p><h4>Inhomogeneous Dirichlet boundary conditions </h4>
<p>The presented program assumes homogeneous Dirichlet boundary conditions. When going to non-homogeneous conditions, the situation is a bit more intricate. To understand how to implement such a setting, let us first recall how these arise in the mathematical formulation and how they are implemented in a matrix-based variant. In essence, an inhomogeneous Dirichlet condition sets some of the nodal values in the solution to given values rather than determining them through the variational principles, </p><p class="formulaDsp">
\begin{eqnarray*} u_h(\mathbf{x}) = \sum_{i\in \mathcal N} \varphi_i(\mathbf{x}) u_i = \sum_{i\in \mathcal N \setminus \mathcal N_D} \varphi_i(\mathbf{x}) u_i + \sum_{i\in \mathcal N_D} \varphi_i(\mathbf{x}) g_i, \end{eqnarray*}
</p>
<p> where \(u_i\) denotes the nodal values of the solution and \(\mathcal N\) denotes the set of all nodes. The set \(\mathcal N_D\subset \mathcal N\) is the subset of the nodes that are subject to Dirichlet boundary conditions where the solution is forced to equal \(u_i = g_i = g(\mathbf{x}_i)\) as the interpolation of boundary values on the Dirichlet-constrained node points \(i\in \mathcal N_D\). We then insert this solution representation into the weak form, e.g. the Laplacian shown above, and move the known quantities to the right hand side: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \varphi_i, \nabla u_h)_\Omega &amp;=&amp; (\varphi_i, f)_\Omega \quad \Rightarrow \\ \sum_{j\in \mathcal N \setminus \mathcal N_D}(\nabla \varphi_i,\nabla \varphi_j)_\Omega \, u_j &amp;=&amp; (\varphi_i, f)_\Omega -\sum_{j\in \mathcal N_D} (\nabla \varphi_i,\nabla\varphi_j)_\Omega\, g_j. \end{eqnarray*}
</p>
<p> In this formula, the equations are tested for all basis functions \(\varphi_i\) with \(i\in N \setminus \mathcal N_D\) that are not related to the nodes constrained by Dirichlet conditions.</p>
<p>In the implementation in deal.II, the integrals \((\nabla \varphi_i,\nabla \varphi_j)_\Omega\) on the right hand side are already contained in the local matrix contributions we assemble on each cell. When using <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> as first described in the <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_7.html">step-7</a> tutorial programs, we can account for the contribution of inhomogeneous constraints <em>j</em> by multiplying the columns <em>j</em> and rows <em>i</em> of the local matrix according to the integrals \((\varphi_i, \varphi_j)_\Omega\) by the inhomogeneities and subtracting the resulting from the position <em>i</em> in the global right-hand-side vector, see also the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module. In essence, we use some of the integrals that get eliminated from the left hand side of the equation to finalize the right hand side contribution. Similar mathematics are also involved when first writing all entries into a left hand side matrix and then eliminating matrix rows and columns by <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a>.</p>
<p>In principle, the components that belong to the constrained degrees of freedom could be eliminated from the linear system because they do not carry any information. In practice, in deal.II we always keep the size of the linear system the same to avoid handling two different numbering systems and avoid confusion about the two different index sets. In order to ensure that the linear system does not get singular when not adding anything to constrained rows, we then add dummy entries to the matrix diagonal that are otherwise unrelated to the real entries.</p>
<p>In a matrix-free method, we need to take a different approach, since the <code>LaplaceOperator</code> class represents the matrix-vector product of a <b>homogeneous</b> operator (the left-hand side of the last formula). It does not matter whether the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object passed to the <a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">MatrixFree::reinit()</a> contains inhomogeneous constraints or not, the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> call will only resolve the homogeneous part of the constraints as long as it represents a <b>linear</b> operator.</p>
<p>In our matrix-free code, the right hand side computation where the contribution of inhomogeneous conditions ends up is completely decoupled from the matrix operator and handled by a different function above. Thus, we need to explicitly generate the data that enters the right hand side rather than using a byproduct of the matrix assembly. Since we already know how to apply the operator on a vector, we could try to use those facilities for a vector where we only set the Dirichlet values: </p><div class="fragment"><div class="line"><span class="comment">// interpolate boundary values on vector solution</span></div><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(mapping,</div><div class="line">                                         dof_handler,</div><div class="line">                                         0,</div><div class="line">                                         BoundaryValueFunction&lt;dim&gt;(),</div><div class="line">                                         boundary_values);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::global_dof_index, double&gt; &amp;pair : boundary_values)</div><div class="line">  <span class="keywordflow">if</span> (solution.locally_owned_elements().is_element(pair.first))</div><div class="line">    solution(pair.first) = pair.second;</div></div><!-- fragment --><p> or, equivalently, if we already had filled the inhomogeneous constraints into an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, </p><div class="fragment"><div class="line">solution = 0;</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div></div><!-- fragment --><p>We could then pass the vector <code>solution</code> to the <code>LaplaceOperator::vmult_add()</code> function and add the new contribution to the <code>system_rhs</code> vector that gets filled in the <code>LaplaceProblem::assemble_rhs()</code> function. However, this idea does not work because the <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">FEEvaluation::read_dof_values()</a> call used inside the vmult() functions assumes homogeneous values on all constraints (otherwise the operator would not be a linear operator but an affine one). To also retrieve the values of the inhomogeneities, we could select one of two following strategies.</p>
<p><a class="anchor" id="UseFEEvaluationread_dof_values_plaintoavoidresolvingconstraints"></a></p><h5>Use <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> to avoid resolving constraints </h5>
<p>The class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> has a facility that addresses precisely this requirement: For non-homogeneous Dirichlet values, we do want to skip the implicit imposition of homogeneous (Dirichlet) constraints upon reading the data from the vector <code>solution</code>. For example, we could extend the <code>LaplaceProblem::assemble_rhs()</code> function to deal with inhomogeneous Dirichlet values as follows, assuming the Dirichlet values have been interpolated into the object <code>constraints:</code> </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  solution = 0;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  solution.update_ghost_values();</div><div class="line">  system_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;double&gt;</a>&gt; &amp;coefficient = system_matrix.get_coefficient();</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(*system_matrix.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values_plain(solution);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_gradient(-coefficient(cell, q) * phi.get_gradient(q), q);</div><div class="line">          phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">        }</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>|<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>In this code, we replaced the <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">FEEvaluation::read_dof_values()</a> function for the tentative solution vector by <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> that ignores all constraints. Due to this setup, we must make sure that other constraints, e.g. by hanging nodes, are correctly distributed to the input vector already as they are not resolved as in <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a>. Inside the loop, we then evaluate the Laplacian and repeat the second derivative call with <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">FEEvaluation::submit_gradient()</a> from the <code>LaplaceOperator</code> class, but with the sign switched since we wanted to subtract the contribution of Dirichlet conditions on the right hand side vector according to the formula above. When we invoke the <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">FEEvaluation::integrate()</a> call, we then set both arguments regarding the value slot and first derivative slot to true to account for both terms added in the loop over quadrature points. Once the right hand side is assembled, we then go on to solving the linear system for the homogeneous problem, say involving a variable <code>solution_update</code>. After solving, we can add <code>solution_update</code> to the <code>solution</code> vector that contains the final (inhomogeneous) solution.</p>
<p>Note that the negative sign for the Laplacian alongside with a positive sign for the forcing that we needed to build the right hand side is a more general concept: We have implemented nothing else than Newton's method for nonlinear equations, but applied to a linear system. We have used an initial guess for the variable <code>solution</code> in terms of the Dirichlet boundary conditions and computed a residual \(r = f - Au_0\). The linear system was then solved as \(\Delta u = A^{-1} (f-Au)\) and we finally computed \(u = u_0 + \Delta u\). For a linear system, we obviously reach the exact solution after a single iteration. If we wanted to extend the code to a nonlinear problem, we would rename the <code>assemble_rhs()</code> function into a more descriptive name like <code>assemble_residual()</code> that computes the (weak) form of the residual, whereas the <code>LaplaceOperator::apply_add()</code> function would get the linearization of the residual with respect to the solution variable.</p>
<p><a class="anchor" id="UseLaplaceOperatorwithasecondAffineConstraintsobjectwithoutDirichletconditions"></a></p><h5>Use LaplaceOperator with a second <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object without Dirichlet conditions </h5>
<p>A second alternative to get the right hand side that re-uses the <code>LaplaceOperator::apply_add()</code> function is to instead add a second LaplaceOperator that skips Dirichlet constraints. To do this, we initialize a second <a class="el" href="classMatrixFree.html">MatrixFree</a> object which does not have any boundary value constraints. This <code>matrix_free</code> object is then passed to a <code>LaplaceOperator</code> class instance <code>inhomogeneous_operator</code> that is only used to create the right hand side: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  system_rhs = 0;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> no_constraints;</div><div class="line">  no_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  LaplaceOperator&lt;dim, degree_finite_element, double&gt; inhomogeneous_operator;</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">  additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">    (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; matrix_free(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">  matrix_free-&gt;reinit(dof_handler,</div><div class="line">                      no_constraints,</div><div class="line">                      <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                      additional_data);</div><div class="line">  inhomogeneous_operator.initialize(matrix_free);</div><div class="line"></div><div class="line">  solution = 0.0;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  inhomogeneous_operator.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">  inhomogeneous_operator.vmult(system_rhs, solution);</div><div class="line">  system_rhs *= -1.0;</div><div class="line"></div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">    *inhomogeneous_operator.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; inhomogeneous_operator.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>A more sophisticated implementation of this technique could reuse the original <a class="el" href="classMatrixFree.html">MatrixFree</a> object. This can be done by initializing the <a class="el" href="classMatrixFree.html">MatrixFree</a> object with multiple blocks, where each block corresponds to a different <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object. Doing this would require making substantial modifications to the LaplaceOperator class, but the <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a> class that comes with the library can do this. See the discussion on blocks in <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> for more information on how to set up blocks.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Katharina Kormann, Martin Kronbichler, Uppsala University,</span></div><div class="line"><span class="comment"> * 2009-2012, updated to MPI version with parallel vectors in 2016</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step37</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_finite_element = 2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension             = 3;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">    number value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">  number Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1. / (0.05 + 2. * p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> value&lt;double&gt;(p, component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceOperator</div><div class="line">    : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">        Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">    LaplaceOperator();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_coefficient(<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">                <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">                <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_compute_diagonal(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;              data,</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp; dst,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                         dummy,</div><div class="line">      <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; coefficient;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  LaplaceOperator&lt;dim, fe_degree, number&gt;::LaplaceOperator()</div><div class="line">    : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                                <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">Vector</a>&lt;number&gt;&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">  {</div><div class="line">    coefficient.reinit(0, 0);</div><div class="line">    <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">      clear();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::evaluate_coefficient(</div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line">    coefficient.reinit(n_cells, phi.n_q_points);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          coefficient(cell, q) =</div><div class="line">            coefficient_function.value(phi.quadrature_point(q));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line">        phi.read_dof_values(src);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), q);</div><div class="line">        phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">        phi.distribute_local_to_global(dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">LaplaceOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">  {</div><div class="line">    this-&gt;inverse_diagonal_entries.reset(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">      this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dummy = 0;</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_compute_diagonal,</div><div class="line">                          <span class="keyword">this</span>,</div><div class="line">                          inverse_diagonal,</div><div class="line">                          dummy);</div><div class="line"></div><div class="line">    this-&gt;set_constrained_entries_to_one(inverse_diagonal);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size</a>(); ++i)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) &gt; 0.,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No diagonal entry in a positive definite operator &quot;</span></div><div class="line">                          <span class="stringliteral">&quot;should be zero&quot;</span>));</div><div class="line">        inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) =</div><div class="line">          1. / inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;             data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;dst,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <a class="code" href="classAlignedVector.html">AlignedVector&lt;VectorizedArray&lt;number&gt;</a>&gt; <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>(phi.dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; phi.dofs_per_cell; ++j)</div><div class="line">              phi.submit_dof_value(<a class="code" href="classVectorizedArray.html">VectorizedArray&lt;number&gt;</a>(), j);</div><div class="line">            phi.submit_dof_value(make_vectorized_array&lt;number&gt;(1.), i);</div><div class="line"></div><div class="line">            phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">              phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q),</div><div class="line">                                  q);</div><div class="line">            phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">            <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i] = phi.get_dof_value(i);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">          phi.submit_dof_value(<a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i], i);</div><div class="line">        phi.distribute_local_to_global(dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType =</div><div class="line">      LaplaceOperator&lt;dim, degree_finite_element, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = LaplaceOperator&lt;dim, degree_finite_element, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a> mg_matrices;</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>             setup_time;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> time_details;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem()</div><div class="line">    :</div><div class="line">#ifdef DEAL_II_WITH_P4EST</div><div class="line">    triangulation(</div><div class="line">      MPI_COMM_WORLD,</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">      <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    ,</div><div class="line">#else</div><div class="line">    triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    ,</div><div class="line">#endif</div><div class="line">    fe(degree_finite_element)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , setup_time(0.)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    ,</div><div class="line">    time_details(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">                 false &amp;&amp; <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    setup_time = 0;</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    mg_matrices.clear_elements();</div><div class="line"></div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line">    dof_handler.distribute_mg_dofs();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Distribute DoFs &amp; B.C.     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::none</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; system_mf_storage(</div><div class="line">        <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">      system_mf_storage-&gt;reinit(mapping,</div><div class="line">                                dof_handler,</div><div class="line">                                constraints,</div><div class="line">                                <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                additional_data);</div><div class="line">      system_matrix.initialize(system_mf_storage);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(solution);</div><div class="line">    system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free system   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">    mg_matrices.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">    dirichlet_boundary.insert(0);</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      relevant_dofs);</div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">        <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">          <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::none</a>;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">          (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">        std::shared_ptr&lt;MatrixFree&lt;dim, float&gt;&gt; mg_mf_storage_level(</div><div class="line">          <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;</a>());</div><div class="line">        mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    level_constraints,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    additional_data);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                      mg_constrained_dofs,</div><div class="line">                                      level);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">      }</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free levels   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line"></div><div class="line">    system_rhs = 0;</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">      *system_matrix.get_matrix_free());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">         cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">         ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">        phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">        phi.distribute_local_to_global(system_rhs);</div><div class="line">      }</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a>                            time;</div><div class="line">    <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a> mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG build transfer time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                            LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                           LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                         mg_smoother;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">    smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">          {</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 5;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            smoother_data[0].smoothing_range = 1e-3;</div><div class="line">            smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">          }</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">      }</div><div class="line">    mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line">    <a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">      mg_coarse;</div><div class="line">    mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">      mg_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">      mg_interface_matrices;</div><div class="line">    mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      mg_interface_matrices[level].initialize(mg_matrices[level]);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">      mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">                   LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">                   <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1e-12 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG build smoother time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Total setup time               (wall) &quot;</span> &lt;&lt; setup_time &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line"></div><div class="line">    time.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">    time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a>(solution);</div><div class="line">    cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Time solve (&quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations)&quot;</span></div><div class="line">          &lt;&lt; (solver_control.last_step() &lt; 10 ? <span class="stringliteral">&quot;  &quot;</span> : <span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;(CPU/wall) &quot;</span></div><div class="line">          &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1000000)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">    flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Time write output          (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(<a class="code" href="classdouble.html">double</a>) * n_vect_doubles;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Vectorization over &quot;</span> &lt;&lt; n_vect_doubles</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; doubles = &quot;</span> &lt;&lt; n_vect_bits &lt;&lt; <span class="stringliteral">&quot; bits (&quot;</span></div><div class="line">            &lt;&lt; <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">          }</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">        setup_system();</div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      };</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step37</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step37;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;dimension&gt; laplace_problem;</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_16.html">step-16</a> , <a class="el" href="step_40.html">step-40</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The test case</a><a href="#Thetestcase">The test case</a>
        <li><a href="#Matrixvectorproductimplementation">Matrix-vector product implementation</a><a href="#Matrixvectorproductimplementation">Matrix-vector product implementation</a>
        <li><a href="#Combinationwithmultigrid">Combination with multigrid</a><a href="#Combinationwithmultigrid">Combination with multigrid</a>
        <li><a href="#UsingCPUdependentinstructionsvectorization">Using CPU-dependent instructions (vectorization)</a><a href="#UsingCPUdependentinstructionsvectorization">Using CPU-dependent instructions (vectorization)</a>
        <li><a href="#Runningmultigridonlargescaleparallelcomputers">Running multigrid on large-scale parallel computers</a><a href="#Runningmultigridonlargescaleparallelcomputers">Running multigrid on large-scale parallel computers</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#Matrixfreeimplementation">Matrix-free implementation</a><a href="#Matrixfreeimplementation">Matrix-free implementation</a>
      <ul>
        <li><a href="#Computationofcoefficient">Computation of coefficient</a><a href="#Computationofcoefficient">Computation of coefficient</a>
        <li><a href="#LocalevaluationofLaplaceoperator">Local evaluation of Laplace operator</a><a href="#LocalevaluationofLaplaceoperator">Local evaluation of Laplace operator</a>
      </ul>
        <li><a href="#LaplaceProblemclass">LaplaceProblem class</a><a href="#LaplaceProblemclass">LaplaceProblem class</a>
      <ul>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_rhs">LaplaceProblem::assemble_rhs</a><a href="#LaplaceProblemassemble_rhs">LaplaceProblem::assemble_rhs</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#LaplaceProblemoutput_results">LaplaceProblem::output_results</a><a href="#LaplaceProblemoutput_results">LaplaceProblem::output_results</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a><a href="#Programoutput">Program output</a>
        <li><a href="#Comparisonwithasparsematrix">Comparison with a sparse matrix</a><a href="#Comparisonwithasparsematrix">Comparison with a sparse matrix</a>
        <li><a href="#ResultsforlargescaleparallelcomputationsonSuperMUC"> Results for large-scale parallel computations on SuperMUC</a><a href="#ResultsforlargescaleparallelcomputationsonSuperMUC"> Results for large-scale parallel computations on SuperMUC</a>
        <li><a href="#Adaptivity"> Adaptivity</a><a href="#Adaptivity"> Adaptivity</a>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions</a><a href="#Possibilitiesforextensions"> Possibilities for extensions</a>
      <ul>
        <li><a href="#Kellyerrorestimator"> Kelly error estimator </a><a href="#Kellyerrorestimator"> Kelly error estimator </a>
        <li><a href="#Sharedmemoryparallelization"> Shared-memory parallelization</a><a href="#Sharedmemoryparallelization"> Shared-memory parallelization</a>
        <li><a href="#InhomogeneousDirichletboundaryconditions"> Inhomogeneous Dirichlet boundary conditions </a><a href="#InhomogeneousDirichletboundaryconditions"> Inhomogeneous Dirichlet boundary conditions </a>
      <ul>
        <li><a href="#UseFEEvaluationread_dof_values_plaintoavoidresolvingconstraints"> Use FEEvaluation::read_dof_values_plain() to avoid resolving constraints </a><a href="#UseFEEvaluationread_dof_values_plaintoavoidresolvingconstraints"> Use FEEvaluation::read_dof_values_plain() to avoid resolving constraints </a>
        <li><a href="#UseLaplaceOperatorwithasecondAffineConstraintsobjectwithoutDirichletconditions"> Use LaplaceOperator with a second AffineConstraints object without Dirichlet conditions </a><a href="#UseLaplaceOperatorwithasecondAffineConstraintsobjectwithoutDirichletconditions"> Use LaplaceOperator with a second AffineConstraints object without Dirichlet conditions </a>
    </ul>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em> This program was contributed by Katharina Kormann and Martin Kronbichler.</em></p>
<p><em>The algorithm for the matrix-vector product is based on the article <a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">A generic interface for parallel cell-based finite element operator application</a><a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">A generic interface for parallel cell-based finite element operator application</a> by Martin Kronbichler and Katharina Kormann, Computers and Fluids 63:135&ndash;147, 2012, and the paper &quot;Parallel finite element operator application: Graph partitioning and coloring&quot; by Katharina Kormann and Martin Kronbichler in: Proceedings of the 7th IEEE International Conference on e-Science, 2011.</em></p>
<p><em>This work was partly supported by the German Research Foundation (DFG) through the project "High-order discontinuous Galerkin for the exa-scale" (ExaDG) within the priority program "Software for Exascale Computing" (SPPEXA). The large-scale computations shown in the results section of this tutorial program were supported by Gauss Centre for Supercomputing e.V. (www.gauss-centre.eu) by providing computing time on the GCS Supercomputer SuperMUC at Leibniz Supercomputing Centre (LRZ, www.lrz.de) through project id pr83te. </em> <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example shows how to implement a matrix-free method, that is, a methodthat does not explicitly store the matrix elements, for a second-order Poissonequation with variable coefficients on a hypercube. The linear system will besolved with a multigrid method and uses large-scale parallelism with MPI. The major motivation for matrix-free methods is the fact that on today'sprocessors access to main memory (i.e., for objects that do not fit in thecaches) has become the bottleneck in many solvers for partial differential equations: To perform amatrix-vector product based on matrices, modern CPUs spend far more timewaiting for data to arrive from memory than on actually doing the floatingpoint multiplications and additions. Thus, if we could substitute looking upmatrix elements in memory by re-computing them &mdash; or rather, the operatorrepresented by these entries &mdash;, we may win in terms of overall run-timeeven if this requires a significant number of additional floating pointoperations. That said, to realize this with a trivial implementation is notenough and one needs to really look at the details to gain inperformance. This tutorial program and the papers referenced above show howone can implement such a scheme and demonstrates the speedup that can beobtained.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>In this example, we consider the Poisson problem </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot a(\mathbf x) \nabla u &amp;=&amp; 1, \\ u &amp;=&amp; 0 \quad \text{on}\ \partial \Omega \end{eqnarray*}
</p>
<p> where \(a(\mathbf x)\) is a variable coefficient.Below, we explain how to implement a matrix-vector product for thisproblem without explicitly forming the matrix. The construction can,of course, be done in a similar way for other equations as well. We choose as domain \(\Omega=[0,1]^3\) and \(a(\mathbf x)=\frac{1}{0.05 + 2\|\mathbf x\|^2}\) . Since the coefficient is symmetric around theorigin but the domain is not, we will end up with a non-symmetricsolution.</p>
<p><a class="anchor" id="Matrixvectorproductimplementation"></a></p><h3>Matrix-vector product implementation</h3>
<p>In order to find out how we can write a code that performs a matrix-vectorproduct, but does not need to store the matrix elements, let us start atlooking how a finite element matrix <em>A</em> is assembled: </p><p class="formulaDsp">
\begin{eqnarray*} A = \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_{\mathrm{cell,{loc-glob}}}^T A_{\mathrm{cell}} P_{\mathrm{cell,{loc-glob}}}. \end{eqnarray*}
</p>
<p> In this formula, the matrix <em>P</em><sub>cell,loc-glob</sub> is a rectangularmatrix that defines the index mapping from local degrees of freedom in thecurrent cell to the global degrees of freedom. The information from which thisoperator can be built is usually encoded in the <code>local_dof_indices</code> variable and is used in the assembly calls filling matrices in deal.II. Here,<em>A</em><sub>cell</sub> denotes the cell matrix associated with <em>A</em>. If we are to perform a matrix-vector product, we can hence use that </p><p class="formulaDsp">
\begin{eqnarray*} y &amp;=&amp; A\cdot u = \left(\sum_{\text{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} P_\mathrm{cell,{loc-glob}}\right) \cdot u \\ &amp;=&amp; \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} u_\mathrm{cell} \\ &amp;=&amp; \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}, \end{eqnarray*}
</p>
<p> where <em>u</em><sub>cell</sub> are the values of <em>u</em> at the degrees of freedomof the respective cell, and<em>v</em><sub>cell</sub>=<em>A</em><sub>cell</sub><em>u</em><sub>cell</sub>correspondingly for the result.A naive attempt to implement the local action of the Laplacian would hence beto use the following code: </p><div class="fragment"><div class="line">Matrixfree&lt;dim&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  dst = 0;</div><div class="line">  </div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>|</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_src (dofs_per_cell),</div><div class="line">                       cell_dst (dofs_per_cell);</div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div><div class="line">  std::vector&lt;double&gt; coefficient_values(n_q_points);</div><div class="line">  </div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices (dofs_per_cell);</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a> (cell);</div><div class="line">      coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             coefficient_values);</div><div class="line">  </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i,q)</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j,q)</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q)*</div><div class="line">                                 coefficient_values[q]);</div><div class="line">  </div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">  </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        cell_src(i) = src(local_dof_indices(i));</div><div class="line">  </div><div class="line">      cell_matrix.<a class="code" href="classFullMatrix.html#a65a409eeef6388d99ac15e2bbe8045f6">vmult</a> (cell_dst, cell_src);</div><div class="line">  </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        dst(local_dof_indices(i)) += cell_dst;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Here we neglected boundary conditions as well as any hanging nodes we mayhave, though neither would be very difficult to include using theAffineConstraints class. Note how we first generate the local matrix in theusual way as a sum over all quadrature points for each local matrix entry.To form the actual product as expressed in the above formula, weextract the values of <code>src</code> of the cell-related degrees of freedom(the action of <em>P</em><sub>cell,loc-glob</sub>), multiply by the local matrix(the action of <em>A</em><sub>cell</sub>), and finally add the result to thedestination vector <code>dst</code> (the action of<em>P</em><sub>cell,loc-glob</sub><sup>T</sup>, added over all the elements). Itis not more difficult than that, in principle. While this code is completely correct, it is very slow. For every cell, wegenerate a local matrix, which takes three nested loops with loop length equalto the number of local degrees of freedom to compute. Themultiplication itself is then done by two nested loops, which means that itis much cheaper. One way to improve this is to realize that conceptually the localmatrix can be thought of as the product of three matrices, </p><p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell}, \end{eqnarray*}
</p>
<p> where for the example of the Laplace operator the (<em>q</em>*dim+<em>d,i</em>)-thelement of <em>B</em><sub>cell</sub> is given by <code>fe_values.shape_grad(i,q)[d]</code> . This matrix consists of <code>dim*n_q_points</code> rows and <code>dofs_per_cell</code> columns. The matrix<em>D</em><sub>cell</sub> is diagonal and contains the values <code>fe_values.JxW(q) coefficient_values[q]</code> (or, rather, <code>dim</code> copies of each of these values). This kind of representation offinite element matrices can often be found in the engineering literature. When the cell matrix is applied to a vector, </p><p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell}\cdot u_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell} \cdot u_\mathrm{cell}, \end{eqnarray*}
</p>
<p> one would then not form the matrix-matrix products, but rather multiply onematrix at a time with a vector from right to left so that only threesuccessive matrix-vector products are formed. This approach removes the threenested loops in the calculation of the local matrix, which reduces thecomplexity of the work on one cell from something like \(\mathcal {O}(\mathrm{dofs\_per\_cell}^3)\) to \(\mathcal {O}(\mathrm{dofs\_per\_cell}^2)\) . An interpretation of this algorithm is thatwe first transform the vector of values on the local DoFs to a vector ofgradients on the quadrature points. In the second loop, we multiply thesegradients by the integration weight and the coefficient. The third loop appliesthe second gradient (in transposed form), so that we get back to a vector of(Laplacian) values on the cell dofs. The bottleneck in the above code is the operations done by the call to <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> for every <code>cell</code> , which take about as much time asthe other steps together (at least if the mesh is unstructured; deal.II canrecognize that the gradients are often unchanged on structured meshes). Thatis certainly not ideal and we would like to do better than this. What thereinit function does is to calculate the gradient in real space bytransforming the gradient on the reference cell using the Jacobian of thetransformation from real to reference cell. This is done for each basisfunction on the cell, for each quadrature point. The Jacobian does not dependon the basis function, but it is different on different quadrature points ingeneral. If you only build the matrix once as we've done in all previoustutorial programs, there is nothing to be optimized since <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> needs to be called on every cell. In this process, the transformation isapplied while computing the local matrix elements. In a matrix-free implementation, however, we will compute those integrals veryoften because iterative solvers will apply the matrix many times during thesolution process. Therefore, we need to think about whether we may be able tocache some data that gets reused in the operator applications, i.e., integralcomputations. On the other hand, we realize that we must not cache too muchdata since otherwise we get back to the situation where memory access becomesthe dominating factor. Therefore, we will not store the transformed gradientsin the matrix <em>B</em>, as they would in general be different for each basisfunction and each quadrature point on every element for curved meshes. The trick is to factor out the Jacobian transformation and first apply thegradient on the reference cell only. This operation interpolates the vector ofvalues on the local dofs to a vector of (unit-coordinate) gradients on thequadrature points. There, we first apply the Jacobian that we factored outfrom the gradient, then apply the weights of the quadrature, and finally applythe transposed Jacobian for preparing the third loop which tests by thegradients on the unit cell and sums over quadrature points. Let us again write this in terms of matrices. Let the matrix<em>B</em><sub>cell</sub> denote the cell-related gradient matrix, with each rowcontaining the values on the quadrature points. It is constructed by amatrix-matrix product as </p><p class="formulaDsp">
\begin{eqnarray*} B_\mathrm{cell} = J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell}, \end{eqnarray*}
</p>
<p> where<em>B</em><sub>ref_cell</sub> denotes the gradient on the reference cell and<em>J</em><sup>-T</sup><sub>cell</sub> denotes the inverse transpose Jacobian ofthe transformation from unit to real cell (in the language of transformations,the operation represented by <em>J</em><sup>-T</sup><sub>cell</sub> represents acovariant transformation). <em>J</em><sup>-T</sup><sub>cell</sub> isblock-diagonal, and the blocks size is equal to the dimension of theproblem. Each diagonal block is the Jacobian transformation that goes from thereference cell to the real cell. Putting things together, we find that </p><p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell} = B_\mathrm{cell}^T D B_\mathrm{cell} = B_\mathrm{ref\_cell}^T J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell}, \end{eqnarray*}
</p>
<p> so we calculate the product (starting the local product from the right) </p><p class="formulaDsp">
\begin{eqnarray*} v_\mathrm{cell} = B_\mathrm{ref\_cell}^T J_\mathrm{cell}^{-1} D J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell} u_\mathrm{cell}, \quad v = \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}. \end{eqnarray*}
</p>
<div class="fragment"><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_reference (fe, quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="namespaceGridGenerator.html#aeb9a83e353f8d69ce49ebdd191a3a51f">reference_cell</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(reference_cell, 0., 1.);</div><div class="line">  fe_values_reference.reinit (reference_cell.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a>());</div><div class="line">  </div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fac654119724aff0c394743170ae949d18">update_inverse_jacobians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  </div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a> (cell);</div><div class="line">      coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             coefficient_values);</div><div class="line">  </div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line">  </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        cell_src(i) = src(local_dof_indices(i));</div><div class="line">  </div><div class="line">      temp_vector = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            temp_vector(q*dim+d) +=</div><div class="line">              fe_values_reference.shape_grad(i,q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] cell_src(i);</div><div class="line">  </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="comment">// apply the transposed inverse Jacobian of the mapping</span></div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> temp;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp[d] = temp_vector(q*dim+d);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            {</div><div class="line">              <span class="keywordtype">double</span> sum = 0;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e=0; e&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div><div class="line">                sum += fe_values.<a class="code" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian</a>(q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>]</div><div class="line">                               temp[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>];</div><div class="line">              temp_vector(q*dim+d) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">            }</div><div class="line">  </div><div class="line">          <span class="comment">// multiply by coefficient and integration weight</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp_vector(q*dim+d)= fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) coefficient_values[q];</div><div class="line">  </div><div class="line">          <span class="comment">// apply the inverse Jacobian of the mapping</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp[d] = temp_vector(q*dim+d);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            {</div><div class="line">              <span class="keywordtype">double</span> sum = 0;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e=0; e&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div><div class="line">                sum += fe_values.<a class="code" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian</a>(q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>]</div><div class="line">                       temp[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>];</div><div class="line">              temp_vector(q*dim+d) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">  </div><div class="line">      cell_dst = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            cell_dst(i) += fe_values_reference.shape_grad(i,q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>]</div><div class="line">                                   temp_vector(q*dim+d);</div><div class="line">  </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        dst(local_dof_indices(i)) += cell_dst(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Note how we create an additional <a class="el" href="classFEValues.html">FEValues</a> object for the reference cellgradients and how we initialize it to the reference cell. The actualderivative data is then applied by the inverse, transposed Jacobians (deal.IIcalls the Jacobian matrix from real to unit cell inverse_jacobian, as theforward transformation is from unit to real cell). The factor \(J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T}\) isblock-diagonal over quadrature. In this form, one realizes that variablecoefficients (possibly expressed through a tensor) and general grid topologieswith Jacobian transformations have a similar effect on the coefficienttransforming the unit-cell derivatives. At this point, one might wonder why we store the matrix \(J_\mathrm{cell}^{-\mathrm T}\) and the coefficient separately, rather thanonly the complete factor \(J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T}\) . The latter would use less memory because thetensor is symmetric with six independent values in 3D, whereas for the formerwe would need nine entries for the inverse transposed Jacobian, one for thequadrature weight and Jacobian determinant, and one for the coefficient,totaling to 11 doubles. The reason is that the former approach allows forimplementing generic differential operators through a common framework ofcached data, whereas the latter specifically stores the coefficient for theLaplacian. In case applications demand for it, this specialization could payoff and would be worthwhile to consider. Note that the implementation indeal.II is smart enough to detect Cartesian or affine geometries where theJacobian is constant throughout the cell and needs not be stored for everycell (and indeed often is the same over different cells as well). The final optimization that is most crucial from an operation count point ofview is to make use of the tensor product structure in the basisfunctions. This is possible because we have factored out the gradient from thereference cell operation described by <em>B</em><sub>ref_cell</sub>, i.e., aninterpolation operation over the completely regular data fields of thereference cell. We illustrate the process of complexity reduction in two spacedimensions, but the same technique can be used in higher dimensions. On thereference cell, the basis functions are of the tensor product form \(\phi(x,y,z) = \varphi_i(x) \varphi_j(y)\) . The part of the matrix<em>B</em><sub>ref_cell</sub> that computes the first component has the form \(B_\mathrm{sub\_cell}^x = B_\mathrm{grad,x} \otimes B_\mathrm{val,y}\) , where<em>B</em><sub>grad,x</sub> and <em>B</em><sub>val,y</sub> contain the evaluationof all the 1D basis functions on all the 1D quadrature points. Forming amatrix <em>U</em> with <em>U(j,i)</em> containing the coefficient belonging tobasis function \(\varphi_i(x) \varphi_j(y)\) , we get \((B_\mathrm{grad,x} \otimes B_\mathrm{val,y})u_\mathrm{cell} = B_\mathrm{val,y} U B_\mathrm{grad,x}\) . Thisreduces the complexity for computing this product from \(p^4\) to \(2 p^3\) , where<em>p</em>-1 is the degree of the finite element (i.e., equivalently, <em>p</em>is the number of shape functions in each coordinate direction), or \(p^{2d}\) to \(d p^{d+1}\) in general. The reason why we look at the complexity in terms ofthe polynomial degree is since we want to be able to go to high degrees andpossibly increase the polynomial degree <em>p</em> instead of the gridresolution. Good algorithms for moderate degrees like the ones used here arelinear in the polynomial degree independent on the dimension, as opposed tomatrix-based schemes or naive evaluation through <a class="el" href="classFEValues.html">FEValues</a>. The techniques usedin the implementations of deal.II have been established in the spectralelement community since the 1980s. Implementing a matrix-free and cell-based finite element operator requires asomewhat different program design as compared to the usual matrix assemblycodes shown in previous tutorial programs. The data structures for doing thisare the <a class="el" href="classMatrixFree.html">MatrixFree</a> class that collects all data and issues a (parallel) loopover all cells and the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class that evaluates finite element basisfunctions by making use of the tensor product structure. The implementation of the matrix-free matrix-vector product shown in thistutorial is slower than a matrix-vector product using a sparse matrix forlinear elements, but faster for all higher order elements thanks to thereduced complexity due to the tensor product structure and due to less memorytransfer during computations. The impact of reduced memory transfer isparticularly beneficial when working on a multicore processor where severalprocessing units share access to memory. In that case, an algorithm which iscomputation bound will show almost perfect parallel speedup (apart frompossible changes of the processor's clock frequency through turbo modesdepending on how many cores are active), whereas an algorithm that is bound bymemory transfer might not achieve similar speedup (even when the work isperfectly parallel and one could expect perfect scaling like in sparsematrix-vector products). An additional gain with this implementation is thatwe do not have to build the sparse matrix itself, which can also be quiteexpensive depending on the underlying differential equation. Moreover, theabove framework is simple to generalize to nonlinear operations, as wedemonstrate in <a class="el" href="step_48.html">step-48</a> .</p>
<p><a class="anchor" id="Combinationwithmultigrid"></a></p><h3>Combination with multigrid</h3>
<p>Above, we have gone to significant lengths to implement a matrix-vectorproduct that does not actually store the matrix elements. In many user codes,however, one wants more than just doing a few matrix-vector products &mdash;one wants to do as few of these operations as possible when solving linearsystems. In theory, we could use the CG method without preconditioning;however, that would not be very efficient for the Laplacian. Rather,preconditioners are used for increasing the speed ofconvergence. Unfortunately, most of the more frequently used preconditionerssuch as SSOR, ILU or algebraic multigrid (AMG) cannot be used here becausetheir implementation requires knowledge of the elements of the system matrix. One solution is to use geometric multigrid methods as shown in <a class="el" href="step_16.html">step-16</a> . Theyare known to be very fast, and they are suitable for our purpose since allingredients, including the transfer between different grid levels, can beexpressed in terms of matrix-vector products related to a collection ofcells. All one needs to do is to find a smoother that is based onmatrix-vector products rather than all the matrix entries. One such candidatewould be a damped Jacobi iteration that requires access to the matrixdiagonal, but it is often not sufficiently good in damping all high-frequencyerrors. The properties of the Jacobi method can be improved by iterating it afew times with the so-called Chebyshev iteration. The Chebyshev iteration isdescribed by a polynomial expression of the matrix-vector product where thecoefficients can be chosen to achieve certain properties, in this case tosmooth the high-frequency components of the error which are associated to theeigenvalues of the Jacobi-preconditioned matrix. At degree zero, the Jacobimethod with optimal damping parameter is retrieved, whereas higher ordercorrections are used to improve the smoothing properties. The effectiveness ofChebyshev smoothing in multigrid has been demonstrated, e.g., in the article<a href="http://www.sciencedirect.com/science/article/pii/S0021999103001943"><em>M. Adams, M. Brezina, J. Hu, R. Tuminaro. Parallel multigrid smoothers: polynomial versus Gauss&ndash;Seidel, J. Comput. Phys. 188:593&ndash;610, 2003</em><em>M. Adams, M. Brezina, J. Hu, R. Tuminaro. Parallel multigrid smoothers: polynomial versus Gauss&ndash;Seidel, J. Comput. Phys. 188:593&ndash;610, 2003</em></a>. This publication also identifies one more advantage ofChebyshev smoothers that we exploit here, namely that they are easy toparallelize, whereas SOR/Gauss&ndash;Seidel smoothing relies on substitutions,for which a naive parallelization works on diagonal sub-blocks of the matrix,thereby decreases efficiency (for more detail see e.g. Y. Saad, IterativeMethods for Sparse Linear Systems, SIAM, 2nd edition, 2003, chapters 11 &amp; 12). The implementation into the multigrid framework is then straightforward. Themultigrid implementation in this program is similar to <a class="el" href="step_16.html">step-16</a> and includesadaptivity.</p>
<p><a class="anchor" id="UsingCPUdependentinstructionsvectorization"></a></p><h3>Using CPU-dependent instructions (vectorization)</h3>
<p>The computational kernels for evaluation in <a class="el" href="classFEEvaluation.html">FEEvaluation</a> are written in a wayto optimally use computational resources. To achieve this, they do not operateon double data types, but something we call <a class="el" href="classVectorizedArray.html">VectorizedArray</a> (check e.g. thereturn type of <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">FEEvaluationBase::get_value</a>, which is <a class="el" href="classVectorizedArray.html">VectorizedArray</a> for ascalar element and a <a class="el" href="classTensor.html">Tensor</a> of <a class="el" href="classVectorizedArray.html">VectorizedArray</a> for a vector finiteelement). <a class="el" href="classVectorizedArray.html">VectorizedArray</a> is a short array of doubles or float whose lengthdepends on the particular computer system in use. For example, systems basedon x86-64 support the streaming SIMD extensions (SSE), where the processor'svector units can process two doubles (or four single-precision floats) by oneCPU instruction. Newer processors (from about 2012 and onwards) support theso-called advanced vector extensions (AVX) with 256 bit operands, which canuse four doubles and eight floats, respectively. Vectorization is asingle-instruction/multiple-data (SIMD) concept, that is, one CPU instructionis used to process multiple data values at once. Often, finite elementprograms do not use vectorization explicitly as the benefits of this conceptare only in arithmetic intensive operations. The bulk of typical finiteelement workloads are memory bandwidth limited (operations on sparse matricesand vectors) where the additional computational power is useless. Behind the scenes, optimized BLAS packages might heavily rely onvectorization, though. Also, optimizing compilers might automaticallytransform loops involving standard code into more efficient vectorized form(deal.II uses OpenMP SIMD pragmas inside the regular loops of vectorupdates). However, the data flow must be very regular in order for compilersto produce efficient code. For example, already the automatic vectorization ofthe prototype operation that benefits from vectorization, matrix-matrixproducts, fails on most compilers (as of writing this tutorial in early 2012and updating in late 2016, neither gcc nor the Intel compiler manage toproduce useful vectorized code for the <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a> function, and noteven on the simpler case where the matrix bounds are compile-time constantsinstead of run-time constants as in <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a>). The main reason forthis is that the information to be processed at the innermost loop (that iswhere vectorization is applied) is not necessarily a multiple of the vectorlength, leaving parts of the resources unused. Moreover, the data that canpotentially be processed together might not be laid out in a contiguous way inmemory or not with the necessary alignment to address boundaries that areneeded by the processor. Or the compiler might not be able to prove that dataarrays do not overlap when loading several elements at once. In the matrix-free implementation in deal.II, we have therefore chosen toapply vectorization at the level which is most appropriate for finite elementcomputations: The cell-wise computations are typically exactly the same forall cells (except for indices in the indirect addressing used while readingfrom and writing to vectors), and hence SIMD can be used to process severalcells at once. In all what follows, you can think of a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> to holddata from several cells. Remember that it is not related to the spatialdimension and the number of elements e.g. in a <a class="el" href="classTensor.html">Tensor</a> or <a class="el" href="classPoint.html">Point</a>. Note that vectorization depends on the CPU the code is running on and forwhich the code is compiled. In order to generate the fastest kernels ofFEEvaluation for your computer, you should compile deal.II with the so-called<em>native</em> processor variant. When using the gcc compiler, it can beenabled by setting the variable <code>CMAKE_CXX_FLAGS</code> to<code>"-march=native"</code> in the cmake build settings (on the command line,specify <code>-DCMAKE_CXX_FLAGS="-march=native"</code>, see the deal.II README formore information). Similar options exist for other compilers. We outputthe current vectorization length in the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function of this example.</p>
<p><a class="anchor" id="Runningmultigridonlargescaleparallelcomputers"></a></p><h3>Running multigrid on large-scale parallel computers</h3>
<p>As mentioned above, all components in the matrix-free framework can easily beparallelized with MPI using domain decomposition. Thanks to the easy access tolarge-scale parallel meshes through p4est (see <a class="el" href="step_40.html">step-40</a> for details) indeal.II, and the fact that cell-based loops with matrix-free evaluation<em>only</em> need a decomposition of the mesh into chunks of roughly equal sizeon each processor, there is relatively little to do to write a parallelprogram working with distributed memory. While other tutorial programs usingMPI have relied on either PETSc or Trilinos, this program uses deal.II's ownparallel vector facilities. The deal.II parallel vector class, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>, holdsthe processor-local part of the solution as well as data fields for ghostedDoFs, i.e. DoFs that are owned by a remote processor but accessed by cellsthat are owned by the present processor. In the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">glossary</a> these degrees of freedom are referred to as locally active degreesof freedom. The function <a class="el" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">MatrixFree::initialize_dof_vector()</a> provides a methodthat sets this design. Note that hanging nodes can relate to additionalghosted degrees of freedom that must be included in the distributed vector butare not part of the locally active DoFs in the sense of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">glossary</a>. Moreover, the distributed vector holds theMPI metadata for DoFs that are owned locally but needed by otherprocessors. A benefit of the design of this vector class is the way ghostedentries are accessed. In the storage scheme of the vector, the data arrayextends beyond the processor-local part of the solution with further vectorentries available for the ghosted degrees of freedom. This gives a contiguousindex range for all locally active degrees of freedom. (Note that the indexrange depends on the exact configuration of the mesh.) Since matrix-freeoperations can be thought of doing linear algebra that is performancecritical, and performance-critical code cannot waste time on doing MPI-globalto MPI-local index translations, the availability of an index spaces local toone MPI rank is fundamental. The way things are accessed here is a directarray access. This is provided through <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">LinearAlgebra::distributed::Vector::local_element()</a>, but it is actually rarelyneeded because all of this happens internally in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>. The design of <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> is similar to the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> data types wehave used in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_32.html">step-32</a> before, but since we do not need any otherparallel functionality of these libraries, we use the <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> class of deal.II instead of linking in anotherlarge library in this tutorial program. Also note that the PETSc and Trilinosvectors do not provide the fine-grained control over ghost entries with directarray access because they abstract away the necessary implementation details.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First include the necessary files from the deal.II library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>This includes the data structures for the efficient implementation of matrix-free methods or more generic finite element operators with the class <a class="el" href="classMatrixFree.html">MatrixFree</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step37</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>To be efficient, the operations performed in the matrix-free implementation require knowledge of loop lengths at compile time, which are given by the degree of the finite element. Hence, we collect the values of the two template parameters that can be changed at one place in the code. Of course, one could make the degree of the finite element a run-time parameter by compiling the computational kernels for all degrees that are likely (say, between 1 and 6) and selecting the appropriate kernel at run time. Here, we simply choose second order \(Q_2\) elements and choose dimension 3 as standard.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_finite_element = 2;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension             = 3;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>We define a variable coefficient function for the Poisson problem. It is similar to the function in <a class="el" href="step_5.html">step-5</a> but we use the form \(a(\mathbf x)=\frac{1}{0.05 + 2\|\bf x\|^2}\) instead of a discontinuous one. It is merely to demonstrate the possibilities of this implementation, rather than making much sense physically. We define the coefficient in the same way as functions in earlier tutorial programs. There is one new function, namely a <code>value</code> method with template argument <code>number</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">  number <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        component = 0) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>This is the new function mentioned above: Evaluate the coefficient for abstract type <code>number</code>. It might be just a usual double, but it can also be a somewhat more complicated type that we call <a class="el" href="classVectorizedArray.html">VectorizedArray</a>. This data type is essentially a short array of doubles as discussed in the introduction that holds data from several cells. For example, we evaluate the coefficient shown here not on a simple point as usually done, but we hand it a <a class="el" href="classPoint.html">Point</a>&lt;dim,<a class="el" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> &gt; point, which is actually a collection of four points in the case of AVX. Do not confuse the entries in <a class="el" href="classVectorizedArray.html">VectorizedArray</a> with the different coordinates of the point. Indeed, the data is laid out such that <code>p[0]</code> returns a <a class="el" href="classVectorizedArray.html">VectorizedArray</a>, which in turn contains the x-coordinate for the first point and the second point. You may access the coordinates individually using e.g. <code>p[0][j]</code> , j=0,1,2,3, but it is recommended to define operations on a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> as much as possible in order to make use of vectorized operations. In the function implementation, we assume that the number type overloads basic arithmetic operations, so we just write the code as usual. The base class function <code>value</code> is then computed from the templated function with double type, in order to avoid duplicating code.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">number Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1. / (0.05 + 2. p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> value&lt;double&gt;(p, component);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Matrixfreeimplementation"></a> </p><h3>Matrix-free implementation</h3>
<p>The following class, called <code>LaplaceOperator</code> , implements the differential operator. For all practical purposes, it is a matrix, i.e., you can ask it for its size (member functions <code>m(), n()</code> ) and you can apply it to a vector (the <code>vmult()</code> function). The difference to a real matrix of course lies in the fact that this class does not actually store the <em>elements</em> of the matrix, but only knows how to compute the action of the operator when applied to a vector. The infrastructure describing the matrix size, the initialization from a <a class="el" href="classMatrixFree.html">MatrixFree</a> object, and the various interfaces to matrix-vector products through vmult() and Tvmult() methods, is provided by the class MatrixFreeOperator::Base from which this class derives. The LaplaceOperator class defined here only has to provide a few interfaces, namely the actual action of the operator through the apply_add() method that gets used in the vmult() functions, and a method to compute the diagonal entries of the underlying matrix. We need the diagonal for the definition of the multigrid smoother. Since we consider a problem with variable coefficient, we further implement a method that can fill the coefficient values. Note that the file <code>include/deal.II/matrix_free/operators.h</code> already contains an implementation of the Laplacian through the class <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a>. For educational purposes, the operator is re-implemented in this tutorial program, explaining the ingredients and concepts used there. This program makes use of the data cache for finite element operator application that is integrated in deal.II. This data cache class is called <a class="el" href="classMatrixFree.html">MatrixFree</a>. It contains mapping information (Jacobians) and index relations between local and global degrees of freedom. It also contains constraints like the ones from hanging nodes or Dirichlet boundary conditions. Moreover, it can issue a loop over all cells in parallel, making sure that only cells are worked on that do not share any degree of freedom (this makes the loop thread-safe when writing into destination vectors). This is a more advanced strategy compared to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class described in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> module. Of course, to not destroy thread-safety, we have to be careful when writing into class-global structures. The class implementing the Laplace operator has three template arguments, one for the dimension (as many deal.II classes carry), one for the degree of the finite element (which we need to enable efficient computations through the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class), and one for the underlying scalar type. We want to use <code>double</code> numbers (i.e., double precision, 64-bit floating point) for the final matrix, but floats (single precision, 32-bit floating point numbers) for the multigrid level matrices (as that is only a preconditioner, and floats can be processed twice as fast). The class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> also takes a template argument for the number of quadrature points in one dimension. In the code below, we hard-code it to <code>fe_degree+1</code> . If we wanted to change it independently of the polynomial degree, we would need to add a template parameter as is done in the <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a> class. As a sidenote, if we implemented several different operations on the same grid and degrees of freedom (like a mass matrix and a Laplace matrix), we would define two classes like the current one for each of the operators (derived from the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class), and let both of them refer to the same <a class="el" href="classMatrixFree.html">MatrixFree</a> data cache from the general problem class. The interface through <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> requires us to only provide a minimal set of functions. This concept allows for writing complex application codes with many matrix-free operations.</p>
<pre class="fragment">@note   Storing values of type   &lt;code&gt;VectorizedArray&lt;number&gt;&lt;/code&gt;   requires care: Here, we use the deal.II table class which is prepared to hold the data with correct alignment. However, storing e.g. an   &lt;code&gt;std::vector&lt;VectorizedArray&lt;number&gt; &gt;&lt;/code&gt;   is not possible with vectorization: A certain alignment of the data with the memory address boundaries is required (essentially, a VectorizedArray that is 32 bytes long in case of AVX needs to start at a memory address that is divisible by 32). The table class (as well as the AlignedVector class it is based on) makes sure that this alignment is respected, whereas   std::vector   does not in general, which may lead to segmentation faults at strange places for some systems or suboptimal performance for other systems.
</pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keyword">class </span>LaplaceOperator</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">      Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">  LaplaceOperator();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_coefficient(<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">              <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">              <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_compute_diagonal(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;              data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp; dst,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                         dummy,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; coefficient;</div><div class="line">};</div></div><!-- fragment --><p>This is the constructor of the <code>LaplaceOperator</code> class. All it does is to call the default constructor of the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, which in turn is based on the <a class="el" href="classSubscriptor.html">Subscriptor</a> class that asserts that this class is not accessed after going out of scope e.g. in a preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">LaplaceOperator&lt;dim, fe_degree, number&gt;::LaplaceOperator()</div><div class="line">  : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                              <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="classVector.html">Vector</a>&lt;number&gt;&gt;()</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">{</div><div class="line">  coefficient.reinit(0, 0);</div><div class="line">  <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">    clear();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computationofcoefficient"></a> </p><h4>Computation of coefficient</h4>
<p>To initialize the coefficient, we directly give it the Coefficient class defined above and then select the method <code>coefficient_function.value</code> with vectorized number (which the compiler can deduce from the point data type). The use of the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class (and its template arguments) will be explained below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::evaluate_coefficient(</div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line">  coefficient.reinit(n_cells, phi.n_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        coefficient(cell, q) =</div><div class="line">          coefficient_function.value(phi.quadrature_point(q));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LocalevaluationofLaplaceoperator"></a> </p><h4>Local evaluation of Laplace operator</h4>
<p>Here comes the main function of this class, the evaluation of the matrix-vector product (or, in general, a finite element operator evaluation). This is done in a function that takes exactly four arguments, the <a class="el" href="classMatrixFree.html">MatrixFree</a> object, the destination and source vectors, and a range of cells that are to be worked on. The method <code>cell_loop</code> in the <a class="el" href="classMatrixFree.html">MatrixFree</a> class will internally call this function with some range of cells that is obtained by checking which cells are possible to work on simultaneously so that write operations do not cause any race condition. Note that the cell range used in the loop is not directly the number of (active) cells in the current mesh, but rather a collection of batches of cells. In other word, "cell" may be the wrong term to begin with, since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> groups data from several cells together. This means that in the loop over quadrature points we are actually seeing a group of quadrature points of several cells as one block. This is done to enable a higher degree of vectorization. The number of such "cells" or "cell batches" is stored in <a class="el" href="classMatrixFree.html">MatrixFree</a> and can be queried through <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a>. Compared to the deal.II cell iterators, in this class all cells are laid out in a plain array with no direct knowledge of level or neighborship relations, which makes it possible to index the cells by unsigned integers. The implementation of the Laplace operator is quite simple: First, we need to create an object <a class="el" href="classFEEvaluation.html">FEEvaluation</a> that contains the computational kernels and has data fields to store temporary results (e.g. gradients evaluated on all quadrature points on a collection of a few cells). Note that temporary results do not use a lot of memory, and since we specify template arguments with the element order, the data is stored on the stack (without expensive memory allocation). Usually, one only needs to set two template arguments, the dimension as a first argument and the degree of the finite element as the second argument (this is equal to the number of degrees of freedom per dimension minus one for <a class="el" href="classFE__Q.html">FE_Q</a> elements). However, here we also want to be able to use float numbers for the multigrid preconditioner, which is the last (fifth) template argument. Therefore, we cannot rely on the default template arguments and must also fill the third and fourth field, consequently. The third argument specifies the number of quadrature points per direction and has a default value equal to the degree of the element plus one. The fourth argument sets the number of components (one can also evaluate vector-valued functions in systems of PDEs, but the default is a scalar element), and finally the last argument sets the number type. Next, we loop over the given cell range and then we continue with the actual implementation: </p><ol>
<li>
Tell the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object the (macro) cell we want to work on. </li>
<li>
Read in the values of the source vectors ( <code>read_dof_values</code>), including the resolution of constraints. This stores \(u_\mathrm{cell}\) as described in the introduction. </li>
<li>
Compute the unit-cell gradient (the evaluation of finite element functions). Since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> can combine value computations with gradient computations, it uses a unified interface to all kinds of derivatives of order between zero and two. We only want gradients, no values and no second derivatives, so we set the function arguments to true in the gradient slot (second slot), and to false in the values slot (first slot). There is also a third slot for the Hessian which is false by default, so it needs not be given. Note that the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class internally evaluates shape functions in an efficient way where one dimension is worked on at a time (using the tensor product form of shape functions and quadrature points as mentioned in the introduction). This gives complexity equal to \(\mathcal O(d^2 (p+1)^{d+1})\) for polynomial degree \(p\) in \(d\) dimensions, compared to the naive approach with loops over all local degrees of freedom and quadrature points that is used in <a class="el" href="classFEValues.html">FEValues</a> and costs \(\mathcal O(d (p+1)^{2d})\) . </li>
<li>
Next comes the application of the Jacobian transformation, the multiplication by the variable coefficient and the quadrature weight. <a class="el" href="classFEEvaluation.html">FEEvaluation</a> has an access function <code>get_gradient</code> that applies the Jacobian and returns the gradient in real space. Then, we just need to multiply by the (scalar) coefficient, and let the function <code>submit_gradient</code> apply the second Jacobian (for the test function) and the quadrature weight and Jacobian determinant (JxW). Note that the submitted gradient is stored in the same data field as where it is read from in <code>get_gradient</code>. Therefore, you need to make sure to not read from the same quadrature point again after having called <code>submit_gradient</code> on that particular quadrature point. In general, it is a good idea to copy the result of <code>get_gradient</code> when it is used more often than once. </li>
<li>
Next follows the summation over quadrature points for all test functions that corresponds to the actual integration step. For the Laplace operator, we just multiply by the gradient, so we call the integrate function with the respective argument set. If you have an equation where you test by both the values of the test functions and the gradients, both template arguments need to be set to true. Calling first the integrate function for values and then gradients in a separate call leads to wrong results, since the second call will internally overwrite the results from the first call. Note that there is no function argument for the second derivative for integrate step. </li>
<li>
Eventually, the local contributions in the vector \(v_\mathrm{cell}\) as mentioned in the introduction need to be added into the result vector (and constraints are applied). This is done with a call to <code>distribute_local_to_global</code>, the same name as the corresponding function in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> (only that we now store the local vector in the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object, as are the indices between local and global degrees of freedom). </li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values(src);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_gradient(coefficient(cell, q) phi.get_gradient(q), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      phi.distribute_local_to_global(dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function implements the loop over all cells for the Base::apply_add() interface. This is done with the <code>cell_loop</code> of the <a class="el" href="classMatrixFree.html">MatrixFree</a> class, which takes the operator() of this class with arguments <a class="el" href="classMatrixFree.html">MatrixFree</a>, OutVector, InVector, cell_range. When working with MPI parallelization (but no threading) as is done in this tutorial program, the cell loop corresponds to the following three lines of code: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line">src.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values</a>();</div><div class="line">local_apply(*this-&gt;data, dst, src, std::make_pair(0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>,</div><div class="line">                                                  data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>()));</div><div class="line">dst.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> Here, the two calls update_ghost_values() and <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> perform the data exchange on processor boundaries for MPI, once for the source vector where we need to read from entries owned by remote processors, and once for the destination vector where we have accumulated parts of the residuals that need to be added to the respective entry of the owner processor. However, <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop</a> does not only abstract away those two calls, but also performs some additional optimizations. On the one hand, it will split the update_ghost_values() and <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> calls in a way to allow for overlapping communication and computation. The local_apply function is then called with three cell ranges representing partitions of the cell range from 0 to <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a>. On the other hand, cell_loop also supports thread parallelism in which case the cell ranges are split into smaller chunks and scheduled in an advanced way that avoids access to the same vector entry by several threads. That feature is explained in <a class="el" href="step_48.html">step-48</a> . Note that after the cell loop, the constrained degrees of freedom need to be touched once more for sensible vmult() operators: Since the assembly loop automatically resolves constraints (just as the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> call does), it does not compute any contribution for constrained degrees of freedom, leaving the respective entries zero. This would represent a matrix that had empty rows and columns for constrained degrees of freedom. However, iterative solvers like CG only work for non-singular matrices. The easiest way to do that is to set the sub-block of the matrix that corresponds to constrained DoFs to an identity matrix, in which case application of the matrix would simply copy the elements of the right hand side vector into the left hand side. Fortunately, the vmult() implementations <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> do this automatically for us outside the apply_add() function, so we do not need to take further action here. When using the combination of <a class="el" href="classMatrixFree.html">MatrixFree</a> and <a class="el" href="classFEEvaluation.html">FEEvaluation</a> in parallel with MPI, there is one aspect to be careful about &mdash; the indexing used for accessing the vector. For performance reasons, <a class="el" href="classMatrixFree.html">MatrixFree</a> and <a class="el" href="classFEEvaluation.html">FEEvaluation</a> are designed to access vectors in MPI-local index space also when working with multiple processors. Working in local index space means that no index translation needs to be performed at the place the vector access happens, apart from the unavoidable indirect addressing. However, local index spaces are ambiguous: While it is standard convention to access the locally owned range of a vector with indices between 0 and the local size, the numbering is not so clear for the ghosted entries and somewhat arbitrary. For the matrix-vector product, only the indices appearing on locally owned cells (plus those referenced via hanging node constraints) are necessary. However, in deal.II we often set all the degrees of freedom on ghosted elements as ghosted vector entries, called the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs described in the glossary</a>. In that case, the MPI-local index of a ghosted vector entry can in general be different in the two possible ghost sets, despite referring to the same global index. To avoid problems, <a class="el" href="classFEEvaluation.html">FEEvaluation</a> checks that the partitioning of the vector used for the matrix-vector product does indeed match with the partitioning of the indices in <a class="el" href="classMatrixFree.html">MatrixFree</a> by a check called <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1121c9b5aa9c34d0fe36486fecf08b58">LinearAlgebra::distributed::Vector::partitioners_are_compatible</a>. To facilitate things, the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class includes a mechanism to fit the ghost set to the correct layout. This happens in the ghost region of the vector, so keep in mind that the ghost region might be modified in both the destination and source vector after a call to a vmult() method. This is legitimate because the ghost region of a distributed deal.II vector is a mutable section and filled on demand. Vectors used in matrix-vector products must not be ghosted upon entry of vmult() functions, so no information gets lost.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">}</div></div><!-- fragment --><p>The following function implements the computation of the diagonal of the operator. Computing matrix entries of a matrix-free operator evaluation turns out to be more complicated than evaluating the operator. Fundamentally, we could obtain a matrix representation of the operator by applying the operator on <em>all</em> unit vectors. Of course, that would be very inefficient since we would need to perform <em>n</em> operator evaluations to retrieve the whole matrix. Furthermore, this approach would completely ignore the matrix sparsity. On an individual cell, however, this is the way to go and actually not that inefficient as there usually is a coupling between all degrees of freedom inside the cell. We first initialize the diagonal vector to the correct parallel layout. This vector is encapsulated in a member called inverse_diagonal_entries of type <a class="el" href="classDiagonalMatrix.html">DiagonalMatrix</a> in the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>. This member is a shared pointer that we first need to initialize and then get the vector representing the diagonal entries in the matrix. As to the actual diagonal computation, we again use the cell_loop infrastructure of <a class="el" href="classMatrixFree.html">MatrixFree</a> to invoke a local worker routine called local_compute_diagonal(). Since we will only write into a vector but not have any source vector, we put a dummy argument of type <code>unsigned int</code> in place of the source vector to confirm with the cell_loop interface. After the loop, we need to set the vector entries subject to Dirichlet boundary conditions to one (either those on the boundary described by the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object inside <a class="el" href="classMatrixFree.html">MatrixFree</a> or the indices at the interface between different grid levels in adaptive multigrid). This is done through the function <a class="el" href="classMatrixFreeOperators_1_1Base.html#a11ff9854b4433dc8a7795d1c117de2c3">MatrixFreeOperators::Base::set_constrained_entries_to_one()</a> and matches with the setting in the matrix-vector product provided by the Base operator. Finally, we need to invert the diagonal entries which is the form required by the Chebyshev smoother based on the Jacobi iteration. In the loop, we assert that all entries are non-zero, because they should either have obtained a positive contribution from integrals or be constrained and treated by <code>set_constrained_entries_to_one()</code> following cell_loop.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">LaplaceOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">{</div><div class="line">  this-&gt;inverse_diagonal_entries.reset(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">    this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dummy = 0;</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_compute_diagonal,</div><div class="line">                        <span class="keyword">this</span>,</div><div class="line">                        inverse_diagonal,</div><div class="line">                        dummy);</div><div class="line"></div><div class="line">  this-&gt;set_constrained_entries_to_one(inverse_diagonal);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size</a>(); ++i)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) &gt; 0.,</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No diagonal entry in a positive definite operator &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;should be zero&quot;</span>));</div><div class="line">      inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) =</div><div class="line">        1. / inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the local compute loop, we compute the diagonal by a loop over all columns in the local matrix and putting the entry 1 in the <em>i</em>th slot and a zero entry in all other slots, i.e., we apply the cell-wise differential operator on one unit vector at a time. The inner part invoking <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate</a>, the loop over quadrature points, and FEEvalution::integrate, is exactly the same as in the local_apply function. Afterwards, we pick out the <em>i</em>th entry of the local result and put it to a temporary storage (as we overwrite all entries in the array behind <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">FEEvaluation::get_dof_value()</a> with the next loop iteration). Finally, the temporary storage is written to the destination vector. Note how we use <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">FEEvaluation::get_dof_value()</a> and <a class="el" href="classFEEvaluationBase.html#a3afd9d62f5762c41973aa0f037dc5099">FEEvaluation::submit_dof_value()</a> to read and write to the data field that <a class="el" href="classFEEvaluation.html">FEEvaluation</a> uses for the integration on the one hand and writes into the global vector on the other hand. Given that we are only interested in the matrix diagonal, we simply throw away all other entries of the local matrix that have been computed along the way. While it might seem wasteful to compute the complete cell matrix and then throw away everything but the diagonal, the integration are so efficient that the computation does not take too much time. Note that the complexity of operator evaluation per element is \(\mathcal O((p+1)^{d+1})\) for polynomial degree \(k\) , so computing the whole matrix costs us \(\mathcal O((p+1)^{2d+1})\) operations, not too far away from \(\mathcal O((p+1)^{2d})\) complexity for computing the diagonal with <a class="el" href="classFEValues.html">FEValues</a>. Since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> is also considerably faster due to vectorization and other optimizations, the diagonal computation with this function is actually the fastest (simple) variant. (It would be possible to compute the diagonal with sum factorization techniques in \(\mathcal O((p+1)^{d+1})\) operations involving specifically adapted kernels&mdash;but since such kernels are only useful in that particular context and the diagonal computation is typically not on the critical path, they have not been implemented in deal.II.) Note that the code that calls distribute_local_to_global on the vector to accumulate the diagonal entries into the global matrix has some limitations. For operators with hanging node constraints that distribute an integral contribution of a constrained DoF to several other entries inside the distribute_local_to_global call, the vector interface used here does not exactly compute the diagonal entries, but lumps some contributions located on the diagonal of the local matrix that would end up in a off-diagonal position of the global matrix to the diagonal. The result is correct up to discretization accuracy as explained in <a href="http://dx.doi.org/10.4208/cicp.101214.021015a">Kormann (2016), section 5.3</a>, but not mathematically equal. In this tutorial program, no harm can happen because the diagonal is only used for the multigrid level matrices where no hanging node constraints appear.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;             data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;dst,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <a class="code" href="classAlignedVector.html">AlignedVector&lt;VectorizedArray&lt;number&gt;</a>&gt; <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>(phi.dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; phi.dofs_per_cell; ++j)</div><div class="line">            phi.submit_dof_value(<a class="code" href="classVectorizedArray.html">VectorizedArray&lt;number&gt;</a>(), j);</div><div class="line">          phi.submit_dof_value(make_vectorized_array&lt;number&gt;(1.), i);</div><div class="line"></div><div class="line">          phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">            phi.submit_gradient(coefficient(cell, q) phi.get_gradient(q),</div><div class="line">                                q);</div><div class="line">          phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">          <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i] = phi.get_dof_value(i);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">        phi.submit_dof_value(<a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i], i);</div><div class="line">      phi.distribute_local_to_global(dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemclass"></a> </p><h3>LaplaceProblem class</h3>
<p>This class is based on the one in <a class="el" href="step_16.html">step-16</a> . However, we replaced the SparseMatrix&lt;double&gt; class by our matrix-free implementation, which means that we can also skip the sparsity patterns. Notice that we define the LaplaceOperator class with the degree of finite element as template argument (the value is defined at the top of the file), and that we use float numbers for the multigrid level matrices. The class also has a member variable to keep track of all the detailed timings for setting up the entire chain of data before we actually go about solving the problem. In addition, there is an output stream (that is disabled by default) that can be used to output details for the individual setup operations instead of the summary only that is printed out by default. Since this program is designed to be used with MPI, we also provide the usual <code>pcout</code> output stream that only prints the information of the processor with MPI rank 0. The grid used for this programs can either be a distributed triangulation based on p4est (in case deal.II is configured to use p4est), otherwise it is a serial grid that only runs without MPI.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"> </div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"> </div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"> </div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"> </div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"> </div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType =</div><div class="line">      LaplaceOperator&lt;dim, degree_finite_element, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"> </div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = LaplaceOperator&lt;dim, degree_finite_element, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a> mg_matrices;</div><div class="line"> </div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"> </div><div class="line">    <span class="keywordtype">double</span>             setup_time;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> time_details;</div><div class="line">  };</div></div><!-- fragment --><p>When we initialize the finite element, we of course have to use the degree specified at the top of the file as well (otherwise, an exception will be thrown at some point, since the computational kernel defined in the templated LaplaceOperator class and the information from the finite element read out by <a class="el" href="classMatrixFree.html">MatrixFree</a> will not match). The constructor of the triangulation needs to set an additional flag that tells the grid to conform to the 2:1 cell balance over vertices, which is needed for the convergence of the geometric multigrid routines. For the distributed grid, we also need to specifically enable the multigrid hierarchy.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem()</div><div class="line">    :</div><div class="line">#ifdef DEAL_II_WITH_P4EST</div><div class="line">    triangulation(</div><div class="line">      MPI_COMM_WORLD,</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">      <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    ,</div><div class="line">#else</div><div class="line">    triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    ,</div><div class="line">#endif</div><div class="line">    fe(degree_finite_element)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , setup_time(0.)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    ,</div></div><!-- fragment --><p>The LaplaceProblem class holds an additional output stream that collects detailed timings about the setup phase. This stream, called time_details, is disabled by default through the <code>false</code> argument specified here. For detailed timings, removing the <code>false</code> argument prints all the details.</p>
<div class="fragment"><div class="line">  time_details(std::cout,</div><div class="line">               <span class="keyword">false</span> &amp;&amp; <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>The setup stage is in analogy to <a class="el" href="step_16.html">step-16</a> with relevant changes due to the LaplaceOperator class. The first thing to do is to set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, including the degrees of freedom for the multigrid levels, and to initialize constraints from hanging nodes and homogeneous Dirichlet conditions. Since we intend to use this programs in parallel with MPI, we need to make sure that the constraints get to know the locally relevant degrees of freedom, otherwise the storage would explode when using more than a few hundred millions of degrees of freedom, see <a class="el" href="step_40.html">step-40</a> .</p>
<p>Once we have created the multigrid dof_handler and the constraints, we can call the reinit function for the global matrix operator as well as each level of the multigrid scheme. The main action is to set up the <code> <a class="el" href="classMatrixFree.html">MatrixFree</a> </code> instance for the problem. The base class of the <code>LaplaceOperator</code> class, <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, is initialized with a shared pointer to <a class="el" href="classMatrixFree.html">MatrixFree</a> object. This way, we can simply create it here and then pass it on to the system matrix and level matrices, respectively. For setting up <a class="el" href="classMatrixFree.html">MatrixFree</a>, we need to activate the update flag in the AdditionalData field of <a class="el" href="classMatrixFree.html">MatrixFree</a> that enables the storage of quadrature point coordinates in real space (by default, it only caches data for gradients (inverse transposed Jacobians) and JxW values). Note that if we call the reinit function without specifying the level (i.e., giving <code>level = <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code> ), <a class="el" href="classMatrixFree.html">MatrixFree</a> constructs a loop over the active cells. In this tutorial, we do not use threads in addition to MPI, which is why we explicitly disable it by setting the <a class="el" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">MatrixFree::AdditionalData::tasks_parallel_scheme</a> to <a class="el" href="structMatrixFree_1_1AdditionalData.html#a5b3198735af965d2fc5019543263f927a70ba08215ce330f13a3fd33adbd977a9">MatrixFree::AdditionalData::none</a>. Finally, the coefficient is evaluated and vectors are initialized as explained above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  setup_time = 0;</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  mg_matrices.clear_elements();</div><div class="line"></div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line">  dof_handler.distribute_mg_dofs();</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Distribute DoFs &amp; B.C.     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">      <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::none</a>;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; system_mf_storage(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">    system_mf_storage-&gt;reinit(mapping,</div><div class="line">                              dof_handler,</div><div class="line">                              constraints,</div><div class="line">                              <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                              additional_data);</div><div class="line">    system_matrix.initialize(system_mf_storage);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(solution);</div><div class="line">  system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free system   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div></div><!-- fragment --><p>Next, initialize the matrices for the multigrid method on all the levels. The data structure <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> keeps information about the indices subject to boundary conditions as well as the indices on edges between different refinement levels as described in the <a class="el" href="step_16.html">step-16</a> tutorial program. We then go through the levels of the mesh and construct the constraints and matrices on each level. These follow closely the construction of the system matrix on the original mesh, except the slight difference in naming when accessing information on the levels rather than the active cells.</p>
<div class="fragment"><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     mg_matrices.resize(0, nlevels</div><div class="line">  </div><div class="line">- 1);</div><div class="line">  </div><div class="line">     std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">     dirichlet_boundary.insert(0);</div><div class="line">     mg_constrained_dofs.initialize(dof_handler);</div><div class="line">     mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                        dirichlet_boundary);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">       {</div><div class="line">         <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                       level,</div><div class="line">                                                       relevant_dofs);</div><div class="line">         <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">         level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">         level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">           mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">         level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  </div><div class="line">         <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">         additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">           <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::none</a>;</div><div class="line">         additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">           (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">         additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">         std::shared_ptr&lt;MatrixFree&lt;dim, float&gt;&gt; mg_mf_storage_level(</div><div class="line">           <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;</a>());</div><div class="line">         mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                     dof_handler,</div><div class="line">                                     level_constraints,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                     additional_data);</div><div class="line">  </div><div class="line">         mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                       mg_constrained_dofs,</div><div class="line">                                       level);</div><div class="line">         mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">       }</div><div class="line">     setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">     time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free levels   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_rhs"></a> </p><h4>LaplaceProblem::assemble_rhs</h4>
<p>The assemble function is very simple since all we have to do is to assemble the right hand side. Thanks to <a class="el" href="classFEEvaluation.html">FEEvaluation</a> and all the data cached in the <a class="el" href="classMatrixFree.html">MatrixFree</a> class, which we query from <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, this can be done in a few lines. Since this call is not wrapped into a <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop</a> (which would be an alternative), we must not forget to call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> at the end of the assembly to send all the contributions of the right hand side to the owner of the respective degree of freedom.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line"></div><div class="line">  system_rhs = 0;</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">   system_matrix.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>The solution process is similar as in <a class="el" href="step_16.html">step-16</a> . We start with the setup of the transfer. For <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>, there is a very fast transfer class called <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> that does the interpolation between the grid levels with the same fast sum factorization kernels that get also used in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a>                            time;</div><div class="line">  <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a> mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG build transfer time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div></div><!-- fragment --><p>As a smoother, this tutorial program uses a Chebyshev iteration instead of SOR in <a class="el" href="step_16.html">step-16</a> . (SOR would be very difficult to implement because we do not have the matrix elements available explicitly, and it is difficult to make it work efficiently in parallel.) The smoother is initialized with our level matrices and the mandatory additional data for the Chebyshev smoother. We use a relatively high degree here (5), since matrix-vector products are comparably cheap. We choose to smooth out a range of \([1.2 \hat{\lambda}_{\max}/15,1.2 \hat{\lambda}_{\max}]\) in the smoother where \(\hat{\lambda}_{\max}\) is an estimate of the largest eigenvalue (the factor 1.2 is applied inside <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>). In order to compute that eigenvalue, the Chebyshev initialization performs a few steps of a CG algorithm without preconditioner. Since the highest eigenvalue is usually the easiest one to find and a rough estimate is enough, we choose 10 iterations. Finally, we also set the inner preconditioner type in the Chebyshev method which is a Jacobi iteration. This is represented by the <a class="el" href="classDiagonalMatrix.html">DiagonalMatrix</a> class that gets the inverse diagonal entry provided by our LaplaceOperator class. On level zero, we initialize the smoother differently because we want to use the Chebyshev iteration as a solver. <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a> allows the user to switch to solver mode where the number of iterations is internally chosen to the correct value. In the additional data object, this setting is activated by choosing the polynomial degree to <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>. The algorithm will then attack all eigenvalues between the smallest and largest one in the coarse level matrix. The number of steps in the Chebyshev smoother are chosen such that the Chebyshev convergence estimates guarantee to reduce the residual by the number specified in the variable <code>smoothing_range</code>. Note that for solving, <code>smoothing_range</code> is a relative tolerance and chosen smaller than one, in this case, we select three orders of magnitude, whereas it is a number larger than 1 when only selected eigenvalues are smoothed. From a computational point of view, the Chebyshev iteration is a very attractive coarse grid solver as long as the coarse size is moderate. This is because the Chebyshev method performs only matrix-vector products and vector updates, which typically parallelize better to the largest cluster size with more than a few tens of thousands of cores than inner product involved in other iterative methods. The former involves only local communication between neighbors in the (coarse) mesh, whereas the latter requires global communication over all processors.</p>
<div class="fragment"><div class="line">     <span class="keyword">using</span> SmootherType =</div><div class="line">       <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                             LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line">     <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                            LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                          mg_smoother;</div><div class="line">     <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">     smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>()</div><div class="line">  </div><div class="line">- 1);</div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">          ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">       {</div><div class="line">         <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">           {</div><div class="line">             smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">             smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 5;</div><div class="line">             smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">           }</div><div class="line">         <span class="keywordflow">else</span></div><div class="line">           {</div><div class="line">             smoother_data[0].smoothing_range = 1e-3;</div><div class="line">             smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">             smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">           }</div><div class="line">         mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line">         smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">           mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">       }</div><div class="line">     mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line">  </div><div class="line">     <a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">       mg_coarse;</div><div class="line">     mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div></div><!-- fragment --><p>The next step is to set up the interface matrices that are needed for the case with hanging nodes. The adaptive multigrid realization in deal.II implements an approach called local smoothing. This means that the smoothing on the finest level only covers the local part of the mesh defined by the fixed (finest) grid level and ignores parts of the computational domain where the terminal cells are coarser than this level. As the method progresses to coarser levels, more and more of the global mesh will be covered. At some coarser level, the whole mesh will be covered. Since all level matrices in the multigrid method cover a single level in the mesh, no hanging nodes appear on the level matrices. At the interface between multigrid levels, homogeneous Dirichlet boundary conditions are set while smoothing. When the residual is transferred to the next coarser level, however, the coupling over the multigrid interface needs to be taken into account. This is done by the so-called interface (or edge) matrices that compute the part of the residual that is missed by the level matrix with homogeneous Dirichlet conditions. We refer to the <a class="el" href="DEALGlossary.html#mg_paper">Multigrid paper by Janssen and Kanschat</a> for more details. For the implementation of those interface matrices, there is already a pre-defined class <a class="el" href="classMatrixFreeOperators_1_1MGInterfaceOperator.html">MatrixFreeOperators::MGInterfaceOperator</a> that wraps the routines <a class="el" href="classMatrixFreeOperators_1_1Base.html#a21cefa5a5d4cb726180c89962d8ae472">MatrixFreeOperators::Base::vmult_interface_down()</a> and <a class="el" href="classMatrixFreeOperators_1_1Base.html#af4f39d8232619d499709aa6ee968db58">MatrixFreeOperators::Base::vmult_interface_up()</a> in a new class with <code>vmult()</code> and <code>Tvmult()</code> operations (that were originally written for matrices, hence expecting those names). Note that vmult_interface_down is used during the restriction phase of the multigrid V-cycle, whereas vmult_interface_up is used during the prolongation phase. Once the interface matrix is created, we set up the remaining <a class="el" href="classMultigrid.html">Multigrid</a> preconditioner infrastructure in complete analogy to <a class="el" href="step_16.html">step-16</a> to obtain a <code>preconditioner</code> object that can be applied to a matrix.</p>
<div class="fragment"><div class="line">     <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">       mg_matrices);</div><div class="line">  </div><div class="line">     <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">       mg_interface_matrices;</div><div class="line">     mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>()</div><div class="line">  </div><div class="line">- 1);</div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">          ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">       mg_interface_matrices[level].initialize(mg_matrices[level]);</div><div class="line">     <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">       mg_interface_matrices);</div><div class="line">  </div><div class="line">     <a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">       mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">     <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line">  </div><div class="line">     <a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">                    LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">                    <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">       preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>The setup of the multigrid routines is quite easy and one cannot see any difference in the solve process as compared to <a class="el" href="step_16.html">step-16</a> . All the magic is hidden behind the implementation of the LaplaceOperator::vmult operation. Note that we print out the solve time and the accumulated setup time through standard out, i.e., in any case, whereas detailed times for the setup operations are only printed in case the flag for detail_times in the constructor is changed.</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1e-12 system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG build smoother time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Total setup time               (wall) &quot;</span> &lt;&lt; setup_time &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line"></div><div class="line">  time.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">  time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a>(solution);</div><div class="line">  cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Time solve (&quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations)&quot;</span></div><div class="line">        &lt;&lt; (solver_control.last_step() &lt; 10 ? <span class="stringliteral">&quot;  &quot;</span> : <span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;(CPU/wall) &quot;</span></div><div class="line">        &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemoutput_results"></a> </p><h4>LaplaceProblem::output_results</h4>
<p>Here is the data output, which is a simplified version of <a class="el" href="step_5.html">step-5</a> . We use the standard VTU (= compressed VTK) output for each grid produced in the refinement process. In addition, we use a compression algorithm that is optimized for speed rather than disk usage. The default setting (which optimizes for disk usage) makes saving the output take about 4 times as long as running the linear solver, while setting <a class="el" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">DataOutBase::VtkFlags::compression_level</a> to <a class="el" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a> lowers this to only one fourth the time of the linear solve. We disable the output when the mesh gets too large. A variant of this program has been run on hundreds of thousands MPI ranks with as many as 100 billion grid cells, which is not directly accessible to classical visualization tools.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1000000)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  solution.update_ghost_values();</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Time write output          (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>The function that runs the program is very similar to the one in <a class="el" href="step_16.html">step-16</a> . We do few refinement steps in 3D compared to 2D, but that's it. Before we run the program, we output some information about the detected vectorization level as discussed in the introduction.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">   {</div><div class="line">     {</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 <span class="keyword">sizeof</span>(<a class="code" href="classdouble.html">double</a>) n_vect_doubles;</div><div class="line">  </div><div class="line">       pcout &lt;&lt; <span class="stringliteral">&quot;Vectorization over &quot;</span> &lt;&lt; n_vect_doubles</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot; doubles = &quot;</span> &lt;&lt; n_vect_bits &lt;&lt; <span class="stringliteral">&quot; bits (&quot;</span></div><div class="line">             &lt;&lt; <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div><div class="line">             &lt;&lt; std::endl;</div><div class="line">     }</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9</div><div class="line">  </div><div class="line">- dim; ++cycle)</div><div class="line">       {</div><div class="line">         pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">         <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">           {</div><div class="line">             <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">             triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3</div><div class="line">  </div><div class="line">- dim);</div><div class="line">           }</div><div class="line">         triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">         setup_system();</div><div class="line">         assemble_rhs();</div><div class="line">         solve();</div><div class="line">         output_results(cycle);</div><div class="line">         pcout &lt;&lt; std::endl;</div><div class="line">       };</div><div class="line">   }</div><div class="line"> } <span class="comment">// namespace Step37</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>Apart from the fact that we set up the MPI framework according to <a class="el" href="step_40.html">step-40</a> , there are no surprises in the main function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step37;</div><div class="line"> </div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"> </div><div class="line">      LaplaceProblem&lt;dimension&gt; laplace_problem;</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>Since this example solves the same problem as <a class="el" href="step_5.html">step-5</a> (except fora different coefficient), there is little to say about thesolution. We show a picture anyway, illustrating the size of thesolution through both isocontours and volume rendering: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.solution.png"/>
</div>
<p> Of more interest is to evaluate some aspects of the multigrid solver.When we run this program in 2D for quadratic ( \(Q_2\) ) elements, we get thefollowing output (when run on one core in release mode): </p><div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 81</div><div class="line">Total setup time               (wall) 0.00159788s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000951s/0.000951052s</div><div class="line">  </div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 289</div><div class="line">Total setup time               (wall) 0.00114608s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000935s/0.000934839s</div><div class="line">  </div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 1089</div><div class="line">Total setup time               (wall) 0.00244665s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.00207s/0.002069s</div><div class="line">  </div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 4225</div><div class="line">Total setup time               (wall) 0.00678205s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.005616s/0.00561595s</div><div class="line">  </div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 16641</div><div class="line">Total setup time               (wall) 0.0241671s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.019543s/0.0195441s</div><div class="line">  </div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 66049</div><div class="line">Total setup time               (wall) 0.0967851s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.07457s/0.0745709s</div><div class="line">  </div><div class="line">Cycle 6</div><div class="line">Number of degrees of freedom: 263169</div><div class="line">Total setup time               (wall) 0.346374s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.260042s/0.265033s</div></div><!-- fragment --><p>As in <a class="el" href="step_16.html">step-16</a> , we see that the number of CG iterations remains constant withincreasing number of degrees of freedom. A constant number of iterations(together with optimal computational properties) means that the computing timeapproximately quadruples as the problem size quadruples from one cycle to thenext. The code is also very efficient in terms of storage. Around 2-4 milliondegrees of freedom fit into 1 GB of memory, see also the MPI results below. Aninteresting fact is that solving one linear system is cheaper than the setup,despite not building a matrix (approximately half of which is spent in the <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a> and <a class="el" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">DoFHandler::distribute_mg_dofs()</a> calls). This shows the high efficiency of this approach, but also that thedeal.II data structures are quite expensive to set up and the setup cost mustbe amortized over several system solves. Not much changes if we run the program in three spatial dimensions. Since weuse uniform mesh refinement, we get eight times as many elements andapproximately eight times as many degrees of freedom with each cycle: </p><div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 125</div><div class="line">Total setup time               (wall) 0.00231099s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000692s/0.000922918s</div><div class="line">  </div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 729</div><div class="line">Total setup time               (wall) 0.00289083s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.001534s/0.0024128s</div><div class="line">  </div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0143182s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.010785s/0.0107841s</div><div class="line">  </div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.087064s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.063522s/0.06545s</div><div class="line">  </div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 0.596306s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.427757s/0.431765s</div><div class="line">  </div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 4.96491s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 3.53126s/3.56142s</div></div><!-- fragment --><p>Since it is so easy, we look at what happens if we increase the polynomialdegree. When selecting the degree as four in 3D, i.e., on \(\mathcal Q_4\) elements, by changing the line <code>const unsigned intdegree_finite_element=4;</code> at the top of the program, we get thefollowing program output: </p><div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 729</div><div class="line">Total setup time               (wall) 0.00633097s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.002829s/0.00379395s</div><div class="line">  </div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0174279s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.012255s/0.012254s</div><div class="line">  </div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.082655s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.052362s/0.0523629s</div><div class="line">  </div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 0.507943s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.341811s/0.345788s</div><div class="line">  </div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 3.46251s</div><div class="line">Time solve (7 iterations)  (CPU/wall) 3.29638s/3.3265s</div><div class="line">  </div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 16974593</div><div class="line">Total setup time               (wall) 27.8989s</div><div class="line">Time solve (7 iterations)  (CPU/wall) 26.3705s/27.1077s</div></div><!-- fragment --><p>Since \(\mathcal Q_4\) elements on a certain mesh correspond to \(\mathcal Q_2\) elements on half the mesh size, we can compare the run time at cycle 4 withfourth degree polynomials with cycle 5 using quadratic polynomials, both at2.1 million degrees of freedom. The surprising effect is that the solver for \(\mathcal Q_4\) element is actually slightly faster than for the quadraticcase, despite using one more linear iteration. The effect that higher-degreepolynomials are similarly fast or even faster than lower degree ones is one ofthe main strengths of matrix-free operator evaluation through sumfactorization, see the <a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">matrix-free paper</a>. This is fundamentally different to matrix-based methods that getmore expensive per unknown as the polynomial degree increases and the couplinggets denser. In addition, also the setup gets a bit cheaper for higher order, which isbecause fewer elements need to be set up. Finally, let us look at the timings with degree 8, which corresponds toanother round of mesh refinement in the lower order methods: </p><div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0842004s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.019296s/0.0192959s</div><div class="line">  </div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.327048s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.07517s/0.075999s</div><div class="line">  </div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 2.12335s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.448739s/0.453698s</div><div class="line">  </div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 16.1743s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 3.95003s/3.97717s</div><div class="line">  </div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 16974593</div><div class="line">Total setup time               (wall) 130.8s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 31.0316s/31.767s</div></div><!-- fragment --><p>Here, the initialization seems considerably slower than before, which ismainly due to the computation of the diagonal of the matrix, which actuallycomputes a 729 x 729 matrix on each cell and throws away everything but thediagonal. The solver times, however, are again very close to the quartic case,showing that the linear increase with the polynomial degree that istheoretically expected is almost completely offset by better computationalcharacteristics and the fact that higher order methods have a smaller share ofdegrees of freedom living on several cells that add to the evaluationcomplexity. <a class="anchor" id="Comparisonwithasparsematrix"></a></p><h3>Comparison with a sparse matrix</h3>
<p>In order to understand the capabilities of the matrix-free implementation, wecompare the performance of the 3d example above with a sparse matriximplementation based on <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> by measuring both thecomputation times for the initialization of the problem (distribute DoFs,setup and assemble matrices, setup multigrid structures) and the actualsolution for the matrix-free variant and the variant based on sparsematrices. We base the preconditioner on float numbers and the actual matrixand vectors on double numbers, as shown above. Tests are run on an Intel Corei7-5500U notebook processor (two cores and <a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>support, i.e., four operations on doubles can be done with one CPUinstruction, which is heavily used in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>), optimized mode, and twoMPI ranks. </p><table align="center" class="doxtable">
<tr>
<th>&#160; </th><th colspan="2">Sparse matrix </th><th colspan="2">Matrix-free implementation  </th></tr>
<tr>
<th>n_dofs </th><th>Setup + assemble </th><th>&#160;Solve&#160; </th><th>Setup + assemble </th><th>&#160;Solve&#160;  </th></tr>
<tr>
<td align="right">125 </td><td align="center">0.0042s </td><td align="center">0.0012s </td><td align="center">0.0022s </td><td align="center">0.00095s  </td></tr>
<tr>
<td align="right">729 </td><td align="center">0.012s </td><td align="center">0.0040s </td><td align="center">0.0027s </td><td align="center">0.0021s  </td></tr>
<tr>
<td align="right">4,913 </td><td align="center">0.082s </td><td align="center">0.012s </td><td align="center">0.011s </td><td align="center">0.0057s  </td></tr>
<tr>
<td align="right">35,937 </td><td align="center">0.73s </td><td align="center">0.13s </td><td align="center">0.048s </td><td align="center">0.040s  </td></tr>
<tr>
<td align="right">274,625 </td><td align="center">5.43s </td><td align="center">1.01s </td><td align="center">0.33s </td><td align="center">0.25s  </td></tr>
<tr>
<td align="right">2,146,689 </td><td align="center">43.8s </td><td align="center">8.24s </td><td align="center">2.42s </td><td align="center">2.06s  </td></tr>
</table>
<p>The table clearly shows that the matrix-free implementation is more than twiceas fast for the solver, and more than six times as fast when it comes toinitialization costs. As the problem size is made a factor 8 larger, we notethat the times usually go up by a factor eight, too (as the solver iterationsare constant at six). The main deviation is in the sparse matrix between 5kand 36k degrees of freedom, where the time increases by a factor 12. This isthe threshold where the (L3) cache in the processor can no longer hold alldata necessary for the matrix-vector products and all matrix elements must befetched from main memory. Of course, this picture does not necessarily translate to all cases, as thereare problems where knowledge of matrix entries enables much better solvers (ashappens when the coefficient is varying more strongly than in the aboveexample). Moreover, it also depends on the computer system. The present systemhas good memory performance, so sparse matrices perform comparablywell. Nonetheless, the matrix-free implementation gives a nice speedup alreadyfor the <em>Q</em><sub>2</sub> elements used in this example. This becomesparticularly apparent for time-dependent or nonlinear problems where sparsematrices would need to be reassembled over and over again, which becomes mucheasier with this class. And of course, thanks to the better complexity of theproducts, the method gains increasingly larger advantages when the order of theelements increases (the matrix-free implementation has costs4<em>d</em><sup>2</sup><em>p</em> per degree of freedom, compared to2<em>p<sup>d</sup></em> for the sparse matrix, so it will win anyway for order 4and higher in 3d). <a class="anchor" id="ResultsforlargescaleparallelcomputationsonSuperMUC"></a></p><h3>Results for large-scale parallel computations on SuperMUC</h3>
<p>As explained in the introduction and the in-code comments, this program can berun in parallel with MPI. It turns out that geometric multigrid schemes workreally well and can scale to very large machines. To the authors' knowledge,the geometric multigrid results shown here are the largest computations donewith deal.II as of late 2016, run on up to 147,456 cores of the <a href="https://www.lrz.de/services/compute/supermuc/systemdescription/">complete SuperMUC Phase 1</a>. The ingredients for scalability beyond 1000 cores arethat no data structure that depends on the global problem size is held in itsentirety on a single processor and that the communication is not too frequentin order not to run into latency issues of the network. For PDEs solved withiterative solvers, the communication latency is often the limiting factor,rather than the throughput of the network. For the example of the SuperMUCsystem, the point-to-point latency between two processors is between 1e-6 and1e-5 seconds, depending on the proximity in the MPI network. The matrix-vectorproducts with <code>LaplaceOperator</code> from this class involves severalpoint-to-point communication steps, interleaved with computations on eachcore. The resulting latency of a matrix-vector product is around 1e-4seconds. Global communication, for example an <code>MPI_Allreduce</code> operation thataccumulates the sum of a single number per rank over all ranks in the MPInetwork, has a latency of 1e-4 seconds. The multigrid V-cycle used in thisprogram is also a form of global communication. Think about the coarse gridsolve that happens on a single processor: It accumulates the contributionsfrom all processors before it starts. When completed, the coarse grid solutionis transferred to finer levels, where more and more processors help insmoothing until the fine grid. Essentially, this is a tree-like pattern overthe processors in the network and controlled by the mesh. As opposed to the <code>MPI_Allreduce</code> operations where the tree in the reduction is optimized to theactual links in the MPI network, the multigrid V-cycle does this according tothe partitioning of the mesh. Thus, we cannot expect the sameoptimality. Furthermore, the multigrid cycle is not simply a walk up and downthe refinement tree, but also communication on each level when doing thesmoothing. In other words, the global communication in multigrid is morechallenging and related to the mesh that provides less optimizationopportunities. The measured latency of the V-cycle is between 6e-3 and 2e-2seconds, i.e., the same as 60 to 200 MPI_Allreduce operations. The following figure shows a scaling experiments on \(\mathcal Q_3\) elements. Along the lines, the problem size is held constant as the number ofcores is increasing. When doubling the number of cores, one expects a halvingof the computational time, indicated by the dotted gray lines. The resultsshow that the implementation shows almost ideal behavior until an absolutetime of around 0.1 seconds is reached. The solver tolerances have been setsuch that the solver performs five iterations. This way of plotting data isthe <b>strong scaling</b> of the algorithm. As we go to very large corecounts, the curves flatten out a bit earlier, which is because of thecommunication network in SuperMUC where communication between processorsfarther away is slightly slower. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_strong.png"/>
</div>
<p> In addition, the plot also contains results for <b>weak scaling</b> that listshow the algorithm behaves as both the number of processor cores and elementsis increased at the same pace. In this situation, we expect that the computetime remains constant. Algorithmically, the number of CG iterations isconstant at 5, so we are good from that end. The lines in the plot arearranged such that the top left point in each data series represents the samesize per processor, namely 131,072 elements (or approximately 3.5 milliondegrees of freedom per core). The gray lines indicating ideal strong scalingare by the same factor of 8 apart. The results show again that the scaling isalmost ideal. The parallel efficiency when going from 288 cores to 147,456cores is at around 75% for a local problem size of 750,000 degrees of freedomper core which takes 1.0s on 288 cores, 1.03s on 2304 cores, 1.19s on 18kcores, and 1.35s on 147k cores. The algorithms also reach a very highutilization of the processor. The largest computation on 147k cores reachesaround 1.7 PFLOPs/s on SuperMUC out of an arithmetic peak of 3.2 PFLOPs/s. Foran iterative PDE solver, this is a very high number and significantly more isoften only reached for dense linear algebra. Sparse linear algebra is limitedto a tenth of this value. As mentioned in the introduction, the matrix-free method reduces the memoryconsumption of the data structures. Besides the higher performance due to lessmemory transfer, the algorithms also allow for very large problems to fit intomemory. The figure below shows the computational time as we increase theproblem size until an upper limit where the computation exhausts memory. We dothis for 1k cores, 8k cores, and 65k cores and see that the problem size canbe varied over almost two orders of magnitude with ideal scaling. The largestcomputation shown in this picture involves 292 billion ( \(2.92 \cdot 10^{11}\) )degrees of freedom. On a DG computation of 147k cores, the above algorithmswere also run involving up to 549 billion (2^39) DoFs. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_size.png"/>
</div>
<p> Finally, we note that while performing the tests on the large-scale systemshown above, improvements of the multigrid algorithms in deal.II have beendeveloped. The original version contained the sub-optimal code based onMGSmootherPrecondition where some MPI_Allreduce commands (checking whetherall vector entries are zero) were done on each smoothingoperation on each level, which only became apparent on 65k cores andmore. However, the following picture shows that the improvement already payoff on a smaller scale, here shown on computations on up to 14,336 cores for \(\mathcal Q_5\) elements: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_oldnew.png"/>
</div>
<p><a class="anchor" id="Adaptivity"></a></p><h3>Adaptivity</h3>
<p>As explained in the code, the algorithm presented here is prepared to run onadaptively refined meshes. If only part of the mesh is refined, the multigridcycle will run with local smoothing and impose Dirichlet conditions along theinterfaces which differ in refinement level for smoothing through the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class. Due to the way the degrees of freedom aredistributed over levels, relating the owner of the level cells to the owner ofthe first descendant active cell, there can be an imbalance between differentprocessors in MPI, which limits scalability by a factor of around two to five. <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Kellyerrorestimator"></a></p><h4>Kelly error estimator </h4>
<p>As mentioned above the code is ready for locally adaptive h-refinement.For the Poisson equation one can employ the Kelly error indicator,implemented in the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class. However one needs to be carefulwith the ghost indices of parallel vectors.In order to evaluate the jump terms in the error indicator, each MPI processneeds to know locally relevant DoFs.However <a class="el" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">MatrixFree::initialize_dof_vector()</a> function initializes the vector only withsome locally relevant DoFs.The ghost indices made available in the vector are a tight set of only those indicesthat are touched in the cell integrals (including constraint resolution).This choice has performance reasons, because sending all locally relevant degreesof freedom would be too expensive compared to the matrix-vector product.Consequently the solution vector as-is isnot suitable for the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class.The trick is to change the ghost part of the partition, for example using atemporary vector and <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab792ddb04b95a220e489f2d7f9eee990">LinearAlgebra::distributed::Vector::copy_locally_owned_data_from()</a> as shown below. </p><div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"><a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> copy_vec(solution);</div><div class="line">solution.reinit(dof_handler.locally_owned_dofs(),</div><div class="line">                locally_relevant_dofs,</div><div class="line">                triangulation.<a class="code" href="classTriangulation.html#a0a2bf98c3056379a2b132ad62266f780">get_communicator</a>());</div><div class="line">solution.copy_locally_owned_data_from(copy_vec);</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">solution.update_ghost_values();</div></div><!-- fragment --><p><a class="anchor" id="Sharedmemoryparallelization"></a></p><h4>Shared-memory parallelization</h4>
<p>This program is parallelized with MPI only. As an alternative, the MatrixFreeloop can also be issued in hybrid mode, for example by using MPI parallelizingover the nodes of a cluster and with threads through Intel TBB within theshared memory region of one node. To use this, one would need to both set thenumber of threads in the MPI_InitFinalize data structure in the main function,and set the <a class="el" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">MatrixFree::AdditionalData::tasks_parallel_scheme</a> topartition_color to actually do the loop in parallel. This use case isdiscussed in <a class="el" href="step_48.html">step-48</a> . <a class="anchor" id="InhomogeneousDirichletboundaryconditions"></a></p><h4>Inhomogeneous Dirichlet boundary conditions </h4>
<p>The presented program assumes homogeneous Dirichlet boundary conditions. Whengoing to non-homogeneous conditions, the situation is a bit more intricate. Tounderstand how to implement such a setting, let us first recall how thesearise in the mathematical formulation and how they are implemented in amatrix-based variant. In essence, an inhomogeneous Dirichlet condition setssome of the nodal values in the solution to given values rather thandetermining them through the variational principles, </p><p class="formulaDsp">
\begin{eqnarray*} u_h(\mathbf{x}) = \sum_{i\in \mathcal N} \varphi_i(\mathbf{x}) u_i = \sum_{i\in \mathcal N \setminus \mathcal N_D} \varphi_i(\mathbf{x}) u_i + \sum_{i\in \mathcal N_D} \varphi_i(\mathbf{x}) g_i, \end{eqnarray*}
</p>
<p> where \(u_i\) denotes the nodal values of the solution and \(\mathcal N\) denotesthe set of all nodes. The set \(\mathcal N_D\subset \mathcal N\) is the subsetof the nodes that are subject to Dirichlet boundary conditions where thesolution is forced to equal \(u_i = g_i = g(\mathbf{x}_i)\) as the interpolationof boundary values on the Dirichlet-constrained node points \(i\in \mathcal N_D\) . We then insert this solutionrepresentation into the weak form, e.g. the Laplacian shown above, and movethe known quantities to the right hand side: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \varphi_i, \nabla u_h)_\Omega &amp;=&amp; (\varphi_i, f)_\Omega \quad \Rightarrow \\ \sum_{j\in \mathcal N \setminus \mathcal N_D}(\nabla \varphi_i,\nabla \varphi_j)_\Omega \, u_j &amp;=&amp; (\varphi_i, f)_\Omega -\sum_{j\in \mathcal N_D} (\nabla \varphi_i,\nabla\varphi_j)_\Omega\, g_j. \end{eqnarray*}
</p>
<p> In this formula, the equations are tested for all basis functions \(\varphi_i\) with \(i\in N \setminus \mathcal N_D\) that are not related to the nodesconstrained by Dirichlet conditions. In the implementation in deal.II, the integrals \((\nabla \varphi_i,\nabla \varphi_j)_\Omega\) on the right hand side are already contained in the local matrix contributionswe assemble on each cell. When using <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> as first described in the <a class="el" href="step_6.html">step-6</a> and <a class="el" href="step_7.html">step-7</a> tutorial programs, we can account for the contribution ofinhomogeneous constraints <em>j</em> by multiplying the columns <em>j</em> androws <em>i</em> of the local matrix according to the integrals \((\varphi_i, \varphi_j)_\Omega\) by the inhomogeneities and subtracting the resulting fromthe position <em>i</em> in the global right-hand-side vector, see also the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module. In essence, we use some of the integrals that geteliminated from the left hand side of the equation to finalize the right handside contribution. Similar mathematics are also involved when first writingall entries into a left hand side matrix and then eliminating matrix rows andcolumns by <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a>. In principle, the components that belong to the constrained degrees of freedomcould be eliminated from the linear system because they do not carry anyinformation. In practice, in deal.II we always keep the size of the linearsystem the same to avoid handling two different numbering systems and avoidconfusion about the two different index sets. In order to ensure that thelinear system does not get singular when not adding anything to constrainedrows, we then add dummy entries to the matrix diagonal that are otherwiseunrelated to the real entries. In a matrix-free method, we need to take a different approach, since the <code>LaplaceOperator</code> class represents the matrix-vector product of a<b>homogeneous</b> operator (the left-hand side of the last formula). It doesnot matter whether the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object passed to the <a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">MatrixFree::reinit()</a> contains inhomogeneous constraints or not, the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> call will only resolve the homogeneous part of theconstraints as long as it represents a <b>linear</b> operator. In our matrix-free code, the right hand side computation where thecontribution of inhomogeneous conditions ends up is completely decoupled fromthe matrix operator and handled by a different function above. Thus, we needto explicitly generate the data that enters the right hand side rather thanusing a byproduct of the matrix assembly. Since we already know how to applythe operator on a vector, we could try to use those facilities for a vectorwhere we only set the Dirichlet values: </p><div class="fragment"><div class="line"><span class="comment">// interpolate boundary values on vector solution</span></div><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(mapping,</div><div class="line">                                         dof_handler,</div><div class="line">                                         0,</div><div class="line">                                         BoundaryValueFunction&lt;dim&gt;(),</div><div class="line">                                         boundary_values);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::global_dof_index, double&gt; &amp;pair : boundary_values)</div><div class="line">  <span class="keywordflow">if</span> (solution.locally_owned_elements().is_element(pair.first))</div><div class="line">    solution(pair.first) = pair.second;</div></div><!-- fragment --><p> or, equivalently, if we already had filled the inhomogeneous constraints intoan <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, </p><div class="fragment"><div class="line">solution = 0;</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div></div><!-- fragment --><p>We could then pass the vector <code>solution</code> to the <code>LaplaceOperator::vmult_add()</code> function and add the new contribution to the <code>system_rhs</code> vector that gets filled in the <code>LaplaceProblem::assemble_rhs()</code> function. However, this idea does not work because the <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">FEEvaluation::read_dof_values()</a> call used inside the vmult() functions assumeshomogeneous values on all constraints (otherwise the operator would not be alinear operator but an affine one). To also retrieve the values of theinhomogeneities, we could select one of two following strategies. <a class="anchor" id="UseFEEvaluationread_dof_values_plaintoavoidresolvingconstraints"></a></p><h5>Use <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> to avoid resolving constraints </h5>
<p>The class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> has a facility that addresses precisely thisrequirement: For non-homogeneous Dirichlet values, we do want to skip theimplicit imposition of homogeneous (Dirichlet) constraints upon reading thedata from the vector <code>solution</code>. For example, we could extend the <code>LaplaceProblem::assemble_rhs()</code> function to deal with inhomogeneous Dirichletvalues as follows, assuming the Dirichlet values have been interpolated intothe object <code>constraints:</code> </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  solution = 0;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  solution.update_ghost_values();</div><div class="line">  system_rhs = 0;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;double&gt;</a>&gt; &amp;coefficient = system_matrix.get_coefficient();</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(*system_matrix.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values_plain(solution);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_gradient(-coefficient(cell, q) phi.get_gradient(q), q);</div><div class="line">          phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">        }</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>|<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>In this code, we replaced the <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">FEEvaluation::read_dof_values()</a> function for thetentative solution vector by <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> thatignores all constraints. Due to this setup, we must make sure that otherconstraints, e.g. by hanging nodes, are correctly distributed to the inputvector already as they are not resolved as in <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a>. Inside the loop, we then evaluate theLaplacian and repeat the second derivative call with <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">FEEvaluation::submit_gradient()</a> from the <code>LaplaceOperator</code> class, but with thesign switched since we wanted to subtract the contribution of Dirichletconditions on the right hand side vector according to the formula above. Whenwe invoke the <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">FEEvaluation::integrate()</a> call, we then set both argumentsregarding the value slot and first derivative slot to true to account for bothterms added in the loop over quadrature points. Once the right hand side isassembled, we then go on to solving the linear system for the homogeneousproblem, say involving a variable <code>solution_update</code>. After solving, we canadd <code>solution_update</code> to the <code>solution</code> vector that contains the final(inhomogeneous) solution. Note that the negative sign for the Laplacian alongside with a positive signfor the forcing that we needed to build the right hand side is a more generalconcept: We have implemented nothing else than Newton's method for nonlinearequations, but applied to a linear system. We have used an initial guess forthe variable <code>solution</code> in terms of the Dirichlet boundary conditions andcomputed a residual \(r = f - Au_0\) . The linear system was then solved as \(\Delta u = A^{-1} (f-Au)\) and we finally computed \(u = u_0 + \Delta u\) . For alinear system, we obviously reach the exact solution after a singleiteration. If we wanted to extend the code to a nonlinear problem, we wouldrename the <code>assemble_rhs()</code> function into a more descriptive name like <code>assemble_residual()</code> that computes the (weak) form of the residual, whereas the <code>LaplaceOperator::apply_add()</code> function would get the linearization of theresidual with respect to the solution variable. <a class="anchor" id="UseLaplaceOperatorwithasecondAffineConstraintsobjectwithoutDirichletconditions"></a></p><h5>Use LaplaceOperator with a second <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object without Dirichlet conditions </h5>
<p>A second alternative to get the right hand side that re-uses the <code>LaplaceOperator::apply_add()</code> function is to instead add a second LaplaceOperatorthat skips Dirichlet constraints. To do this, we initialize a second MatrixFreeobject which does not have any boundary value constraints. This <code>matrix_free</code> object is then passed to a <code>LaplaceOperator</code> class instance <code>inhomogeneous_operator</code> that is only used to create the right hand side: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  system_rhs = 0;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> no_constraints;</div><div class="line">  no_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  LaplaceOperator&lt;dim, degree_finite_element, double&gt; inhomogeneous_operator;</div><div class="line">  </div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">  additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">    (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; matrix_free(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">  matrix_free-&gt;reinit(dof_handler,</div><div class="line">                      no_constraints,</div><div class="line">                      <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                      additional_data);</div><div class="line">  inhomogeneous_operator.initialize(matrix_free);</div><div class="line">  </div><div class="line">  solution = 0.0;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  inhomogeneous_operator.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">  inhomogeneous_operator.vmult(system_rhs, solution);</div><div class="line">  system_rhs=</div><div class="line">  </div><div class="line">-1.0;</div><div class="line">  </div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">   inhomogeneous_operator.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; inhomogeneous_operator.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>A more sophisticated implementation of this technique could reuse the originalMatrixFree object. This can be done by initializing the <a class="el" href="classMatrixFree.html">MatrixFree</a> object withmultiple blocks, where each block corresponds to a different AffineConstraintsobject. Doing this would require making substantial modifications to theLaplaceOperator class, but the <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a> class thatcomes with the library can do this. See the discussion on blocks in <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> for more information on how to set up blocks.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Katharina Kormann, Martin Kronbichler, Uppsala University,</span></div><div class="line"><span class="comment"> * 2009-2012, updated to MPI version with parallel vectors in 2016</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step37</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_finite_element = 2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension             = 3;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">    number value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">  number Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1. / (0.05 + 2. * p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> value&lt;double&gt;(p, component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceOperator</div><div class="line">    : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">        Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">    LaplaceOperator();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_coefficient(<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">                <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">                <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_compute_diagonal(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;              data,</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp; dst,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                         dummy,</div><div class="line">      <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; coefficient;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  LaplaceOperator&lt;dim, fe_degree, number&gt;::LaplaceOperator()</div><div class="line">    : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                                <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">Vector</a>&lt;number&gt;&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">  {</div><div class="line">    coefficient.reinit(0, 0);</div><div class="line">    <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">      clear();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::evaluate_coefficient(</div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line">    coefficient.reinit(n_cells, phi.n_q_points);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          coefficient(cell, q) =</div><div class="line">            coefficient_function.value(phi.quadrature_point(q));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line">        phi.read_dof_values(src);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), q);</div><div class="line">        phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">        phi.distribute_local_to_global(dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">LaplaceOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">  {</div><div class="line">    this-&gt;inverse_diagonal_entries.reset(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">      this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dummy = 0;</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_compute_diagonal,</div><div class="line">                          <span class="keyword">this</span>,</div><div class="line">                          inverse_diagonal,</div><div class="line">                          dummy);</div><div class="line"></div><div class="line">    this-&gt;set_constrained_entries_to_one(inverse_diagonal);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size</a>(); ++i)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) &gt; 0.,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No diagonal entry in a positive definite operator &quot;</span></div><div class="line">                          <span class="stringliteral">&quot;should be zero&quot;</span>));</div><div class="line">        inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) =</div><div class="line">          1. / inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;             data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;dst,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <a class="code" href="classAlignedVector.html">AlignedVector&lt;VectorizedArray&lt;number&gt;</a>&gt; <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>(phi.dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; phi.dofs_per_cell; ++j)</div><div class="line">              phi.submit_dof_value(<a class="code" href="classVectorizedArray.html">VectorizedArray&lt;number&gt;</a>(), j);</div><div class="line">            phi.submit_dof_value(make_vectorized_array&lt;number&gt;(1.), i);</div><div class="line"></div><div class="line">            phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">              phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q),</div><div class="line">                                  q);</div><div class="line">            phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">            <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i] = phi.get_dof_value(i);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">          phi.submit_dof_value(<a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i], i);</div><div class="line">        phi.distribute_local_to_global(dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType =</div><div class="line">      LaplaceOperator&lt;dim, degree_finite_element, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = LaplaceOperator&lt;dim, degree_finite_element, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a> mg_matrices;</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>             setup_time;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> time_details;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem()</div><div class="line">    :</div><div class="line">#ifdef DEAL_II_WITH_P4EST</div><div class="line">    triangulation(</div><div class="line">      MPI_COMM_WORLD,</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">      <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    ,</div><div class="line">#else</div><div class="line">    triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    ,</div><div class="line">#endif</div><div class="line">    fe(degree_finite_element)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , setup_time(0.)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    ,</div><div class="line">    time_details(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">                 false &amp;&amp; <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    setup_time = 0;</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    mg_matrices.clear_elements();</div><div class="line"></div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line">    dof_handler.distribute_mg_dofs();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Distribute DoFs &amp; B.C.     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::none</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; system_mf_storage(</div><div class="line">        <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">      system_mf_storage-&gt;reinit(mapping,</div><div class="line">                                dof_handler,</div><div class="line">                                constraints,</div><div class="line">                                <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                additional_data);</div><div class="line">      system_matrix.initialize(system_mf_storage);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(solution);</div><div class="line">    system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free system   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">    mg_matrices.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">    dirichlet_boundary.insert(0);</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      relevant_dofs);</div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">        <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">          <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::none</a>;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">          (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">        std::shared_ptr&lt;MatrixFree&lt;dim, float&gt;&gt; mg_mf_storage_level(</div><div class="line">          <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;</a>());</div><div class="line">        mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    level_constraints,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    additional_data);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                      mg_constrained_dofs,</div><div class="line">                                      level);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">      }</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free levels   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line"></div><div class="line">    system_rhs = 0;</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">      *system_matrix.get_matrix_free());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">         cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">         ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">        phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">        phi.distribute_local_to_global(system_rhs);</div><div class="line">      }</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a>                            time;</div><div class="line">    <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a> mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG build transfer time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                            LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                           LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                         mg_smoother;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">    smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">          {</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 5;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            smoother_data[0].smoothing_range = 1e-3;</div><div class="line">            smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">          }</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">      }</div><div class="line">    mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line">    <a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">      mg_coarse;</div><div class="line">    mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">      mg_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">      mg_interface_matrices;</div><div class="line">    mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      mg_interface_matrices[level].initialize(mg_matrices[level]);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">      mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">                   LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">                   <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1e-12 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG build smoother time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Total setup time               (wall) &quot;</span> &lt;&lt; setup_time &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line"></div><div class="line">    time.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">    time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a>(solution);</div><div class="line">    cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Time solve (&quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations)&quot;</span></div><div class="line">          &lt;&lt; (solver_control.last_step() &lt; 10 ? <span class="stringliteral">&quot;  &quot;</span> : <span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;(CPU/wall) &quot;</span></div><div class="line">          &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1000000)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">    flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Time write output          (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(<a class="code" href="classdouble.html">double</a>) * n_vect_doubles;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Vectorization over &quot;</span> &lt;&lt; n_vect_doubles</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; doubles = &quot;</span> &lt;&lt; n_vect_bits &lt;&lt; <span class="stringliteral">&quot; bits (&quot;</span></div><div class="line">            &lt;&lt; <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">          }</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">        setup_system();</div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      };</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step37</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step37;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;dimension&gt; laplace_problem;</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_16.html">step-16</a>, <a class="el" href="step_40.html">step-40</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The test case</a>
        <li><a href="#Matrixvectorproductimplementation">Matrix-vector product implementation</a>
        <li><a href="#Combinationwithmultigrid">Combination with multigrid</a>
        <li><a href="#UsingCPUdependentinstructionsvectorization">Using CPU-dependent instructions (vectorization)</a>
        <li><a href="#Runningmultigridonlargescaleparallelcomputers">Running multigrid on large-scale parallel computers</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Matrixfreeimplementation">Matrix-free implementation</a>
      <ul>
        <li><a href="#Computationofcoefficient">Computation of coefficient</a>
        <li><a href="#LocalevaluationofLaplaceoperator">Local evaluation of Laplace operator</a>
      </ul>
        <li><a href="#LaplaceProblemclass">LaplaceProblem class</a>
      <ul>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_rhs">LaplaceProblem::assemble_rhs</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#LaplaceProblemoutput_results">LaplaceProblem::output_results</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
        <li><a href="#Comparisonwithasparsematrix">Comparison with a sparse matrix</a>
        <li><a href="#ResultsforlargescaleparallelcomputationsonSuperMUC"> Results for large-scale parallel computations on SuperMUC</a>
        <li><a href="#Adaptivity"> Adaptivity</a>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions</a>
      <ul>
        <li><a href="#Kellyerrorestimator"> Kelly error estimator </a>
        <li><a href="#Sharedmemoryparallelization"> Shared-memory parallelization</a>
        <li><a href="#InhomogeneousDirichletboundaryconditions"> Inhomogeneous Dirichlet boundary conditions </a>
      <ul>
        <li><a href="#UseFEEvaluationread_dof_values_plaintoavoidresolvingconstraints"> Use FEEvaluation::read_dof_values_plain() to avoid resolving constraints </a>
        <li><a href="#UseLaplaceOperatorwithasecondAffineConstraintsobjectwithoutDirichletconditions"> Use LaplaceOperator with a second AffineConstraints object without Dirichlet conditions </a>
    </ul>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-37/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Katharina Kormann and Martin Kronbichler.</em></p>
<p><em>The algorithm for the matrix-vector product is based on the article <a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">A generic interface for parallel cell-based finite element operator application</a><a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">A generic interface for parallel cell-based finite element operator application</a> by Martin Kronbichler and Katharina Kormann, Computers and Fluids 63:135&ndash;147, 2012, and the paper &quot;Parallel finite element operator application: Graph partitioning and coloring&quot; by Katharina Kormann and Martin Kronbichler in: Proceedings of the 7th IEEE International Conference on e-Science, 2011.</em></p>
<p><em>This work was partly supported by the German Research Foundation (DFG) through the project "High-order discontinuous Galerkin for the exa-scale" (ExaDG) within the priority program "Software for Exascale Computing" (SPPEXA). The large-scale computations shown in the results section of this tutorial program were supported by Gauss Centre for Supercomputing e.V. (www.gauss-centre.eu) by providing computing time on the GCS Supercomputer SuperMUC at Leibniz Supercomputing Centre (LRZ, www.lrz.de) through project id pr83te. </em> 。</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>这个例子展示了如何在超立方体上实现一个无矩阵的方法，即不明确存储矩阵元素的方法，用于具有可变系数的二阶泊松方程。该线性系统将用多网格方法求解，并使用MPI的大规模并行性。</p>
<p>无矩阵方法的主要动机是，在今天的处理器上，对主内存的访问（即对不适合缓存的对象）已经成为许多偏微分方程求解器的瓶颈。为了执行基于矩阵的矩阵-向量乘积，现代CPU花在等待数据从内存到达的时间远远多于实际进行浮点乘法和加法的时间。因此，如果我们可以通过重新计算矩阵元素来代替在内存中查找矩阵元素，或者更确切地说，这些条目所代表的运算符&mdash;，我们可能会在整体运行时间方面获胜，即使这需要大量的额外浮点运算。也就是说，用一个微不足道的实现来实现这一点是不够的，我们需要真正关注细节来获得性能。这个教程程序和上面提到的论文展示了如何实现这样一个方案，并演示了可以获得的速度提升。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>在这个例子中，我们考虑泊松问题 </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot a(\mathbf x) \nabla u &amp;=&amp; 1, \\ u &amp;=&amp; 0 \quad \text{on}\ \partial \Omega \end{eqnarray*}
</p>
<p>，其中 \(a(\mathbf x)\) 是一个可变系数。下面，我们将解释如何在不明确形成矩阵的情况下实现这个问题的矩阵-向量乘积。当然，对于其他方程也可以用类似的方法进行构造。</p>
<p>我们选择 \(\Omega=[0,1]^3\) 和 \(a(\mathbf x)=\frac{1}{0.05 + 2\|\mathbf x\|^2}\) 作为域。由于系数是围绕原点对称的，但域却不是，我们最终会得到一个非对称的解决方案。</p>
<p><a class="anchor" id="Matrixvectorproductimplementation"></a></p><h3>Matrix-vector product implementation</h3>
<p>为了找出我们如何编写一个执行矩阵-向量乘积的代码，但不需要存储矩阵元素，让我们先看看一个有限元矩阵<em>A</em>是如何组装起来的。</p>
<p class="formulaDsp">
\begin{eqnarray*} A = \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_{\mathrm{cell,{loc-glob}}}^T A_{\mathrm{cell}} P_{\mathrm{cell,{loc-glob}}}. \end{eqnarray*}
</p>
<p>在这个公式中，矩阵<em>P</em><sub>cell,loc-glob</sub>是一个矩形矩阵，定义了从当前单元的局部自由度到全局自由度的索引映射。可以建立这个算子的信息通常被编码在 <code>local_dof_indices</code> 变量中，并在deal.II中用于汇编调用填充矩阵。这里，&lt;i&gt;A<sub>cell</sub>表示与<em>A</em>相关的单元矩阵。</p>
<p>如果我们要进行矩阵-向量乘积，因此我们可以使用</p>
<p class="formulaDsp">
\begin{eqnarray*} y &amp;=&amp; A\cdot u = \left(\sum_{\text{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} P_\mathrm{cell,{loc-glob}}\right) \cdot u \\ &amp;=&amp; \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} u_\mathrm{cell} \\ &amp;=&amp; \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}, \end{eqnarray*}
</p>
<p>其中<em>u</em><sub>cell</sub>是<em>u</em>在各单元自由度处的值，而<em>v</em><sub>cell</sub>=<em>A</em><sub>cell</sub><em>u</em><sub>cell</sub>相应为结果。因此，实现拉普拉斯的局部作用的一个天真尝试是使用以下代码。</p>
<div class="fragment"><div class="line">Matrixfree&lt;dim&gt;::vmult (<a class="code" href="classVector.html">Vector&lt;double&gt;</a>       &amp;dst,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  dst = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>+1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>|</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>       cell_src (dofs_per_cell),</div><div class="line">                       cell_dst (dofs_per_cell);</div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</div><div class="line">  std::vector&lt;double&gt; coefficient_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; local_dof_indices (dofs_per_cell);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a> (cell);</div><div class="line">      coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             coefficient_values);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i,q) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j,q) *</div><div class="line">                                 fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q)*</div><div class="line">                                 coefficient_values[q]);</div><div class="line"></div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        cell_src(i) = src(local_dof_indices(i));</div><div class="line"></div><div class="line"></div><div class="line">      cell_matrix.<a class="code" href="classFullMatrix.html#a65a409eeef6388d99ac15e2bbe8045f6">vmult</a> (cell_dst, cell_src);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        dst(local_dof_indices(i)) += cell_dst;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>在这里，我们忽略了边界条件以及我们可能有的任何悬空节点，尽管使用AffineConstraints类来包括这两者都不是很困难。请注意，我们首先以通常的方式生成局部矩阵，作为每个局部矩阵项的所有正交点的总和。为了形成上述公式中表达的实际乘积，我们提取细胞相关自由度的 <code>src</code> 的值（<em>P</em><sub>cell,loc-glob</sub>的作用），乘以局部矩阵（<em>A</em><sub>cell</sub>），最后把结果加到目标向量 <code>dst</code> （<em>P</em><sub>cell,loc-glob</sub><sup>T</sup>的动作，加在所有元素上）。原则上不会比这更难。</p>
<p>虽然这段代码是完全正确的，但它非常慢。对于每个单元，我们生成一个局部矩阵，这需要三个嵌套循环，循环长度等于局部自由度的数量来计算。然后，乘法本身是由两个嵌套循环完成的，这意味着它要便宜得多。</p>
<p>改善这一点的一个方法是认识到，从概念上讲，局部矩阵可以被认为是三个矩阵的乘积。</p>
<p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell}, \end{eqnarray*}
</p>
<p>对于拉普拉斯算子的例子，<em>q</em>*dim+<em>d,i</em>的第1个元素<sub>cell</sub>是由 <code>fe_values.shape_grad(i,q)[d]</code> 给出。这个矩阵由 <code>dim*n_q_points</code> 行和 <code>dofs_per_cell</code> 列组成。矩阵<em>D</em><sub>cell</sub>是对角线，包含了 <code>fe_values.JxW(q) * coefficient_values[q]</code> 的值（或者说， <code>这些值中每一个的dim副本）。这种有限元矩阵的表示方法经常可以在工程文献中找到。</code> </p>
<p>当单元格矩阵被应用于一个矢量时。</p>
<p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell}\cdot u_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell} \cdot u_\mathrm{cell}, \end{eqnarray*}
</p>
<p>这样就不会形成矩阵-矩阵乘积，而是每次用一个矩阵与一个矢量从右到左相乘，这样就只形成三个连续的矩阵-矢量乘积。这种方法去掉了局部矩阵计算中的三个嵌套循环，从而将一个单元格的工作复杂度从类似 \(\mathcal {O}(\mathrm{dofs\_per\_cell}^3)\) 降低到 \(\mathcal {O}(\mathrm{dofs\_per\_cell}^2)\) 。对这种算法的解释是，我们首先将本地DoF上的值向量转换为正交点上的梯度向量。在第二个循环中，我们把这些梯度乘以积分权重和系数。第三次循环应用第二个梯度（转置形式），这样我们就得到了单元斗室上的（拉普拉斯）值矢量。</p>
<p>上述代码的瓶颈是对每一个 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> 的调用所做的操作，其花费的时间和其他步骤加起来差不多（至少如果网格是非结构化的；deal.II可以识别结构化网格上的梯度往往是不变的）。这当然不理想，我们希望能做得更好。reinit函数所做的是计算实空间的梯度，使用从实空间到参考单元的转换的Jacobian来转换参考单元上的梯度。这是为单元格上的每个基函数和每个正交点进行的。雅各布系数并不取决于基函数，但它在不同的正交点上通常是不同的。如果你只建立一次矩阵，就像我们在以前所有的教程程序中所做的那样，没有什么需要优化的，因为 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> 需要在每个单元上调用。在这个过程中，转换是在计算局部矩阵元素时应用的。</p>
<p>然而，在一个无矩阵的实现中，我们会经常计算这些积分，因为迭代求解器在求解过程中会多次应用矩阵。因此，我们需要考虑是否可以缓存一些在运算器应用中被重用的数据，也就是积分计算。另一方面，我们意识到我们不能缓存太多的数据，否则我们又回到了内存访问成为主导因素的情况。因此，我们不会在矩阵<em>B</em>中存储转换后的梯度，因为一般来说，对于曲线网格的每个基函数和每个元素上的正交点，它们都是不同的。</p>
<p>诀窍是去掉雅各布变换的因素，首先只在参考单元上应用梯度。这个操作将本地道夫上的值向量插值到正交点上的（单位坐标）梯度向量。在这里，我们首先应用我们从梯度中分解出来的雅各布，然后应用正交点的权重，最后应用转置的雅各布来准备第三个循环，通过单元格上的梯度测试并对正交点求和。</p>
<p>让我们再次用矩阵的方式来写。让矩阵<em>B</em><sub>cell</sub>表示与单元有关的梯度矩阵，每一行包含正交点上的值。它由矩阵与矩阵的乘积构成 </p><p class="formulaDsp">
\begin{eqnarray*} B_\mathrm{cell} = J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell}, \end{eqnarray*}
</p>
<p>，其中<em>B</em><sub>ref_cell</sub>表示参考单元的梯度，<em>J</em><sup>-T</sup><sub>cell</sub>表示从单位到实数单元的变换的反转置Jacobian（在变换的语言中，由<em>J</em><sup>-T</sup><sub>cell</sub>表示协变变换的操作）。<em>J</em><sup>-T</sup><sub>cell</sub>是块对角线的，块的大小等于问题的维度。每个对角线块都是雅各布变换，从参考单元到实际单元。</p>
<p>把事情放在一起，我们发现</p>
<p class="formulaDsp">
\begin{eqnarray*} A_\mathrm{cell} = B_\mathrm{cell}^T D B_\mathrm{cell} = B_\mathrm{ref\_cell}^T J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell}, \end{eqnarray*}
</p>
<p>所以我们要计算积（从右边开始计算局部积）。</p>
<p class="formulaDsp">
\begin{eqnarray*} v_\mathrm{cell} = B_\mathrm{ref\_cell}^T J_\mathrm{cell}^{-1} D J_\mathrm{cell}^{-\mathrm T} B_\mathrm{ref\_cell} u_\mathrm{cell}, \quad v = \sum_{\mathrm{cell}=1}^{\mathrm{n\_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}. \end{eqnarray*}
</p>
<div class="fragment"><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_reference (fe, quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="namespaceGridGenerator.html#aeb9a83e353f8d69ce49ebdd191a3a51f">reference_cell</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(reference_cell, 0., 1.);</div><div class="line">  fe_values_reference.reinit (reference_cell.<a class="code" href="classTriangulation.html#ae4bd2787b33fb53f9ba3d18dc81efa2d">begin</a>());</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (fe, quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fac654119724aff0c394743170ae949d18">update_inverse_jacobians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a> (cell);</div><div class="line">      coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             coefficient_values);</div><div class="line"></div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices (local_dof_indices);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        cell_src(i) = src(local_dof_indices(i));</div><div class="line"></div><div class="line"></div><div class="line">      temp_vector = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">            temp_vector(q*dim+d) +=</div><div class="line">              fe_values_reference.shape_grad(i,q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] * cell_src(i);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="comment">// apply the transposed inverse Jacobian of the mapping</span></div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> temp;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp[d] = temp_vector(q*dim+d);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            {</div><div class="line">              <span class="keywordtype">double</span> sum = 0;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e=0; e&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div><div class="line">                sum += fe_values.<a class="code" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian</a>(q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] *</div><div class="line">                               temp[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>];</div><div class="line">              temp_vector(q*dim+d) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">          <span class="comment">// multiply by coefficient and integration weight</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp_vector(q*dim+d) *= fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) * coefficient_values[q];</div><div class="line"></div><div class="line"></div><div class="line">          <span class="comment">// apply the inverse Jacobian of the mapping</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            temp[d] = temp_vector(q*dim+d);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            {</div><div class="line">              <span class="keywordtype">double</span> sum = 0;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> e=0; e&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div><div class="line">                sum += fe_values.<a class="code" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian</a>(q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>] *</div><div class="line">                       temp[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>];</div><div class="line">              temp_vector(q*dim+d) = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      cell_dst = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            cell_dst(i) += fe_values_reference.shape_grad(i,q)[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] *</div><div class="line">                                   temp_vector(q*dim+d);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        dst(local_dof_indices(i)) += cell_dst(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>注意我们如何为参考单元梯度创建一个额外的FEValues对象，以及如何将其初始化为参考单元。然后，实际的导数数据是由反的、转置的Jacobian（deal.II将Jacobian矩阵从实单元到单位单元称为inverse_jacobian，因为正向转换是从单位单元到实单元）应用的。因子 \(J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T}\) 是块对角线超过正交的。在这种形式下，人们意识到可变系数（可能通过张量表示）和一般网格拓扑结构的雅各布变换对变换单元格导数的系数有类似的影响。</p>
<p>在这一点上，人们可能会想，为什么我们要分别存储矩阵 \(J_\mathrm{cell}^{-\mathrm T}\) 和系数，而不是只存储完整的因子 \(J_\mathrm{cell}^{-1} D_\mathrm{cell} J_\mathrm{cell}^{-\mathrm T}\) 。后者会使用更少的内存，因为张量是对称的，在三维中具有六个独立的值，而对于前者，我们需要九个条目用于反转雅各布系数，一个用于正交权重和雅各布行列式，一个用于系数，总共是11个双数。原因是前者允许通过一个共同的缓存数据框架来实现通用的微分算子，而后者则专门存储拉普拉斯的系数。如果应用需要，这种专门化可能会得到回报，值得考虑。请注意，deal.II中的实现足够聪明，可以检测笛卡尔或仿生几何，其中雅各布系数在整个单元中是恒定的，不需要为每个单元存储（实际上在不同的单元中也常常是相同的）。</p>
<p>从操作数的角度来看，最后的优化是利用基函数中的张量积结构，这是最为关键的。这是可能的，因为我们已经从<em>B</em><sub>ref_cell</sub>描述的参考单元操作中剔除了梯度，即对参考单元的完全规则的数据域进行插值操作。我们举例说明在两个空间维度上降低复杂度的过程，但是同样的技术也可以用在更高的维度上。在参考单元上，基函数是张量积形式的 \(\phi(x,y,z) = \varphi_i(x) \varphi_j(y)\) 。矩阵<em>B</em><sub>ref_cell</sub>计算第一分量的部分具有 \(B_\mathrm{sub\_cell}^x = B_\mathrm{grad,x} \otimes B_\mathrm{val,y}\) 的形式，其中<em>B</em><sub>grad,x</sub>和<em>B</em><sub>val,y</sub>包含所有一维正交点上所有一维基函数的评价。用含有属于基函数 \(\varphi_i(x) \varphi_j(y)\) 的系数的<em>U</em>组成矩阵<em>U(j,i)</em>，我们得到 \((B_\mathrm{grad,x} \otimes B_\mathrm{val,y})u_\mathrm{cell} = B_\mathrm{val,y} U B_\mathrm{grad,x}\) 。这就把计算这个乘积的复杂度从 \(p^4\) 降低到 \(2 p^3\) ，其中<em>p</em>-1是有限元的度数（即，等价地，<em>p</em>是每个坐标方向上的形状函数的数量），或者一般来说 \(p^{2d}\) 到 \(d p^{d+1}\) 。我们之所以用多项式度数来看复杂度，是因为我们希望能够到高度数，可能会增加多项式度数<em>p</em>而不是网格分辨率。像这里使用的中等度数的好算法是独立于维度的多项式度数的线性算法，而不是基于矩阵的方案或通过FEValues的天真评价。在deal.II的实现中所使用的技术自20世纪80年代以来就已经在谱元界建立起来。</p>
<p>实现一个无矩阵和基于单元的有限元算子，与以前的教程程序中显示的通常的矩阵装配代码相比，需要一个有点不同的程序设计。做到这一点的数据结构是MatrixFree类和FEEvaluation类，前者收集所有数据并在所有单元上发出一个（并行）循环，后者利用张量积结构评估有限元基函数。</p>
<p>本教程中展示的无矩阵的矩阵-向量乘积的实现比使用稀疏矩阵的线性元素的矩阵-向量乘积要慢，但由于张量乘积结构降低了复杂度，并且在计算过程中减少了内存传输，所以对所有高阶元素来说速度更快。当在一个多核处理器上工作时，减少内存传输的影响特别有利，因为在这个处理器上有几个处理单元共享内存的访问。在这种情况下，一个受计算约束的算法将显示出几乎完美的并行加速（除了可能通过涡轮模式改变处理器的时钟频率，这取决于有多少个核心在工作），而一个受内存传输约束的算法可能无法实现类似的加速（即使工作是完全并行的，我们可以期待像稀疏矩阵-向量产品那样的完美缩放）。这种实现方式的另一个好处是，我们不必建立稀疏矩阵本身，这也可能是相当昂贵的，这取决于基础微分方程。此外，上述框架可以简单地推广到非线性运算，正如我们在步骤48中所展示的那样。</p>
<p><a class="anchor" id="Combinationwithmultigrid"></a></p><h3>Combination with multigrid</h3>
<p>上面，我们花了很大的力气来实现一个不实际存储矩阵元素的矩阵-向量积。然而，在许多用户代码中，人们想要的不仅仅是做一些矩阵-向量乘积&amp;mdash；在求解线性系统时，人们希望尽可能少做这些操作。理论上，我们可以使用CG方法，而不需要预处理；然而，这对拉普拉斯的效率并不高。相反，预调节器是用来提高收敛速度的。不幸的是，大多数比较常用的预处理方法，如SSOR、ILU或代数多网格（AMG）不能在这里使用，因为它们的实现需要了解系统矩阵的元素。</p>
<p>一个解决方案是使用几何多网格方法，如步骤16所示。众所周知，它们的速度非常快，而且适合我们的目的，因为所有的成分，包括不同网格层之间的转移，都可以用与单元格集合相关的矩阵-向量产品来表示。我们需要做的就是找到一个基于矩阵-向量乘积而不是所有矩阵条目的平滑器。一个这样的候选方法是阻尼雅可比迭代，它需要访问矩阵对角线，但它在阻尼所有高频误差方面往往不够好。雅可比方法的特性可以通过所谓的切比雪夫迭代进行几次改进。切比雪夫迭代由矩阵-向量乘积的多项式表达式描述，其中的系数可以被选择来实现某些特性，在这种情况下，可以平滑误差的高频成分，这些误差与雅可比预处理矩阵的特征值相关。在零度时，具有最佳阻尼参数的雅可比方法被检索出来，而高阶修正被用来改善平滑特性。切比雪夫平滑法在多网格中的有效性已经被证明，例如在文章<a href="http://www.sciencedirect.com/science/article/pii/S0021999103001943"><em>M. Adams, M. Brezina, J. Hu, R. Tuminaro. Parallel multigrid smoothers: polynomial versus Gauss&ndash;Seidel, J. Comput. Phys. 188:593&ndash;610, 2003</em><em>M. Adams, M. Brezina, J. Hu, R. Tuminaro. Parallel multigrid smoothers: polynomial versus Gauss&ndash;Seidel, J. Comput. Phys. 188:593&ndash;610, 2003</em></a>中。这篇文章还指出了我们在这里利用的切比雪夫平滑器的另一个优势，即它们很容易并行化，而SOR/Gauss&ndash;Seidel平滑依赖于替换，对于这种替换，天真的并行化在矩阵的对角线子块上工作，从而降低了效率（更多细节见例如Y. Saad, Iterative Methods for Sparse Linear Systems, SIAM, 2nd edition, 2003, chapters 11 &amp; 12）。</p>
<p>然后，在多网格框架中的实现就很简单了。本程序中的多网格实现与<a class="el" href="step_16.html">step-16</a>类似，包括自适应性。</p>
<p><a class="anchor" id="UsingCPUdependentinstructionsvectorization"></a></p><h3>Using CPU-dependent instructions (vectorization)</h3>
<p>FEEvaluation中的计算内核是以优化使用计算资源的方式来编写的。为了达到这个目的，他们不对双倍数据类型进行操作，而是对我们称之为VectorizedArray的东西进行操作（例如，查看 <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">FEEvaluationBase::get_value</a>, 的返回类型，对于标量元素是VectorizedArray，对于矢量有限元素是Tensor of VectorizedArray）。VectorizedArray是一个双数或浮点数的短阵列，其长度取决于使用的特定计算机系统。例如，基于x86-64的系统支持流式SIMD扩展（SSE），处理器的矢量单元可以通过一条CPU指令处理两个双数（或四个单精度浮点数）。较新的处理器（大约从2012年起）支持所谓的高级向量扩展（AVX），有256位操作数，可以分别使用四个双数和八个浮点数。矢量化是一个单指令/多数据（SIMD）的概念，也就是说，一条CPU指令被用来同时处理多个数据值。通常情况下，有限元程序不会明确使用矢量化，因为这个概念的好处只体现在算术密集型操作中。大部分典型的有限元工作负载都受到内存带宽的限制（对稀疏矩阵和向量的操作），在这种情况下，额外的计算能力是无用的。</p>
<p>不过，在幕后，优化的BLAS包可能严重依赖矢量化。另外，优化的编译器可能会自动将涉及标准代码的循环转化为更有效的矢量化形式（deal.II在矢量更新的常规循环中使用OpenMP SIMD pragmas）。然而，数据流必须非常有规律，才能让编译器产生高效的代码。例如，受益于矢量化的原型操作（矩阵-矩阵乘积）的自动矢量化在大多数编译器上都失败了（截至2012年初编写本教程并在2016年底更新时，gcc和英特尔编译器都无法为 <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a> 函数，甚至在更简单的情况下也不行，即矩阵边界是编译时常量而不是 <a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">FullMatrix::mmult</a>). 中的运行时常量。此外，有可能被一起处理的数据可能没有以连续的方式布置在内存中，或者没有对处理器需要的地址边界进行必要的对齐。或者编译器可能无法证明数据阵列在一次加载几个元素时不会重叠。</p>
<p>因此，在deal.II的无矩阵实现中，我们选择在最适合于有限元计算的层次上应用矢量化。所有单元的计算通常是完全相同的（除了从向量读写时使用的间接寻址中的索引），因此SIMD可以用来一次处理几个单元。在下面的所有内容中，你可以考虑用一个向量数组来保存几个单元的数据。记住，它与空间维度和元素数量无关，例如在Tensor或Point中。</p>
<p>请注意，矢量化取决于代码运行的CPU，以及代码的编译对象。为了给你的计算机生成最快的FEEvaluation内核，你应该用所谓的<em>native</em>处理器变体编译deal.II。当使用gcc编译器时，可以通过在cmake构建设置中设置变量&lt;tt&gt;CMAKE_CXX_FLAGS为<code>"-march=native"</code>来启用它（在命令行中，指定<code>-DCMAKE_CXX_FLAGS="-march=native"</code>，更多信息见deal.II阅读手册）。其他编译器也有类似的选项。我们在本例的run()函数中输出当前的矢量化长度。</p>
<p><a class="anchor" id="Runningmultigridonlargescaleparallelcomputers"></a></p><h3>Running multigrid on large-scale parallel computers</h3>
<p>如上所述，无矩阵框架中的所有组件都可以通过MPI使用领域分解轻松实现并行化。由于在deal.II中通过p4est（详见<a class="el" href="step_40.html">step-40</a>）可以很容易地访问大规模的并行网格，而且基于单元格的循环与无矩阵评估<em>only</em>需要在每个处理器上将网格分解成大小基本相同的块，因此编写一个使用分布式内存工作的并行程序所需的工作相对较少。虽然其他使用MPI的教程程序依赖于PETSc或Trilinos，但这个程序使用deal.II自己的并行向量设施。</p>
<p>deal.II并行向量类， <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>, 持有解决方案的处理器本地部分以及重影自由度的数据字段，即由远程处理器拥有的自由度，但由当前处理器拥有的单元访问。在 <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">术语表 </a>中，这些自由度被称为本地活动自由度。函数 <a class="el" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">MatrixFree::initialize_dof_vector()</a> 提供了一个设置这种设计的方法。请注意，悬挂节点可以与额外的重影自由度有关，这些自由度必须包括在分布式矢量中，但不属于 <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">词汇表 </a>意义上的本地活动自由度。此外，分布式向量持有本地拥有但其他处理器需要的DoF的MPI元数据。这个向量类设计的一个好处是对重影项的访问方式。在向量的存储方案中，数据阵列延伸到解决方案的处理器本地部分之外，有更多的向量条目可用于重影自由度。这为所有本地活动自由度提供了一个连续的索引范围。(注意，索引范围取决于网格的具体配置。)由于无矩阵操作可以被认为是在做性能关键的线性代数，而性能关键的代码不能把时间浪费在做MPI全局到MPI局部的索引转换上，一个MPI等级的局部索引空间的可用性是很重要的。这里访问事物的方式是直接数组访问。这是通过 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">LinearAlgebra::distributed::Vector::local_element()</a>, 提供的，但实际上很少需要，因为所有这些都发生在FEEvaluation的内部。</p>
<p><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 的设计与我们之前在<a class="el" href="step_40.html">step-40</a>和<a class="el" href="step_32.html">step-32</a>中使用的 <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> 和 <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> 数据类型类似，但由于我们不需要这些库的其他并行功能，所以我们使用deal.II的 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> 类来代替在本教程程序中链接另一个大型库。还要注意的是，PETSc和Trilinos向量不提供对直接数组访问的幽灵条目的细粒度控制，因为它们抽象出了必要的实现细节。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First include the necessary files from the deal.II library.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>This includes the data structures for the efficient implementation of matrix-free methods or more generic finite element operators with the class <a class="el" href="classMatrixFree.html">MatrixFree</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step37</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p>To be efficient, the operations performed in the matrix-free implementation require knowledge of loop lengths at compile time, which are given by the degree of the finite element. Hence, we collect the values of the two template parameters that can be changed at one place in the code. Of course, one could make the degree of the finite element a run-time parameter by compiling the computational kernels for all degrees that are likely (say, between 1 and 6) and selecting the appropriate kernel at run time. Here, we simply choose second order \(Q_2\) elements and choose dimension 3 as standard.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_finite_element = 2;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension             = 3;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>We define a variable coefficient function for the Poisson problem. It is similar to the function in <a class="el" href="step_5.html">step-5</a> but we use the form \(a(\mathbf x)=\frac{1}{0.05 + 2\|\bf x\|^2}\) instead of a discontinuous one. It is merely to demonstrate the possibilities of this implementation, rather than making much sense physically. We define the coefficient in the same way as functions in earlier tutorial programs. There is one new function, namely a <code>value</code> method with template argument <code>number</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">  number <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        component = 0) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>This is the new function mentioned above: Evaluate the coefficient for abstract type <code>number</code>. It might be just a usual double, but it can also be a somewhat more complicated type that we call <a class="el" href="classVectorizedArray.html">VectorizedArray</a>. This data type is essentially a short array of doubles as discussed in the introduction that holds data from several cells. For example, we evaluate the coefficient shown here not on a simple point as usually done, but we hand it a <a class="el" href="classPoint.html">Point</a>&lt;dim,<a class="el" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> &gt; point, which is actually a collection of four points in the case of AVX. Do not confuse the entries in <a class="el" href="classVectorizedArray.html">VectorizedArray</a> with the different coordinates of the point. Indeed, the data is laid out such that <code>p[0]</code> returns a <a class="el" href="classVectorizedArray.html">VectorizedArray</a>, which in turn contains the x-coordinate for the first point and the second point. You may access the coordinates individually using e.g. <code>p[0][j]</code>, j=0,1,2,3, but it is recommended to define operations on a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> as much as possible in order to make use of vectorized operations.</p>
<p>In the function implementation, we assume that the number type overloads basic arithmetic operations, so we just write the code as usual. The base class function <code>value</code> is then computed from the templated function with double type, in order to avoid duplicating code.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">number Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1. / (0.05 + 2. * p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> value&lt;double&gt;(p, component);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Matrixfreeimplementation"></a> </p><h3>Matrix-free implementation</h3>
<p>The following class, called <code>LaplaceOperator</code>, implements the differential operator. For all practical purposes, it is a matrix, i.e., you can ask it for its size (member functions <code>m(), n()</code>) and you can apply it to a vector (the <code>vmult()</code> function). The difference to a real matrix of course lies in the fact that this class does not actually store the <em>elements</em> of the matrix, but only knows how to compute the action of the operator when applied to a vector.</p>
<p>The infrastructure describing the matrix size, the initialization from a <a class="el" href="classMatrixFree.html">MatrixFree</a> object, and the various interfaces to matrix-vector products through vmult() and Tvmult() methods, is provided by the class MatrixFreeOperator::Base from which this class derives. The LaplaceOperator class defined here only has to provide a few interfaces, namely the actual action of the operator through the apply_add() method that gets used in the vmult() functions, and a method to compute the diagonal entries of the underlying matrix. We need the diagonal for the definition of the multigrid smoother. Since we consider a problem with variable coefficient, we further implement a method that can fill the coefficient values.</p>
<p>Note that the file <code>include/deal.II/matrix_free/operators.h</code> already contains an implementation of the Laplacian through the class <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a>. For educational purposes, the operator is re-implemented in this tutorial program, explaining the ingredients and concepts used there.</p>
<p>This program makes use of the data cache for finite element operator application that is integrated in deal.II. This data cache class is called <a class="el" href="classMatrixFree.html">MatrixFree</a>. It contains mapping information (Jacobians) and index relations between local and global degrees of freedom. It also contains constraints like the ones from hanging nodes or Dirichlet boundary conditions. Moreover, it can issue a loop over all cells in parallel, making sure that only cells are worked on that do not share any degree of freedom (this makes the loop thread-safe when writing into destination vectors). This is a more advanced strategy compared to the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class described in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> module. Of course, to not destroy thread-safety, we have to be careful when writing into class-global structures.</p>
<p>The class implementing the Laplace operator has three template arguments, one for the dimension (as many deal.II classes carry), one for the degree of the finite element (which we need to enable efficient computations through the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class), and one for the underlying scalar type. We want to use <code>double</code> numbers (i.e., double precision, 64-bit floating point) for the final matrix, but floats (single precision, 32-bit floating point numbers) for the multigrid level matrices (as that is only a preconditioner, and floats can be processed twice as fast). The class <a class="el" href="classFEEvaluation.html">FEEvaluation</a> also takes a template argument for the number of quadrature points in one dimension. In the code below, we hard-code it to <code>fe_degree+1</code>. If we wanted to change it independently of the polynomial degree, we would need to add a template parameter as is done in the <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a> class.</p>
<p>As a sidenote, if we implemented several different operations on the same grid and degrees of freedom (like a mass matrix and a Laplace matrix), we would define two classes like the current one for each of the operators (derived from the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class), and let both of them refer to the same <a class="el" href="classMatrixFree.html">MatrixFree</a> data cache from the general problem class. The interface through <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> requires us to only provide a minimal set of functions. This concept allows for writing complex application codes with many matrix-free operations.</p>
<dl class="section note"><dt>Note</dt><dd>Storing values of type <code>VectorizedArray&lt;number&gt;</code> requires care: Here, we use the deal.II table class which is prepared to hold the data with correct alignment. However, storing e.g. an <code>std::vector&lt;VectorizedArray&lt;number&gt; &gt;</code> is not possible with vectorization: A certain alignment of the data with the memory address boundaries is required (essentially, a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> that is 32 bytes long in case of AVX needs to start at a memory address that is divisible by 32). The table class (as well as the <a class="el" href="classAlignedVector.html">AlignedVector</a> class it is based on) makes sure that this alignment is respected, whereas std::vector does not in general, which may lead to segmentation faults at strange places for some systems or suboptimal performance for other systems.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keyword">class </span>LaplaceOperator</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">      Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">  LaplaceOperator();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_coefficient(<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">              <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">              <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_compute_diagonal(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;              data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp; dst,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                         dummy,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; coefficient;</div><div class="line">};</div></div><!-- fragment --><p>This is the constructor of the <code>LaplaceOperator</code> class. All it does is to call the default constructor of the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, which in turn is based on the <a class="el" href="classSubscriptor.html">Subscriptor</a> class that asserts that this class is not accessed after going out of scope e.g. in a preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">LaplaceOperator&lt;dim, fe_degree, number&gt;::LaplaceOperator()</div><div class="line">  : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                              <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="classVector.html">Vector</a>&lt;number&gt;&gt;()</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">{</div><div class="line">  coefficient.reinit(0, 0);</div><div class="line">  <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">    clear();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computationofcoefficient"></a> </p><h4>Computation of coefficient</h4>
<p>To initialize the coefficient, we directly give it the Coefficient class defined above and then select the method <code>coefficient_function.value</code> with vectorized number (which the compiler can deduce from the point data type). The use of the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class (and its template arguments) will be explained below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::evaluate_coefficient(</div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line">  coefficient.reinit(n_cells, phi.n_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        coefficient(cell, q) =</div><div class="line">          coefficient_function.value(phi.quadrature_point(q));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LocalevaluationofLaplaceoperator"></a> </p><h4>Local evaluation of Laplace operator</h4>
<p>Here comes the main function of this class, the evaluation of the matrix-vector product (or, in general, a finite element operator evaluation). This is done in a function that takes exactly four arguments, the <a class="el" href="classMatrixFree.html">MatrixFree</a> object, the destination and source vectors, and a range of cells that are to be worked on. The method <code>cell_loop</code> in the <a class="el" href="classMatrixFree.html">MatrixFree</a> class will internally call this function with some range of cells that is obtained by checking which cells are possible to work on simultaneously so that write operations do not cause any race condition. Note that the cell range used in the loop is not directly the number of (active) cells in the current mesh, but rather a collection of batches of cells. In other word, "cell" may be the wrong term to begin with, since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> groups data from several cells together. This means that in the loop over quadrature points we are actually seeing a group of quadrature points of several cells as one block. This is done to enable a higher degree of vectorization. The number of such "cells" or "cell batches" is stored in <a class="el" href="classMatrixFree.html">MatrixFree</a> and can be queried through <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a>. Compared to the deal.II cell iterators, in this class all cells are laid out in a plain array with no direct knowledge of level or neighborship relations, which makes it possible to index the cells by unsigned integers.</p>
<p>The implementation of the Laplace operator is quite simple: First, we need to create an object <a class="el" href="classFEEvaluation.html">FEEvaluation</a> that contains the computational kernels and has data fields to store temporary results (e.g. gradients evaluated on all quadrature points on a collection of a few cells). Note that temporary results do not use a lot of memory, and since we specify template arguments with the element order, the data is stored on the stack (without expensive memory allocation). Usually, one only needs to set two template arguments, the dimension as a first argument and the degree of the finite element as the second argument (this is equal to the number of degrees of freedom per dimension minus one for <a class="el" href="classFE__Q.html">FE_Q</a> elements). However, here we also want to be able to use float numbers for the multigrid preconditioner, which is the last (fifth) template argument. Therefore, we cannot rely on the default template arguments and must also fill the third and fourth field, consequently. The third argument specifies the number of quadrature points per direction and has a default value equal to the degree of the element plus one. The fourth argument sets the number of components (one can also evaluate vector-valued functions in systems of PDEs, but the default is a scalar element), and finally the last argument sets the number type.</p>
<p>Next, we loop over the given cell range and then we continue with the actual implementation: </p><ol>
<li>
Tell the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object the (macro) cell we want to work on. </li>
<li>
Read in the values of the source vectors (<code>read_dof_values</code>), including the resolution of constraints. This stores \(u_\mathrm{cell}\) as described in the introduction. </li>
<li>
Compute the unit-cell gradient (the evaluation of finite element functions). Since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> can combine value computations with gradient computations, it uses a unified interface to all kinds of derivatives of order between zero and two. We only want gradients, no values and no second derivatives, so we set the function arguments to true in the gradient slot (second slot), and to false in the values slot (first slot). There is also a third slot for the Hessian which is false by default, so it needs not be given. Note that the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class internally evaluates shape functions in an efficient way where one dimension is worked on at a time (using the tensor product form of shape functions and quadrature points as mentioned in the introduction). This gives complexity equal to \(\mathcal O(d^2 (p+1)^{d+1})\) for polynomial degree \(p\) in \(d\) dimensions, compared to the naive approach with loops over all local degrees of freedom and quadrature points that is used in <a class="el" href="classFEValues.html">FEValues</a> and costs \(\mathcal O(d (p+1)^{2d})\). </li>
<li>
Next comes the application of the Jacobian transformation, the multiplication by the variable coefficient and the quadrature weight. <a class="el" href="classFEEvaluation.html">FEEvaluation</a> has an access function <code>get_gradient</code> that applies the Jacobian and returns the gradient in real space. Then, we just need to multiply by the (scalar) coefficient, and let the function <code>submit_gradient</code> apply the second Jacobian (for the test function) and the quadrature weight and Jacobian determinant (JxW). Note that the submitted gradient is stored in the same data field as where it is read from in <code>get_gradient</code>. Therefore, you need to make sure to not read from the same quadrature point again after having called <code>submit_gradient</code> on that particular quadrature point. In general, it is a good idea to copy the result of <code>get_gradient</code> when it is used more often than once. </li>
<li>
Next follows the summation over quadrature points for all test functions that corresponds to the actual integration step. For the Laplace operator, we just multiply by the gradient, so we call the integrate function with the respective argument set. If you have an equation where you test by both the values of the test functions and the gradients, both template arguments need to be set to true. Calling first the integrate function for values and then gradients in a separate call leads to wrong results, since the second call will internally overwrite the results from the first call. Note that there is no function argument for the second derivative for integrate step. </li>
<li>
Eventually, the local contributions in the vector \(v_\mathrm{cell}\) as mentioned in the introduction need to be added into the result vector (and constraints are applied). This is done with a call to <code>distribute_local_to_global</code>, the same name as the corresponding function in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> (only that we now store the local vector in the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object, as are the indices between local and global degrees of freedom). </li>
</ol>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values(src);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      phi.distribute_local_to_global(dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function implements the loop over all cells for the Base::apply_add() interface. This is done with the <code>cell_loop</code> of the <a class="el" href="classMatrixFree.html">MatrixFree</a> class, which takes the operator() of this class with arguments <a class="el" href="classMatrixFree.html">MatrixFree</a>, OutVector, InVector, cell_range. When working with MPI parallelization (but no threading) as is done in this tutorial program, the cell loop corresponds to the following three lines of code:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">src.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values</a>();</div><div class="line">local_apply(*this-&gt;data, dst, src, std::make_pair(0<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>,</div><div class="line">                                                  data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>()));</div><div class="line">dst.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --> </div><p>Here, the two calls update_ghost_values() and <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> perform the data exchange on processor boundaries for MPI, once for the source vector where we need to read from entries owned by remote processors, and once for the destination vector where we have accumulated parts of the residuals that need to be added to the respective entry of the owner processor. However, <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop</a> does not only abstract away those two calls, but also performs some additional optimizations. On the one hand, it will split the update_ghost_values() and <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> calls in a way to allow for overlapping communication and computation. The local_apply function is then called with three cell ranges representing partitions of the cell range from 0 to <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a>. On the other hand, cell_loop also supports thread parallelism in which case the cell ranges are split into smaller chunks and scheduled in an advanced way that avoids access to the same vector entry by several threads. That feature is explained in <a class="el" href="step_48.html">step-48</a>.</p>
<p>Note that after the cell loop, the constrained degrees of freedom need to be touched once more for sensible vmult() operators: Since the assembly loop automatically resolves constraints (just as the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> call does), it does not compute any contribution for constrained degrees of freedom, leaving the respective entries zero. This would represent a matrix that had empty rows and columns for constrained degrees of freedom. However, iterative solvers like CG only work for non-singular matrices. The easiest way to do that is to set the sub-block of the matrix that corresponds to constrained DoFs to an identity matrix, in which case application of the matrix would simply copy the elements of the right hand side vector into the left hand side. Fortunately, the vmult() implementations <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> do this automatically for us outside the apply_add() function, so we do not need to take further action here.</p>
<p>When using the combination of <a class="el" href="classMatrixFree.html">MatrixFree</a> and <a class="el" href="classFEEvaluation.html">FEEvaluation</a> in parallel with MPI, there is one aspect to be careful about &mdash; the indexing used for accessing the vector. For performance reasons, <a class="el" href="classMatrixFree.html">MatrixFree</a> and <a class="el" href="classFEEvaluation.html">FEEvaluation</a> are designed to access vectors in MPI-local index space also when working with multiple processors. Working in local index space means that no index translation needs to be performed at the place the vector access happens, apart from the unavoidable indirect addressing. However, local index spaces are ambiguous: While it is standard convention to access the locally owned range of a vector with indices between 0 and the local size, the numbering is not so clear for the ghosted entries and somewhat arbitrary. For the matrix-vector product, only the indices appearing on locally owned cells (plus those referenced via hanging node constraints) are necessary. However, in deal.II we often set all the degrees of freedom on ghosted elements as ghosted vector entries, called the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs described in the</a> glossary". In that case, the MPI-local index of a ghosted vector entry can in general be different in the two possible ghost sets, despite referring to the same global index. To avoid problems, <a class="el" href="classFEEvaluation.html">FEEvaluation</a> checks that the partitioning of the vector used for the matrix-vector product does indeed match with the partitioning of the indices in <a class="el" href="classMatrixFree.html">MatrixFree</a> by a check called <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1121c9b5aa9c34d0fe36486fecf08b58">LinearAlgebra::distributed::Vector::partitioners_are_compatible</a>. To facilitate things, the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class includes a mechanism to fit the ghost set to the correct layout. This happens in the ghost region of the vector, so keep in mind that the ghost region might be modified in both the destination and source vector after a call to a vmult() method. This is legitimate because the ghost region of a distributed deal.II vector is a mutable section and filled on demand. Vectors used in matrix-vector products must not be ghosted upon entry of vmult() functions, so no information gets lost.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">}</div></div><!-- fragment --><p>The following function implements the computation of the diagonal of the operator. Computing matrix entries of a matrix-free operator evaluation turns out to be more complicated than evaluating the operator. Fundamentally, we could obtain a matrix representation of the operator by applying the operator on <em>all</em> unit vectors. Of course, that would be very inefficient since we would need to perform <em>n</em> operator evaluations to retrieve the whole matrix. Furthermore, this approach would completely ignore the matrix sparsity. On an individual cell, however, this is the way to go and actually not that inefficient as there usually is a coupling between all degrees of freedom inside the cell.</p>
<p>We first initialize the diagonal vector to the correct parallel layout. This vector is encapsulated in a member called inverse_diagonal_entries of type <a class="el" href="classDiagonalMatrix.html">DiagonalMatrix</a> in the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>. This member is a shared pointer that we first need to initialize and then get the vector representing the diagonal entries in the matrix. As to the actual diagonal computation, we again use the cell_loop infrastructure of <a class="el" href="classMatrixFree.html">MatrixFree</a> to invoke a local worker routine called local_compute_diagonal(). Since we will only write into a vector but not have any source vector, we put a dummy argument of type <code>unsigned int</code> in place of the source vector to confirm with the cell_loop interface. After the loop, we need to set the vector entries subject to Dirichlet boundary conditions to one (either those on the boundary described by the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object inside <a class="el" href="classMatrixFree.html">MatrixFree</a> or the indices at the interface between different grid levels in adaptive multigrid). This is done through the function <a class="el" href="classMatrixFreeOperators_1_1Base.html#a11ff9854b4433dc8a7795d1c117de2c3">MatrixFreeOperators::Base::set_constrained_entries_to_one()</a> and matches with the setting in the matrix-vector product provided by the Base operator. Finally, we need to invert the diagonal entries which is the form required by the Chebyshev smoother based on the Jacobi iteration. In the loop, we assert that all entries are non-zero, because they should either have obtained a positive contribution from integrals or be constrained and treated by <code>set_constrained_entries_to_one()</code> following cell_loop.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">LaplaceOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">{</div><div class="line">  this-&gt;inverse_diagonal_entries.reset(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">    this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dummy = 0;</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_compute_diagonal,</div><div class="line">                        <span class="keyword">this</span>,</div><div class="line">                        inverse_diagonal,</div><div class="line">                        dummy);</div><div class="line"></div><div class="line">  this-&gt;set_constrained_entries_to_one(inverse_diagonal);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size</a>(); ++i)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) &gt; 0.,</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No diagonal entry in a positive definite operator &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;should be zero&quot;</span>));</div><div class="line">      inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) =</div><div class="line">        1. / inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the local compute loop, we compute the diagonal by a loop over all columns in the local matrix and putting the entry 1 in the <em>i</em>th slot and a zero entry in all other slots, i.e., we apply the cell-wise differential operator on one unit vector at a time. The inner part invoking <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate</a>, the loop over quadrature points, and FEEvalution::integrate, is exactly the same as in the local_apply function. Afterwards, we pick out the <em>i</em>th entry of the local result and put it to a temporary storage (as we overwrite all entries in the array behind <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">FEEvaluation::get_dof_value()</a> with the next loop iteration). Finally, the temporary storage is written to the destination vector. Note how we use <a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">FEEvaluation::get_dof_value()</a> and <a class="el" href="classFEEvaluationBase.html#a3afd9d62f5762c41973aa0f037dc5099">FEEvaluation::submit_dof_value()</a> to read and write to the data field that <a class="el" href="classFEEvaluation.html">FEEvaluation</a> uses for the integration on the one hand and writes into the global vector on the other hand.</p>
<p>Given that we are only interested in the matrix diagonal, we simply throw away all other entries of the local matrix that have been computed along the way. While it might seem wasteful to compute the complete cell matrix and then throw away everything but the diagonal, the integration are so efficient that the computation does not take too much time. Note that the complexity of operator evaluation per element is \(\mathcal O((p+1)^{d+1})\) for polynomial degree \(k\), so computing the whole matrix costs us \(\mathcal O((p+1)^{2d+1})\) operations, not too far away from \(\mathcal O((p+1)^{2d})\) complexity for computing the diagonal with <a class="el" href="classFEValues.html">FEValues</a>. Since <a class="el" href="classFEEvaluation.html">FEEvaluation</a> is also considerably faster due to vectorization and other optimizations, the diagonal computation with this function is actually the fastest (simple) variant. (It would be possible to compute the diagonal with sum factorization techniques in \(\mathcal O((p+1)^{d+1})\) operations involving specifically adapted kernels&mdash;but since such kernels are only useful in that particular context and the diagonal computation is typically not on the critical path, they have not been implemented in deal.II.)</p>
<p>Note that the code that calls distribute_local_to_global on the vector to accumulate the diagonal entries into the global matrix has some limitations. For operators with hanging node constraints that distribute an integral contribution of a constrained DoF to several other entries inside the distribute_local_to_global call, the vector interface used here does not exactly compute the diagonal entries, but lumps some contributions located on the diagonal of the local matrix that would end up in a off-diagonal position of the global matrix to the diagonal. The result is correct up to discretization accuracy as explained in <a href="http://dx.doi.org/10.4208/cicp.101214.021015a">Kormann (2016), section 5.3</a>, but not mathematically equal. In this tutorial program, no harm can happen because the diagonal is only used for the multigrid level matrices where no hanging node constraints appear.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;             data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;dst,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <a class="code" href="classAlignedVector.html">AlignedVector&lt;VectorizedArray&lt;number&gt;</a>&gt; <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>(phi.dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; phi.dofs_per_cell; ++j)</div><div class="line">            phi.submit_dof_value(<a class="code" href="classVectorizedArray.html">VectorizedArray&lt;number&gt;</a>(), j);</div><div class="line">          phi.submit_dof_value(make_vectorized_array&lt;number&gt;(1.), i);</div><div class="line"></div><div class="line">          phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">            phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q),</div><div class="line">                                q);</div><div class="line">          phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">          <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i] = phi.get_dof_value(i);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">        phi.submit_dof_value(<a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i], i);</div><div class="line">      phi.distribute_local_to_global(dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemclass"></a> </p><h3>LaplaceProblem class</h3>
<p>This class is based on the one in <a class="el" href="step_16.html">step-16</a>. However, we replaced the SparseMatrix&lt;double&gt; class by our matrix-free implementation, which means that we can also skip the sparsity patterns. Notice that we define the LaplaceOperator class with the degree of finite element as template argument (the value is defined at the top of the file), and that we use float numbers for the multigrid level matrices.</p>
<p>The class also has a member variable to keep track of all the detailed timings for setting up the entire chain of data before we actually go about solving the problem. In addition, there is an output stream (that is disabled by default) that can be used to output details for the individual setup operations instead of the summary only that is printed out by default.</p>
<p>Since this program is designed to be used with MPI, we also provide the usual <code>pcout</code> output stream that only prints the information of the processor with MPI rank 0. The grid used for this programs can either be a distributed triangulation based on p4est (in case deal.II is configured to use p4est), otherwise it is a serial grid that only runs without MPI.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType =</div><div class="line">      LaplaceOperator&lt;dim, degree_finite_element, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = LaplaceOperator&lt;dim, degree_finite_element, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a> mg_matrices;</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>             setup_time;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> time_details;</div><div class="line">  };</div></div><!-- fragment --><p>When we initialize the finite element, we of course have to use the degree specified at the top of the file as well (otherwise, an exception will be thrown at some point, since the computational kernel defined in the templated LaplaceOperator class and the information from the finite element read out by <a class="el" href="classMatrixFree.html">MatrixFree</a> will not match). The constructor of the triangulation needs to set an additional flag that tells the grid to conform to the 2:1 cell balance over vertices, which is needed for the convergence of the geometric multigrid routines. For the distributed grid, we also need to specifically enable the multigrid hierarchy.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem()</div><div class="line">    :</div><div class="line">#ifdef DEAL_II_WITH_P4EST</div><div class="line">    triangulation(</div><div class="line">      MPI_COMM_WORLD,</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">      <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    ,</div><div class="line">#else</div><div class="line">    triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    ,</div><div class="line">#endif</div><div class="line">    fe(degree_finite_element)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , setup_time(0.)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    ,</div></div><!-- fragment --><p>The LaplaceProblem class holds an additional output stream that collects detailed timings about the setup phase. This stream, called time_details, is disabled by default through the <code>false</code> argument specified here. For detailed timings, removing the <code>false</code> argument prints all the details.</p>
<div class="fragment"><div class="line">  time_details(std::cout,</div><div class="line">               <span class="keyword">false</span> &amp;&amp; <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>The setup stage is in analogy to <a class="el" href="step_16.html">step-16</a> with relevant changes due to the LaplaceOperator class. The first thing to do is to set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, including the degrees of freedom for the multigrid levels, and to initialize constraints from hanging nodes and homogeneous Dirichlet conditions. Since we intend to use this programs in parallel with MPI, we need to make sure that the constraints get to know the locally relevant degrees of freedom, otherwise the storage would explode when using more than a few hundred millions of degrees of freedom, see <a class="el" href="step_40.html">step-40</a>.</p>
<p>Once we have created the multigrid dof_handler and the constraints, we can call the reinit function for the global matrix operator as well as each level of the multigrid scheme. The main action is to set up the <code> <a class="el" href="classMatrixFree.html">MatrixFree</a> </code> instance for the problem. The base class of the <code>LaplaceOperator</code> class, <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, is initialized with a shared pointer to <a class="el" href="classMatrixFree.html">MatrixFree</a> object. This way, we can simply create it here and then pass it on to the system matrix and level matrices, respectively. For setting up <a class="el" href="classMatrixFree.html">MatrixFree</a>, we need to activate the update flag in the AdditionalData field of <a class="el" href="classMatrixFree.html">MatrixFree</a> that enables the storage of quadrature point coordinates in real space (by default, it only caches data for gradients (inverse transposed Jacobians) and JxW values). Note that if we call the reinit function without specifying the level (i.e., giving <code>level = <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>), <a class="el" href="classMatrixFree.html">MatrixFree</a> constructs a loop over the active cells. In this tutorial, we do not use threads in addition to MPI, which is why we explicitly disable it by setting the <a class="el" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">MatrixFree::AdditionalData::tasks_parallel_scheme</a> to <a class="el" href="structMatrixFree_1_1AdditionalData.html#a5b3198735af965d2fc5019543263f927a70ba08215ce330f13a3fd33adbd977a9">MatrixFree::AdditionalData::none</a>. Finally, the coefficient is evaluated and vectors are initialized as explained above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  setup_time = 0;</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  mg_matrices.clear_elements();</div><div class="line"></div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line">  dof_handler.distribute_mg_dofs();</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Distribute DoFs &amp; B.C.     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">      <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::none</a>;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; system_mf_storage(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">    system_mf_storage-&gt;reinit(mapping,</div><div class="line">                              dof_handler,</div><div class="line">                              constraints,</div><div class="line">                              <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                              additional_data);</div><div class="line">    system_matrix.initialize(system_mf_storage);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(solution);</div><div class="line">  system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free system   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div></div><!-- fragment --><p>Next, initialize the matrices for the multigrid method on all the levels. The data structure <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> keeps information about the indices subject to boundary conditions as well as the indices on edges between different refinement levels as described in the <a class="el" href="step_16.html">step-16</a> tutorial program. We then go through the levels of the mesh and construct the constraints and matrices on each level. These follow closely the construction of the system matrix on the original mesh, except the slight difference in naming when accessing information on the levels rather than the active cells.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">  mg_matrices.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">  dirichlet_boundary.insert(0);</div><div class="line">  mg_constrained_dofs.initialize(dof_handler);</div><div class="line">  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                     dirichlet_boundary);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                    level,</div><div class="line">                                                    relevant_dofs);</div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">        mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::none</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">      std::shared_ptr&lt;MatrixFree&lt;dim, float&gt;&gt; mg_mf_storage_level(</div><div class="line">        <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;</a>());</div><div class="line">      mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                  dof_handler,</div><div class="line">                                  level_constraints,</div><div class="line">                                  <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                  additional_data);</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                    mg_constrained_dofs,</div><div class="line">                                    level);</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">    }</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free levels   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_rhs"></a> </p><h4>LaplaceProblem::assemble_rhs</h4>
<p>The assemble function is very simple since all we have to do is to assemble the right hand side. Thanks to <a class="el" href="classFEEvaluation.html">FEEvaluation</a> and all the data cached in the <a class="el" href="classMatrixFree.html">MatrixFree</a> class, which we query from <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, this can be done in a few lines. Since this call is not wrapped into a <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop</a> (which would be an alternative), we must not forget to call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> at the end of the assembly to send all the contributions of the right hand side to the owner of the respective degree of freedom.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line"></div><div class="line">  system_rhs = 0;</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">    *system_matrix.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>The solution process is similar as in <a class="el" href="step_16.html">step-16</a>. We start with the setup of the transfer. For <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>, there is a very fast transfer class called <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> that does the interpolation between the grid levels with the same fast sum factorization kernels that get also used in <a class="el" href="classFEEvaluation.html">FEEvaluation</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a>                            time;</div><div class="line">  <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a> mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG build transfer time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div></div><!-- fragment --><p>As a smoother, this tutorial program uses a Chebyshev iteration instead of SOR in <a class="el" href="step_16.html">step-16</a>. (SOR would be very difficult to implement because we do not have the matrix elements available explicitly, and it is difficult to make it work efficiently in parallel.) The smoother is initialized with our level matrices and the mandatory additional data for the Chebyshev smoother. We use a relatively high degree here (5), since matrix-vector products are comparably cheap. We choose to smooth out a range of \([1.2 \hat{\lambda}_{\max}/15,1.2 \hat{\lambda}_{\max}]\) in the smoother where \(\hat{\lambda}_{\max}\) is an estimate of the largest eigenvalue (the factor 1.2 is applied inside <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>). In order to compute that eigenvalue, the Chebyshev initialization performs a few steps of a CG algorithm without preconditioner. Since the highest eigenvalue is usually the easiest one to find and a rough estimate is enough, we choose 10 iterations. Finally, we also set the inner preconditioner type in the Chebyshev method which is a Jacobi iteration. This is represented by the <a class="el" href="classDiagonalMatrix.html">DiagonalMatrix</a> class that gets the inverse diagonal entry provided by our LaplaceOperator class.</p>
<p>On level zero, we initialize the smoother differently because we want to use the Chebyshev iteration as a solver. <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a> allows the user to switch to solver mode where the number of iterations is internally chosen to the correct value. In the additional data object, this setting is activated by choosing the polynomial degree to <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>. The algorithm will then attack all eigenvalues between the smallest and largest one in the coarse level matrix. The number of steps in the Chebyshev smoother are chosen such that the Chebyshev convergence estimates guarantee to reduce the residual by the number specified in the variable <code>smoothing_range</code>. Note that for solving, <code>smoothing_range</code> is a relative tolerance and chosen smaller than one, in this case, we select three orders of magnitude, whereas it is a number larger than 1 when only selected eigenvalues are smoothed.</p>
<p>From a computational point of view, the Chebyshev iteration is a very attractive coarse grid solver as long as the coarse size is moderate. This is because the Chebyshev method performs only matrix-vector products and vector updates, which typically parallelize better to the largest cluster size with more than a few tens of thousands of cores than inner product involved in other iterative methods. The former involves only local communication between neighbors in the (coarse) mesh, whereas the latter requires global communication over all processors.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> SmootherType =</div><div class="line">  <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                        LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                       LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                     mg_smoother;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">      {</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 5;</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        smoother_data[0].smoothing_range = 1e-3;</div><div class="line">        smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">        smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">      }</div><div class="line">    mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line">    smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">  }</div><div class="line">mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line"><a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">  mg_coarse;</div><div class="line">mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div></div><!-- fragment --><p>The next step is to set up the interface matrices that are needed for the case with hanging nodes. The adaptive multigrid realization in deal.II implements an approach called local smoothing. This means that the smoothing on the finest level only covers the local part of the mesh defined by the fixed (finest) grid level and ignores parts of the computational domain where the terminal cells are coarser than this level. As the method progresses to coarser levels, more and more of the global mesh will be covered. At some coarser level, the whole mesh will be covered. Since all level matrices in the multigrid method cover a single level in the mesh, no hanging nodes appear on the level matrices. At the interface between multigrid levels, homogeneous Dirichlet boundary conditions are set while smoothing. When the residual is transferred to the next coarser level, however, the coupling over the multigrid interface needs to be taken into account. This is done by the so-called interface (or edge) matrices that compute the part of the residual that is missed by the level matrix with homogeneous Dirichlet conditions. We refer to the <a class="el" href="DEALGlossary.html#mg_paper">Multigrid paper by Janssen and Kanschat</a> for more details.</p>
<p>For the implementation of those interface matrices, there is already a pre-defined class <a class="el" href="classMatrixFreeOperators_1_1MGInterfaceOperator.html">MatrixFreeOperators::MGInterfaceOperator</a> that wraps the routines <a class="el" href="classMatrixFreeOperators_1_1Base.html#a21cefa5a5d4cb726180c89962d8ae472">MatrixFreeOperators::Base::vmult_interface_down()</a> and <a class="el" href="classMatrixFreeOperators_1_1Base.html#af4f39d8232619d499709aa6ee968db58">MatrixFreeOperators::Base::vmult_interface_up()</a> in a new class with <code>vmult()</code> and <code>Tvmult()</code> operations (that were originally written for matrices, hence expecting those names). Note that vmult_interface_down is used during the restriction phase of the multigrid V-cycle, whereas vmult_interface_up is used during the prolongation phase.</p>
<p>Once the interface matrix is created, we set up the remaining <a class="el" href="classMultigrid.html">Multigrid</a> preconditioner infrastructure in complete analogy to <a class="el" href="step_16.html">step-16</a> to obtain a <code>preconditioner</code> object that can be applied to a matrix.</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">  mg_matrices);</div><div class="line"></div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">  mg_interface_matrices;</div><div class="line">mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  mg_interface_matrices[level].initialize(mg_matrices[level]);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">  mg_interface_matrices);</div><div class="line"></div><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">               LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">               <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>The setup of the multigrid routines is quite easy and one cannot see any difference in the solve process as compared to <a class="el" href="step_16.html">step-16</a>. All the magic is hidden behind the implementation of the LaplaceOperator::vmult operation. Note that we print out the solve time and the accumulated setup time through standard out, i.e., in any case, whereas detailed times for the setup operations are only printed in case the flag for detail_times in the constructor is changed.</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1e-12 * system_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">  setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;MG build smoother time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Total setup time               (wall) &quot;</span> &lt;&lt; setup_time &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line"></div><div class="line">  time.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">  time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a>(solution);</div><div class="line">  cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Time solve (&quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations)&quot;</span></div><div class="line">        &lt;&lt; (solver_control.last_step() &lt; 10 ? <span class="stringliteral">&quot;  &quot;</span> : <span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;(CPU/wall) &quot;</span></div><div class="line">        &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemoutput_results"></a> </p><h4>LaplaceProblem::output_results</h4>
<p>Here is the data output, which is a simplified version of <a class="el" href="step_5.html">step-5</a>. We use the standard VTU (= compressed VTK) output for each grid produced in the refinement process. In addition, we use a compression algorithm that is optimized for speed rather than disk usage. The default setting (which optimizes for disk usage) makes saving the output take about 4 times as long as running the linear solver, while setting <a class="el" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">DataOutBase::VtkFlags::compression_level</a> to <a class="el" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a> lowers this to only one fourth the time of the linear solve.</p>
<p>We disable the output when the mesh gets too large. A variant of this program has been run on hundreds of thousands MPI ranks with as many as 100 billion grid cells, which is not directly accessible to classical visualization tools.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1000000)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  solution.update_ghost_values();</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">  time_details &lt;&lt; <span class="stringliteral">&quot;Time write output          (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">               &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>The function that runs the program is very similar to the one in <a class="el" href="step_16.html">step-16</a>. We do few refinement steps in 3D compared to 2D, but that's it.</p>
<p>Before we run the program, we output some information about the detected vectorization level as discussed in the introduction.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(<a class="code" href="classdouble.html">double</a>) * n_vect_doubles;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Vectorization over &quot;</span> &lt;&lt; n_vect_doubles</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; doubles = &quot;</span> &lt;&lt; n_vect_bits &lt;&lt; <span class="stringliteral">&quot; bits (&quot;</span></div><div class="line">            &lt;&lt; <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">          }</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">        setup_system();</div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      };</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step37</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>Apart from the fact that we set up the MPI framework according to <a class="el" href="step_40.html">step-40</a>, there are no surprises in the main function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step37;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;dimension&gt; laplace_problem;</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-37/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>由于这个例子解决的是与步骤5相同的问题（除了不同的系数），所以对解决方案没有什么可说的。我们还是展示了一张图片，通过等高线和体积渲染来说明解决方案的大小。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.solution.png"/>
</div>
<p>更有趣的是评估多网格求解器的某些方面。当我们在二维运行这个程序时，对于二次（ \(Q_2\) ）元素，我们得到以下输出（当在一个核心上以释放模式运行时）。</p>
<div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 81</div><div class="line">Total setup time               (wall) 0.00159788s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000951s/0.000951052s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 289</div><div class="line">Total setup time               (wall) 0.00114608s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000935s/0.000934839s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 1089</div><div class="line">Total setup time               (wall) 0.00244665s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.00207s/0.002069s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 4225</div><div class="line">Total setup time               (wall) 0.00678205s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.005616s/0.00561595s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 16641</div><div class="line">Total setup time               (wall) 0.0241671s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.019543s/0.0195441s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 66049</div><div class="line">Total setup time               (wall) 0.0967851s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.07457s/0.0745709s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 6</div><div class="line">Number of degrees of freedom: 263169</div><div class="line">Total setup time               (wall) 0.346374s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.260042s/0.265033s</div></div><!-- fragment --><p>如同步骤16，我们看到随着自由度的增加，CG的迭代次数保持不变。恒定的迭代次数（加上最佳的计算特性）意味着当问题大小在一个周期内翻两番时，计算时间大约翻了四倍。该代码在存储方面也非常有效。大约200-400万个自由度适合于1GB的内存，也见下面的MPI结果。一个有趣的事实是，尽管没有建立矩阵，但解决一个线性系统比设置要便宜（大约一半的时间花在 <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a> 和 <a class="el" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">DoFHandler::distribute_mg_dofs()</a> 的调用上）。这表明这种方法的效率很高，但也表明deal.II数据结构的设置相当昂贵，设置成本必须在几个系统求解中摊销。</p>
<p>如果我们在三个空间维度上运行程序，就不会有太大变化。由于我们使用了均匀的网格细化，我们得到的元素数量是八倍，每个周期的自由度大约是八倍。</p>
<div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 125</div><div class="line">Total setup time               (wall) 0.00231099s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.000692s/0.000922918s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 729</div><div class="line">Total setup time               (wall) 0.00289083s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.001534s/0.0024128s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0143182s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.010785s/0.0107841s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.087064s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.063522s/0.06545s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 0.596306s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.427757s/0.431765s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 4.96491s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 3.53126s/3.56142s</div></div><!-- fragment --><p>既然如此简单，我们看看如果我们增加多项式的度数会发生什么。当在三维中选择度数为4，即在 \(\mathcal Q_4\) 元素上，通过改变程序顶部的一行<code>const unsigned int degree_finite_element=4;</code>，我们得到以下程序输出。</p>
<div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 729</div><div class="line">Total setup time               (wall) 0.00633097s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.002829s/0.00379395s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0174279s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.012255s/0.012254s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.082655s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.052362s/0.0523629s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 0.507943s</div><div class="line">Time solve (6 iterations)  (CPU/wall) 0.341811s/0.345788s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 3.46251s</div><div class="line">Time solve (7 iterations)  (CPU/wall) 3.29638s/3.3265s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 5</div><div class="line">Number of degrees of freedom: 16974593</div><div class="line">Total setup time               (wall) 27.8989s</div><div class="line">Time solve (7 iterations)  (CPU/wall) 26.3705s/27.1077s</div></div><!-- fragment --><p>由于一定网格上的 \(\mathcal Q_4\) 元素对应于一半网格大小的 \(\mathcal Q_2\) 元素，我们可以比较第四周期使用四度多项式和第五周期使用二次多项式的运行时间，两者都是210万自由度。令人惊讶的效果是，尽管多用了一次线性迭代， \(\mathcal Q_4\) 元素的求解器实际上比四次方的情况略快。高阶多项式的速度与低阶多项式类似，甚至比低阶多项式更快，这是通过和分解进行无矩阵算子评估的主要优势之一，见<a href="http://dx.doi.org/10.1016/j.compfluid.2012.04.012">matrix-free paper</a>。这与基于矩阵的方法有根本的不同，后者随着多项式度数的增加和耦合的密集，每个未知数的成本会越来越高。</p>
<p>此外，对于更高的订单，设置也变得更便宜，这是因为需要设置的元素更少。</p>
<p>最后，让我们看一下度数为8的时间，这相当于低阶方法的另一轮网格细化。</p>
<div class="fragment"><div class="line">Vectorization over 2 doubles = 128 bits (SSE2)</div><div class="line">Cycle 0</div><div class="line">Number of degrees of freedom: 4913</div><div class="line">Total setup time               (wall) 0.0842004s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.019296s/0.0192959s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of degrees of freedom: 35937</div><div class="line">Total setup time               (wall) 0.327048s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.07517s/0.075999s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of degrees of freedom: 274625</div><div class="line">Total setup time               (wall) 2.12335s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 0.448739s/0.453698s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of degrees of freedom: 2146689</div><div class="line">Total setup time               (wall) 16.1743s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 3.95003s/3.97717s</div><div class="line"></div><div class="line"></div><div class="line">Cycle 4</div><div class="line">Number of degrees of freedom: 16974593</div><div class="line">Total setup time               (wall) 130.8s</div><div class="line">Time solve (8 iterations)  (CPU/wall) 31.0316s/31.767s</div></div><!-- fragment --><p>在这里，初始化似乎比以前慢得多，这主要是由于矩阵对角线的计算，它实际上是在每个单元格上计算一个729 x 729的矩阵，扔掉除对角线以外的所有东西。然而，解算时间再次非常接近四次方的情况，这表明理论上预期的随着多项式程度的增加而出现的线性增长几乎完全被更好的计算特性和高阶方法在几个单元上的自由度份额较小而增加了评估的复杂性所抵消。</p>
<p><a class="anchor" id="Comparisonwithasparsematrix"></a></p><h3>Comparison with a sparse matrix</h3>
<p>为了了解无矩阵实现的能力，我们通过测量问题初始化的计算时间（分配DoF、设置和装配矩阵、设置多网格结构）以及无矩阵变体和基于稀疏矩阵的变体的实际求解时间，将上面的3D例子与基于稀疏矩阵的变体的性能进行比较。如上图所示，我们将预处理程序建立在浮点数上，将实际的矩阵和向量建立在双数上。测试在英特尔酷睿i7-5500U笔记本处理器（两个核心，支持<a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a>，即用一条CPU指令就可以完成对双数的四次操作，这在FEEvaluation中被大量使用）、优化模式和两个MPI行列上运行。</p>
<table align="center" class="doxtable">
<tr>
<th>&#160; </th><th colspan="2">Sparse matrix </th><th colspan="2">Matrix-free implementation  </th></tr>
<tr>
<th>n_dofs </th><th>Setup + assemble </th><th>&#160;Solve&#160; </th><th>Setup + assemble </th><th>&#160;Solve&#160;  </th></tr>
<tr>
<td align="right">125 </td><td align="center">0.0042s </td><td align="center">0.0012s </td><td align="center">0.0022s </td><td align="center">0.00095s  </td></tr>
<tr>
<td align="right">729 </td><td align="center">0.012s </td><td align="center">0.0040s </td><td align="center">0.0027s </td><td align="center">0.0021s  </td></tr>
<tr>
<td align="right">4,913 </td><td align="center">0.082s </td><td align="center">0.012s </td><td align="center">0.011s </td><td align="center">0.0057s  </td></tr>
<tr>
<td align="right">35,937 </td><td align="center">0.73s </td><td align="center">0.13s </td><td align="center">0.048s </td><td align="center">0.040s  </td></tr>
<tr>
<td align="right">274,625 </td><td align="center">5.43s </td><td align="center">1.01s </td><td align="center">0.33s </td><td align="center">0.25s  </td></tr>
<tr>
<td align="right">2,146,689 </td><td align="center">43.8s </td><td align="center">8.24s </td><td align="center">2.42s </td><td align="center">2.06s  </td></tr>
</table>
<p>该表清楚地显示，无矩阵实现的求解速度是两倍以上，而在初始化成本方面，则是六倍以上。随着问题大小被放大8倍，我们注意到，时间通常也会上升8倍（因为求解器的迭代次数恒定为6次）。主要的偏差是在5k到36k自由度的稀疏矩阵中，时间增加了12倍。这是处理器中的（L3）缓存不能再容纳矩阵-向量乘积所需的所有数据的阈值，所有的矩阵元素必须从主内存中获取。</p>
<p>当然，这种情况不一定适用于所有情况，因为在有些问题上，对矩阵项的了解可以使解算器的效果好得多（如当系数的变化比上面的例子更强烈时）。此外，这也取决于计算机系统。目前的系统具有良好的内存性能，因此稀疏矩阵的性能相当好。尽管如此，对于本例中使用的<em>Q</em><sub>2</sub>元素，无矩阵的实现已经给出了一个不错的速度。这一点对于时间依赖性或非线性问题尤其明显，在这些问题中，稀疏矩阵需要一次又一次地被重新组合，有了这个类，这就变得容易多了。当然，由于产品的复杂性更好，当元素的阶数增加时，该方法获得了越来越大的优势（无矩阵实现每个自由度的成本为4<em>d</em><sup>2</sup><em>p</em>，而稀疏矩阵为2<em>p<sup>d</sup></em>，所以无论如何它在4阶以上的3d中会获胜）。</p>
<p><a class="anchor" id="ResultsforlargescaleparallelcomputationsonSuperMUC"></a></p><h3>Results for large-scale parallel computations on SuperMUC</h3>
<p>正如介绍和代码中的注释所解释的，这个程序可以用MPI并行运行。事实证明，几何多栅方案工作得非常好，可以扩展到非常大的机器。据作者所知，这里显示的几何多网格结果是截至2016年底用deal.II完成的最大计算，在<a href="https://www.lrz.de/services/compute/supermuc/systemdescription/">complete SuperMUC Phase 1</a>的多达147456个核心上运行。超过1000个核心的可扩展性的要素是，没有任何依赖于全局问题大小的数据结构被完整地保存在一个处理器上，并且通信不是太频繁，以避免遇到网络的延迟问题。 对于用迭代求解器求解的PDEs，通信延迟往往是限制因素，而不是网络的吞吐量。以SuperMUC系统为例，两个处理器之间的点对点延迟在1e-6到1e-5秒之间，取决于MPI网络中的距离。这一类的矩阵-向量产品与 <code>LaplaceOperator</code> 涉及几个点对点通信步骤，与每个核心上的计算交错进行。由此产生的矩阵-向量乘积的延迟约为1e-4秒。全局通信，例如一个 <code>MPI_Allreduce</code> 操作，在MPI网络中的所有等级上累积每个等级的单一数字之和，其延迟为1e-4秒。这个程序中使用的多网格V型循环也是全局通信的一种形式。想一想发生在单个处理器上的粗略网格求解。在开始之前，它积累了来自所有处理器的贡献。当完成后，粗网格解决方案被转移到更细的层次，在那里越来越多的处理器帮助平滑，直到细网格。从本质上讲，这是在网络中的处理器上的一个树状模式，并由网格控制。相对于 <code>MPI_Allreduce</code> 的操作，在还原中的树被优化为MPI网络中的实际链接，多网格V-cycle是根据网格的划分来做的。因此，我们不能期望有同样的优化效果。此外，多网格循环并不是简单地在细化树上走来走去，而是在做平滑的时候在每一层上进行通信。换句话说，多网格中的全局通信更具挑战性，与提供较少优化机会的网格有关。测得的V型周期的延迟在6e-3和2e-2秒之间，即与60至200次MPI_Allreduce操作相同。</p>
<p>下图显示了在 \(\mathcal Q_3\) 元素上进行的缩放实验。沿着这条线，问题的大小保持不变，因为核的数量在增加。当内核数量增加一倍时，人们期望计算时间减少一半，灰色虚线表示。结果显示，在达到0.1秒左右的绝对时间之前，该实现显示了几乎理想的行为。解算器的公差已经被设定为解算器执行五次迭代。这种绘制数据的方式是该算法的<b>strong scaling</b>。当我们走到非常大的核心数时，曲线会提前变平，这是因为SuperMUC中的通信网络，距离较远的处理器之间的通信会稍慢一些。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_strong.png"/>
</div>
<p>此外，该图还包含了<b>weak scaling</b>的结果，列出了当处理器内核和元素的数量都以相同的速度增加时，算法的表现。在这种情况下，我们期望计算时间保持不变。在算法上，CG的迭代次数恒定在5次，所以我们从这一点来看是好的。图中的线条是这样排列的：每个数据系列中的左上角点代表每个处理器的相同大小，即131,072个元素（或每个核心大约350万个自由度）。表示理想的强缩放的灰色线条相隔8个相同的系数。结果再次表明，缩放比例几乎是理想的。当从288个核到147456个核时，并行效率在75左右，每个核的局部问题大小为75万自由度，在288个核上需要1.0秒，在2304个核上需要1.03秒，在18000个核上需要1.19秒，在147000个核上需要1.35秒。这些算法对处理器的利用率也达到了很高。在147k核心上最大的计算在SuperMUC上达到约1.7 PFLOPs/s，其中算术峰值为3.2 PFLOPs/s。对于一个迭代式PDE求解器来说，这是一个非常高的数字，而且通常只有密集线性代数才会达到显著的数字。稀疏线性代数被限制在这个数值的十分之一。</p>
<p>正如介绍中提到的，无矩阵方法减少了数据结构的内存消耗。除了由于更少的内存传输而带来的更高的性能外，该算法还允许非常大的问题被装入内存。下图显示了随着我们增加问题的大小，直到计算耗尽内存的上限时的计算时间。我们对1k核、8k核和65k核进行了计算，发现问题的大小几乎可以在两个数量级上进行理想的扩展。这张图中显示的最大的计算涉及2920亿（ \(2.92 \cdot 10^{11}\) ）个自由度。在147k核心的DG计算中，上述算法也被运行，涉及多达5490亿（2^39）个自由度。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_size.png"/>
</div>
<p>最后，我们注意到，在对上述大规模系统进行测试的同时，deal.II中的多网格算法也得到了改进。原始版本包含了基于MGSmootherPrecondition的次优代码，其中一些MPI_Allreduce命令（检查所有向量条目是否为零）在每一级的平滑操作上都要进行，这在65k核以上的系统中才变得明显。然而，下面的图片显示，改进已经在较小的规模上得到了回报，这里显示的是对 \(\mathcal Q_5\) 元素在多达14336个内核上的计算。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-37.scaling_oldnew.png"/>
</div>
<p><a class="anchor" id="Adaptivity"></a></p><h3>Adaptivity</h3>
<p>正如代码中所解释的，这里介绍的算法是为运行在自适应细化的网格上准备的。如果只有部分网格被细化，多网格循环将以局部平滑的方式运行，并通过 <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> 类对细化程度不同的界面施加迪里切条件进行平滑。由于自由度在层次上的分布方式，将层次单元的所有者与第一个下级活动单元的所有者联系起来，在MPI中不同的处理器之间可能存在不平衡，这限制了可扩展性，约为2到5倍。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Kellyerrorestimator"></a></p><h4>Kelly error estimator </h4>
<p>如上所述，代码已经准备好用于局部自适应h-精简。对于泊松方程，可以采用KellyErrorEstimator类中实现的Kelly误差指标。然而，我们需要小心处理平行向量的鬼魂指数。为了评估误差指标中的跳跃项，每个MPI进程需要知道本地相关的DoF。然而 <a class="el" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">MatrixFree::initialize_dof_vector()</a> 函数只用一些本地相关的DoF来初始化向量。在向量中提供的鬼魂指数是一个严格的集合，只有那些在单元积分（包括约束解决）中被触及的指数。这种选择有性能上的原因，因为与矩阵-向量乘积相比，发送所有本地相关的自由度会过于昂贵。因此，原样的解决方案向量不适合KellyErrorEstimator类。诀窍是改变分区的幽灵部分，例如使用一个临时向量和 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab792ddb04b95a220e489f2d7f9eee990">LinearAlgebra::distributed::Vector::copy_locally_owned_data_from()</a> ，如下所示。</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"><a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> copy_vec(solution);</div><div class="line">solution.reinit(dof_handler.locally_owned_dofs(),</div><div class="line">                locally_relevant_dofs,</div><div class="line">                triangulation.<a class="code" href="classTriangulation.html#a0a2bf98c3056379a2b132ad62266f780">get_communicator</a>());</div><div class="line">solution.copy_locally_owned_data_from(copy_vec);</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">solution.update_ghost_values();</div></div><!-- fragment --><p><a class="anchor" id="Sharedmemoryparallelization"></a></p><h4>Shared-memory parallelization</h4>
<p>这个程序只用MPI来并行化。作为一种选择，MatrixFree循环也可以在混合模式下发出，例如通过在集群的节点上使用MPI并行化，在一个节点的共享内存区域内通过Intel TBB使用线程。要使用这一点，就需要在主函数的MPI_InitFinalize数据结构中同时设置线程数，并将 <a class="el" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">MatrixFree::AdditionalData::tasks_parallel_scheme</a> 设置为partition_color，以便真正并行地进行循环。这个用例将在步骤-48中讨论。</p>
<p><a class="anchor" id="InhomogeneousDirichletboundaryconditions"></a></p><h4>Inhomogeneous Dirichlet boundary conditions </h4>
<p>所提出的程序假定了同质的Dirichlet边界条件。当进入非均质条件时，情况就有点复杂了。为了理解如何实现这样的设置，让我们首先回顾一下这些条件是如何在数学公式中出现的，以及它们是如何在基于矩阵的变体中实现的。从本质上讲，非均质Dirichlet条件将解决方案中的一些节点值设定为给定值，而不是通过变分原理来确定它们。</p>
<p class="formulaDsp">
\begin{eqnarray*} u_h(\mathbf{x}) = \sum_{i\in \mathcal N} \varphi_i(\mathbf{x}) u_i = \sum_{i\in \mathcal N \setminus \mathcal N_D} \varphi_i(\mathbf{x}) u_i + \sum_{i\in \mathcal N_D} \varphi_i(\mathbf{x}) g_i, \end{eqnarray*}
</p>
<p>其中 \(u_i\) 表示解决方案的节点值， \(\mathcal N\) 表示所有节点的集合。集合 \(\mathcal N_D\subset \mathcal N\) 是受迪里希特边界条件约束的节点子集，其中解被强制等于 \(u_i = g_i = g(\mathbf{x}_i)\) 作为迪里希特约束的节点点上的边界值插值 \(i\in \mathcal N_D\) 。然后我们把这个解的表示插入到弱的形式中，例如上面所示的拉普拉斯，并把已知量移到右边。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \varphi_i, \nabla u_h)_\Omega &amp;=&amp; (\varphi_i, f)_\Omega \quad \Rightarrow \\ \sum_{j\in \mathcal N \setminus \mathcal N_D}(\nabla \varphi_i,\nabla \varphi_j)_\Omega \, u_j &amp;=&amp; (\varphi_i, f)_\Omega -\sum_{j\in \mathcal N_D} (\nabla \varphi_i,\nabla\varphi_j)_\Omega\, g_j. \end{eqnarray*}
</p>
<p>在这个公式中，对所有的基函数 \(\varphi_i\) 与 \(i\in N \setminus \mathcal N_D\) 进行测试，这些基函数与迪里希特条件约束的节点没有关系。</p>
<p>在deal.II的实现中，右手边的积分 \((\nabla \varphi_i,\nabla \varphi_j)_\Omega\) 已经包含在我们在每个单元格上组装的局部矩阵贡献中。当使用 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 时，正如在步骤6和步骤7的教程程序中首次描述的那样，我们可以通过将本地矩阵的列<em>j</em>和行<em>i</em>相乘来说明不均匀约束的贡献<em>j</em> 的局部矩阵根据积分 \((\varphi_i, \varphi_j)_\Omega\) 乘以不均匀性，然后从全局右侧向量中的位置<em>i</em>中减去所得，也见 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块。实质上，我们使用一些从方程左侧被消除的积分来最终确定右侧的贡献。当首先将所有条目写进左侧矩阵，然后通过 <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a>. 消除矩阵的行和列时，也会涉及类似的数学。</p>
<p>原则上，属于受限自由度的成分可以从线性系统中剔除，因为它们不携带任何信息。实际上，在deal.II中，我们总是保持线性系统的大小不变，以避免处理两种不同的编号系统，并避免对两种不同的索引集产生混淆。为了确保在不向受限行添加任何东西时，线性系统不会变得奇异，我们再向矩阵对角线添加假条目，否则与真实条目无关。</p>
<p>在无矩阵方法中，我们需要采取不同的方法，因为 <code>LaplaceOperator类代表了<b>homogeneous</b>算子的矩阵-向量乘积（最后一个公式的左手边）。</code> 传递给 <a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">MatrixFree::reinit()</a> 的AffineConstraints对象是否包含不均匀约束并不重要，只要它代表一个<b>linear</b>算子， <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> 调用将只解决约束的同质部分。</p>
<p>在我们的无矩阵代码中，非均质条件的贡献最终会在右侧计算中与矩阵算子完全脱钩，并由上述不同的函数处理。因此，我们需要明确地生成进入右手边的数据，而不是使用矩阵装配的副产品。由于我们已经知道如何在一个向量上应用算子，我们可以尝试对一个向量使用这些设施，我们只设置Dirichlet值。</p>
<div class="fragment"><div class="line"><span class="comment">// interpolate boundary values on vector solution</span></div><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(mapping,</div><div class="line">                                         dof_handler,</div><div class="line">                                         0,</div><div class="line">                                         BoundaryValueFunction&lt;dim&gt;(),</div><div class="line">                                         boundary_values);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::global_dof_index, double&gt; &amp;pair : boundary_values)</div><div class="line">  <span class="keywordflow">if</span> (solution.locally_owned_elements().is_element(pair.first))</div><div class="line">    solution(pair.first) = pair.second;</div></div><!-- fragment --><p>或者说，如果我们已经将不均匀约束填充到AffineConstraints对象中。</p>
<div class="fragment"><div class="line">solution = 0;</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div></div><!-- fragment --><p>然后我们可以将向量 <code>solution</code> 传递给 <code>LaplaceOperator::vmult_add()</code> 函数，并将新的贡献添加到 <code>system_rhs向量中，在</code> <code>LaplaceProblem::assemble_rhs()</code> 函数中被填充。然而，这个想法并不奏效，因为vmult()函数中使用的 <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">FEEvaluation::read_dof_values()</a> 调用假定所有约束条件的值都是同质的（否则运算符就不是线性运算符，而是仿射运算符）。为了同时检索不均匀性的值，我们可以选择以下两种策略中的一种。</p>
<p><a class="anchor" id="UseFEEvaluationread_dof_values_plaintoavoidresolvingconstraints"></a></p><h5>Use <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> to avoid resolving constraints </h5>
<p>FEEvaluation类有一个设施，正是为了解决这个要求。对于非均质的Dirichlet值，我们确实希望在从向量 <code>solution</code>. 中读取数据时跳过隐含的均质（Dirichlet）约束。例如，我们可以扩展 <code>LaplaceProblem::assemble_rhs()</code> 函数来处理非均质的Dirichlet值，如下所示，假设Dirichlet值已经被插值到对象 <code>constraints:</code> 中</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  solution = 0;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  solution.update_ghost_values();</div><div class="line">  system_rhs = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;double&gt;</a>&gt; &amp;coefficient = system_matrix.get_coefficient();</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(*system_matrix.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values_plain(solution);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_gradient(-coefficient(cell, q) * phi.get_gradient(q), q);</div><div class="line">          phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">        }</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>|<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>在这段代码中，我们用忽略所有约束的 <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> 代替了用于暂定解向量的 <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">FEEvaluation::read_dof_values()</a> 函数。由于这种设置，我们必须确保其他约束条件，例如通过悬挂节点，已经正确地分布到输入向量中，因为它们没有像 <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a>. 那样被解决。 在循环内部，我们然后评估拉普拉斯，并用 <code>LaplaceOperator</code> 类中的 <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">FEEvaluation::submit_gradient()</a> 重复二次导数调用，但符号调换，因为我们想根据上述公式减去右侧向量的迪里希条件的贡献。当我们调用 <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">FEEvaluation::integrate()</a> 时，我们将关于值槽和第一导数槽的两个参数设置为真，以说明在正交点的循环中加入的两个项。一旦右手边集合完毕，我们就继续求解同质问题的线性系统，比如说涉及到一个变量 <code>solution_update</code>. 在求解之后，我们可以将 <code>solution_update</code> 加入到包含最终（非同质）解决方案的 <code>solution</code> 向量中。</p>
<p>请注意，拉普拉斯的负号与我们需要用来建立右手边的强制力的正号是一个更普遍的概念。我们所实施的只不过是牛顿的非线性方程方法，但应用于线性系统。我们在迪里切特边界条件方面使用了对变量 <code>solution</code> 的初始猜测，并计算了残差 \(r = f - Au_0\) 。然后线性系统被解为 \(\Delta u = A^{-1} (f-Au)\) ，我们最后计算出 \(u = u_0 + \Delta u\) 。对于一个线性系统，我们显然在一次迭代后就能达到精确解。如果我们想将代码扩展到非线性问题，我们会将 <code>assemble_rhs()</code> 函数重新命名为一个更具描述性的名字，如 <code>assemble_residual()，计算残差的（弱）形式，而</code> <code>LaplaceOperator::apply_add()</code> 函数将得到残差相对于解变量的线性化。</p>
<p><a class="anchor" id="UseLaplaceOperatorwithasecondAffineConstraintsobjectwithoutDirichletconditions"></a></p><h5>Use LaplaceOperator with a second <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object without Dirichlet conditions </h5>
<p>获得重新使用 <code>LaplaceOperator::apply_add()</code> 函数的第二个替代方法是添加第二个LaplaceOperator，跳过Dirichlet约束。为了做到这一点，我们初始化第二个MatrixFree对象，它没有任何边界值约束。这个 <code>matrix_free</code> 对象然后被传递给一个 <code>LaplaceOperator</code> 类实例 <code>inhomogeneous_operator，它只用于创建右手边。</code> </p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  system_rhs = 0;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> no_constraints;</div><div class="line">  no_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  LaplaceOperator&lt;dim, degree_finite_element, double&gt; inhomogeneous_operator;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">  additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">    (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; matrix_free(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">  matrix_free-&gt;reinit(dof_handler,</div><div class="line">                      no_constraints,</div><div class="line">                      <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                      additional_data);</div><div class="line">  inhomogeneous_operator.initialize(matrix_free);</div><div class="line"></div><div class="line"></div><div class="line">  solution = 0.0;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  inhomogeneous_operator.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">  inhomogeneous_operator.vmult(system_rhs, solution);</div><div class="line">  system_rhs *= -1.0;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">    *inhomogeneous_operator.get_matrix_free());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">       cell &lt; inhomogeneous_operator.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">       ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">      phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">      phi.distribute_local_to_global(system_rhs);</div><div class="line">    }</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>这种技术的更复杂的实现可以重新使用原始的MatrixFree对象。这可以通过用多个块初始化MatrixFree对象来实现，其中每个块对应于不同的AffineConstraints对象。这样做需要对LaplaceOperator类进行大量的修改，但是库中的 <a class="el" href="classMatrixFreeOperators_1_1LaplaceOperator.html">MatrixFreeOperators::LaplaceOperator</a> 类可以做到这一点。关于如何设置块的更多信息，请参见 <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> 中关于块的讨论。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Katharina Kormann, Martin Kronbichler, Uppsala University,</span></div><div class="line"><span class="comment"> * 2009-2012, updated to MPI version with parallel vectors in 2016</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step37</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree_finite_element = 2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dimension             = 3;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">    number value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        component = 0) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</div><div class="line">  number Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim, number&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1. / (0.05 + 2. * p.<a class="code" href="classPoint.html#a859ea7f3bf3e64be2e0f5ed1bfcc8550">square</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Coefficient&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> value&lt;double&gt;(p, component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceOperator</div><div class="line">    : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">        Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">    LaplaceOperator();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_coefficient(<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">                <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">                <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_compute_diagonal(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;              data,</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp; dst,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;                         dummy,</div><div class="line">      <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; coefficient;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  LaplaceOperator&lt;dim, fe_degree, number&gt;::LaplaceOperator()</div><div class="line">    : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                                <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">Vector</a>&lt;number&gt;&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">  {</div><div class="line">    coefficient.reinit(0, 0);</div><div class="line">    <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">      clear();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::evaluate_coefficient(</div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line">    coefficient.reinit(n_cells, phi.n_q_points);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          coefficient(cell, q) =</div><div class="line">            coefficient_function.value(phi.quadrature_point(q));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line">        phi.read_dof_values(src);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q), q);</div><div class="line">        phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">        phi.distribute_local_to_global(dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">LaplaceOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">  {</div><div class="line">    this-&gt;inverse_diagonal_entries.reset(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">      this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dummy = 0;</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;LaplaceOperator::local_compute_diagonal,</div><div class="line">                          <span class="keyword">this</span>,</div><div class="line">                          inverse_diagonal,</div><div class="line">                          dummy);</div><div class="line"></div><div class="line">    this-&gt;set_constrained_entries_to_one(inverse_diagonal);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size</a>(); ++i)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) &gt; 0.,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No diagonal entry in a positive definite operator &quot;</span></div><div class="line">                          <span class="stringliteral">&quot;should be zero&quot;</span>));</div><div class="line">        inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i) =</div><div class="line">          1. / inverse_diagonal.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a>(i);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;             data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;dst,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <a class="code" href="classAlignedVector.html">AlignedVector&lt;VectorizedArray&lt;number&gt;</a>&gt; <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>(phi.dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(0), data.<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(coefficient.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; phi.dofs_per_cell; ++j)</div><div class="line">              phi.submit_dof_value(<a class="code" href="classVectorizedArray.html">VectorizedArray&lt;number&gt;</a>(), j);</div><div class="line">            phi.submit_dof_value(make_vectorized_array&lt;number&gt;(1.), i);</div><div class="line"></div><div class="line">            phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">              phi.submit_gradient(coefficient(cell, q) * phi.get_gradient(q),</div><div class="line">                                  q);</div><div class="line">            phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">            <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i] = phi.get_dof_value(i);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; phi.dofs_per_cell; ++i)</div><div class="line">          phi.submit_dof_value(<a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a9f7392eb627119096334bd291f1d1e86">diagonal</a>[i], i);</div><div class="line">        phi.distribute_local_to_global(dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_P4EST</span></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType =</div><div class="line">      LaplaceOperator&lt;dim, degree_finite_element, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = LaplaceOperator&lt;dim, degree_finite_element, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a> mg_matrices;</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>             setup_time;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> time_details;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem()</div><div class="line">    :</div><div class="line">#ifdef DEAL_II_WITH_P4EST</div><div class="line">    triangulation(</div><div class="line">      MPI_COMM_WORLD,</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">      <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    ,</div><div class="line">#else</div><div class="line">    triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    ,</div><div class="line">#endif</div><div class="line">    fe(degree_finite_element)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , setup_time(0.)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    ,</div><div class="line">    time_details(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">                 false &amp;&amp; <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    setup_time = 0;</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    mg_matrices.clear_elements();</div><div class="line"></div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line">    dof_handler.distribute_mg_dofs();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Distribute DoFs &amp; B.C.     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::none</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      std::shared_ptr&lt;MatrixFree&lt;dim, double&gt;&gt; system_mf_storage(</div><div class="line">        <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a>());</div><div class="line">      system_mf_storage-&gt;reinit(mapping,</div><div class="line">                                dof_handler,</div><div class="line">                                constraints,</div><div class="line">                                <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                additional_data);</div><div class="line">      system_matrix.initialize(system_mf_storage);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(solution);</div><div class="line">    system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free system   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">    mg_matrices.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">    dirichlet_boundary.insert(0);</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      relevant_dofs);</div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">        <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">          <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::none</a>;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">          (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">        std::shared_ptr&lt;MatrixFree&lt;dim, float&gt;&gt; mg_mf_storage_level(</div><div class="line">          <span class="keyword">new</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;</a>());</div><div class="line">        mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    level_constraints,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                                    additional_data);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                      mg_constrained_dofs,</div><div class="line">                                      level);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_coefficient(Coefficient&lt;dim&gt;());</div><div class="line">      }</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Setup matrix-free levels   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line"></div><div class="line">    system_rhs = 0;</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, degree_finite_element&gt;</a> phi(</div><div class="line">      *system_matrix.get_matrix_free());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0;</div><div class="line">         cell &lt; system_matrix.get_matrix_free()-&gt;n_cell_batches();</div><div class="line">         ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          phi.submit_value(make_vectorized_array&lt;double&gt;(1.0), q);</div><div class="line">        phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">        phi.distribute_local_to_global(system_rhs);</div><div class="line">      }</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Assemble right hand side   (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimer.html">Timer</a>                            time;</div><div class="line">    <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a> mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG build transfer time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">    time.<a class="code" href="classTimer.html#aa3f7871196bb56202af2bc982bfbfff6">restart</a>();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                            LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                           LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                         mg_smoother;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">    smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">          {</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 5;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            smoother_data[0].smoothing_range = 1e-3;</div><div class="line">            smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">          }</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">      }</div><div class="line">    mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line">    <a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">      mg_coarse;</div><div class="line">    mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">      mg_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">      mg_interface_matrices;</div><div class="line">    mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      mg_interface_matrices[level].initialize(mg_matrices[level]);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">      mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">                   LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">                   <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1e-12 * system_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line">    setup_time += time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>();</div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;MG build smoother time     (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Total setup time               (wall) &quot;</span> &lt;&lt; setup_time &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line"></div><div class="line">    time.<a class="code" href="classTimer.html#a9020542d73357a4eef512eefaf57524b">reset</a>();</div><div class="line">    time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a>(solution);</div><div class="line">    cg.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Time solve (&quot;</span> &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; iterations)&quot;</span></div><div class="line">          &lt;&lt; (solver_control.last_step() &lt; 10 ? <span class="stringliteral">&quot;  &quot;</span> : <span class="stringliteral">&quot; &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;(CPU/wall) &quot;</span></div><div class="line">          &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1000000)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">    flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">    time_details &lt;&lt; <span class="stringliteral">&quot;Time write output          (CPU/wall) &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>()</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;s/&quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot;s\n&quot;</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(<a class="code" href="classdouble.html">double</a>) * n_vect_doubles;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Vectorization over &quot;</span> &lt;&lt; n_vect_doubles</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; doubles = &quot;</span> &lt;&lt; n_vect_bits &lt;&lt; <span class="stringliteral">&quot; bits (&quot;</span></div><div class="line">            &lt;&lt; <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">          }</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">        setup_system();</div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      };</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step37</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step37;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;dimension&gt; laplace_problem;</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
