<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/CodingConventions.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Coding conventions used throughout deal.II</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Coding conventions used throughout deal.II </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>在整个deal.II中，我们努力保持我们的编程风格和我们提供的界面种类尽可能的一致。为此，我们采用了一套编码惯例，并尽可能地加以遵守。它们有两个部分：风格问题，以及我们称之为 "防御性编程
"的东西，后者是试图让我们的代码帮助我们发现错误。 在阅读它们的时候，重要的是要记住，风格并不是神赐予的，也不是比任何其他的惯例都要好；它们的目的只是为了使deal.II尽可能的统一。统一性减少了我们产生的错误的数量，因为我们可以，例如，总是假设输入参数在函数调用的输出参数之前。它们也简化了代码的阅读，因为有些东西通过查看代码的写法就已经很清楚了，而不需要去查找某些东西的确切定义。 </p><h3>Notes on deal.II indentation</h3>
<p>deal.II使用 <code>clang-format</code> 6.0来规范缩进。Astyle文件提供在 </p><div class="fragment"><div class="line">${SOURCE_DIR}/.clang-format</div></div><!-- fragment --> <p>在提交之前，你应该运行 </p><div class="fragment"><div class="line">clang-format</div><div class="line"></div><div class="line">-i &lt;file&gt;</div></div><!-- fragment --><p> 在你的每一个文件上。这将确保缩进符合本页面中列出的风格指南。 这是很麻烦的。因此，更容易的是，你可以直接运行 </p><div class="fragment"><div class="line">make indent</div></div><!-- fragment --><p> 在你设置的编译库的任何目录中，对所有最近被修改的源文件进行缩进。如果你想确保所有提交的缩进都是正确的，你可能想设置一个提交后钩子。一种方法是将 <code>${SOURCE_DIR}/contrib/git-hooks/pre-commit</code> 复制到 <code>${SOURCE_DIR}/.git/hooks/pre-commit</code> ，并确保其可执行。 如果你工作的系统安装了不止一个版本的 <code>clang-format</code> （或者它不在路径中），你应该将上述 <code>make indent</code> 命令改为 </p><div class="fragment"><div class="line">make DEAL_II_CLANG_FORMAT=/path/to/clang-6.0/clang-format indent</div></div><!-- fragment --><p> 以指向正确的可执行文件。 </p>
<h3>Style issues</h3>
<ol>
<li>
返回某物数量（单元数、自由度等）的函数应以 <code>n_*</code> 开始。例如。 <a class="el" href="classSparsityPatternBase.html#a0707927053081fd6c46dac186e63c543">SparsityPatternBase::n_nonzero_elements()</a>. </li>
<li>
设置位或标志的函数应以 <code>set_*</code> 开始；清除位或标志的函数应以 <code>clear_*</code> 命名。 例子。 <a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">CellAccessor::set_refine_flag()</a>. </li>
<li>
应使用传统的逻辑运算符，而不是它们的英文等价物（即，使用 <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> 而不是 <code>and</code>, <code>or</code>, and <code>not</code> ）。 </li>
<li>
在实现文件中，在每个函数之后，希望有三个空行，以使可读性更好。一个空行出现在函数中，用于对代码块进行分组，因为两个空行不足以明显地区分出代码属于两个不同的函数。  </li>
<li>
每当一个整数变量只能承担非负值，它就被标记为无符号。这同样适用于只能返回正值或零值的函数。例子。 <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a>. </li>
<li>
每当一个函数的参数不会被改变，它就应该被标记为const，即使是通过值传递。一般来说，我们将输入参数标记为const。这有助于作为一个额外的文档工具来澄清参数的意图（输入、输出或两者），并让编译器在这样的参数被改变时发出警告，这往往是不由自主的或糟糕的风格。  </li>
<li>
每当一个函数不改变嵌入类/对象的任何成员变量时，它就应该被标记为const。  </li>
<li>
函数和变量名称不能只由一个或两个字母组成，除非该变量是一个纯粹的计数索引。  </li>
<li>
类型别名（ <code>using</code> -declarations）优于 <code>typedef</code> -declarations。  </li>
<li>
使用GeometryInfo中的几何信息来获取每个单元的面数、每个单元的子数、与面3相邻的子单元的子指数等，而不是像 <code>2*dim</code> 、 <code>(1&lt;&lt;dim)</code> 和 <code>{0,3}</code> 那样直接写进代码。这减少了出错的可能性，提高了代码的可读性。  </li>
<li>
类声明的布局如下：首先是公共函数块，从构造函数开始，然后是解构函数。如果有公共成员变量，这些变量必须出现在构造函数之前。只有当公有变量是常量（特别是静态和常量）或不可避免时，才应使用公有变量。 <br />
 在公共成员之后，应列出受保护成员，最后是私有成员。顺序如上：先是变量，然后是函数。 <br />
 异常应在公共部分的末尾声明，然后再开始非公共部分。 <br />
 对于既不是 <code>static const</code> nor <code>static constexpr</code> 的成员变量，我们不使用C++11风格的类成员初始化；即，代替 <div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line"> <span class="keywordtype">int</span> a = 42;</div><div class="line"> intb = <span class="keyword">nullptr</span>;</div><div class="line">};</div></div><!-- fragment --> 写 <div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line"> Foo();</div><div class="line"></div><div class="line"> <span class="keywordtype">int</span> a;</div><div class="line"> intb;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">inline</span> Foo::Foo()</div><div class="line">: a(42)</div><div class="line">, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>(nullptr)</div><div class="line">{}</div></div><!-- fragment -->  </li>
<li>
如果一个函数有输入和输出参数，通常输入参数应在输出参数之前，除非有充分的理由改变这个顺序。最常见的原因是带有默认值的输入参数的尾部。 </li>
<li>
异常用于内部参数检查和通过Assert宏进行一致性检查。像C++语言那样的异常处理（ <code>try/throw/catch</code> ，并使用AssertThrow宏）用于处理运行时的错误（如I/O故障），在任何情况下都必须开启，而不仅仅是在调试模式下。  </li>
<li>
有时通过使用几个非成员函数来实现一个类是有意义的，这些非成员函数不是公共接口的一部分，而且只在当前源文件中被调用。这样的自由函数应该放在一个内部命名空间中，其结构如下。 <div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceinternal.html">internal</a></div><div class="line">{</div><div class="line"> <span class="keyword">namespace </span>ClassNameImplementation</div><div class="line"> {</div><div class="line">   <span class="comment">// free functions go here</span></div><div class="line"> }</div><div class="line">}</div></div><!-- fragment --> 其中 <code>ClassName</code> 是调用类的名称。 </li>
<li>
类、命名空间和类型一般使用大写字母来表示词的开头（例如TriaIterator）&amp;mdash；有时也称为<a href="http://en.wikipedia.org/wiki/Camel_case"><em>camel case</em><em>camel case</em></a>&amp;mdash；而函数和变量使用小写字母和下划线来分隔单词。 唯一的例外是Triangulation和DoFHandler中的迭代器别名（命名为cell_iterator、active_line_iterator等），以使其与标准库容器类的联系清晰。  </li>
<li>
对于有多个模板参数的类，维度通常放在数据类型指定器之前，即我们使用Point&lt;dim,number&gt;而不是Point&lt;number,dim&gt;。 </li>
<li>
在deal.II中，有几个地方我们在头文件中使用正向声明。这样做的原因是，当我们只需要将某个类型标记为某个函数的参数时，不使用头文件，希望可以提高编译速度。在deal.II中使用的惯例是，如果我们需要的只是一个类型名称，那么这个类型可以在我们需要的头文件中向前声明；如果一个函数（或成员函数）可以返回一个值，那么这个值的类型声明应该可以得到（通过包括必要的头文件）。例如， <code>deal.II/dofs/dof_handler.h</code> 包括 <code>deal.II/dofs/dof_accessor.h</code> ，这样就可以写出类似 <code>dof_handler.begin_active()-&gt;is_active()</code> 的东西，而不需要明确包括声明 <code>begin_active()</code> 所返回对象类型的头文件。 </li>
<li>
每个类都必须有至少200页的文档；-)  </li>
</ol>
<h3>Instantiation of templated functions/classes</h3>
<p>deal.II中的大多数类和函数是模板化的。这就带来了一个问题：如果有的话，这些对象是如何以及在哪里被实例化的。在整个deal.II中，我们采用了以下惯例。 </p>
<ol>
<li>
如果我们可以列举出所有可能的模板参数（例如，维度只能是1、2或3），那么一个函数模板就会进入 <code>.cc</code> 文件，我们明确地将所有可能性实例化。用户不会有任何需要看到这些函数模板，因为他们无论如何都不想为其他模板参数实例化这些函数。  </li>
<li>
<p class="startli">如果我们不能列举所有可能的模板参数（例如，vectortypes</p>
<p>因为用户可能想定义他们自己的向量种类），但至少知道一些常见的使用情况，那么该函数将被放入一个 <code>.templates.h</code> file. We #include it into the <code>.cc</code> 文件中，并为所有常见的参数实例化函数。对于几乎所有的用户来说，这样做就可以了</p>
<ul>
<li>他们只使用我们已经实例化的（向量、矩阵......）类型，对他们来说， <code>.templates.h</code> 文件不会有任何意义。这也不会减慢他们的编译速度，因为他们看到的东西都会包括 <code>.templates.h</code> 文件。但是定义了自己的（向量、矩阵......）类型的用户可以通过包括 <code>.templates.h</code> 文件，用自己的用户定义的类型实例化模板函数。 </li>
</ul>
</li>
<li>
最后，如果我们不能事先假定模板参数将采取哪些值（例如，任何从Subscriptor派生的类都可以作为参数），函数的定义将在头文件的底部提供声明。这些定义应该用<code>#ifndefDOXYGEN ...#以防止Doxygen发现它们。  </code></li>
</ol>
<p><code> 对于前两种情况，实例化指令被定义在 <code>.inst.in</code> 文件中。它们由一个叫做expand_instantiations的二进制文件处理（由 <code>cmake/scripts/expand_instantiations.cc</code> 构建），参数根据你的配置通过cmake动态定义（见构建目录中的 <code>cmake/config/template-arguments.in</code> ）。正是这些 <code>.inst</code> 文件最终被包含在相应的 <code>.cc</code> 文件中。 </code></p>
<p><code></code></p>
<p><code> </p><h3>Defensive programming</h3>
<p></code></p>
<p><code> </code></p>
<p><code> 防御性编程是我们经常使用的一个术语，当我们在谈论写代码的时候，要考虑到错误会发生。在这里，错误有两种方式：第一，我自己在写函数时可能犯错；第二，别人在调用我的函数时可能犯错。不管是哪种情况，我都希望我的代码写得(i)尽可能不出错，(ii)编译器已经可以发现一些错误，(iii)剩下的错误相对容易发现，比如说因为程序中止了。因此，防御性编程是一组使这些目标更有可能实现的策略。 </code></p>
<p><code> </code></p>
<p><code> 随着时间的推移，我们已经学会了一些这方面的技术，其中一些我们在此列出。 </p><ol>
<li>
<p class="startli"><em>Assert preconditions on parameters:</em> 人们总是用错误或无意义的参数调用函数。作为典型的例子，考虑一个微不足道的向量加法的实现。 </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector</a> &amp;</div><div class="line">operator+=(<a class="code" href="classVector.html">Vector</a>       &amp;lhs,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    lhs(i) += rhs(i);</div><div class="line">  <span class="keywordflow">return</span> lhs;</div><div class="line">}</div></div><!-- fragment --><p> 虽然正确，但如果两个向量的大小不一样，这个函数就会陷入困境。你认为用不同大小的向量来调用这个函数是愚蠢的？是的，当然是这样的。但这种情况经常发生：人们忘记重新初始化一个向量，或者它在不同的函数中被重置，等等。这种情况时有发生。所以，如果你遇到这种不幸运的情况，可能要花很长时间才能弄清楚发生了什么，因为你很可能只是读取了未初始化的内存，或者也许你正在向 <code>lhs</code> 向量实际上并不拥有的内存写入。 这两种情况都不会导致程序的立即终止，但你可能会在以后的时间里出现随机错误。如果程序只是在这里立即停止，那就容易多了。下面的实现正是这样做的。 </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector</a> &amp;</div><div class="line">operator+=(<a class="code" href="classVector.html">Vector</a>       &amp;lhs,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>() == rhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), rhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    lhs(i) += rhs(i);</div><div class="line">  <span class="keywordflow">return</span> lhs;</div><div class="line">}</div></div><!-- fragment --><p> <code>Assert</code> 宏确保条件在运行时为真，否则会打印一个包含由第二个参数编码的信息的字符串，并中止程序。这样，当你写一个新的程序恰好调用这个函数时，你会马上知道你的错误，并有机会修复它，而不需要认真调试什么。 </p>
<p>作为一般准则，每当你实现一个新的函数时，要考虑<em>preconditions</em>上的参数，即该函数对每一个参数或它们的组合期望是什么。 然后为所有这些先决条件写断言。在某些情况下，这可能是半打断言，但请记住，每个断言都是一个潜在的错误，已经通过琐碎的手段发现。 </p>
<p class="endli">最后，让我们说说断言当然是昂贵的：当你把一个程序与库的调试版本链接时，它们可能会使程序慢3或5倍。但是如果你考虑到你的<em>overall</em>开发时间，快速发现错误的能力可能远远超过你等待程序完成的时间。此外，在优化模式下，对Assert宏的调用被从程序中移除（你可能只在知道在调试模式下一切运行正常后才使用。优化后的库比调试后的库快3-5倍，但代价是更难发现错误。  </p>
</li>
<li>
<em>Assert postconditions:</em> 如果一个函数计算出一些非微不足道的东西，那么代码中可能有一个错误。为了找到这些，可以使用后置条件：就像你对输入参数的有用值有一定的了解一样，你对可能的返回值也有一定的了解。例如，一个计算向量规范的函数希望规范是正的。你可以把它写成这样。 <div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;v)</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> s = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;v.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    s += v(i) v(i);</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (s &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(s);</div><div class="line">}</div></div><!-- fragment --> 这个函数太简单了，无法真正证明这个断言的正确性，但是想象一下计算的长度，你就可以看到这个断言是如何帮助你确保（或<em>hedge</em>）自己不犯错误的。请注意，人们可以争辩说，一旦我们运行了若干次程序，发现条件从未被触发，就应该删除这个断言。但最好还是把它留在原处：它为未来（和读者）编码了你对该函数的了解；如果有人出现，用更有效的算法取代了该函数的实现，断言可以帮助确保该函数继续做它应该做的事。  </li>
<li>
<em>Assert internal states:</em> 类似地，如果你有一个复杂的算法，使用断言来确保你对正在发生的事情的心理模型与确实的事实相符。例如，假设你正在编写一个函数，以确保网格尺寸不会在本地发生太大的变化。你最终可能会得到如下的代码。 <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; ...)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (something)</div><div class="line">        { ... }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="comment">// we have a cell whose neighbor must</span></div><div class="line">          <span class="comment">// be at the boundary if we got here</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> 导致我们进入else-branch的条件可能很复杂，虽然我们认为我们到达这里的唯一可能性是邻居在边界上，这可能是真的，但在我们的实现中可能存在一个bug。也可能是我们的思维出现了错误，或者有人在同一个函数中改变了上面的代码而忘记了这里的问题，或者在库中一个完全不同的位置的改变使得这个假设站不住脚。在所有这些情况下，我们的断言的明确陈述可以确保这些问题被轻易发现。  </li>
<li>
<p class="startli"><em>Initialize variables at the point of their declaration if they live on the stack:</em> 传统的C语言要求在函数的开头声明变量，即使它们只在下面进一步使用。这就导致了我们可以想象在1d代码中出现这样的代码。 </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center;</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      cell_center = (cell-&gt;vertex(0) + cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> 问题是，如果声明和初始化之间的代码又长又复杂，你不可能在一页纸上查到一个变量的类型是什么，它的值可能是什么。事实上，甚至可能不太清楚该变量是否被用于初始化，或者它是否被意外地留在了未初始化状态。 </p>
<p>一个更好的方法是这样做的。 </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = (cell-&gt;vertex(0) + cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> 这使得变量的类型更加清晰，而且事实上它只在初始化时使用。此外，如果有人想阅读代码，看看这个变量实际上在做什么，在最内层的作用域中声明和初始化它，使这项任务更容易：我们不必在声明之外向上寻找它，也不必在当前作用域的末端向下寻找，因为这是变量死亡的地方。 </p>
<p class="endli">作为最后的说明，很明显，你只能对完全生活在堆栈中的变量做这种事情，而不需要在堆上分配内存。在deal.II中，这只适用于像 <code>int, double, char</code> 等内置类型，以及点和张量类。其他的东西都有像 <code>std::vector</code> 这样的成员变量，这需要内存分配&amp;mdash；你不想在循环内声明这些，至少在循环被频繁遍历的情况下。  </p>
</li>
<li>
<em>Make variables const:</em> 继续上面的例子，注意在大多数情况下，我们不会再改变如此初始化的变量。换句话说，如果是这种情况，我们不妨把事情写成如下。 <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = (cell-&gt;vertex(0) +</div><div class="line">                                      cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --> 通过标记变量为常量，我们可以确保我们不会意外地改变它。例如，编译器可以捕获这样的代码。 <div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_center[0] = 0)</div><div class="line">  ...</div></div><!-- fragment --> 这很可能是指 <code>==</code> 而不是一个赋值。通过将该变量标记为常量，编译器就会告诉我们这个错误。也许同样重要的是，代码的人类读者不需要再往下看，变量的值是否真的在声明和使用之间的某个地方被改变了&amp;mdash；如果它被标记为const，就不可能了。  </li>
<li>
<em>Make input arguments of functions const:</em> 对于函数参数，本质上也是如此。如果你不打算改变一个变量（这通常是输入参数的情况），那么就把它标记为常量。例如，下面这个函数应该把它的参数作为一个常数。 <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line"><a class="code" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">CellAccessor&lt;dim&gt;::child</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child_no)</div><div class="line">{</div><div class="line">  ...</div><div class="line">  <span class="keywordflow">return</span> something;</div><div class="line">}</div></div><!-- fragment --> 这里，用户调用 <code>cell-&gt;child(3)</code> ，例如。真的没有理由这个函数要改变 <code>child_no</code> 这个参数的值&amp;mdash；所以把它标记为常量：这既可以帮助代码的读者理解这是一个函数的输入参数，我们不需要在下面搜索它是否被改变过，又可以帮助编译器在我们不小心改变了这个值时帮助我们找到bug。 </li>
</ol>
<p></code></p>
<p><code>Throughout deal.II, we strive to keep our programming style and the kind of interfaces we provide as consistent as possible. To this end, we have adopted a set of coding conventions that we attempt to follow wherever possible. They have two parts: style issues, and something we call "defensive programming", the latter being an attempt to let our code help us find bugs. When reading through them, it is important to remember that styles are not god given or better than any other set of conventions; their purpose is merely to keep deal.II as uniform as possible. Uniformity reduces the number of bugs we produce because we can, for example, always assume that input arguments come before output arguments of a function call. They also simplify reading code because some things become clear already by looking at the style a piece of code is written, without having to look up the exact definition of something.</code></p>
<p><code></p><h3>Notes on deal.II indentation</h3>
<p></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code>deal.II uses <code>clang-format</code> 6.0 to normalize indentation. A style file is provided at </p><div class="fragment"><div class="line">${SOURCE_DIR}/.clang-format</div></div><!-- fragment --><p></code></p>
<p><code></code></p>
<p><code>Before a commit, you should run </p><div class="fragment"><div class="line">clang-format -i &lt;file&gt;</div></div><!-- fragment --><p> on each of your files. This will make sure indentation is conforming to the style guidelines outlined in this page.</code></p>
<p><code>This is cumbersome. Consequently, and more easily, you can just run </p><div class="fragment"><div class="line">make indent</div></div><!-- fragment --><p> in whatever directory you set up the library to be compiled in, to indent all source files that have been changed recently. If you want to make sure that the indenting is correct for all your commits, you might want to set up a pre-commit hook. One way to do so, is to copy <code>${SOURCE_DIR}/contrib/git-hooks/pre-commit</code> to <code>${SOURCE_DIR}/.git/hooks/pre-commit</code> and make sure it is executable.</code></p>
<p><code>If the system you are working on has more than one version of <code>clang-format</code> installed (or if it is not in the path) you should replace the above <code>make indent</code> command with </p><div class="fragment"><div class="line">make DEAL_II_CLANG_FORMAT=/path/to/clang-6.0/clang-format indent</div></div><!-- fragment --><p> to point to the correct executable. </code></p>
<p><code></code></p>
<p><code></p><h3>Style issues</h3>
<p></code></p>
<p><code></code></p>
<p><code></p><ol>
<li>
<p class="startli">Functions which return the number of something (number of cells, degrees of freedom, etc) should start with <code>n_*</code>. Example: <a class="el" href="classSparsityPatternBase.html#a0707927053081fd6c46dac186e63c543">SparsityPatternBase::n_nonzero_elements()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Functions which set a bit or flag should start with <code>set_*</code>; functions which clear bits or flags should be named <code>clear_*</code>. Example: <a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">CellAccessor::set_refine_flag()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Traditional logical operators should be used instead of their English equivalents (i.e., use <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> instead of <code>and</code>, <code>or</code>, and <code>not</code>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In the implementation files, after each function, three empty lines are expected to enable better readability. One empty line occurs in functions to group blocks of code, since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Whenever an integer variable can only assume nonnegative values, it is marked as unsigned. The same applies to functions that can only return positive or zero values. Example: <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Whenever an argument to a function will not be changed, it should be marked const, even if passed by value. Generally, we mark input parameters as const. This aids as an additional documentation tool to clarify the intent of a parameter (input, output, or both) and lets the compiler issue warnings if such a parameter is changed, which is often either involuntarily or poor style.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Whenever a function does not change any of the member variable of the embedding class/object, it should be marked as const.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Function and variable names may not consist of only one or two letters, unless the variable is a pure counting index.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Type aliases (<code>using</code>-declarations) are preferred to <code>typedef</code>-declarations.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Use the geometry information in <a class="el" href="structGeometryInfo.html">GeometryInfo</a> to get the number of faces per cell, the number of children per cell, the child indices of the child cells adjacent to face 3, etc, rather than writing them into the code directly as <code>2*dim</code>, <code>(1&lt;&lt;dim)</code> and <code>{0,3}</code>. This reduces the possibilities for errors and enhances readability of code.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The layout of class declarations is the following: first the block of public functions, beginning with the constructors, then the destructors. If there are public member variables, these have to occur before the constructor. Public variables shall only be used if constant (in particular if they are static and constant) or unavoidable. <br />
 After the public members, the protected and finally the private members are to be listed. The order is as above: first variables then functions. <br />
 <a class="el" href="namespaceExceptions.html">Exceptions</a> shall be declared at the end of the public section before the non-public sections start. <br />
 We do not use the C++11-style class member initialization for member variables that are neither <code>static const</code> nor <code>static constexpr</code>; i.e., instead of </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> a = 42;</div><div class="line">  <span class="keywordtype">int</span> *<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a> = <span class="keyword">nullptr</span>;</div><div class="line">};</div></div><!-- fragment --><p> write </p><div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line">  Foo();</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> a;</div><div class="line">  <span class="keywordtype">int</span> *<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">inline</span> Foo::Foo()</div><div class="line">: a(42)</div><div class="line">, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>(nullptr)</div><div class="line">{}</div></div><!-- fragment --> <p class="endli"></p>
</li>
<li>
<p class="startli">If a function has both input and output parameters, usually the input parameters shall precede the output parameters, unless there are good reasons to change this order. (The most common reason is trailing input parameters with default values.) </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="namespaceExceptions.html">Exceptions</a> are used for internal parameter checking and for consistency checks through the Assert macro. Exception handling like done by the C++ language (<code>try/throw/catch</code>, and using the AssertThrow macro) are used to handle run time errors (like I/O failures) which must be on in any case, not only in debug mode.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Sometimes it makes sense to implement a class by using several non-member functions that are not part of the public interface and are only meant to be called in the current source file. Such free functions should be put in an internal namespace structured in the following way: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceinternal.html">internal</a></div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span>ClassNameImplementation</div><div class="line">  {</div><div class="line">    <span class="comment">// free functions go here</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> where <code>ClassName</code> is the name of the calling class.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Classes, namespaces and types generally are named using uppercase letters to denote word beginnings (e.g. <a class="el" href="classTriaIterator.html">TriaIterator</a>) &mdash; sometimes called <a href="http://en.wikipedia.org/wiki/Camel_case"><em>camel case</em></a> &mdash; while functions and variables use lowercase letters and underscores to separate words. The only exception are the iterator alias in <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> (named cell_iterator, active_line_iterator, etc) to make the connection to the standard library container classes clear.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For classes with multiple template arguments, the dimension is usually put before the data type specifier, i.e., we use Point&lt;dim,number&gt; and not Point&lt;number,dim&gt;.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">There are several places in deal.II where we use forward declarations in header files. The reason for this is that we can, hopefully, improve compilation speeds by not using headers when we just need to mark a certain type as an argument to a function. The convention used in deal.II is that, if all we need is a type name, then the type may be forward declared in the header where we need it; if a function (or member function) can return a value then a declaration of that value's type should be available (by including the necessary header). For example, <code>deal.II/dofs/dof_handler.h</code> includes <code>deal.II/dofs/dof_accessor.h</code> so that one can write something like <code>dof_handler.begin_active()-&gt;is_active()</code> without explicitly including the header declaring the type of the object returned by <code>begin_active()</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Each class has to have at least 200 pages of documentation ;-)</p>
<p class="endli"></p>
</li>
</ol>
<p></code></p>
<p><code></p><h3>Instantiation of templated functions/classes</h3>
<p></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code>The majority of classes and functions in deal.II are templated. This brings a question of how and where such objects are instantiated, if at all. Throughout deal.II we adopt the following convention:</code></p>
<p><code></code></p>
<p><code></p><ol>
<li>
<p class="startli">If we can enumerate all possible template arguments (e.g., the dimension can only be 1, 2, or 3), then a function template goes into the <code>.cc</code> file and we explicitly instantiate all possibilities. Users will not have any need to ever see these function templates because they will not want to instantiate these functions for any other template arguments anyway. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If we can not enumerate all possible template arguments (e.g., vector types &ndash; because users might want to define their own vector kinds) but at least know a few common usage cases, then the function is put into a <code>.templates.h</code> file. We #include it into the <code>.cc</code> file and instantiate the functions for all of the common arguments. For almost all users, this will be just fine &ndash; they only use the (vector, matrix, ...) types we already instantiate, and for them the <code>.templates.h</code> file will not be of any interest. It will also not slow down their compilations because nothing they see will #include the <code>.templates.h</code> file. But users who define their own (vector, matrix, ...) types can instantiate the template functions with their own user-defined types by including the <code>.templates.h</code> files.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Finally, if we can not assume in advance which values template arguments will take (e.g., any class derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> can be used as an argument), the definitions of functions are provided at the bottom of the header file with declarations. The definitions should be guarded with <code>#ifndef DOXYGEN ... #endif</code> to prevent Doxygen from picking them up.</p>
<p class="endli"></p>
</li>
</ol>
<p></code></p>
<p><code></code></p>
<p><code> For the first two cases, instantiation instructions are defined in <code>.inst.in</code> files. They are processed by a binary called expand_instantiations (built from <code>cmake/scripts/expand_instantiations.cc</code>) and the parameters are defined dynamically through cmake depending on your configuration (see <code>cmake/config/template-arguments.in</code> in your build directory). It is those <code>.inst</code> files that are eventually included from the corresponding <code>.cc</code> files. </code></p>
<p><code></code></p>
<p><code></p><h3>Defensive programming</h3>
<p></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code> Defensive programming is a term that we use frequently when we talk about writing code while in the mindset that errors will happen. Here, errors can come in two ways: first, I can make a mistake myself while writing a functions; and secondly, someone else can make a mistake while calling my function. In either case, I would like to write my code in such a way that errors are (i) as unlikely as possible, (ii) that the compiler can already find some of the mistakes, and (iii) that the remaining mistakes are relatively easy to find, for example because the program aborts. Defensive programming is then a set of strategies that make these goals more likely. </code></p>
<p><code></code></p>
<p><code></code></p>
<p><code> Over time, we have learned a number of techniques to this end, some of which we list here: </p><ol>
<li>
<p class="startli"><em>Assert preconditions on parameters:</em> People call functions with wrong or nonsensical parameters, all the time. As the prototypical example, consider a trivial implementation of vector addition: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector</a> &amp;</div><div class="line">operator+=(<a class="code" href="classVector.html">Vector</a>       &amp;lhs,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    lhs(i) += rhs(i);</div><div class="line">  <span class="keywordflow">return</span> lhs;</div><div class="line">}</div></div><!-- fragment --><p> While correct, this function will get into trouble if the two vectors do not have the same size. You think it is silly to call this function with vectors of different size? Yes, of course it is. But it happens all the time: people forget to reinitialize a vector, or it is reset in a different function, etc. It happens. So if you are in such an unlucky case, it can take a long time to figure out what's going on because you are likely to just read uninitialized memory, or maybe you are writing to memory the <code>lhs</code> vector doesn't actually own. Neither is going to lead to immediate termination of the program, but you'll probably get random errors at a later time. It would be much easier if the program just stopped here right away. The following implementation will do exactly this: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector</a> &amp;</div><div class="line">operator+=(<a class="code" href="classVector.html">Vector</a>       &amp;lhs,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>() == rhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), rhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    lhs(i) += rhs(i);</div><div class="line">  <span class="keywordflow">return</span> lhs;</div><div class="line">}</div></div><!-- fragment --><p> The <code>Assert</code> macro ensures that the condition is true at run time, and otherwise prints a string containing information encoded by the second argument and aborts the program. This way, when you write a new program that happens to call this function, you will learn of your error right away and have the opportunity to fix it without ever having to seriously debug anything. </p>
<p>As a general guideline, whenever you implement a new function, think about the <em>preconditions</em> on parameter, i.e. what does the function expect to be true about each of them, or their combination. Then write assertions for all of these preconditions. This may be half a dozen assertions in some cases but remember that each assertion is a potential bug already found through trivial means. </p>
<p>In a final note, let us remark that assertions are of course expensive: they may make a program 3 or 5 times slower when you link it against the debug version of the library. But if you consider your <em>overall</em> development time, the ability to find bugs quickly probably far outweighs the time you spend waiting for your program to finish. Furthermore, calls to the Assert macro are removed from the program in optimized mode (which you presumably only use once you know that everything runs just fine in debug mode. The optimized libraries are faster by a factor of 3-5 than the debug libraries, at the price that it's much harder to find bugs. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Assert postconditions:</em> If a function computes something non-trivial there may be a bug in the code. To find these, use postconditions: just like you have certain knowledge about useful values for input parameters, you have knowledge about what you expect possible return values to be. For example, a function that computes the norm of a vector would expect the norm to be positive. You can write this as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;v)</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> s = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;v.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    s += v(i) * v(i);</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (s &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(s);</div><div class="line">}</div></div><!-- fragment --><p> This function is too simple to really justify this assertion, but imagine the computation to be lengthier and you can see how the assertion helps you ensure (or <em>hedge</em>) yourself against mistakes. Note that one could argue that the assertion should be removed once we've run the program a number of times and found that the condition never triggers. But it's better to leave it right where it is: it encodes for the future (and for readers) knowledge you have about the function; if someone comes along and replaced the implementation of the function by a more efficient algorithm, the assertion can help make sure that the function continues to do what it is supposed to do. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Assert internal states:</em> In a similar vein, if you have a complex algorithm, use assertions to ensure that your mental model of what is going on matches what is indeed true. For example, assume you are writing a function that ensures that mesh sizes do not change too much locally. You may end up with a code of the following kind: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; ...)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (something)</div><div class="line">        { ... }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="comment">// we have a cell whose neighbor must</span></div><div class="line">          <span class="comment">// be at the boundary if we got here</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> The conditions that got us into the else-branch may be complicated, and while it may be true that we believed that the only possibility we got here is that the neighbor is at the boundary, there may have been a bug in our implementation. There may also have been a bug in our thinking, or someone changes the code way above in the same function and forgets about the issue here, or a change at a completely different location in the library makes the assumption untenable. In all of these cases, the explicit statement of our assertion makes sure that these problems are easily found. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Initialize variables at the point of their declaration if they live on the stack:</em> Traditional C required that variables are declared at the beginning of the function even if they are only used further below. This leads to code like this that we may imagine in a 1d code: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center;</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      cell_center = (cell-&gt;vertex(0) + cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> The problem is that if the code between the declaration and initialization is long and complicated, you can't look up on one page what the type of a variable is and what it's value may be. In fact, it may not even be quite clear that the variable is used initialized at all, or whether it is accidentally left uninitialized. </p>
<p>A better way to do this would be as follows: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = (cell-&gt;vertex(0) + cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> This makes it much clearer what the type of the variable is and that it is in fact only ever used when initialized. Furthermore, if someone wants to read the code to see what the variable is in fact doing, declaring and initializing it in the innermost possible scope makes this task easier: we don't have to look upwards for it beyond the declaration, and we don't have to look downward beyond the end of the current scope since this is where the variable dies. </p>
<p>As a final note, it is clear that you can only do this sort of stuff for variables that completely live on the stack without allocating memory on the heap. Within deal.II, this is only true for builtin types like <code>int, double, char</code>, etc, as well as the <a class="el" href="classPoint.html">Point</a> and <a class="el" href="classTensor.html">Tensor</a> classes. Everything else has something like a <code>std::vector</code> as a member variable, which requires memory allocation &mdash; you don't want to declare these inside loops, at least not if the loop is traversed frequently. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><em>Make variables const:</em> To pick up on the example above, note that in most cases we will never change the variable so initialized any more. In other words, if this is the case, we may as well write things as follows: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = (cell-&gt;vertex(0) +</div><div class="line">                                      cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> By marking the variable as constant we make sure that we don't accidentally change it. For example, the compiler could catch code like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_center[0] = 0)</div><div class="line">  ...</div></div><!-- fragment --><p> This was most likely meant to be a <code>==</code> rather than an assignment. By marking the variable as const, the compiler would have told us about this bug. Maybe equally importantly, human readers of the code need not look further down whether the value of the variable may actually be changed somewhere between declaration and use &mdash; it can't be if it is marked as const. </p>
<p class="endli"></p>
</li>
<li>
<em>Make input arguments of functions const:</em> The same essentially holds true as well as for function arguments: If you have no intention of changing a variable (which is typically the case for input arguments), then mark it as constant. For example, the following function should take its argument as a constant value: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line"><a class="code" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">CellAccessor&lt;dim&gt;::child</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child_no)</div><div class="line">{</div><div class="line">  ...</div><div class="line">  <span class="keywordflow">return</span> something;</div><div class="line">}</div></div><!-- fragment --> Here, the user calls <code>cell-&gt;child(3)</code>, for example. There really is no reason why the function would ever want to change the value of the <code>child_no</code> argument &mdash; so mark it as constant: this both helps the reader of the code understand that this is an input argument of the function for which we need not search below whether it is ever changed, and it helps the compiler help us finding bugs if we ever accidentally change the value. </li>
</ol>
<p></code></p>
<p><code>Throughout deal.II, we strive to keep our programming style and the kind ofinterfaces we provide as consistent as possible. To this end, we have adopteda set of coding conventions that we attempt to follow wherever possible. Theyhave two parts: style issues, and something we call "defensive programming",the latter being an attempt to let our code help us find bugs. When readingthrough them, it is important to remember that styles are not god given orbetter than any other set of conventions; their purpose is merely to keepdeal.II as uniform as possible. Uniformity reduces the number of bugs weproduce because we can, for example, always assume that input arguments comebefore output arguments of a function call. They also simplify reading codebecause some things become clear already by looking at the style a piece ofcode is written, without having to look up the exact definition of something. </p><h3>Notes on deal.II indentation</h3>
<p></code></p>
<p><code> </code></p>
<p><code> deal.II uses <code>clang-format</code> 6.0 to normalize indentation. Astyle file is provided at </p><div class="fragment"><div class="line">${SOURCE_DIR}/.clang-format</div></div><!-- fragment --><p></code></p>
<p><code></code></p>
<p><code> Before a commit, you should run </p><div class="fragment"><div class="line">clang-format</div><div class="line"></div><div class="line">-i &lt;file&gt;</div></div><!-- fragment --><p> on each of your files. This will make sure indentation is conforming to thestyle guidelines outlined in this page. This is cumbersome. Consequently, and more easily, you can just run </p><div class="fragment"><div class="line">make indent</div></div><!-- fragment --><p> in whatever directory you set up the library to be compiled in, to indent allsource files that have been changed recently. If you want to make sure thatthe indenting is correct for all your commits, you might want to set up apre-commit hook. One way to do so, is to copy <code>${SOURCE_DIR}/contrib/git-hooks/pre-commit</code> to <code>${SOURCE_DIR}/.git/hooks/pre-commit</code> and make sure it isexecutable. If the system you are working on has more than one version of <code>clang-format</code> installed (or if it is not in the path)you should replace the above <code>make indent</code> command with </p><div class="fragment"><div class="line">make DEAL_II_CLANG_FORMAT=/path/to/clang-6.0/clang-format indent</div></div><!-- fragment --><p> to point to the correct executable. </code></p>
<p><code> </p><h3>Style issues</h3>
<p></code></p>
<p><code> </p><ol>
<li>
Functions which return the number of something (number of cells, degrees of freedom, etc) should start with <code>n_*</code> . Example: <a class="el" href="classSparsityPatternBase.html#a0707927053081fd6c46dac186e63c543">SparsityPatternBase::n_nonzero_elements()</a>. </li>
<li>
Functions which set a bit or flag should start with <code>set_*</code> ; functions which clear bits or flags should be named <code>clear_*</code> . Example: <a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">CellAccessor::set_refine_flag()</a>. </li>
<li>
Traditional logical operators should be used instead of their English equivalents (i.e., use <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> instead of <code>and</code>, <code>or</code>, and <code>not</code> ). </li>
<li>
In the implementation files, after each function, three empty lines are expected to enable better readability. One empty line occurs in functions to group blocks of code, since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions.  </li>
<li>
Whenever an integer variable can only assume nonnegative values, it is marked as unsigned. The same applies to functions that can only return positive or zero values. Example: <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a>. </li>
<li>
Whenever an argument to a function will not be changed, it should be marked const, even if passed by value. Generally, we mark input parameters as const. This aids as an additional documentation tool to clarify the intent of a parameter (input, output, or both) and lets the compiler issue warnings if such a parameter is changed, which is often either involuntarily or poor style.  </li>
<li>
Whenever a function does not change any of the member variable of the embedding class/object, it should be marked as const.  </li>
<li>
Function and variable names may not consist of only one or two letters, unless the variable is a pure counting index.  </li>
<li>
Type aliases ( <code>using</code> -declarations) are preferred to <code>typedef</code> -declarations.  </li>
<li>
Use the geometry information in <a class="el" href="structGeometryInfo.html">GeometryInfo</a> to get the number of faces per cell, the number of children per cell, the child indices of the child cells adjacent to face 3, etc, rather than writing them into the code directly as <code>2*dim</code> , <code>(1&lt;&lt;dim)</code> and <code>{0,3}</code> . This reduces the possibilities for errors and enhances readability of code.  </li>
<li>
The layout of class declarations is the following: first the block of public functions, beginning with the constructors, then the destructors. If there are public member variables, these have to occur before the constructor. Public variables shall only be used if constant (in particular if they are static and constant) or unavoidable. <br />
 After the public members, the protected and finally the private members are to be listed. The order is as above: first variables then functions. <br />
 <a class="el" href="namespaceExceptions.html">Exceptions</a> shall be declared at the end of the public section before the non-public sections start. <br />
 We do not use the C++11-style class member initialization for member variables that are neither <code>static const</code> nor <code>static constexpr</code> ; i.e., instead of <div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line"> <span class="keywordtype">int</span> a = 42;</div><div class="line"> intb = <span class="keyword">nullptr</span>;</div><div class="line">};</div></div><!-- fragment --> write <div class="fragment"><div class="line"><span class="keyword">class </span>Foo</div><div class="line">{</div><div class="line"> Foo();</div><div class="line"></div><div class="line"> <span class="keywordtype">int</span> a;</div><div class="line"> intb;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">inline</span> Foo::Foo()</div><div class="line">: a(42)</div><div class="line">, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>(nullptr)</div><div class="line">{}</div></div><!-- fragment -->  </li>
<li>
If a function has both input and output parameters, usually the input parameters shall precede the output parameters, unless there are good reasons to change this order. (The most common reason is trailing input parameters with default values.)  </li>
<li>
<a class="el" href="namespaceExceptions.html">Exceptions</a> are used for internal parameter checking and for consistency checks through the Assert macro. Exception handling like done by the C++ language ( <code>try/throw/catch</code> , and using the AssertThrow macro) are used to handle run time errors (like I/O failures) which must be on in any case, not only in debug mode.  </li>
<li>
Sometimes it makes sense to implement a class by using several non-member functions that are not part of the public interface and are only meant to be called in the current source file. Such free functions should be put in an internal namespace structured in the following way: <div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceinternal.html">internal</a></div><div class="line">{</div><div class="line"> <span class="keyword">namespace </span>ClassNameImplementation</div><div class="line"> {</div><div class="line">   <span class="comment">// free functions go here</span></div><div class="line"> }</div><div class="line">}</div></div><!-- fragment --> where <code>ClassName</code> is the name of the calling class. </li>
<li>
Classes, namespaces and types generally are named using uppercase letters to denote word beginnings (e.g. <a class="el" href="classTriaIterator.html">TriaIterator</a>) &mdash; sometimes called <a href="http://en.wikipedia.org/wiki/Camel_case"><em>camel case</em><em>camel case</em></a> &mdash; while functions and variables use lowercase letters and underscores to separate words. The only exception are the iterator alias in <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> (named cell_iterator, active_line_iterator, etc) to make the connection to the standard library container classes clear.  </li>
<li>
For classes with multiple template arguments, the dimension is usually put before the data type specifier, i.e., we use Point&lt;dim,number&gt; and not Point&lt;number,dim&gt;. </li>
<li>
There are several places in deal.II where we use forward declarations in header files. The reason for this is that we can, hopefully, improve compilation speeds by not using headers when we just need to mark a certain type as an argument to a function. The convention used in deal.II is that, if all we need is a type name, then the type may be forward declared in the header where we need it; if a function (or member function) can return a value then a declaration of that value's type should be available (by including the necessary header). For example, <code>deal.II/dofs/dof_handler.h</code> includes <code>deal.II/dofs/dof_accessor.h</code> so that one can write something like <code>dof_handler.begin_active()-&gt;is_active()</code> without explicitly including the header declaring the type of the object returned by <code>begin_active()</code> . </li>
<li>
Each class has to have at least 200 pages of documentation ;-)  </li>
</ol>
<p></code></p>
<p><code> </p><h3>Instantiation of templated functions/classes</h3>
<p></code></p>
<p><code> </code></p>
<p><code> The majority of classes and functions in deal.II are templated. This brings aquestion of how and where such objects are instantiated, if at all. Throughoutdeal.II we adopt the following convention: </code></p>
<p><code> </p><ol>
<li>
If we can enumerate all possible template arguments (e.g., the dimensioncan only be 1, 2, or 3), then a function template goes into the <code>.cc</code> file and we explicitly instantiate all possibilities. Users will not have anyneed to ever see these function templates because they will not want toinstantiate these functions for any other template arguments anyway.  </li>
<li>
<p class="startli">If we can not enumerate all possible template arguments (e.g., vectortypes</p>
<ul>
<li>because users might want to define their own vector kinds) but atleast know a few common usage cases, then the function is put into a <code>.templates.h</code> file. We #include it into the <code>.cc</code> fileand instantiate the functions for all of the common arguments. For almost allusers, this will be just fine</li>
<li>they only use the (vector, matrix, ...) typeswe already instantiate, and for them the <code>.templates.h</code> file will notbe of any interest. It will also not slow down their compilations becausenothing they see will #include the <code>.templates.h</code> file. But users whodefine their own (vector, matrix, ...) types can instantiate the templatefunctions with their own user-defined types by including the <code>.templates.h</code> files. </li>
</ul>
</li>
<li>
Finally, if we can not assume in advance which values template argumentswill take (e.g., any class derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> can be used as an argument),the definitions of functions are provided at the bottom of the headerfile with declarations. The definitions should be guarded with <code>#ifndefDOXYGEN ... #endif</code> to prevent Doxygen from picking them up.  </li>
</ol>
<p></code></p>
<p><code> For the first two cases, instantiation instructions are defined in <code>.inst.in</code> files. They are processed by a binary calledexpand_instantiations (built from <code>cmake/scripts/expand_instantiations.cc</code> ) and the parameters aredefined dynamically through cmake depending on your configuration (see <code>cmake/config/template-arguments.in</code> in your build directory).It is those <code>.inst</code> files that are eventually included from thecorresponding <code>.cc</code> files. </code></p>
<p><code></code></p>
<p><code> </p><h3>Defensive programming</h3>
<p></code></p>
<p><code> </code></p>
<p><code> Defensive programming is a term that we use frequently when we talk aboutwriting code while in the mindset that errors will happen. Here, errors cancome in two ways: first, I can make a mistake myself while writing afunctions; and secondly, someone else can make a mistake while calling myfunction. In either case, I would like to write my code in such a way thaterrors are (i) as unlikely as possible, (ii) that the compiler can alreadyfind some of the mistakes, and (iii) that the remaining mistakes arerelatively easy to find, for example because the program aborts. Defensiveprogramming is then a set of strategies that make these goals more likely. </code></p>
<p><code> </code></p>
<p><code> Over time, we have learned a number of techniques to this end, some of whichwe list here: </p><ol>
<li>
<p class="startli"><em>Assert preconditions on parameters:</em> People call functions with wrong or nonsensical parameters, all the time. As the prototypical example, consider a trivial implementation of vector addition: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector</a> &amp;</div><div class="line">operator+=(<a class="code" href="classVector.html">Vector</a>       &amp;lhs,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    lhs(i) += rhs(i);</div><div class="line">  <span class="keywordflow">return</span> lhs;</div><div class="line">}</div></div><!-- fragment --><p> While correct, this function will get into trouble if the two vectors do not have the same size. You think it is silly to call this function with vectors of different size? Yes, of course it is. But it happens all the time: people forget to reinitialize a vector, or it is reset in a different function, etc. It happens. So if you are in such an unlucky case, it can take a long time to figure out what's going on because you are likely to just read uninitialized memory, or maybe you are writing to memory the <code>lhs</code> vector doesn't actually own. Neither is going to lead to immediate termination of the program, but you'll probably get random errors at a later time. It would be much easier if the program just stopped here right away. The following implementation will do exactly this: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector</a> &amp;</div><div class="line">operator+=(<a class="code" href="classVector.html">Vector</a>       &amp;lhs,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;rhs)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>() == rhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(),</div><div class="line">          <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(), rhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;lhs.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    lhs(i) += rhs(i);</div><div class="line">  <span class="keywordflow">return</span> lhs;</div><div class="line">}</div></div><!-- fragment --><p> The <code>Assert</code> macro ensures that the condition is true at run time, and otherwise prints a string containing information encoded by the second argument and aborts the program. This way, when you write a new program that happens to call this function, you will learn of your error right away and have the opportunity to fix it without ever having to seriously debug anything. </p>
<p>As a general guideline, whenever you implement a new function, think about the <em>preconditions</em> on parameter, i.e. what does the function expect to be true about each of them, or their combination. Then write assertions for all of these preconditions. This may be half a dozen assertions in some cases but remember that each assertion is a potential bug already found through trivial means. </p>
<p class="endli">In a final note, let us remark that assertions are of course expensive: they may make a program 3 or 5 times slower when you link it against the debug version of the library. But if you consider your <em>overall</em> development time, the ability to find bugs quickly probably far outweighs the time you spend waiting for your program to finish. Furthermore, calls to the Assert macro are removed from the program in optimized mode (which you presumably only use once you know that everything runs just fine in debug mode. The optimized libraries are faster by a factor of 3-5 than the debug libraries, at the price that it's much harder to find bugs.  </p>
</li>
<li>
<em>Assert postconditions:</em> If a function computes something non-trivial there may be a bug in the code. To find these, use postconditions: just like you have certain knowledge about useful values for input parameters, you have knowledge about what you expect possible return values to be. For example, a function that computes the norm of a vector would expect the norm to be positive. You can write this as follows: <div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>(<span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a> &amp;v)</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> s = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;v.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++i)</div><div class="line">    s += v(i) v(i);</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a> (s &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(s);</div><div class="line">}</div></div><!-- fragment --> This function is too simple to really justify this assertion, but imagine the computation to be lengthier and you can see how the assertion helps you ensure (or <em>hedge</em>) yourself against mistakes. Note that one could argue that the assertion should be removed once we've run the program a number of times and found that the condition never triggers. But it's better to leave it right where it is: it encodes for the future (and for readers) knowledge you have about the function; if someone comes along and replaced the implementation of the function by a more efficient algorithm, the assertion can help make sure that the function continues to do what it is supposed to do.  </li>
<li>
<em>Assert internal states:</em> In a similar vein, if you have a complex algorithm, use assertions to ensure that your mental model of what is going on matches what is indeed true. For example, assume you are writing a function that ensures that mesh sizes do not change too much locally. You may end up with a code of the following kind: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> face=0; ...)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (something)</div><div class="line">        { ... }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="comment">// we have a cell whose neighbor must</span></div><div class="line">          <span class="comment">// be at the boundary if we got here</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> The conditions that got us into the else-branch may be complicated, and while it may be true that we believed that the only possibility we got here is that the neighbor is at the boundary, there may have been a bug in our implementation. There may also have been a bug in our thinking, or someone changes the code way above in the same function and forgets about the issue here, or a change at a completely different location in the library makes the assumption untenable. In all of these cases, the explicit statement of our assertion makes sure that these problems are easily found.  </li>
<li>
<p class="startli"><em>Initialize variables at the point of their declaration if they live on the stack:</em> Traditional C required that variables are declared at the beginning of the function even if they are only used further below. This leads to code like this that we may imagine in a 1d code: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center;</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      cell_center = (cell-&gt;vertex(0) + cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> The problem is that if the code between the declaration and initialization is long and complicated, you can't look up on one page what the type of a variable is and what it's value may be. In fact, it may not even be quite clear that the variable is used initialized at all, or whether it is accidentally left uninitialized. </p>
<p>A better way to do this would be as follows: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = (cell-&gt;vertex(0) + cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p> This makes it much clearer what the type of the variable is and that it is in fact only ever used when initialized. Furthermore, if someone wants to read the code to see what the variable is in fact doing, declaring and initializing it in the innermost possible scope makes this task easier: we don't have to look upwards for it beyond the declaration, and we don't have to look downward beyond the end of the current scope since this is where the variable dies. </p>
<p class="endli">As a final note, it is clear that you can only do this sort of stuff for variables that completely live on the stack without allocating memory on the heap. Within deal.II, this is only true for builtin types like <code>int, double, char</code> , etc, as well as the <a class="el" href="classPoint.html">Point</a> and <a class="el" href="classTensor.html">Tensor</a> classes. Everything else has something like a <code>std::vector</code> as a member variable, which requires memory allocation &mdash; you don't want to declare these inside loops, at least not if the loop is traversed frequently.  </p>
</li>
<li>
<em>Make variables const:</em> To pick up on the example above, note that in most cases we will never change the variable so initialized any more. In other words, if this is the case, we may as well write things as follows: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> foo ()</div><div class="line">{</div><div class="line">  ... <span class="comment">// something lengthy and complicated</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = dof_handler.active_cell_iterators())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> cell_center = (cell-&gt;vertex(0) +</div><div class="line">                                      cell-&gt;vertex(1)) / 2;</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --> By marking the variable as constant we make sure that we don't accidentally change it. For example, the compiler could catch code like this: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_center[0] = 0)</div><div class="line">  ...</div></div><!-- fragment --> This was most likely meant to be a <code>==</code> rather than an assignment. By marking the variable as const, the compiler would have told us about this bug. Maybe equally importantly, human readers of the code need not look further down whether the value of the variable may actually be changed somewhere between declaration and use &mdash; it can't be if it is marked as const.  </li>
<li>
<em>Make input arguments of functions const:</em> The same essentially holds true as well as for function arguments: If you have no intention of changing a variable (which is typically the case for input arguments), then mark it as constant. For example, the following function should take its argument as a constant value: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a></div><div class="line"><a class="code" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">CellAccessor&lt;dim&gt;::child</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> child_no)</div><div class="line">{</div><div class="line">  ...</div><div class="line">  <span class="keywordflow">return</span> something;</div><div class="line">}</div></div><!-- fragment --> Here, the user calls <code>cell-&gt;child(3)</code> , for example. There really is no reason why the function would ever want to change the value of the <code>child_no</code> argument &mdash; so mark it as constant: this both helps the reader of the code understand that this is an input argument of the function for which we need not search below whether it is ever changed, and it helps the compiler help us finding bugs if we ever accidentally change the value. </li>
</ol>
<p></code></p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
