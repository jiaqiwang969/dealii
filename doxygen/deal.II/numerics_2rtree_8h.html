<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/numerics_2rtree_8h.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II/numerics/rtree.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_ee90d91a514b839c31faec7a1d916f67.html">deal.II</a></li><li class="navelem"><a class="el" href="dir_5c2eb6d9a7a6f1e9cd32e0e8abf42ca6.html">numerics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rtree.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="config_8h_source.html">deal.II/base/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="base_2point_8h_source.html">deal.II/base/point.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="base_2std__cxx20_2iota__view_8h_source.html">deal.II/base/std_cxx20/iota_view.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="boost__adaptors_2bounding__box_8h_source.html">deal.II/boost_adaptors/bounding_box.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="boost__adaptors_2point_8h_source.html">deal.II/boost_adaptors/point.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="boost__adaptors_2segment_8h_source.html">deal.II/boost_adaptors/segment.h</a>&gt;</code><br />
<code>#include &lt;boost/geometry/index/rtree.hpp&gt;</code><br />
<code>#include &lt;boost/geometry/strategies/strategies.hpp&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
</div>
<p><a href="numerics_2rtree_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices&lt; Container &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExtractLevelVisitor.html">ExtractLevelVisitor&lt; Value, Options, Translator, Box, Allocators &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4c344ba05898daa78401ef2c92580f97"><td class="memTemplParams" colspan="2">template&lt;typename LeafType , typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename IndexableGetter  = boost::geometry::index::indexable&lt;LeafType&gt;&gt; </td></tr>
<tr class="memitem:a4c344ba05898daa78401ef2c92580f97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a> = boost::geometry::index::rtree&lt; LeafType, IndexType, IndexableGetter &gt;</td></tr>
<tr class="separator:a4c344ba05898daa78401ef2c92580f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename LeafTypeIterator , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename LeafTypeIterator::value_type&gt;&gt; </td></tr>
<tr class="memitem:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename LeafTypeIterator::value_type, IndexType, IndexableGetter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> LeafTypeIterator &amp;<a class="el" href="chunk__sparsity__pattern__0_8txt.html#a1b85ba44191e874d873fa30bb66efabd">begin</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> LeafTypeIterator &amp;<a class="el" href="chunk__sparsity__pattern__0_8txt.html#afd9d8ed92a81e47388f0f4666beb0712">end</a>)</td></tr>
<tr class="separator:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e3cb848beee59152a7963c98c857dd"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename ContainerType::value_type&gt;&gt; </td></tr>
<tr class="memitem:a21e3cb848beee59152a7963c98c857dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename ContainerType::value_type, IndexType, IndexableGetter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="numerics_2rtree_8h.html#a21e3cb848beee59152a7963c98c857dd">pack_rtree</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ContainerType &amp;<a class="el" href="particle__iterator__0_8txt.html#a8814ad7ef6b3df9a381316a0106e3a09">container</a>)</td></tr>
<tr class="separator:a21e3cb848beee59152a7963c98c857dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType &gt; </td></tr>
<tr class="memitem:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename ContainerType::size_type, IndexType, <a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices</a>&lt; ContainerType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="numerics_2rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ContainerType &amp;<a class="el" href="particle__iterator__0_8txt.html#a8814ad7ef6b3df9a381316a0106e3a09">container</a>)</td></tr>
<tr class="separator:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3591e6e032b1a56920f897a2bc387d43"><td class="memTemplParams" colspan="2">template&lt;typename Rtree &gt; </td></tr>
<tr class="memitem:a3591e6e032b1a56920f897a2bc387d43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="symmetric__tensor__0_8txt.html#a6edfde50c98e496c6d723c198719a0cd">boost::geometry::dimension</a>&lt; typename Rtree::indexable_type &gt;::<a class="el" href="vector__tools__constraints__0_8txt.html#ae2791e1c63ecc8b5fbb62db8c73b0642">value</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Rtree &amp;<a class="el" href="iterators__0_8txt.html#aa434a1a36be167d69b91da0085566b8b">tree</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a> <a class="el" href="mg__transfer__global__coarsening__0_8txt.html#a7f79286582b1a7fa6f3fdd8e1448bcba">level</a>)</td></tr>
<tr class="separator:a3591e6e032b1a56920f897a2bc387d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4c344ba05898daa78401ef2c92580f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c344ba05898daa78401ef2c92580f97">&#9670;&nbsp;</a></span>RTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeafType , typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename IndexableGetter  = boost::geometry::index::indexable&lt;LeafType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a> =  boost::geometry::index::rtree&lt;LeafType, IndexType, IndexableGetter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper for the boost::geometry::index::rtree class, implementing a self-balancing spatial index (the R-tree) capable of storing various types of values, using different balancing algorithms. From <a href="https://en.wikipedia.org/wiki/R-tree">Wikipedia</a>: </p><blockquote class="doxtable">
<p>R-trees are tree data structures used for spatial access methods, i.e., for indexing multi-dimensional information such as geographical coordinates, rectangles or polygons. The R-tree was proposed by Antonin Guttman in 1984 and has found significant use in both theoretical and applied contexts. A common real-world usage for an R-tree might be to store spatial objects such as restaurant locations or the polygons that typical maps are made of: streets, buildings, outlines of lakes, coastlines, etc. and then find answers quickly to queries such as "Find all museums within 2 km of my
current location", "retrieve all road segments within 2 km of my location" (to display them in a navigation system) or "find the nearest gas station" (although not taking roads into account). The R-tree can also accelerate nearest neighbor search for various distance metrics, including great-circle distance. The key idea of the data structure is to group nearby objects and represent them with their minimum bounding rectangle in the next higher level of the tree; the "R" in R-tree is for rectangle. Since all objects lie within this bounding rectangle, a query that does not intersect the bounding rectangle also cannot intersect any of the contained objects. At the leaf level, each rectangle describes a single object; at higher levels the aggregation of an increasing number of objects. This can also be seen as an increasingly coarse approximation of the data set. The key difficulty of R-tree is to build an efficient tree that on one hand is balanced (so the leaf nodes are at the same height) on the other hand the rectangles do not cover too much empty space and do not overlap too much (so that during search, fewer subtrees need to be processed). For example, the original idea for inserting elements to obtain an efficient tree is to always insert into the subtree that requires least enlargement of its bounding box. Once that page is full, the data is split into two sets that should cover the minimal area each. Most of the research and improvements for R-trees aims at improving the way the tree is built and can be grouped into two objectives: building an efficient tree from scratch (known as bulk-loading) and performing changes on an existing tree (insertion and deletion). </p>
</blockquote>
<p>An RTree may store any type of <code>LeafType</code> as long as it is possible to extract an <code>Indexable</code> that the RTree can handle and compare values. An <code>Indexable</code> is a type adapted to the <a class="el" href="classPoint.html">Point</a>, <a class="el" href="classBoundingBox.html">BoundingBox</a> or Segment concept, for which distance and equality comparison are implemented. The deal.II <a class="el" href="classPoint.html">Point</a>, Segment, and <a class="el" href="classBoundingBox.html">BoundingBox</a> classes satisfy this requirement, but you can mix in any geometry object that <a class="el" href="namespaceboost_1_1geometry.html">boost::geometry</a> accepts as indexable. In particular, given an <code>Indexable</code> type (for example a <a class="el" href="classPoint.html">Point</a>, a <a class="el" href="classBoundingBox.html">BoundingBox</a>, or a Segment), <code>LeafType</code> can by any of <code>Indexable</code>, <code>std::pair&lt;Indexable, T&gt;</code>, <code>boost::tuple&lt;Indexable, ...&gt;</code> or <code>std::tuple&lt;Indexable, ...&gt;</code>. The optional argument <code>IndexType</code> is used only when adding elements to the tree one by one. If a range insertion is used, then the tree is built using the packing algorithm. Linear, quadratic, and rstar algorithms are available if one wants to construct the tree sequentially. However, none of these is very efficient, and users should use the packing algorithm when possible. The packing algorithm constructs the tree all at once, and may be used when you have all the leaves at your disposal. This class is usually used in combination with one of the two helper functions <a class="el" href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree()</a>, that takes a container or a range of iterators to construct the RTree using the packing algorithm. An example usage is the following:</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;2&gt;&gt; <a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a> = generate_some_points();</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a> = <a class="code" href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(<a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>.begin(), <a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>.end());</div>
<div class="line"><span class="comment">// or, equivalently:</span></div>
<div class="line"><span class="comment">// auto tree = pack_rtree(points);</span></div>
</div><!-- fragment --><p>The tree is accessed by using <a href="https://www.boost.org/doc/libs/1_68_0/libs/geometry/doc/html/geometry/spatial_indexes/queries.html"><code>boost::geometry::index</code> queries</a>. For example, after constructing the tree with the snippet above, one can ask for the closest points to a segment in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>bgi = <a class="code" href="scalapack__0_8txt.html#abc6ecee32660d1fa6d6157325220179a">boost::geometry::index</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="boost__adaptors_2segment_8h.html#abe8b244c98d19a51f52c0b4e9c5516bc">Segment&lt;2&gt;</a> segment(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0,0), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1,1));</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Point&lt;2&gt;&gt; nearest;</div>
<div class="line"><a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a>.query(bgi::nearest(segment,3), std::back_inserter(intersection));</div>
<div class="line"><span class="comment">// Returns the 3 closest points to the Segment defined above.</span></div>
</div><!-- fragment --><p>In general, a tree does not need to store the actual objects, as long as it knows how to access a const reference to an indexable type. This is achieved by passing the optional template argument <code>IndexableGetter</code>, that extracts a const reference to one of the possible indexable types given an object of type <code>LeafType</code>. As an example, one may store points in a container, and only create a tree of the indices within the container, using the <a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices</a> class defined below, and the function <a class="el" href="numerics_2rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices()</a>. </p>

<p class="definition">Definition at line <a class="el" href="numerics_2rtree_8h_source.html#l00135">135</a> of file <a class="el" href="numerics_2rtree_8h_source.html">rtree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a66a9d76ea405b07e60e74aa6159ac7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a9d76ea405b07e60e74aa6159ac7ad">&#9670;&nbsp;</a></span>pack_rtree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename LeafTypeIterator , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename LeafTypeIterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename LeafTypeIterator::value_type, IndexType, IndexableGetter&gt; pack_rtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> LeafTypeIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> LeafTypeIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the correct RTree object by passing an iterator range. Notice that the order of the parameters is the opposite with respect to the RTree class, since we can automatically infer the <code>LeafType</code> from the arguments. </p>

</div>
</div>
<a id="a21e3cb848beee59152a7963c98c857dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e3cb848beee59152a7963c98c857dd">&#9670;&nbsp;</a></span>pack_rtree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename ContainerType::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename ContainerType::value_type, IndexType, IndexableGetter&gt; pack_rtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ContainerType &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an RTree object by passing an STL container type. This function is used in <a class="el" href="step_70.html">step-70</a> . Notice that the order of the template parameters is the opposite with respect to the RTree class, since we can automatically infer the <code>LeafType</code> from the arguments, and we only need to specify the <code>IndexType</code> if the default is not adequate. </p>

</div>
</div>
<a id="a37474f7ac23c083eaa5c89c59f37a09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37474f7ac23c083eaa5c89c59f37a09e">&#9670;&nbsp;</a></span>pack_rtree_of_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="numerics_2rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename ContainerType::size_type, IndexType, <a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices</a>&lt;ContainerType&gt; &gt; pack_rtree_of_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ContainerType &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a RTree object that stores the indices of an existing container of indexable types. The only requirement on the container is that it supports operator[] for any index between 0 and the size of the container (i.e., a std::vector, or an std::array will do, however an std::map won't). Differently from the object created by the <a class="el" href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree()</a> function, in this case we don't store the actual geometrical types, but just their indices:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>bgi = <a class="code" href="scalapack__0_8txt.html#abc6ecee32660d1fa6d6157325220179a">boost::geometry::index</a>;</div>
<div class="line">std::vector&lt;Point&lt;dim&gt;&gt; some_points = <a class="code" href="convergence__table__0_8txt.html#a37c53a384d86a02751b04a0a89820c55">fill</a>();</div>
<div class="line"><span class="keyword">auto</span> <a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a> = <a class="code" href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(<a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>); <span class="comment">// the tree contains a copy of the points</span></div>
<div class="line"><span class="keyword">auto</span> index_tree = <a class="code" href="numerics_2rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices</a>(<a class="code" href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a>); <span class="comment">// the tree contains only</span></div>
<div class="line">                                               <span class="comment">// the indices of the</span></div>
<div class="line">                                               <span class="comment">// points</span></div>
<div class="line"><a class="code" href="classBoundingBox.html">BoundingBox&lt;dim&gt;</a> <a class="code" href="base_2bounding__box__0_8txt.html#af37935e4c84062243619eb336c9068ad">box</a> = build_a_box();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a>: <a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a>       | bgi::adaptors::queried(bgi::intersects(<a class="code" href="base_2bounding__box__0_8txt.html#af37935e4c84062243619eb336c9068ad">box</a>)))</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Point p: &quot;</span> &lt;&lt; <a class="code" href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>: index_tree | bgi::adaptors::queried(bgi::intersects(<a class="code" href="base_2bounding__box__0_8txt.html#af37935e4c84062243619eb336c9068ad">box</a>)))</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Point p: &quot;</span> &lt;&lt; some_points[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The leaves stored in the tree are the indices of the corresponding entry in the container. A reference to the external container is stored internally, but keep in mind that if you change the container, you should rebuild the tree. </p>

</div>
</div>
<a id="a3591e6e032b1a56920f897a2bc387d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3591e6e032b1a56920f897a2bc387d43">&#9670;&nbsp;</a></span>extract_rtree_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rtree &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kinsol__0_8txt.html#ab19f5518dcad7cebd9aa51c8bc219a22">std::vector</a>&lt;<a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; <a class="el" href="symmetric__tensor__0_8txt.html#a6edfde50c98e496c6d723c198719a0cd">boost::geometry::dimension</a>&lt;typename Rtree::indexable_type&gt;::<a class="el" href="vector__tools__constraints__0_8txt.html#ae2791e1c63ecc8b5fbb62db8c73b0642">value</a>&gt; &gt; extract_rtree_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> Rtree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> unsigned <a class="el" href="matrix__free__0_8txt.html#afdb878b17ab7df395a1435ac49d661fc">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a RTree object <code>rtree</code>, and a target level <code>level</code>, return a vector of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects containing all the bounding boxes that make the given <code>level</code> of the <code>rtree</code>. This function is a convenient wrapper around the <a class="el" href="structExtractLevelVisitor.html">ExtractLevelVisitor</a> class. It is used in <a class="el" href="step_70.html">step-70</a> . Since an RTree object is a balanced tree, you can expect each entry of the resulting vector to contain roughly the same number of children, and ultimately, the same number of leaf objects. If you request for a level that is not present in the RTree, the last level is returned. A typical usage of this function is in the context of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, where one would like to construct a rough representation of the area which is covered by the locally owned cells of the active process, and exchange this information with other processes. The finest level of information is given by the leaves, which in this context would be the collection of all the bounding boxes associated to the locally owned cells of the triangulation. Exchanging this information with all participating processes would defeat the purpuse of parallel computations. If however one constructs an RTree containing these bounding boxes (for example, by calling <a class="el" href="classGridTools_1_1Cache.html#aca2782d6e93b5a0033c046b57904c67f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>), and then extracts one of the first levels of the RTree, only a handful of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects would be returned, allowing the user to have a very efficient description of the geometry of the domain, and of its distribution among processes. An example usage is given by the following snippet of code:</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;2&gt;</a> tria(MPI_COMM_WORLD);</div>
<div class="line"><a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria);</div>
<div class="line">tria.refine_global(4);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;BoundingBox&lt;2&gt;&gt; all_boxes(tria.n_locally_owned_active_cells());</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : tria.active_cell_iterators())</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;is_locally_owned())</div>
<div class="line">  all_boxes[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>++] = <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;bounding_box();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a>  = <a class="code" href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="base_2bounding__box__0_8txt.html#a56581e78a349db4405441847b3ee5b1d">boxes</a> = <a class="code" href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(<a class="code" href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a>, 1);</div>
</div><!-- fragment --><p>When run on three processes, the complete set of the <a class="el" href="classBoundingBox.html">BoundingBox</a> objects surrounding only the locally owned cells and the second level of the rtree constructed with those boxes would look like in the following pictures (one image per process): </p><div class="image">
<img src="rtree-process-0.png" alt=""/>
<div class="caption">
<div class="image">
<img src="rtree-process-1.png" alt=""/>
<div class="caption">
<div class="image">
<img src="rtree-process-2.png" alt=""/>
</div>
 </div></div>
</div></div>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="anumerics_2rtree_8h_html_a66a9d76ea405b07e60e74aa6159ac7ad"><div class="ttname"><a href="numerics_2rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a></div><div class="ttdeci">RTree&lt; typename LeafTypeIterator::value_type, IndexType, IndexableGetter &gt; pack_rtree(const LeafTypeIterator &amp;begin, const LeafTypeIterator &amp;end)</div></div>
<div class="ttc" id="aconvergence__table__0_8txt_html_a37c53a384d86a02751b04a0a89820c55"><div class="ttname"><a href="convergence__table__0_8txt.html#a37c53a384d86a02751b04a0a89820c55">fill</a></div><div class="ttdeci">*The ConvergenceTable class is an application to the TableHandler class and stores some convergence data such as residuals of the cg method or some evaluated[1.x.0] errors of discrete and evaluates convergence rates or orders *The already implemented *For the number of cells may be added to the table by calling n_dofs Of one can also add more kinds of information by calling before the output of the table the functions it switches off the auto fill mode of the TableHandler base class If you intend to add further data with auto fill</div><div class="ttdef"><b>Definition:</b> <a href="convergence__table__0_8txt_source.html#l00025">convergence_table_0.txt:25</a></div></div>
<div class="ttc" id="aclassBoundingBox_html"><div class="ttname"><a href="classBoundingBox.html">BoundingBox</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2bounding__box_8h_source.html#l00128">bounding_box.h:128</a></div></div>
<div class="ttc" id="abase_2bounding__box__0_8txt_html_a56581e78a349db4405441847b3ee5b1d"><div class="ttname"><a href="base_2bounding__box__0_8txt.html#a56581e78a349db4405441847b3ee5b1d">boxes</a></div><div class="ttdeci">*The enumerator NeighborType describes the neighboring relation between two bounding boxes ***Not in this means that the two boxes touch at one corner of the each box **Attached in this means that the two boxes touch along an edge **Mergeable e g **or one is inside the other **A class that represents a box of arbitrary dimension&lt; tt &gt; spacedim&lt;/tt &gt; and with sides parallel to the coordinate axes that is a region a bounding box is top right for useful in parallel distributed meshes to give a general description of the owners of each portion of the mesh *Taking the cross section of a BoundingBox&lt; spacedim &gt; orthogonal to a given direction gives a box in one dimension the coordinates of the cross section of BoundingBox&lt; 3 &gt; can be ordered in different ways That if we take the cross section orthogonal to the y direction we could either order a coordinate into a coordinate as[2.x.1] or as[2.x.2] This class uses the second convention corresponding to the coordinates being ordered cyclicly[2.x.3] To be if we take a cross z y *This is according to the convention set by the function *[2.x.4] **Standard constructor Creates an object that corresponds to an empty i e a degenerate box with both points being the origin **Standard constructor for non empty boxes</div><div class="ttdef"><b>Definition:</b> <a href="base_2bounding__box__0_8txt_source.html#l00060">bounding_box_0.txt:60</a></div></div>
<div class="ttc" id="anumerics_2rtree_8h_html_a37474f7ac23c083eaa5c89c59f37a09e"><div class="ttname"><a href="numerics_2rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices</a></div><div class="ttdeci">RTree&lt; typename ContainerType::size_type, IndexType, IndexableGetterFromIndices&lt; ContainerType &gt; &gt; pack_rtree_of_indices(const ContainerType &amp;container)</div></div>
<div class="ttc" id="anumerics_2rtree_8h_html_a3591e6e032b1a56920f897a2bc387d43"><div class="ttname"><a href="numerics_2rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a></div><div class="ttdeci">std::vector&lt; BoundingBox&lt; boost::geometry::dimension&lt; typename Rtree::indexable_type &gt;::value &gt; &gt; extract_rtree_level(const Rtree &amp;tree, const unsigned int level)</div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a553c97770c66367cd8861ec511390650"><div class="ttname"><a href="multithreading__0_8txt.html#a553c97770c66367cd8861ec511390650">points</a></div><div class="ttdeci">for if the values of a function need to be evaluated at quadrature points</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00182">multithreading_0.txt:182</a></div></div>
<div class="ttc" id="aclassparallel_1_1distributed_1_1Triangulation_html"><div class="ttname"><a href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></div><div class="ttdef"><b>Definition:</b> <a href="distributed_2tria_8h_source.html#l00226">tria.h:226</a></div></div>
<div class="ttc" id="aboost__adaptors_2segment_8h_html_abe8b244c98d19a51f52c0b4e9c5516bc"><div class="ttname"><a href="boost__adaptors_2segment_8h.html#abe8b244c98d19a51f52c0b4e9c5516bc">Segment</a></div><div class="ttdeci">boost::geometry::model::segment&lt; Point&lt; dim &gt; &gt; Segment</div><div class="ttdef"><b>Definition:</b> <a href="boost__adaptors_2segment_8h_source.html#l00038">segment.h:38</a></div></div>
<div class="ttc" id="abase_2bounding__box__0_8txt_html_af37935e4c84062243619eb336c9068ad"><div class="ttname"><a href="base_2bounding__box__0_8txt.html#af37935e4c84062243619eb336c9068ad">box</a></div><div class="ttdeci">*The enumerator NeighborType describes the neighboring relation between two bounding boxes ***Not in this means that the two boxes touch at one corner of the each box **Attached in this means that the two boxes touch along an edge **Mergeable e g **or one is inside the other **A class that represents a box of arbitrary dimension&lt; tt &gt; spacedim&lt;/tt &gt; and with sides parallel to the coordinate axes that is a region a bounding box is top right for useful in parallel distributed meshes to give a general description of the owners of each portion of the mesh *Taking the cross section of a BoundingBox&lt; spacedim &gt; orthogonal to a given direction gives a box in one dimension the coordinates of the cross section of BoundingBox&lt; 3 &gt; can be ordered in different ways That if we take the cross section orthogonal to the y direction we could either order a coordinate into a coordinate as[2.x.1] or as[2.x.2] This class uses the second convention corresponding to the coordinates being ordered cyclicly[2.x.3] To be if we take a cross z y *This is according to the convention set by the function *[2.x.4] **Standard constructor Creates an object that corresponds to an empty box</div><div class="ttdef"><b>Definition:</b> <a href="base_2bounding__box__0_8txt_source.html#l00056">bounding_box_0.txt:56</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_a533c4778cbc9bcbed365dcab42ca4418"><div class="ttname"><a href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a></div><div class="ttdeci">void hyper_ball(Triangulation&lt; dim &gt; &amp;tria, const Point&lt; dim &gt; &amp;center=Point&lt; dim &gt;(), const double radius=1., const bool attach_spherical_manifold_on_boundary_cells=false)</div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; 2 &gt;</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6e6ddb523c3838fca58a8e556843d8d3"><div class="ttname"><a href="iterators__0_8txt.html#a6e6ddb523c3838fca58a8e556843d8d3">tree</a></div><div class="ttdeci">after this come the grandchildren of the coarse and so on it must be noted that programs should not rely on this particularorder of traversing a tree</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00022">iterators_0.txt:22</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="ascalapack__0_8txt_html_abc6ecee32660d1fa6d6157325220179a"><div class="ttname"><a href="scalapack__0_8txt.html#abc6ecee32660d1fa6d6157325220179a">index</a></div><div class="ttdeci">[2.x.71] and column index=[2.x.72] . **************- The global row and column index of the first element of the submatrix B is provided by[2.x.73] with row index=[2.x.74] and column index=[2.x.75] . **************- The dimension of the submatrix to be copied is given by[2.x.76] with number of rows=[2.x.77] and number of columns=[2.x.78] . If it is necessary to copy complete matrices with an identical block-cyclic distribution, use[2.x.79] &amp;dest) with only one argument to avoid communication. The underlying process grids of the matrices[2.x.80] and[2.x.81] must have been built with the same MPI communicator. *[0.x.17] *Transposing assignment:[2.x.82] The matrices[2.x.83] and[2.x.84] must have the same process grid. The following alignment conditions have to be fulfilled:[2.x.85] and[2.x.86] . *[0.x.18] *The operations based on the input parameter[2.x.87] and the alignment conditions are summarized in the following table:|transpose_B|Block Sizes|Operation||:---------:|:--------------------------:|:-------------------------------------------:||false|[2.x.88][2.x.89][2.x.90]|[2.x.91]||true|[2.x.92][2.x.93][2.x.94]|[2.x.95]|The matrices[2.x.96] and[2.x.97] must have the same process grid. *[0.x.19] *Matrix-addition:[2.x.98] The matrices[2.x.99] and[2.x.100] must have the same process grid. The following alignment conditions have to be fulfilled:[2.x.101] and[2.x.102] . *[0.x.20] *Matrix-addition:[2.x.103] The matrices[2.x.104] and[2.x.105] must have the same process grid. The following alignment conditions have to be fulfilled:[2.x.106] and[2.x.107] . *[0.x.21] *Matrix-matrix-multiplication:The operations based on the input parameters and the alignment conditions are summarized in the following table:|transpose_A|transpose_B|Block Sizes|Operation||:---------:|:---------:|:-------------------------------------------:|:-------------------------------------------------------------:||false|false|[2.x.108][2.x.109][2.x.110][2.x.111][2.x.112]|[2.x.113]||false|true|[2.x.114][2.x.115][2.x.116][2.x.117][2.x.118]|[2.x.119]||true|false|[2.x.120][2.x.121][2.x.122][2.x.123][2.x.124]|[2.x.125]||true|true|[2.x.126][2.x.127][2.x.128][2.x.129][2.x.130]|[2.x.131]|It is assumed that[2.x.132] and[2.x.133] have compatible sizes and that[2.x.134] already has the right size. The matrices[2.x.135],[2.x.136] and[2.x.137] must have the same process grid. *[0.x.22] *Matrix-matrix-multiplication. The optional parameter[2.x.138] determines whether the result is stored in[2.x.139] or added to[2.x.140] . if([2.x.141][2.x.142] else[2.x.143] It is assumed that[2.x.144] and[2.x.145] have compatible sizes and that[2.x.146] already has the right size. The following alignment conditions have to be fulfilled:[2.x.147],[2.x.148] and[2.x.149] . *[0.x.23] *Matrix-matrix-multiplication using transpose of[2.x.150] . The optional parameter[2.x.151] determines whether the result is stored in[2.x.152] or added to[2.x.153] . if([2.x.154][2.x.155] else[2.x.156] It is assumed that[2.x.157] and[2.x.158] have compatible sizes and that[2.x.159] already has the right size. The following alignment conditions have to be fulfilled:[2.x.160],[2.x.161] and[2.x.162] . *[0.x.24] *Matrix-matrix-multiplication using the transpose of[2.x.163] . The optional parameter[2.x.164] determines whether the result is stored in[2.x.165] or added to[2.x.166] . if([2.x.167][2.x.168] else[2.x.169] It is assumed that[2.x.170] and[2.x.171] have compatible sizes and that[2.x.172] already has the right size. The following alignment conditions have to be fulfilled:[2.x.173],[2.x.174] and[2.x.175] . *[0.x.25] *Matrix-matrix-multiplication using transpose of[2.x.176] and[2.x.177] . The optional parameter[2.x.178] determines whether the result is stored in[2.x.179] or added to[2.x.180] . if([2.x.181][2.x.182] else[2.x.183] It is assumed that[2.x.184] and[2.x.185] have compatible sizes and that[2.x.186] already has the right size. The following alignment conditions have to be fulfilled:[2.x.187],[2.x.188] and[2.x.189] . *[0.x.26] *Stores the distributed matrix in[2.x.190] using HDF5. In case that deal.II was built without HDF5 a call to this function will cause an exception to be thrown. If HDF5 was built with MPI, parallel I/O is used to save the matrix. Otherwise, just one process will do the output. This means that internally the distributed matrix is copied to one process, which does the output. Therefore, the matrix has to fit into the memory of one process. To tweak the I/O performance, especially for parallel I/O, the user may define the optional parameter[2.x.191] All MPI processes need to call the function with the same value. The matrix is written in chunks to the file, therefore the properties of the system define the optimal chunk size. Internally, HDF5 splits the matrix into&lt; tt &gt;chunk_size.first&lt;/tt &gt; x&lt; tt &gt;chunk_size.second&lt;/tt &gt; sized blocks, with&lt; tt &gt;chunk_size.first&lt;/tt &gt; being the number of rows of a chunk and&lt; tt &gt;chunk_size.second&lt;/tt &gt; the number of columns. *[0.x.27] *Loads the distributed matrix from file[2.x.192] using HDF5. In case that deal.II was built without HDF5 a call to this function will cause an exception to be thrown. The matrix must have the same dimensions as the matrix stored in the file. If HDF5 was build with MPI, parallel I/O is used to load the matrix. Otherwise, just one process will load the matrix from storage and distribute the content to the other processes subsequently. *[0.x.28] *Compute the Cholesky factorization of the matrix using ScaLAPACK function[2.x.193] . The result of the factorization is stored in this object. *[0.x.29] *Compute the LU factorization of the matrix using ScaLAPACK function[2.x.194] and partial pivoting with row interchanges. The result of the factorization is stored in this object. *[0.x.30] *Invert the matrix by first computing a Cholesky for symmetric matrices or a LU factorization for general matrices and then building the actual inverse using[2.x.195] or[2.x.196] . If the matrix is triangular, the LU factorization step is skipped, and[2.x.197] is used directly. If a Cholesky or LU factorization has been applied previously,[2.x.198] are called directly. The inverse is stored in this object. *[0.x.31] *Computing selected eigenvalues and, optionally, the eigenvectors of the real symmetric matrix[2.x.199] . The eigenvalues/eigenvectors are selected by prescribing a range of indices[2.x.200] If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix. If all eigenvalues/eigenvectors have to be computed, pass the closed interval[2.x.201] in[2.x.202] Pass the closed interval[2.x.203] if the[2.x.204] largest eigenvalues/eigenvectors are desired. *[0.x.32] *Computing selected eigenvalues and, optionally, the eigenvectors. The eigenvalues/eigenvectors are selected by prescribing a range of values[2.x.205] for the eigenvalues. If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix. *[0.x.33] *Computing selected eigenvalues and, optionally, the eigenvectors of the real symmetric matrix[2.x.206] using the MRRR algorithm. The eigenvalues/eigenvectors are selected by prescribing a range of indices[2.x.207] If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix. If all eigenvalues/eigenvectors have to be computed, pass the closed interval[2.x.208] in[2.x.209] Pass the closed interval[2.x.210] if the[2.x.211] largest eigenvalues/eigenvectors are desired. *[0.x.34] *Computing selected eigenvalues and, optionally, the eigenvectors of the real symmetric matrix[2.x.212] using the MRRR algorithm. The eigenvalues/eigenvectors are selected by prescribing a range of values[2.x.213] for the eigenvalues. If successful, the computed eigenvalues are arranged in ascending order. The eigenvectors are stored in the columns of the matrix, thereby overwriting the original content of the matrix. *[0.x.35] *Computing the singular value decomposition(SVD) of a matrix[2.x.214], optionally computing the left and/or right singular vectors. The SVD is written as[2.x.215] with[2.x.216] as a diagonal matrix,[2.x.217] and[2.x.218] as orthogonal matrices. The diagonal elements of[2.x.219] are the singular values of[2.x.220] and the columns of[2.x.221] and[2.x.222] are the corresponding left and right singular vectors, respectively. The singular values are returned in decreasing order and only the first[2.x.223] columns of[2.x.224] and rows of[2.x.225] are computed. Upon return the content of the matrix is unusable. The matrix[2.x.226] must have identical block cyclic distribution for the rows and column. If left singular vectors are required matrices[2.x.227] and[2.x.228] have to be constructed with the same process grid and block cyclic distribution. If right singular vectors are required matrices[2.x.229] and[2.x.230] have to be constructed with the same process grid and block cyclic distribution. To avoid computing the left and/or right singular vectors the function accepts[2.x.231] for[2.x.232] and/or[2.x.233] *[0.x.36] *Solving overdetermined or underdetermined real linear systems involving matrix[2.x.234], or its transpose[2.x.235], using a QR or LQ factorization of[2.x.236] for[2.x.237] RHS vectors in the columns of matrix[2.x.238] It is assumed that[2.x.239] has full rank:[2.x.240] . The following options are supported:********- If(!transpose) and[2.x.241] :least squares solution of overdetermined system[2.x.242] .\n Upon exit the rows[2.x.243] to[2.x.244] of[2.x.245] contain the least square solution vectors. The residual sum of squares for each column is given by the sum of squares of elements[2.x.246] to[2.x.247] in that column. **************- If(!transpose) and[2.x.248] :find minimum norm solutions of underdetermined systems[2.x.249] .\n Upon exit the columns of[2.x.250] contain the minimum norm solution vectors. **************- If(transpose) and[2.x.251] :find minimum norm solutions of underdetermined system[2.x.252] .\n Upon exit the columns of[2.x.253] contain the minimum norm solution vectors. **************- If(transpose) and[2.x.254] :least squares solution of overdetermined system[2.x.255] .\n Upon exit the rows[2.x.256] to[2.x.257] contain the least square solution vectors. The residual sum of squares for each column is given by the sum of squares of elements[2.x.258] to[2.x.259] in that column. If(!tranpose) then[2.x.260], otherwise[2.x.261] . The matrices[2.x.262] and[2.x.263] must have an identical block cyclic distribution for rows and columns. *[0.x.37] *Compute the pseudoinverse[2.x.264](Moore-Penrose inverse) of a real matrix[2.x.265] using the singular value decomposition[2.x.266] . Unlike the inverse, the pseudoinverse[2.x.267] exists for both rectangular as well as singular matrices[2.x.268] . For a rectangular[2.x.269] the pseudoinverse is computed by taking the reciprocal of each non-zero element on the diagonal, leaving the zeros in place, and then transposing[2.x.270] . For the numerical computation only the singular values[2.x.271] are taken into account. Upon successful exit, the function returns the number of singular values fulfilling that condition. That value can be interpreted as the rank of[2.x.272] . Upon return this object contains the pseudoinverse[2.x.273] . The following alignment conditions have to be fulfilled:[2.x.274] . *[0.x.38] *Estimate the condition number of a SPD matrix in the[2.x.275] -norm. The matrix has to be in the Cholesky state(see compute_cholesky_factorization()). The reciprocal of the condition number is returned in order to avoid the possibility of overflow when the condition number is very large.[2.x.276] must contain the[2.x.277] -norm of the matrix prior to calling Cholesky factorization(see l1_norm()). *[2.x.278] An alternative is to compute the inverse of the matrix explicitly and manually construct[2.x.279] . *[0.x.39] *Compute the[2.x.280] -norm of the matrix. *[0.x.40] *Compute the[2.x.281] norm of the matrix. *[0.x.41] *Compute the Frobenius norm of the matrix. *[0.x.42] *Number of rows of the[2.x.282] matrix. *[0.x.43] *Number of columns of the[2.x.283] matrix. *[0.x.44] *Number of local rows on this MPI processes. *[0.x.45] *Number of local columns on this MPI process. *[0.x.46] *Return the global row number for the given local row[2.x.284] . *[0.x.47] *Return the global column number for the given local column[2.x.285] *[0.x.48] *Read access to local element. *[0.x.49] *Write access to local element. *[0.x.50] *Scale the columns of the distributed matrix by the scalars provided in the array[2.x.286] The array[2.x.287] must have as many entries as the matrix columns. Copies of[2.x.288] have to be available on all processes of the underlying MPI communicator. *[2.x.289] The fundamental prerequisite for the[2.x.290] is that it must be possible to create an ArrayView from it index</div><div class="ttdef"><b>Definition:</b> <a href="scalapack__0_8txt_source.html#l00250">scalapack_0.txt:250</a></div></div>
<div class="ttc" id="aparsed__convergence__table__0_8txt_html_a8a90f5ba57a42a3fd4c067e00f8b8aea"><div class="ttname"><a href="parsed__convergence__table__0_8txt.html#a8a90f5ba57a42a3fd4c067e00f8b8aea">p</a></div><div class="ttdeci">****This class simplifies the construction of convergence tables reading the options for the generation of the table from a parameter file It provides a series of methods that can be used to compute the error given a reference exact solution or the difference between two numerical solutions or any other custom computation of the error given via[2.x.1] objects *An example usage of this class is given by ****The above code constructs a ParsedConvergenceTable that works for scalar and will produce an error table with and Linfty_norm norms of the error *Whenever a call to the methods the instance of this class inspects its parameters computes all norms specified by the parameter given at construction time possibly modified via a parameter file computes all extra column entries specified using the method and writes one row of the convergence table *Once you have finished with the a call to and to the the same code can be used to estimate the errors of mixed or multi physics e and one component for the pressure field p</div><div class="ttdef"><b>Definition:</b> <a href="parsed__convergence__table__0_8txt_source.html#l00020">parsed_convergence_table_0.txt:20</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
