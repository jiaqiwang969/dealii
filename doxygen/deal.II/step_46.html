<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_46.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-46 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-46 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_22.html">step-22</a>, <a class="el" href="step_27.html">step-27</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thegeneralidea">The general idea</a>
        <li><a href="#Implementation">Implementation</a>
        <li><a href="#Specificsoftheimplementation"> Specifics of the implementation </a>
      <ul>
        <li><a href="#Dealingwiththeinterfaceterms">Dealing with the interface terms</a>
        <li><a href="#Velocityboundaryconditionsontheinterface">Velocity boundary conditions on the interface</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
      <ul>
        <li><a href="#Identifyingwhichsubdomainacellisin">Identifying which subdomain a cell is in</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Meshrefinement">Mesh refinement</a>
    </ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeFluidStructureProblemcodeclasstemplate">The <code>FluidStructureProblem</code> class template</a>
        <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a>
        <li><a href="#ThecodeFluidStructureProblemcodeimplementation">The <code>FluidStructureProblem</code> implementation</a>
      <ul>
        <li><a href="#Constructorsandhelperfunctions">Constructors and helper functions</a>
        <li><a href="#Meshesandassigningsubdomains">Meshes and assigning subdomains</a>
        <li><a href="#codeFluidStructureProblemsetup_dofscode"><code>FluidStructureProblem::setup_dofs</code></a>
        <li><a href="#codeFluidStructureProblemassemble_systemcode"><code>FluidStructureProblem::assemble_system</code></a>
        <li><a href="#codeFluidStructureProblemsolvecode"><code>FluidStructureProblem::solve</code></a>
        <li><a href="#codeFluidStructureProblemoutput_resultscode"><code>FluidStructureProblem::output_results</code></a>
        <li><a href="#codeFluidStructureProblemrefine_meshcode"><code>FluidStructureProblem::refine_mesh</code></a>
        <li><a href="#codeFluidStructureProblemruncode"><code>FluidStructureProblem::run</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#2dresults">2d results</a>
        <li><a href="#3dresults">3d results</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
        <li><a href="#Refinementindicators">Refinement indicators</a>
        <li><a href="#Verification">Verification</a>
        <li><a href="#Bettermodels">Better models</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The University of California &ndash; Davis. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program deals with the problem of coupling different physics in different parts of the domain. Specifically, let us consider the following situation that couples a Stokes fluid with an elastic solid (these two problems were previously discussed separately in <a class="el" href="step_22.html">step-22</a> and <a class="el" href="step_8.html">step-8</a>, where you may want to read up on the individual equations):</p>
<ul>
<li>In a part \(\Omega_f\) of \(\Omega\), we have a fluid flowing that satisfies the time independent Stokes equations (in the form that involves the strain tensor): <p class="formulaDsp">
\begin{align*} -2\eta\nabla \cdot \varepsilon(\mathbf v) + \nabla p &amp;= 0, \qquad \qquad &amp;&amp; \text{in}\ \Omega_f\\ -\nabla \cdot \mathbf v &amp;= 0 &amp;&amp; \text{in}\ \Omega_f. \end{align*}
</p>
 Here, \(\mathbf v, p\) are the fluid velocity and pressure, respectively. We prescribe the velocity on part of the external boundary, <p class="formulaDsp">
\begin{align*} \mathbf v = \mathbf v_0 \qquad\qquad \text{on}\ \Gamma_{f,1} \subset \partial\Omega \cap \partial\Omega_f \end{align*}
</p>
 while we assume free-flow conditions on the remainder of the external boundary, <p class="formulaDsp">
\begin{align*} (2\eta \varepsilon(\mathbf v) - p \mathbf 1) \cdot \mathbf n = 0 \qquad\qquad \text{on}\ \Gamma_{f,2} = \partial\Omega \cap \partial\Omega_f \backslash \Gamma_{f,1}. \end{align*}
</p>
</li>
<li>The remainder of the domain, \(\Omega_s = \Omega \backslash \Omega_f\) is occupied by a solid whose deformation field \(\mathbf u\) satisfies the elasticity equation, <p class="formulaDsp">
\begin{align*} -\nabla \cdot C \varepsilon(\mathbf u) = 0 \qquad\qquad &amp; \text{in}\ \Omega_s, \end{align*}
</p>
 where \(C\) is the rank-4 elasticity tensor (for which we will use a particularly simple form by assuming that the solid is isotropic). It deforms in reaction to the forces exerted by the fluid flowing along the boundary of the solid. We assume this deformation to be so small that it has no feedback effect on the fluid, i.e. the coupling is only in one direction. For simplicity, we will assume that the solid's external boundary is clamped, i.e. <p class="formulaDsp">
\begin{align*} \mathbf u = \mathbf 0 \qquad\qquad \text{on}\ \Gamma_{s,1} = \partial\Omega \cap \partial\Omega_s \end{align*}
</p>
</li>
<li>As a consequence of the small displacement assumption, we will pose the following boundary conditions on the interface between the fluid and solid: first, we have no slip boundary conditions for the fluid, <p class="formulaDsp">
\begin{align*} \mathbf v = \mathbf 0 \qquad\qquad \text{on}\ \Gamma_{i} = \partial\Omega_s \cap \partial\Omega_f. \end{align*}
</p>
 Secondly, the forces (traction) on the solid equal the normal stress from the fluid, <p class="formulaDsp">
\begin{align*} (C \varepsilon(\mathbf u)) \mathbf n = (2 \eta \varepsilon(\mathbf v) - p \mathbf 1) \mathbf n \qquad\qquad \text{on}\ \Gamma_{i} = \partial\Omega_s \cap \partial\Omega_f, \end{align*}
</p>
 where \(\mathbf{n}\) is the normal vector on \(\Gamma_{i}\) pointing from the solid to the fluid.</li>
</ul>
<p>We get a weak formulation of this problem by following our usual rule of multiplying from the left by a test function and integrating over the domain. It then looks like this: Find \(y = \{\mathbf v, p, \mathbf u\} \in Y \subset H^1(\Omega_f)^d \times L_2(\Omega_f) \times H^1(\Omega_s)^d\) such that </p><p class="formulaDsp">
\begin{align*} 2 \eta (\varepsilon(\mathbf a), \varepsilon(\mathbf v))_{\Omega_f} - (\nabla \cdot \mathbf a, p)_{\Omega_f} - (q, \nabla \cdot \mathbf v)_{\Omega_f} &amp; \\ + (\varepsilon(\mathbf b), C \varepsilon(\mathbf u))_{\Omega_s} &amp; \\ - (\mathbf b, (2 \eta \varepsilon(\mathbf v) - p \mathbf 1) \mathbf n)_{\Gamma_i} &amp;= 0, \end{align*}
</p>
<p> for all test functions \(\mathbf a, q, \mathbf b\); the first, second, and third lines correspond to the fluid, solid, and interface contributions, respectively. Note that \(Y\) is only a subspace of the spaces listed above to accommodate for the various Dirichlet boundary conditions.</p>
<p>This sort of coupling is of course possible by simply having two <a class="el" href="classTriangulation.html">Triangulation</a> and two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, one each for each of the two subdomains. On the other hand, deal.II is much simpler to use if there is a single <a class="el" href="classDoFHandler.html">DoFHandler</a> object that knows about the discretization of the entire problem.</p>
<p>This program is about how this can be achieved. Note that the goal is not to present a particularly useful physical model (a realistic fluid-structure interaction model would have to take into account the finite deformation of the solid and the effect this has on the fluid): this is, after all, just a tutorial program intended to demonstrate techniques, not to solve actual problems. Furthermore, we will make the assumption that the interface between the subdomains is aligned with coarse mesh cell faces.</p>
<p><a class="anchor" id="Thegeneralidea"></a></p><h3>The general idea</h3>
<p>Before going into more details let us state the obvious: this is a problem with multiple solution variables; for this, you will probably want to read the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> documentation module first, which presents the basic philosophical framework in which we address problems with more than one solution variable. But back to the problem at hand:</p>
<p>The fundamental idea to implement these sort of problems in deal.II goes as follows: in the problem formulation, the velocity and pressure variables \(\mathbf v, p\) only live in the fluid subdomain \(\Omega_f\). But let's assume that we extend them by zero to the entire domain \(\Omega\) (in the general case this means that they will be discontinuous along \(\Gamma_i\)). So what is the appropriate function space for these variables? We know that on \(\Omega_f\) we should require \(\mathbf v \in H^1(\Omega_f)^d, p \in L_2(\Omega_f)\), so for the extensions \(\tilde{\mathbf v}, \tilde p\) to the whole domain the following appears a useful set of function spaces: </p><p class="formulaDsp">
\begin{align*} \tilde {\mathbf v} &amp;\in V = \{\tilde {\mathbf v}|_{\Omega_f} \in H^1(\Omega_f)^d, \quad \tilde {\mathbf v}|_{\Omega_s} = 0 \} \\ \tilde p &amp;\in P = \{\tilde p|_{\Omega_f} \in L_2(\Omega_f), \quad \tilde p|_{\Omega_s} = 0 \}. \end{align*}
</p>
<p> (Since this is not important for the current discussion, we have omitted the question of boundary values from the choice of function spaces; this question also affects whether we can choose \(L_2\) for the pressure or whether we have to choose the space \(L_{2,0}(\Omega_f)=\{q\in L_2(\Omega_f): \int_{\Omega_f} q = 0\}\) for the pressure. None of these questions are relevant to the following discussion, however.)</p>
<p>Note that these are indeed a linear function spaces with obvious norm. Since no confusion is possible in practice, we will henceforth omit the tilde again to denote the extension of a function to the whole domain and simply refer by \(\mathbf v, p\) to both the original and the extended function.</p>
<p>For discretization, we need finite dimensional subspaces \(V_h,P_h\) of \(V, P\). For Stokes, we know from <a class="el" href="step_22.html">step-22</a> that an appropriate choice is \(Q_{p+1}^d\times Q_P\) but this only holds for that part of the domain occupied by the fluid. For the extended field, let's use the following subspaces defined on the triangulation \(\mathbb T\): </p><p class="formulaDsp">
\begin{align*} V_h &amp;= \{{\mathbf v}_h \quad | \quad \forall K \in {\mathbb T}: {\mathbf v}_h|_K \in Q_{p+1}^d\ \text{if}\ K\subset {\Omega_f}, \quad {\mathbf v}_h|_{\Omega_f}\ \text{is continuous}, \quad {\mathbf v}_h|_K = 0\ \text{if}\ K\subset {\Omega_s}\} &amp;&amp; \subset V \\ P_h &amp;= \{ p_h \quad | \quad \forall K \in {\mathbb T}: p_h|_K \in Q_p\ \text{if}\ K\subset {\Omega_f}, \quad p_h|_{\Omega_f}\ \text{is continuous}, \quad p_h|_K = 0\ \text{if}\ K\subset {\Omega_s}\ \} &amp;&amp; \subset P. \end{align*}
</p>
<p> In other words, on \(\Omega_f\) we choose the usual discrete spaces but we keep the (discontinuous) extension by zero. The point to make is that we now need a description of a finite element space for functions that are zero on a cell &mdash; and this is where the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> class comes in: it describes a finite dimensional function space of functions that are constant zero. A particular property of this peculiar linear vector space is that it has no degrees of freedom: it isn't just finite dimensional, it is in fact zero dimensional, and consequently for objects of this type, <a class="el" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">FiniteElement::n_dofs_per_cell()</a> will return zero. For discussion below, let us give this space a proper symbol: </p><p class="formulaDsp">
\[ Z = \{ \varphi: \varphi(x)=0 \}. \]
</p>
<p> The symbol \(Z\) reminds of the fact that functions in this space are zero. Obviously, we choose \(Z_h=Z\).</p>
<p>This entire discussion above can be repeated for the variables we use to describe the elasticity equation. Here, for the extended variables, we have </p><p class="formulaDsp">
\begin{align*} \tilde {\mathbf u} &amp;\in U = \{\tilde {\mathbf u}|_{\Omega_s} \in H^1(\Omega_f)^d, \quad \tilde {\mathbf u}|_{\Omega_f} \in Z(\Omega_s)^d \}, \end{align*}
</p>
<p> and we will typically use a finite element space of the kind </p><p class="formulaDsp">
\begin{align*} U_h &amp;= \{{\mathbf u}_h \quad | \quad \forall K \in {\mathbb T}: {\mathbf u}_h|_K \in Q_r^d\ \text{if}\ K\subset {\Omega_s}, \quad {\mathbf u}_h|_{\Omega_f}\ \text{is continuous}, \quad {\mathbf u}_h|_K \in Z^d\ \text{if}\ K\subset {\Omega_f}\} &amp;&amp; \subset U \end{align*}
</p>
<p> of polynomial degree \(r\).</p>
<p>So to sum up, we are going to look for a discrete vector-valued solution \(y_h = \{\mathbf v_h, p_h, \mathbf u_h\}\) in the following space: </p><p class="formulaDsp">
\begin{align*} Y_h = \{ &amp; y_h = \{\mathbf v_h, p_h, \mathbf u_h\} : \\ &amp; y_h|_{\Omega_f} \in Q_{p+1}^d \times Q_p \times Z^d, \\ &amp; y_h|_{\Omega_s} \in Z^d \times Z \times Q_r^d \}. \end{align*}
</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>So how do we implement this sort of thing? First, we realize that the discrete space \(Y_h\) essentially calls for two different finite elements: First, on the fluid subdomain, we need the element \(Q_{p+1}^d \times Q_p \times Z^d\) which in deal.II is readily implemented by </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(p+1), dim,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(p), 1,</div><div class="line">               <a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), dim),</div></div><!-- fragment --><p> where <code><a class="el" href="classFE__Nothing.html">FE_Nothing</a></code> implements the space of functions that are always zero. Second, on the solid subdomain, we need the element \(\in Z^d \times Z \times Q_r^d\), which we get using </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), dim,</div><div class="line">               <a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), 1,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(r), dim),</div></div><!-- fragment --><p>The next step is that we associate each of these two elements with the cells that occupy each of the two subdomains. For this we realize that in a sense the two elements are just variations of each other in that they have the same number of vector components but have different polynomial degrees &mdash; this smells very much like what one would do in \(hp\) finite element methods, and it is exactly what we are going to do here: we are going to (ab)use the classes and facilities of the hp-namespace to assign different elements to different cells. In other words, we will use collect the two finite elements in an <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>, will integrate with an appropriate <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> using an <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object, and our <a class="el" href="classDoFHandler.html">DoFHandler</a> will be in <em>hp</em>-mode. You may wish to take a look at <a class="el" href="step_27.html">step-27</a> for an overview of all of these concepts.</p>
<p>Before going on describing the testcase, let us clarify a bit <em>why</em> this approach of extending the functions by zero to the entire domain and then mapping the problem on to the hp-framework makes sense:</p>
<ul>
<li>It makes things uniform: On all cells, the number of vector components is the same (here, <code>2*dim+1</code>). This makes all sorts of things possible since a uniform description allows for code re-use. For example, counting degrees of freedom per vector component (<a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>), sorting degrees of freedom by component (<a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>), subsequent partitioning of matrices and vectors into blocks and many other functions work as they always did without the need to add special logic to them that describes cases where some of the variables only live on parts of the domain. Consequently, you have all sorts of tools already available to you in programs like the current one that weren't originally written for the multiphysics case but work just fine in the current context.</li>
<li>It allows for easy graphical output: All graphical output formats we support require that each field in the output is defined on all nodes of the mesh. But given that now all solution components live everywhere, our existing <a class="el" href="classDataOut.html">DataOut</a> routines work as they always did, and produce graphical output suitable for visualization &ndash; the fields will simply be extended by zero, a value that can easily be filtered out by visualization programs if not desired.</li>
<li>There is essentially no cost: The trick with the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> does not add any degrees of freedom to the overall problem, nor do we ever have to handle a shape function that belongs to these components &mdash; the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> has no degrees of freedom, not does it have shape functions, all it does is take up vector components.</li>
</ul>
<p><a class="anchor" id="Specificsoftheimplementation"></a></p><h3>Specifics of the implementation </h3>
<p>More specifically, in the program we have to address the following points:</p><ul>
<li>Implementing the bilinear form, and in particular dealing with the interface term, both in the matrix and the sparsity pattern.</li>
<li>Implementing Dirichlet boundary conditions on the external and internal parts of the boundaries \(\partial\Omega_f,\partial\Omega_s\).</li>
</ul>
<p><a class="anchor" id="Dealingwiththeinterfaceterms"></a></p><h4>Dealing with the interface terms</h4>
<p>Let us first discuss implementing the bilinear form, which at the discrete level we recall to be </p><p class="formulaDsp">
\begin{align*} 2 \eta (\varepsilon(\mathbf a_h), \varepsilon(\mathbf v_h))_{\Omega_f} - (\nabla \cdot \mathbf a_h, p_h)_{\Omega_f} - (q_h, \nabla \cdot \mathbf v_h)_{\Omega_f} &amp; \\ + (\varepsilon(\mathbf b_h), C \varepsilon(\mathbf u_h))_{\Omega_s} &amp; \\ - (\mathbf b_h, (2 \eta \varepsilon(\mathbf v_h) - p \mathbf 1) \mathbf n)_{\Gamma_i} &amp;= 0, \end{align*}
</p>
<p> Given that we have extended the fields by zero, we could in principle write the integrals over subdomains to the entire domain \(\Omega\), though it is little additional effort to first ask whether a cell is part of the elastic or fluid region before deciding which terms to integrate. Actually integrating these terms is not very difficult; for the Stokes equations, the relevant steps have been shown in <a class="el" href="step_22.html">step-22</a>, whereas for the elasticity equation we take essentially the form shown in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module (rather than the one from <a class="el" href="step_8.html">step-8</a>).</p>
<p>The term that is of more interest is the interface term, </p><p class="formulaDsp">
\[ -(\mathbf b_h, (2 \eta \varepsilon(\mathbf v_h) - p \mathbf 1) \mathbf n)_{\Gamma_i}. \]
</p>
<p> Based on our assumption that the interface \(\Gamma_i\) coincides with cell boundaries, this can in fact be written as a set of face integrals. If we denote the velocity, pressure and displacement components of shape function \(\psi_i\in Y_h\) using the extractor notation \(\psi_i[\mathbf v],\psi_i[p], \psi_i[\mathbf u]\), then the term above yields the following contribution to the global matrix entry \(i,j\): </p><p class="formulaDsp">
\[ -\sum_K (\psi_i[\mathbf u], (2 \eta \varepsilon(\psi_j[\mathbf v]) - \psi_j[p] \mathbf 1) \mathbf n)_{\partial K \cap \Gamma_i}. \]
</p>
<p> Although it isn't immediately obvious, this term presents a slight complication: while \(\psi_i[\mathbf u]\) and \(\mathbf n\) are evaluated on the solid side of the interface (they are test functions for the displacement and the normal vector to \(\Omega_s\), respectively, we need to evaluate \(\psi_j[\mathbf v],\psi_j[p]\) on the fluid side of the interface since they correspond to the stress/force exerted by the fluid. In other words, in our implementation, we will need FEFaceValue objects for both sides of the interface. To make things slightly worse, we may also have to deal with the fact that one side or the other may be refined, leaving us with the need to integrate over parts of a face. Take a look at the implementation below on how to deal with this.</p>
<p>As an additional complication, the matrix entries that result from this term need to be added to the sparsity pattern of the matrix somehow. This is the realm of various functions in the <a class="el" href="namespaceDoFTools.html">DoFTools</a> namespace like <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> and <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>. Essentially, what these functions do is simulate what happens during assembly of the system matrix: whenever assembly would write a nonzero entry into the global matrix, the functions in <a class="el" href="namespaceDoFTools.html">DoFTools</a> would add an entry to the sparsity pattern. We could therefore do the following: let <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> add all those entries to the sparsity pattern that arise from the regular cell-by-cell integration, and then do the same by hand that arise from the interface terms. If you look at the implementation of the interface integrals in the program below, it should be obvious how to do that and would require no more than maybe 100 lines of code at most.</p>
<p>But we're lazy people: the interface term couples degrees of freedom from two adjacent cells along a face, which is exactly the kind of thing one would do in discontinuous Galerkin schemes for which the function <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> was written. This is a superset of matrix entries compared to the usual <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>: it will also add all entries that result from computing terms coupling the degrees of freedom from both sides of all faces. Unfortunately, for the simplest version of this function, this is a pretty big superset. Consider for example the following mesh with two cells and a \(Q_1\) finite element: </p><div class="fragment"><div class="line">2---3---5</div><div class="line">|   |   |</div><div class="line">0---1---4</div></div><!-- fragment --><p> Here, the sparsity pattern produced by <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> will only have entries for degrees of freedom that couple on a cell. However, it will not have sparsity pattern entries \((0,4),(0,5),(2,4),(2,5)\). The sparsity pattern generated by <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> will have these entries, however: it assumes that you want to build a sparsity pattern for a bilinear form that couples <em>all</em> degrees of freedom from adjacent cells. This is not what we want: our interface term acts only on a small subset of cells, and we certainly don't need all the extra couplings between two adjacent fluid cells, or two adjacent solid cells. Furthermore, the fact that we use higher order elements means that we would really generate many many more entries than we actually need: on the coarsest mesh, in 2d, 44,207 nonzero entries instead of 16,635 for <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>, leading to plenty of zeros in the matrix we later build (of course, the 16,635 are not enough since they don't include the interface entries). This ratio would be even worse in 3d.</p>
<p>So being extremely lazy comes with a cost: too many entries in the matrix. But we can get away with being moderately lazy: there is a variant of <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> that allows us to specify which vector components of the finite element couple with which other components, both in cell terms as well as in face terms. For cells that are in the solid subdomain, we couple all displacements with each other; for fluid cells, all velocities with all velocities and the pressure, but not the pressure with itself. Since no cell has both sets of variables, there is no need to distinguish between the two kinds of cells, so we can write the mask like this: </p><div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> cell_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                           fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    <span class="keywordflow">if</span> (((c&lt;dim+1) &amp;&amp; (d&lt;dim+1)</div><div class="line">         &amp;&amp; !((c==dim) &amp;&amp; (d==dim)))</div><div class="line">        ||</div><div class="line">        ((c&gt;=dim+1) &amp;&amp; (d&gt;=dim+1)))</div><div class="line">      cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::Coupling::always</a>;</div></div><!-- fragment --><p> Here, we have used the fact that the first <code>dim</code> components of the finite element are the velocities, then the pressure, and then the <code>dim</code> displacements. (We could as well have stated that the velocities/pressure also couple with the displacements since no cell ever has both sets of variables.) On the other hand, the interface terms require a mask like this: </p><div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> face_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                           fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    <span class="keywordflow">if</span> ((c&gt;=dim+1) &amp;&amp; (d&lt;dim+1))</div><div class="line">      face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::Coupling::always</a>;</div></div><!-- fragment --><p> In other words, all displacement test functions (components <code>c&gt;=dim+1</code>) couple with all velocity and pressure shape functions on the other side of an interface. This is not entirely true, though close: in fact, the exact form of the interface term only those pressure displacement shape functions that are indeed nonzero on the common interface, which is not true for all shape functions; on the other hand, it really couples all velocities (since the integral involves gradients of the velocity shape functions, which are all nonzero on all faces of the cell). However, the mask we build above, is not capable of these subtleties. Nevertheless, through these masks we manage to get the number of sparsity pattern entries down to 21,028 &mdash; good enough for now.</p>
<p><a class="anchor" id="Velocityboundaryconditionsontheinterface"></a></p><h4>Velocity boundary conditions on the interface</h4>
<p>The second difficulty is that while we know how to enforce a zero velocity or stress on the external boundary (using <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, called with an appropriate component mask and setting different boundary indicators for solid and fluid external boundaries), we now also needed the velocity to be zero on the interior interface, i.e. \(\mathbf v|_{\Gamma_i}=0\). At the time of writing this, there is no function in deal.II that handles this part, but it isn't particularly difficult to implement by hand: essentially, we just have to loop over all cells, and if it is a fluid cell and its neighbor is a solid cell, then add constraints that ensure that the velocity degrees of freedom on this face are zero. Some care is necessary to deal with the case that the adjacent solid cell is refined, yielding the following code: </p><div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; local_face_dof_indices (stokes_fe.dofs_per_face);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell: dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell))</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">      <span class="keywordflow">if</span> (!cell-&gt;at_boundary(f))</div><div class="line">        {</div><div class="line">          <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>)</div><div class="line">                  &amp;&amp;</div><div class="line">                  (cell_is_in_solid_domain (cell-&gt;neighbor(f))))</div><div class="line">                face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">                {</div><div class="line">              <span class="comment">// The neighbor does have children. See if any of the cells</span></div><div class="line">              <span class="comment">// on the other side are elastic</span></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf=0; sf&lt;cell-&gt;face(f)-&gt;n_children(); ++sf)</div><div class="line">                    <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell-&gt;neighbor_child_on_subface(f, sf)))</div><div class="line">                      {</div><div class="line">                   face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                            <span class="keywordflow">break</span>;</div><div class="line">                      }</div><div class="line">                }</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">           {</div><div class="line">             cell-&gt;face(f)-&gt;get_dof_indices (local_face_dof_indices, 0);</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;local_face_dof_indices.size(); ++i)</div><div class="line">             <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt; dim)</div><div class="line">               constraints.add_line (local_face_dof_indices[i]);</div><div class="line">           }</div><div class="line">        }</div></div><!-- fragment --><p>The call <code>constraints.add_line(t)</code> tells the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> to start a new constraint for degree of freedom <code>t</code> of the form \(x_t=\sum_{l=0}^{N-1} c_{tl} x_l + b_t\). Typically, one would then proceed to set individual coefficients \(c_{tl}\) to nonzero values (using <a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">AffineConstraints::add_entry</a>) or set \(b_t\) to something nonzero (using <a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">AffineConstraints::set_inhomogeneity</a>); doing nothing as above, funny as it looks, simply leaves the constraint to be \(x_t=0\), which is exactly what we need in the current context. The call to <a class="el" href="classFiniteElement.html#aecb73242a6dca33f8da1bb44a5f00d61">FiniteElement::face_system_to_component_index</a> makes sure that we only set boundary values to zero for velocity but not pressure components.</p>
<p>Note that there are cases where this may yield incorrect results: notably, once we find a solid neighbor child to a current fluid cell, we assume that all neighbor children on the common face are in the solid subdomain. But that need not be so; consider, for example, the following mesh: </p><div class="fragment"><div class="line">+---------+----+----+</div><div class="line">|         | f  |    |</div><div class="line">|    f    +----+----+</div><div class="line">|         | s  |    |</div><div class="line">+---------+----+----+</div></div><!-- fragment --><p>In this case, we would set all velocity degrees of freedom on the right face of the left cell to zero, which is incorrect for the top degree of freedom on that face. That said, that can only happen if the fluid and solid subdomains do not coincide with a set of complete coarse mesh cells &mdash; but this is a contradiction to the assumption stated at the end of the first section of this introduction.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>We will consider the following situation as a testcase:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.layout.png"/>
</div>
<p>As discussed at the top of this document, we need to assume in a few places that a cell is either entirely in the fluid or solid part of the domain and, furthermore, that all children of an inactive cell also belong to the same subdomain. This can definitely be ensured if the coarse mesh already subdivides the mesh into solid and fluid coarse mesh cells; given the geometry outlined above, we can do that by using an \(8\times 8\) coarse mesh, conveniently provided by the <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> function.</p>
<p>The fixed boundary at the bottom implies \(\mathbf u=0\), and we also prescribe Dirichlet conditions for the flow at the top so that we get inflow at the left and outflow at the right. At the left and right boundaries, no boundary conditions are imposed explicitly for the flow, yielding the implicit no-stress condition \((2\eta \varepsilon(\mathbf v) - p \mathbf 1) \cdot \mathbf n = 0\). The conditions on the interface between the two domains has already been discussed above.</p>
<p>For simplicity, we choose the material parameters to be \(\eta=\lambda=\mu=1\). In the results section below, we will also show a 3d simulation that can be obtained from the same program. The boundary conditions and geometry are defined nearly analogously to the 2d situation above.</p>
<p><a class="anchor" id="Identifyingwhichsubdomainacellisin"></a></p><h4>Identifying which subdomain a cell is in</h4>
<p>In the program, we need a way to identify which part of the domain a cell is in. There are many different ways of doing this. A typical way would be to use the <a class="el" href="DEALGlossary.html#GlossSubdomainId">subdomain_id</a> tag available with each cell, though this field has a special meaning in parallel computations. An alternative is the <a class="el" href="DEALGlossary.html#GlossMaterialId">material_id</a> field also available with every cell. It has the additional advantage that it is inherited from the mother to the child cell upon mesh refinement; in other words, we would set the material id once upon creating the mesh and it will be correct for all active cells even after several refinement cycles. We therefore go with this alternative: we define an <code>enum</code> with symbolic names for material_id numbers and will use them to identify which part of the domain a cell is on.</p>
<p>Secondly, we use an object of type <a class="el" href="classDoFHandler.html">DoFHandler</a> operating in <em>hp</em>-mode. This class needs to know which cells will use the Stokes and which the elasticity finite element. At the beginning of each refinement cycle we will therefore have to walk over all cells and set the (in hp-parlance) active FE index to whatever is appropriate in the current situation. While we can use symbolic names for the material id, the active FE index is in fact a number that will frequently be used to index into collections of objects (e.g. of type <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> and <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>); that means that the active FE index actually has to have value zero for the fluid and one for the elastic part of the domain.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h4>Linear solvers</h4>
<p>This program is primarily intended to show how to deal with different physics in different parts of the domain, and how to implement such models in deal.II. As a consequence, we won't bother coming up with a good solver: we'll just use the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class which always works, even if not with optimal complexity. We will, however, comment on possible other solvers in the <a href="#Results">results</a> section.</p>
<p><a class="anchor" id="Meshrefinement"></a></p><h4>Mesh refinement</h4>
<p>One of the trickier aspects of this program is how to estimate the error. Because it works on almost any program, we'd like to use the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>, and we can relatively easily do that here as well using code like the following: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> stokes_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> elasticity_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; stokes_component_mask (dim+1+dim, <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">  stokes_component_mask[d] = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                    face_q_collection,</div><div class="line">                                    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>*&gt;(),</div><div class="line">                                    solution,</div><div class="line">                                    stokes_estimated_error_per_cell,</div><div class="line">                                    stokes_component_mask);</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; elasticity_component_mask (dim+1+dim, <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">  elasticity_component_mask[dim+1+d] = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                    face_q_collection,</div><div class="line">                                    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>*&gt;(),</div><div class="line">                                    solution,</div><div class="line">                                    elasticity_estimated_error_per_cell,</div><div class="line">                                    elasticity_component_mask);</div></div><!-- fragment --><p> This gives us two sets of error indicators for each cell. We would then somehow combine them into one for mesh refinement, for example using something like the following (note that we normalize the squared error indicator in the two vectors because error quantities have physical units that do not match in the current situation, leading to error indicators that may differ by orders of magnitude between the two subdomains): </p><div class="fragment"><div class="line">stokes_estimated_error_per_cell /= stokes_estimated_error_per_cell.l2_norm();</div><div class="line">elasticity_estimated_error_per_cell /= elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">estimated_error_per_cell += elasticity_estimated_error_per_cell;</div></div><!-- fragment --><p> (In the code, we actually weigh the error indicators 4:1 in favor of the ones computed on the Stokes subdomain since refinement is otherwise heavily biased towards the elastic subdomain, but this is just a technicality. The factor 4 has been determined heuristically to work reasonably well.)</p>
<p>While this principle is sound, it doesn't quite work as expected. The reason is that the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class computes error indicators by integrating the jump in the solution's gradient around the faces of each cell. This jump is likely to be very large at the locations where the solution is discontinuous and extended by zero; it also doesn't become smaller as the mesh is refined. The <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class can't just ignore the interface because it essentially only sees a <a class="el" href="classDoFHandler.html">DoFHandler</a> in <em>hp</em>-mode where the element type changes from one cell to another &mdash; precisely the thing that the <em>hp</em>-mode was designed for, the interface in the current program looks no different than the interfaces in <a class="el" href="step_27.html">step-27</a>, for example, and certainly no less legitimate. Be that as it may, the end results is that there is a layer of cells on both sides of the interface between the two subdomains where error indicators are irrationally large. Consequently, most of the mesh refinement is focused on the interface.</p>
<p>This clearly wouldn't happen if we had a refinement indicator that actually understood something about the problem and simply ignore the interface between subdomains when integrating jump terms. On the other hand, this program is about showing how to represent problems where we have different physics in different subdomains, not about the peculiarities of the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>, and so we resort to the big hammer called "heuristics": we simply set the error indicators of cells at the interface to zero. This cuts off the spikes in the error indicators. At first sight one would also think that it prevents the mesh from being refined at the interface, but the requirement that neighboring cells may only differ by one level of refinement will still lead to a reasonably refined mesh.</p>
<p>While this is clearly a suboptimal solution, it works for now and leaves room for future improvement.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The include files for this program are the same as for many others before. The only new one is the one that declares <a class="el" href="classFE__Nothing.html">FE_Nothing</a> as discussed in the introduction. The ones in the hp directory have already been discussed in <a class="el" href="step_27.html">step-27</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step46</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeFluidStructureProblemcodeclasstemplate"></a> </p><h3>The <code>FluidStructureProblem</code> class template</h3>
<p>This is the main class. It is, if you want, a combination of <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_22.html">step-22</a> in that it has member variables that either address the global problem (the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, as well as the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> and various linear algebra objects) or that pertain to either the elasticity or Stokes sub-problems. The general structure of the class, however, is like that of most of the other programs implementing stationary problems.</p>
<p>There are a few helper functions (<code>cell_is_in_fluid_domain, cell_is_in_solid_domain</code>) of self-explanatory nature (operating on the symbolic names for the two subdomains that will be used as material_ids for cells belonging to the subdomains, as explained in the introduction) and a few functions (<code>make_grid, set_active_fe_indices, assemble_interface_terms</code>) that have been broken out of other functions that can be found in many of the other tutorial programs and that will be discussed as we get to their implementation.</p>
<p>The final set of variables (<code>viscosity, lambda, eta</code>) describes the material properties used for the two physics models.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>FluidStructureProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  FluidStructureProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">enum</span></div><div class="line">  {</div><div class="line">    fluid_domain_id,</div><div class="line">    solid_domain_id</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_fluid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_solid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> set_active_fe_indices();</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_interface_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">    std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">    std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         stokes_fe;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         elasticity_fe;</div><div class="line">  <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>       dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lambda;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3>Boundary values and right hand side</h3>
<p>The following class does as its name suggests. The boundary values for the velocity are \(\mathbf u=(0, \sin(\pi x))^T\) in 2d and \(\mathbf u=(0, 0, \sin(\pi x)\sin(\pi y))^T\) in 3d, respectively. The remaining boundary conditions for this problem are all homogeneous and have been discussed in the introduction. The right hand side forcing term is zero for both the fluid and the solid so we don't need an extra class for it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StokesBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1 + dim)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> StokesBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (component == dim - 1)</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]);</div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[1]);</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesBoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = StokesBoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeFluidStructureProblemcodeimplementation"></a> </p><h3>The <code>FluidStructureProblem</code> implementation</h3>
<p><a class="anchor" id="Constructorsandhelperfunctions"></a> </p><h4>Constructors and helper functions</h4>
<p>Let's now get to the implementation of the primary class of this program. The first few functions are the constructor and the helper functions that can be used to determine which part of the domain a cell is in. Given the discussion of these topics in the introduction, their implementation is rather obvious. In the constructor, note that we have to construct the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> object from the base elements for Stokes and elasticity; using the <a class="el" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">hp::FECollection::push_back</a> function assigns them spots zero and one in this collection, an order that we have to remember and use consistently in the rest of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">FluidStructureProblem&lt;dim&gt;::FluidStructureProblem(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree)</div><div class="line">  : stokes_degree(stokes_degree)</div><div class="line">  , elasticity_degree(elasticity_degree)</div><div class="line">  , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1),</div><div class="line">              dim,</div><div class="line">              <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree),</div><div class="line">              1,</div><div class="line">              <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">              dim)</div><div class="line">  , elasticity_fe(<a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                  dim,</div><div class="line">                  <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                  1,</div><div class="line">                  <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(elasticity_degree),</div><div class="line">                  dim)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , viscosity(2)</div><div class="line">  , lambda(1)</div><div class="line">  , mu(1)</div><div class="line">{</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(stokes_fe);</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(elasticity_fe);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_fluid_domain(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (cell-&gt;material_id() == fluid_domain_id);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_solid_domain(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (cell-&gt;material_id() == solid_domain_id);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Meshesandassigningsubdomains"></a> </p><h4>Meshes and assigning subdomains</h4>
<p>The next pair of functions deals with generating a mesh and making sure all flags that denote subdomains are correct. <code>make_grid</code>, as discussed in the introduction, generates an \(8\times 8\) mesh (or an \(8\times 8\times 8\) mesh in 3d) to make sure that each coarse mesh cell is completely within one of the subdomains. After generating this mesh, we loop over its boundary and set the boundary indicator to one at the top boundary, the only place where we set nonzero Dirichlet boundary conditions. After this, we loop again over all cells to set the material indicator &mdash; used to denote which part of the domain we are in, to either the fluid or solid indicator.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 8, -1, 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; (face-&gt;center()[dim - 1] == 1))</div><div class="line">        face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &lt; 0.25) &amp;&amp;</div><div class="line">         (cell-&gt;center()[dim - 1] &gt; 0.5)) ||</div><div class="line">        ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &gt;= 0.25) &amp;&amp;</div><div class="line">         (cell-&gt;center()[dim - 1] &gt; -0.5)))</div><div class="line">      cell-&gt;set_material_id(fluid_domain_id);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      cell-&gt;set_material_id(solid_domain_id);</div><div class="line">}</div></div><!-- fragment --><p>The second part of this pair of functions determines which finite element to use on each cell. Above we have set the material indicator for each coarse mesh cell, and as mentioned in the introduction, this information is inherited from mother to child cell upon mesh refinement.</p>
<p>In other words, whenever we have refined (or created) the mesh, we can rely on the material indicators to be a correct description of which part of the domain a cell is in. We then use this to set the active FE index of the cell to the corresponding element of the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> member variable of this class: zero for fluid cells, one for solid cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::set_active_fe_indices()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">        cell-&gt;set_active_fe_index(0);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">        cell-&gt;set_active_fe_index(1);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemsetup_dofscode"></a> </p><h4><code>FluidStructureProblem::setup_dofs</code></h4>
<p>The next step is to setup the data structures for the linear system. To this end, we first have to set the active FE indices with the function immediately above, then distribute degrees of freedom, and then determine constraints on the linear system. The latter includes hanging node constraints as usual, but also the inhomogeneous boundary values at the top fluid boundary, and zero boundary values along the perimeter of the solid subdomain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  set_active_fe_indices();</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_collection);</div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             StokesBoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints,</div><div class="line">                                             fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(</div><div class="line">                                               velocities));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      dof_handler,</div><div class="line">      0,</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1 + dim),</div><div class="line">      constraints,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line">  }</div></div><!-- fragment --><p>There are more constraints we have to handle, though: we have to make sure that the velocity is zero at the interface between fluid and solid. The following piece of code was already presented in the introduction:</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_face_dof_indices(</div><div class="line">    stokes_fe.n_dofs_per_face());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">          {</div><div class="line">            <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (cell_is_in_solid_domain(cell-&gt;neighbor(face_no))))</div><div class="line">              face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf = 0;</div><div class="line">                     sf &lt; cell-&gt;face(face_no)-&gt;n_children();</div><div class="line">                     ++sf)</div><div class="line">                  <span class="keywordflow">if</span> (cell_is_in_solid_domain(</div><div class="line">                        cell-&gt;neighbor_child_on_subface(face_no, sf)))</div><div class="line">                    {</div><div class="line">                      face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                      <span class="keywordflow">break</span>;</div><div class="line">                    }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">              {</div><div class="line">                cell-&gt;face(face_no)-&gt;get_dof_indices(local_face_dof_indices,</div><div class="line">                                                     0);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; local_face_dof_indices.size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt;</div><div class="line">                      dim)</div><div class="line">                    constraints.add_line(local_face_dof_indices[i]);</div><div class="line">              }</div><div class="line">          }</div><div class="line">}</div></div><!-- fragment --><p>At the end of all this, we can declare to the constraints object that we now have all constraints ready to go and that the object can rebuild its internal data structures for better efficiency:</p>
<div class="fragment"><div class="line">constraints.close();</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>In the rest of this function we create a sparsity pattern as discussed extensively in the introduction, and use it to initialize the matrix; then also set vectors to their correct sizes:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> cell_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> face_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (((c &lt; dim + 1) &amp;&amp; (d &lt; dim + 1) &amp;&amp;</div><div class="line">               !((c == dim) &amp;&amp; (d == dim))) ||</div><div class="line">              ((c &gt;= dim + 1) &amp;&amp; (d &gt;= dim + 1)))</div><div class="line">            cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((c &gt;= dim + 1) &amp;&amp; (d &lt; dim + 1))</div><div class="line">            face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler,</div><div class="line">                                         dsp,</div><div class="line">                                         cell_coupling,</div><div class="line">                                         face_coupling);</div><div class="line">    constraints.condense(dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemassemble_systemcode"></a> </p><h4><code>FluidStructureProblem::assemble_system</code></h4>
<p>Following is the central function of this program: the one that assembles the linear system. It has a long section of setting up auxiliary functions at the beginning: from creating the quadrature formulas and setting up the <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects necessary to integrate the cell terms as well as the interface terms for the case where cells along the interface come together at same size or with differing levels of refinement...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> stokes_quadrature(stokes_degree + 2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> elasticity_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a> q_collection;</div><div class="line">  q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_quadrature);</div><div class="line">  q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(elasticity_quadrature);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div><div class="line">                                 q_collection,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; common_face_quadrature(</div><div class="line">    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(stokes_degree + 2, elasticity_degree + 2));</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    stokes_fe_face_values(stokes_fe,</div><div class="line">                                          common_face_quadrature,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    elasticity_fe_face_values(elasticity_fe,</div><div class="line">                                              common_face_quadrature,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> stokes_fe_subface_values(stokes_fe,</div><div class="line">                                                common_face_quadrature,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> elasticity_fe_subface_values(elasticity_fe,</div><div class="line">                                                    common_face_quadrature,</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div></div><!-- fragment --><p>...to objects that are needed to describe the local contributions to the global linear system...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_dofs_per_cell =</div><div class="line">  elasticity_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix;</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_interface_matrix(elasticity_dofs_per_cell,</div><div class="line">                                          stokes_dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs;</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">std::vector&lt;types::global_dof_index&gt; neighbor_dof_indices(</div><div class="line">  stokes_dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> right_hand_side(dim + 1);</div></div><!-- fragment --><p>...to variables that allow us to extract certain components of the shape functions and cache their values rather than having to recompute them at every quadrature point:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; stokes_symgrad_phi_u(</div><div class="line">  stokes_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; stokes_div_phi_u(stokes_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; stokes_phi_p(stokes_dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;2, dim&gt;&gt; elasticity_grad_phi(elasticity_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         elasticity_div_phi(elasticity_dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; elasticity_phi(elasticity_dofs_per_cell);</div></div><!-- fragment --><p>Then comes the main loop over all cells and, as in <a class="el" href="step_27.html">step-27</a>, the initialization of the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object for the current cell and the extraction of a <a class="el" href="classFEValues.html">FEValues</a> object that is appropriate for the current cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    hp_fe_values.reinit(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div><div class="line"></div><div class="line">    local_matrix.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(),</div><div class="line">                        cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">    local_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p>With all of this done, we continue to assemble the cell terms for cells that are part of the Stokes and elastic regions. While we could in principle do this in one formula, in effect implementing the one bilinear form stated in the introduction, we realize that our finite element spaces are chosen in such a way that on each cell, one set of variables (either velocities and pressure, or displacements) are always zero, and consequently a more efficient way of computing local integrals is to do only what's necessary based on an <code>if</code> clause that tests which part of the domain we are in.</p>
<p>The actual computation of the local matrix is the same as in <a class="el" href="step_22.html">step-22</a> as well as that given in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> documentation module for the elasticity equations:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == stokes_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            stokes_symgrad_phi_u[k] =</div><div class="line">              fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">            stokes_div_phi_u[k] =</div><div class="line">              fe_values[velocities].divergence(k, q);</div><div class="line">            stokes_phi_p[k] = fe_values[pressure].value(k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            local_matrix(i, j) +=</div><div class="line">              (2 * viscosity * stokes_symgrad_phi_u[i] *</div><div class="line">                 stokes_symgrad_phi_u[j] -</div><div class="line">               stokes_div_phi_u[i] * stokes_phi_p[j] -</div><div class="line">               stokes_phi_p[i] * stokes_div_phi_u[j]) *</div><div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == elasticity_dofs_per_cell,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            elasticity_grad_phi[k] =</div><div class="line">              fe_values[displacements].gradient(k, q);</div><div class="line">            elasticity_div_phi[k] =</div><div class="line">              fe_values[displacements].divergence(k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              local_matrix(i, j) +=</div><div class="line">                (lambda * elasticity_div_phi[i] *</div><div class="line">                   elasticity_div_phi[j] +</div><div class="line">                 mu * <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                     elasticity_grad_phi[j]) +</div><div class="line">                 mu *</div><div class="line">                   <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                  <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(elasticity_grad_phi[j]))) *</div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Once we have the contributions from cell integrals, we copy them into the global matrix (taking care of constraints right away, through the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a> function). Note that we have not written anything into the <code>local_rhs</code> variable, though we still need to pass it along since the elimination of nonzero boundary values requires the modification of local and consequently also global right hand side values:</p>
<div class="fragment"><div class="line">local_dof_indices.resize(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                       local_rhs,</div><div class="line">                                       local_dof_indices,</div><div class="line">                                       system_matrix,</div><div class="line">                                       system_rhs);</div></div><!-- fragment --><p>The more interesting part of this function is where we see about face terms along the interface between the two subdomains. To this end, we first have to make sure that we only assemble them once even though a loop over all faces of all cells would encounter each part of the interface twice. We arbitrarily make the decision that we will only evaluate interface terms if the current cell is part of the solid subdomain and if, consequently, a face is not at the boundary and the potential neighbor behind it is part of the fluid domain. Let's start with these conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">      {</div></div><!-- fragment --><p>At this point we know that the current cell is a candidate for integration and that a neighbor behind face <code>f</code> exists. There are now three possibilities:</p>
<ul>
<li>The neighbor is at the same refinement level and has no children.</li>
<li>The neighbor has children.</li>
<li>The neighbor is coarser.</li>
</ul>
<p>In all three cases, we are only interested in it if it is part of the fluid subdomain. So let us start with the first and simplest case: if the neighbor is at the same level, has no children, and is a fluid cell, then the two cells share a boundary that is part of the interface along which we want to integrate interface terms. All we have to do is initialize two <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object with the current face and the face of the neighboring cell (note how we find out which face of the neighboring cell borders on the current cell) and pass things off to the function that evaluates the interface terms (the third through fifth arguments to this function provide it with scratch arrays). The result is then again copied into the global matrix, using a function that knows that the DoF indices of rows and columns of the local matrix result from different cells:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">    (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">    cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">  {</div><div class="line">    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">    stokes_fe_face_values.reinit(cell-&gt;neighbor(f),</div><div class="line">                                 cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                            stokes_fe_face_values,</div><div class="line">                            elasticity_phi,</div><div class="line">                            stokes_symgrad_phi_u,</div><div class="line">                            stokes_phi_p,</div><div class="line">                            local_interface_matrix);</div><div class="line"></div><div class="line">    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">    constraints.distribute_local_to_global(</div><div class="line">      local_interface_matrix,</div><div class="line">      local_dof_indices,</div><div class="line">      neighbor_dof_indices,</div><div class="line">      system_matrix);</div><div class="line">  }</div></div><!-- fragment --><p>The second case is if the neighbor has further children. In that case, we have to loop over all the children of the neighbor to see if they are part of the fluid subdomain. If they are, then we integrate over the common interface, which is a face for the neighbor and a subface of the current cell, requiring us to use an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for the neighbor and an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> for the current cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">         (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface = 0;</div><div class="line">         subface &lt; cell-&gt;face(f)-&gt;n_children();</div><div class="line">         ++subface)</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(</div><div class="line">            cell-&gt;neighbor_child_on_subface(f, subface)))</div><div class="line">        {</div><div class="line">          elasticity_fe_subface_values.reinit(cell, f, subface);</div><div class="line">          stokes_fe_face_values.reinit(</div><div class="line">            cell-&gt;neighbor_child_on_subface(f, subface),</div><div class="line">            cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">          assemble_interface_term(elasticity_fe_subface_values,</div><div class="line">                                  stokes_fe_face_values,</div><div class="line">                                  elasticity_phi,</div><div class="line">                                  stokes_symgrad_phi_u,</div><div class="line">                                  stokes_phi_p,</div><div class="line">                                  local_interface_matrix);</div><div class="line"></div><div class="line">          cell-&gt;neighbor_child_on_subface(f, subface)</div><div class="line">            -&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(</div><div class="line">            local_interface_matrix,</div><div class="line">            local_dof_indices,</div><div class="line">            neighbor_dof_indices,</div><div class="line">            system_matrix);</div><div class="line">        }</div><div class="line">  }</div></div><!-- fragment --><p>The last option is that the neighbor is coarser. In that case we have to use an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object for the neighbor and a <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for the current cell; the rest is the same as before:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                       cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                {</div><div class="line">                  elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                  stokes_fe_subface_values.reinit(</div><div class="line">                    cell-&gt;neighbor(f),</div><div class="line">                    cell-&gt;neighbor_of_coarser_neighbor(f).first,</div><div class="line">                    cell-&gt;neighbor_of_coarser_neighbor(f).second);</div><div class="line"></div><div class="line">                  assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                          stokes_fe_subface_values,</div><div class="line">                                          elasticity_phi,</div><div class="line">                                          stokes_symgrad_phi_u,</div><div class="line">                                          stokes_phi_p,</div><div class="line">                                          local_interface_matrix);</div><div class="line"></div><div class="line">                  cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                  constraints.distribute_local_to_global(</div><div class="line">                    local_interface_matrix,</div><div class="line">                    local_dof_indices,</div><div class="line">                    neighbor_dof_indices,</div><div class="line">                    system_matrix);</div><div class="line">                }</div><div class="line">            }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the function that assembles the global system, we passed computing interface terms to a separate function we discuss here. The key is that even though we can't predict the combination of <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects, they are both derived from the <a class="el" href="classFEFaceValuesBase.html">FEFaceValuesBase</a> class and consequently we don't have to care: the function is simply called with two such objects denoting the values of the shape functions on the quadrature points of the two sides of the face. We then do what we always do: we fill the scratch arrays with the values of shape functions and their derivatives, and then loop over all entries of the matrix to compute the local integrals. The details of the bilinear form we evaluate here are given in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_interface_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">  std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">  std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a> ==</div><div class="line">           elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_quadrature_points =</div><div class="line">    elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">  local_interface_matrix = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">        elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">        {</div><div class="line">          stokes_symgrad_phi_u[k] =</div><div class="line">            stokes_fe_face_values[velocities].symmetric_gradient(k, q);</div><div class="line">          stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">           ++k)</div><div class="line">        elasticity_phi[k] =</div><div class="line">          elasticity_fe_face_values[displacements].value(k, q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">           ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">          local_interface_matrix(i, j) +=</div><div class="line">            -((2 * viscosity * (stokes_symgrad_phi_u[j] * normal_vector) -</div><div class="line">               stokes_phi_p[j] * normal_vector) *</div><div class="line">              elasticity_phi[i] * stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemsolvecode"></a> </p><h4><code>FluidStructureProblem::solve</code></h4>
<p>As discussed in the introduction, we use a rather trivial solver here: we just pass the linear system off to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct solver (see, for example, <a class="el" href="step_29.html">step-29</a>). The only thing we have to do after solving is ensure that hanging node and boundary value constraints are correct.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemoutput_resultscode"></a> </p><h4><code>FluidStructureProblem::output_results</code></h4>
<p>Generating graphical output is rather trivial here: all we have to do is identify which components of the solution vector belong to scalars and/or vectors (see, for example, <a class="el" href="step_22.html">step-22</a> for a previous example), and then pass it all on to the <a class="el" href="classDataOut.html">DataOut</a> class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemrefine_meshcode"></a> </p><h4><code>FluidStructureProblem::refine_mesh</code></h4>
<p>The next step is to refine the mesh. As was discussed in the introduction, this is a bit tricky primarily because the fluid and the solid subdomains use variables that have different physical dimensions and for which the absolute magnitude of error estimates is consequently not directly comparable. We will therefore have to scale them. At the top of the function, we therefore first compute error estimates for the different variables separately (using the velocities but not the pressure for the fluid domain, and the displacements in the solid domain):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> stokes_estimated_error_per_cell(</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> elasticity_estimated_error_per_cell(</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; stokes_face_quadrature(stokes_degree + 2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; elasticity_face_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim - 1&gt; face_q_collection;</div><div class="line">  face_q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_face_quadrature);</div><div class="line">  face_q_collection.push_back(elasticity_face_quadrature);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    face_q_collection,</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    stokes_estimated_error_per_cell,</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    face_q_collection,</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    elasticity_estimated_error_per_cell,</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div></div><!-- fragment --><p>We then normalize error estimates by dividing by their norm and scale the fluid error indicators by a factor of 4 as discussed in the introduction. The results are then added together into a vector that contains error indicators for all cells:</p>
<div class="fragment"><div class="line">stokes_estimated_error_per_cell *=</div><div class="line">  4. / stokes_estimated_error_per_cell.l2_norm();</div><div class="line">elasticity_estimated_error_per_cell *=</div><div class="line">  1. / elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">estimated_error_per_cell += elasticity_estimated_error_per_cell;</div></div><!-- fragment --><p>The second to last part of the function, before actually refining the mesh, involves a heuristic that we have already mentioned in the introduction: because the solution is discontinuous, the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class gets all confused about cells that sit at the boundary between subdomains: it believes that the error is large there because the jump in the gradient is large, even though this is entirely expected and a feature that is in fact present in the exact solution as well and therefore not indicative of any numerical error.</p>
<p>Consequently, we set the error indicators to zero for all cells at the interface; the conditions determining which cells this affects are slightly awkward because we have to account for the possibility of adaptively refined meshes, meaning that the neighboring cell can be coarser than the current one, or could in fact be refined some more. The structure of these nested conditions is much the same as we encountered when assembling interface terms in <code>assemble_system</code>.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">              (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                cell_is_in_fluid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">               ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                (cell_is_in_fluid_domain(</div><div class="line">                  cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">               (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                cell_is_in_fluid_domain(cell-&gt;neighbor(f)))))</div><div class="line">            estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">              (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                cell_is_in_solid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">               ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                (cell_is_in_solid_domain(</div><div class="line">                  cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">               (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                cell_is_in_solid_domain(cell-&gt;neighbor(f)))))</div><div class="line">            estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.0);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemruncode"></a> </p><h4><code>FluidStructureProblem::run</code></h4>
<p>This is, as usual, the function that controls the overall flow of operation. If you've read through tutorial programs <a class="el" href="step_1.html">step-1</a> through <a class="el" href="step_6.html">step-6</a>, for example, then you are already quite familiar with the following structure:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">FluidStructureProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 10 - 2 * dim;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing output...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step46</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main()</code> function</h4>
<p>This, final, function contains pretty much exactly what most of the other tutorial programs have:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step46;</div><div class="line"></div><div class="line">      FluidStructureProblem&lt;2&gt; flow_problem(1, 1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="2dresults"></a></p><h3>2d results</h3>
<p>When running the program, you should get output like the following: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 531</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 136</div><div class="line">   Number of degrees of freedom: 1260</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 436</div><div class="line">   Number of degrees of freedom: 3723</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 1072</div><div class="line">   Number of degrees of freedom: 7493</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2632</div><div class="line">   Number of degrees of freedom: 15005</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 5944</div><div class="line">   Number of degrees of freedom: 29437</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div></div><!-- fragment --><p>The results are easily visualized:</p>
<table width="80%" align="center">
<tr valign="top">
<td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.velocity-2d.png"/>
</div>
 <p>Magnitude and vectors for the fluid velocity. </p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.pressure-2d.png"/>
</div>
 <p>Fluid pressure. The dynamic range has been truncated to cut off the pressure singularities at the top left and right corners of the domain as well as the top corners of the solid that forms re-entrant corners into the fluid domain. </p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.displacement-2d.png"/>
</div>
 <p>Magnitude and vectors for the solid displacement. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>The plots are easily interpreted: as the flow drives down on the left side and up on the right side of the upright part of the solid, it produces a pressure that is high on the left and low on the right, and these forces bend the vertical part of the solid to the right.</p>
<p><a class="anchor" id="3dresults"></a></p><h3>3d results</h3>
<p>By changing the dimension of the <code>FluidStructureProblem</code> class in <code>main()</code> to 3, we can also run the same problem 3d. You'd get output along the following lines: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 512</div><div class="line">   Number of degrees of freedom: 11631</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 1716</div><div class="line">   Number of degrees of freedom: 48984</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 8548</div><div class="line">   Number of degrees of freedom: 245746</div><div class="line">   Assembling...</div><div class="line">   Solving...</div></div><!-- fragment --><p> You'll notice that the big bottleneck is the solver: SparseDirectUmfpack needs nearly 5 hours and some 80 GB of memory to solve the last iteration of this problem on a 2016 workstation (the second to last iteration took only 16 minutes). Clearly a better solver is needed here, a topic discussed below.</p>
<p>The results can also be visualized and yield good pictures as well. Here is one, showing both a vector plot for the velocity (in oranges), the solid displacement (in blues), and shading the solid region:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.3d.png"/>
</div>
 <p>In addition to the lack of a good solver, the mesh is a bit unbalanced: mesh refinement heavily favors the fluid subdomain (in 2d, it was the other way around, prompting us to weigh the fluid error indicators higher). Clearly, some tweaking of the relative importance of error indicators in the two subdomains is important if one wanted to go on doing more 3d computations.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Linearsolversandpreconditioners"></a></p><h4>Linear solvers and preconditioners</h4>
<p>An obvious place to improve the program would be to use a more sophisticated solver &mdash; in particular one that scales well and will also work for realistic 3d problems. This shouldn't actually be too hard to achieve here, because of the one-way coupling from fluid into solid. To this end, assume we had re-ordered degrees of freedom in such a way that we first have all velocity and pressure degrees of freedom, and then all displacements (this is easily possible using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>). Then the system matrix could be split into the following block form: </p><p class="formulaDsp">
\[ A_\text{global} = \begin{pmatrix} A_{\text{fluid}} &amp; 0 \\ B &amp; A_{\text{solid}} \end{pmatrix} \]
</p>
<p> where \(A_{\text{fluid}}\) is the Stokes matrix for velocity and pressure (it could be further subdivided into a \(2\times 2\) matrix as in <a class="el" href="step_22.html">step-22</a>, though this is immaterial for the current purpose), \(A_{\text{solid}}\) results from the elasticity equations for the displacements, and \(B\) is the matrix that comes from the interface conditions. Now notice that the matrix </p><p class="formulaDsp">
\[ A_\text{global}^{-1} = \begin{pmatrix} A_{\text{fluid}}^{-1} &amp; 0 \\ -A_\text{solid}^{-1} B A_\text{fluid}^{-1} &amp; A_{\text{solid}}^{-1} \end{pmatrix} \]
</p>
<p> is the inverse of \(A_\text{global}\). Applying this matrix requires only one solve with \(A_\text{fluid}\) and \(A_\text{solid}\) each since </p><p class="formulaDsp">
\[ \begin{pmatrix} p_x \\ p_y \end{pmatrix} = \begin{pmatrix} A_{\text{fluid}}^{-1} &amp; 0 \\ -A_\text{solid}^{-1} B A_\text{fluid}^{-1} &amp; A_{\text{solid}}^{-1} \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} \]
</p>
<p> can be computed as \(p_x = A_{\text{fluid}}^{-1} x\) followed by \(p_y = A_{\text{solid}}^{-1} (y-Bp_x)\).</p>
<p>One can therefore expect that </p><p class="formulaDsp">
\[ \widetilde{A_\text{global}^{-1}} = \begin{pmatrix} \widetilde{A_{\text{fluid}}^{-1}} &amp; 0 \\ -\widetilde{A_\text{solid}^{-1}} B \widetilde{A_\text{fluid}^{-1}} &amp; \widetilde{A_{\text{solid}}^{-1}} \end{pmatrix} \]
</p>
<p> would be a good preconditioner if \(\widetilde{A_{\text{fluid}}^{-1}} \approx A_{\text{fluid}}^{-1}, \widetilde{A_{\text{solid}}^{-1}} \approx A_{\text{solid}}^{-1}\).</p>
<p>That means, we only need good preconditioners for Stokes and the elasticity equations separately. These are well known: for Stokes, we can use the preconditioner discussed in the results section of <a class="el" href="step_22.html">step-22</a>; for elasticity, a good preconditioner would be a single V-cycle of a geometric or algebraic multigrid. There are more open questions, however: For an "optimized" solver block-triangular preconditioner built from two sub-preconditioners, one point that often comes up is that, when choosing parameters for the sub-preconditioners, values that work well when solving the two problems separately may not be optimal when combined into a multiphysics preconditioner. In particular, when solving just a solid or fluid mechanics problem separately, the balancing act between the number of iterations to convergence and the cost of applying the preconditioner on a per iteration basis may lead one to choose an expensive preconditioner for the Stokes problem and a cheap preconditioner for the elasticity problem (or vice versa). When combined, however, there is the additional constraint that you want the two sub-preconditioners to converge at roughly the same rate, or else the cheap one may drive up the global number of iterations while the expensive one drives up the cost-per-iteration. For example, while a single AMG V-cycle is a good approach for elasticity by itself, when combined into a multiphysics problem there may be an incentive to using a full W-cycle or multiple cycles to help drive down the total solve time.</p>
<p><a class="anchor" id="Refinementindicators"></a></p><h4>Refinement indicators</h4>
<p>As mentioned in the introduction, the refinement indicator we use for this program is rather ad hoc. A better one would understand that the jump in the gradient of the solution across the interface is not indicative of the error but to be expected and ignore the interface when integrating the jump terms. Nevertheless, this is not what the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class does. Another, bigger question, is whether this kind of estimator is a good strategy in the first place: for example, if we want to have maximal accuracy in one particular aspect of the displacement (e.g. the displacement at the top right corner of the solid), then is it appropriate to scale the error indicators for fluid and solid to the same magnitude? Maybe it is necessary to solve the fluid problem with more accuracy than the solid because the fluid solution directly affects the solids solution? Maybe the other way around?</p>
<p>Consequently, an obvious possibility for improving the program would be to implement a better refinement criterion. There is some literature on this topic; one of a variety of possible starting points would be the paper by Thomas Wick on "Adaptive finite elements for monolithic fluid-structure
interaction on a prolongated domain: Applied to an heart valve simulation", Proceedings of the Computer Methods in Mechanics Conference 2011 (CMM-2011), 9-12 May 2011, Warszaw, Poland.</p>
<p><a class="anchor" id="Verification"></a></p><h4>Verification</h4>
<p>The results above are purely qualitative as there is no evidence that our scheme in fact converges. An obvious thing to do would therefore be to add some quantitative measures to check that the scheme at least converges to <em>something</em>. For example, we could output for each refinement cycle the deflection of the top right corner of the part of the solid that protrudes into the fluid subdomain. Or we could compute the net force vector or torque the fluid exerts on the solid.</p>
<p><a class="anchor" id="Bettermodels"></a></p><h4>Better models</h4>
<p>In reality, most fluid structure interaction problems are so that the movement of the solid does affect the flow of the fluid. For example, the forces of the air around an air foil cause it to flex and to change its shape. Likewise, a flag flaps in the wind, completely changing its shape.</p>
<p>Such problems where the coupling goes both ways are typically handled in an Arbitrary Lagrangian Eulerian (ALE) framework, in which the displacement of the solid is extended into the fluid domain in some smooth way, rather than by zero as we do here. The extended displacement field is then used to deform the mesh on which we compute the fluid flow. Furthermore, the boundary conditions for the fluid on the interface are no longer that the velocity is zero; rather, in a time dependent program, the fluid velocity must be equal to the time derivative of the displacement along the interface.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step46</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>FluidStructureProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    FluidStructureProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span></div><div class="line">    {</div><div class="line">      fluid_domain_id,</div><div class="line">      solid_domain_id</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_fluid_domain(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_solid_domain(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> set_active_fe_indices();</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_interface_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">      std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">      std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         stokes_fe;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         elasticity_fe;</div><div class="line">    <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>       dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lambda;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1 + dim)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> StokesBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (component == dim - 1)</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> 2:</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]);</div><div class="line">          <span class="keywordflow">case</span> 3:</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[1]);</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesBoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                               Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = StokesBoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  FluidStructureProblem&lt;dim&gt;::FluidStructureProblem(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree)</div><div class="line">    : stokes_degree(stokes_degree)</div><div class="line">    , elasticity_degree(elasticity_degree)</div><div class="line">    , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1),</div><div class="line">                dim,</div><div class="line">                <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree),</div><div class="line">                1,</div><div class="line">                <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                dim)</div><div class="line">    , elasticity_fe(<a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                    dim,</div><div class="line">                    <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                    1,</div><div class="line">                    <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(elasticity_degree),</div><div class="line">                    dim)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , viscosity(2)</div><div class="line">    , lambda(1)</div><div class="line">    , mu(1)</div><div class="line">  {</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(stokes_fe);</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(elasticity_fe);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_fluid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (cell-&gt;material_id() == fluid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_solid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (cell-&gt;material_id() == solid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 8, -1, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; (face-&gt;center()[dim - 1] == 1))</div><div class="line">          face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &lt; 0.25) &amp;&amp;</div><div class="line">           (cell-&gt;center()[dim - 1] &gt; 0.5)) ||</div><div class="line">          ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &gt;= 0.25) &amp;&amp;</div><div class="line">           (cell-&gt;center()[dim - 1] &gt; -0.5)))</div><div class="line">        cell-&gt;set_material_id(fluid_domain_id);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        cell-&gt;set_material_id(solid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::set_active_fe_indices()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          cell-&gt;set_active_fe_index(0);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          cell-&gt;set_active_fe_index(1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    set_active_fe_indices();</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_collection);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               1,</div><div class="line">                                               StokesBoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(</div><div class="line">                                                 velocities));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        0,</div><div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1 + dim),</div><div class="line">        constraints,</div><div class="line">        fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_face_dof_indices(</div><div class="line">        stokes_fe.n_dofs_per_face());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                    (cell_is_in_solid_domain(cell-&gt;neighbor(face_no))))</div><div class="line">                  face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf = 0;</div><div class="line">                         sf &lt; cell-&gt;face(face_no)-&gt;n_children();</div><div class="line">                         ++sf)</div><div class="line">                      <span class="keywordflow">if</span> (cell_is_in_solid_domain(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(face_no, sf)))</div><div class="line">                        {</div><div class="line">                          face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                          <span class="keywordflow">break</span>;</div><div class="line">                        }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">                  {</div><div class="line">                    cell-&gt;face(face_no)-&gt;get_dof_indices(local_face_dof_indices,</div><div class="line">                                                         0);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; local_face_dof_indices.size();</div><div class="line">                         ++i)</div><div class="line">                      <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt;</div><div class="line">                          dim)</div><div class="line">                        constraints.add_line(local_face_dof_indices[i]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">    }</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> cell_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                                 fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> face_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                                 fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (((c &lt; dim + 1) &amp;&amp; (d &lt; dim + 1) &amp;&amp;</div><div class="line">                 !((c == dim) &amp;&amp; (d == dim))) ||</div><div class="line">                ((c &gt;= dim + 1) &amp;&amp; (d &gt;= dim + 1)))</div><div class="line">              cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ((c &gt;= dim + 1) &amp;&amp; (d &lt; dim + 1))</div><div class="line">              face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          }</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler,</div><div class="line">                                           dsp,</div><div class="line">                                           cell_coupling,</div><div class="line">                                           face_coupling);</div><div class="line">      constraints.condense(dsp);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> stokes_quadrature(stokes_degree + 2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> elasticity_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a> q_collection;</div><div class="line">    q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_quadrature);</div><div class="line">    q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(elasticity_quadrature);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div><div class="line">                                   q_collection,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; common_face_quadrature(</div><div class="line">      <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(stokes_degree + 2, elasticity_degree + 2));</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    stokes_fe_face_values(stokes_fe,</div><div class="line">                                            common_face_quadrature,</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    elasticity_fe_face_values(elasticity_fe,</div><div class="line">                                                common_face_quadrature,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> stokes_fe_subface_values(stokes_fe,</div><div class="line">                                                  common_face_quadrature,</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> elasticity_fe_subface_values(elasticity_fe,</div><div class="line">                                                      common_face_quadrature,</div><div class="line">                                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_dofs_per_cell =</div><div class="line">      elasticity_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_interface_matrix(elasticity_dofs_per_cell,</div><div class="line">                                              stokes_dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; neighbor_dof_indices(</div><div class="line">      stokes_dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> right_hand_side(dim + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; stokes_symgrad_phi_u(</div><div class="line">      stokes_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt; stokes_div_phi_u(stokes_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt; stokes_phi_p(stokes_dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; elasticity_grad_phi(elasticity_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         elasticity_div_phi(elasticity_dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; elasticity_phi(elasticity_dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        hp_fe_values.reinit(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div><div class="line"></div><div class="line">        local_matrix.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(),</div><div class="line">                            cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">        local_rhs.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == stokes_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                  {</div><div class="line">                    stokes_symgrad_phi_u[k] =</div><div class="line">                      fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                    stokes_div_phi_u[k] =</div><div class="line">                      fe_values[velocities].divergence(k, q);</div><div class="line">                    stokes_phi_p[k] = fe_values[pressure].value(k, q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (2 * viscosity * stokes_symgrad_phi_u[i] *</div><div class="line">                         stokes_symgrad_phi_u[j] -</div><div class="line">                       stokes_div_phi_u[i] * stokes_phi_p[j] -</div><div class="line">                       stokes_phi_p[i] * stokes_div_phi_u[j]) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == elasticity_dofs_per_cell,</div><div class="line">                   <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                  {</div><div class="line">                    elasticity_grad_phi[k] =</div><div class="line">                      fe_values[displacements].gradient(k, q);</div><div class="line">                    elasticity_div_phi[k] =</div><div class="line">                      fe_values[displacements].divergence(k, q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    {</div><div class="line">                      local_matrix(i, j) +=</div><div class="line">                        (lambda * elasticity_div_phi[i] *</div><div class="line">                           elasticity_div_phi[j] +</div><div class="line">                         mu * <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                             elasticity_grad_phi[j]) +</div><div class="line">                         mu *</div><div class="line">                           <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                          <a class="code" href="derivative__form_8h.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(elasticity_grad_phi[j]))) *</div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                    }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        local_dof_indices.resize(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                    (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                    cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                  {</div><div class="line">                    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                    stokes_fe_face_values.reinit(cell-&gt;neighbor(f),</div><div class="line">                                                 cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                            stokes_fe_face_values,</div><div class="line">                                            elasticity_phi,</div><div class="line">                                            stokes_symgrad_phi_u,</div><div class="line">                                            stokes_phi_p,</div><div class="line">                                            local_interface_matrix);</div><div class="line"></div><div class="line">                    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                    constraints.distribute_local_to_global(</div><div class="line">                      local_interface_matrix,</div><div class="line">                      local_dof_indices,</div><div class="line">                      neighbor_dof_indices,</div><div class="line">                      system_matrix);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                         (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>))</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface = 0;</div><div class="line">                         subface &lt; cell-&gt;face(f)-&gt;n_children();</div><div class="line">                         ++subface)</div><div class="line">                      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(f, subface)))</div><div class="line">                        {</div><div class="line">                          elasticity_fe_subface_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell, f, subface);</div><div class="line">                          stokes_fe_face_values.reinit(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(f, subface),</div><div class="line">                            cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                          assemble_interface_term(elasticity_fe_subface_values,</div><div class="line">                                                  stokes_fe_face_values,</div><div class="line">                                                  elasticity_phi,</div><div class="line">                                                  stokes_symgrad_phi_u,</div><div class="line">                                                  stokes_phi_p,</div><div class="line">                                                  local_interface_matrix);</div><div class="line"></div><div class="line">                          cell-&gt;neighbor_child_on_subface(f, subface)</div><div class="line">                            -&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                          constraints.distribute_local_to_global(</div><div class="line">                            local_interface_matrix,</div><div class="line">                            local_dof_indices,</div><div class="line">                            neighbor_dof_indices,</div><div class="line">                            system_matrix);</div><div class="line">                        }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                         cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                  {</div><div class="line">                    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                    stokes_fe_subface_values.reinit(</div><div class="line">                      cell-&gt;neighbor(f),</div><div class="line">                      cell-&gt;neighbor_of_coarser_neighbor(f).first,</div><div class="line">                      cell-&gt;neighbor_of_coarser_neighbor(f).second);</div><div class="line"></div><div class="line">                    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                            stokes_fe_subface_values,</div><div class="line">                                            elasticity_phi,</div><div class="line">                                            stokes_symgrad_phi_u,</div><div class="line">                                            stokes_phi_p,</div><div class="line">                                            local_interface_matrix);</div><div class="line"></div><div class="line">                    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                    constraints.distribute_local_to_global(</div><div class="line">                      local_interface_matrix,</div><div class="line">                      local_dof_indices,</div><div class="line">                      neighbor_dof_indices,</div><div class="line">                      system_matrix);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_interface_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">    std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">    std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a> ==</div><div class="line">             elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_quadrature_points =</div><div class="line">      elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">    local_interface_matrix = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_quadrature_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">          elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">          {</div><div class="line">            stokes_symgrad_phi_u[k] =</div><div class="line">              stokes_fe_face_values[velocities].symmetric_gradient(k, q);</div><div class="line">            stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">             ++k)</div><div class="line">          elasticity_phi[k] =</div><div class="line">            elasticity_fe_face_values[displacements].value(k, q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">             ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">            local_interface_matrix(i, j) +=</div><div class="line">              -((2 * viscosity * (stokes_symgrad_phi_u[j] * normal_vector) -</div><div class="line">                 stokes_phi_p[j] * normal_vector) *</div><div class="line">                elasticity_phi[i] * stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; stokes_estimated_error_per_cell(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    Vector&lt;float&gt; elasticity_estimated_error_per_cell(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; stokes_face_quadrature(stokes_degree + 2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; elasticity_face_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim - 1&gt; face_q_collection;</div><div class="line">    face_q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_face_quadrature);</div><div class="line">    face_q_collection.push_back(elasticity_face_quadrature);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      face_q_collection,</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      stokes_estimated_error_per_cell,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      face_q_collection,</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      elasticity_estimated_error_per_cell,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line"></div><div class="line">    stokes_estimated_error_per_cell *=</div><div class="line">      4. / stokes_estimated_error_per_cell.l2_norm();</div><div class="line">    elasticity_estimated_error_per_cell *=</div><div class="line">      1. / elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">    estimated_error_per_cell += elasticity_estimated_error_per_cell;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                  cell_is_in_fluid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">                 ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                  (cell_is_in_fluid_domain(</div><div class="line">                    cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">                 (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                  cell_is_in_fluid_domain(cell-&gt;neighbor(f)))))</div><div class="line">              estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                  cell_is_in_solid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">                 ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                  (cell_is_in_solid_domain(</div><div class="line">                    cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">                 (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                  cell_is_in_solid_domain(cell-&gt;neighbor(f)))))</div><div class="line">              estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">          }</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.0);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">FluidStructureProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 10 - 2 * dim;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing output...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step46</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step46;</div><div class="line"></div><div class="line">      FluidStructureProblem&lt;2&gt; flow_problem(1, 1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_22.html">step-22</a> , <a class="el" href="step_27.html">step-27</a> . 
 <table class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Thegeneralidea">The general idea</a><a
 href="#Thegeneralidea">The general idea</a>
 <li><a href="#Implementation">Implementation</a><a
 href="#Implementation">Implementation</a>
 <li><a href="#Specificsoftheimplementation"> Specifics of the
 implementation </a><a href="#Specificsoftheimplementation"> Specifics of
 the implementation </a>
 <ul>
 <li><a href="#Dealingwiththeinterfaceterms">Dealing with the interface
 terms</a><a href="#Dealingwiththeinterfaceterms">Dealing with the interface
 terms</a>
 <li><a href="#Velocityboundaryconditionsontheinterface">Velocity boundary
 conditions on the interface</a><a
 href="#Velocityboundaryconditionsontheinterface">Velocity boundary
 conditions on the interface</a>
 </ul>
 <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The
 testcase</a>
 <ul>
 <li><a href="#Identifyingwhichsubdomainacellisin">Identifying which
 subdomain a cell is in</a><a
 href="#Identifyingwhichsubdomainacellisin">Identifying which subdomain a
 cell is in</a>
 <li><a href="#Linearsolvers">Linear solvers</a><a
 href="#Linearsolvers">Linear solvers</a>
 <li><a href="#Meshrefinement">Mesh refinement</a><a
 href="#Meshrefinement">Mesh refinement</a>
 </ul>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#ThecodeFluidStructureProblemcodeclasstemplate">The
 <code>FluidStructureProblem</code> class template</a><a
 href="#ThecodeFluidStructureProblemcodeclasstemplate">The
 <code>FluidStructureProblem</code> class template</a>
 <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right
 hand side</a><a href="#Boundaryvaluesandrighthandside">Boundary values and
 right hand side</a>
 <li><a href="#ThecodeFluidStructureProblemcodeimplementation">The
 <code>FluidStructureProblem</code> implementation</a><a
 href="#ThecodeFluidStructureProblemcodeimplementation">The
 <code>FluidStructureProblem</code> implementation</a>
 <ul>
 <li><a href="#Constructorsandhelperfunctions">Constructors and helper
 functions</a><a href="#Constructorsandhelperfunctions">Constructors and
 helper functions</a>
 <li><a href="#Meshesandassigningsubdomains">Meshes and assigning
 subdomains</a><a href="#Meshesandassigningsubdomains">Meshes and assigning
 subdomains</a>
 <li><a
 href="#codeFluidStructureProblemsetup_dofscode"><code>FluidStructureProblem::setup_dofs</code></a><a
 href="#codeFluidStructureProblemsetup_dofscode"><code>FluidStructureProblem::setup_dofs</code></a>
 <li><a
 href="#codeFluidStructureProblemassemble_systemcode"><code>FluidStructureProblem::assemble_system</code></a><a
 href="#codeFluidStructureProblemassemble_systemcode"><code>FluidStructureProblem::assemble_system</code></a>
 <li><a
 href="#codeFluidStructureProblemsolvecode"><code>FluidStructureProblem::solve</code></a><a
 href="#codeFluidStructureProblemsolvecode"><code>FluidStructureProblem::solve</code></a>
 <li><a
 href="#codeFluidStructureProblemoutput_resultscode"><code>FluidStructureProblem::output_results</code></a><a
 href="#codeFluidStructureProblemoutput_resultscode"><code>FluidStructureProblem::output_results</code></a>
 <li><a
 href="#codeFluidStructureProblemrefine_meshcode"><code>FluidStructureProblem::refine_mesh</code></a><a
 href="#codeFluidStructureProblemrefine_meshcode"><code>FluidStructureProblem::refine_mesh</code></a>
 <li><a
 href="#codeFluidStructureProblemruncode"><code>FluidStructureProblem::run</code></a><a
 href="#codeFluidStructureProblemruncode"><code>FluidStructureProblem::run</code></a>
 <li><a href="#Thecodemaincodefunction">The <code>main()</code>
 function</a><a href="#Thecodemaincodefunction">The <code>main()</code>
 function</a>
 </ul>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#2dresults">2d results</a><a href="#2dresults">2d results</a>
 <li><a href="#3dresults">3d results</a><a href="#3dresults">3d results</a>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 <ul>
 <li><a href="#Linearsolversandpreconditioners">Linear solvers and
 preconditioners</a><a href="#Linearsolversandpreconditioners">Linear
 solvers and preconditioners</a>
 <li><a href="#Refinementindicators">Refinement indicators</a><a
 href="#Refinementindicators">Refinement indicators</a>
 <li><a href="#Verification">Verification</a><a
 href="#Verification">Verification</a>
 <li><a href="#Bettermodels">Better models</a><a href="#Bettermodels">Better
 models</a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The University of California &ndash; Davis. </em></p>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program deals with the problem of coupling different physics in differentparts of the domain. Specifically, let us consider the followingsituation that couples a Stokes fluid with an elastic solid (these twoproblems were previously discussed separately in <a class="el" href="step_22.html">step-22</a> and <a class="el" href="step_8.html">step-8</a> ,where you may want to read up on the individual equations):</p>
<ul>
<li>In a part \(\Omega_f\) of \(\Omega\) , we have a fluid flowing that satisfies the time independent Stokes equations (in the form that involves the strain tensor): <p class="formulaDsp">
\begin{align*} -2\eta\nabla \cdot \varepsilon(\mathbf v) + \nabla p &amp;= 0, \qquad \qquad &amp;&amp; \text{in}\ \Omega_f\\ -\nabla \cdot \mathbf v &amp;= 0 &amp;&amp; \text{in}\ \Omega_f. \end{align*}
</p>
 Here, \(\mathbf v, p\) are the fluid velocity and pressure, respectively. We prescribe the velocity on part of the external boundary, <p class="formulaDsp">
\begin{align*} \mathbf v = \mathbf v_0 \qquad\qquad \text{on}\ \Gamma_{f,1} \subset \partial\Omega \cap \partial\Omega_f \end{align*}
</p>
 while we assume free-flow conditions on the remainder of the external boundary, <p class="formulaDsp">
\begin{align*} (2\eta \varepsilon(\mathbf v) - p \mathbf 1) \cdot \mathbf n = 0 \qquad\qquad \text{on}\ \Gamma_{f,2} = \partial\Omega \cap \partial\Omega_f \backslash \Gamma_{f,1}. \end{align*}
</p>
</li>
<li>The remainder of the domain, \(\Omega_s = \Omega \backslash \Omega_f\) is occupied by a solid whose deformation field \(\mathbf u\) satisfies the elasticity equation, <p class="formulaDsp">
\begin{align*} -\nabla \cdot C \varepsilon(\mathbf u) = 0 \qquad\qquad &amp; \text{in}\ \Omega_s, \end{align*}
</p>
 where \(C\) is the rank-4 elasticity tensor (for which we will use a particularly simple form by assuming that the solid is isotropic). It deforms in reaction to the forces exerted by the fluid flowing along the boundary of the solid. We assume this deformation to be so small that it has no feedback effect on the fluid, i.e. the coupling is only in one direction. For simplicity, we will assume that the solid's external boundary is clamped, i.e. <p class="formulaDsp">
\begin{align*} \mathbf u = \mathbf 0 \qquad\qquad \text{on}\ \Gamma_{s,1} = \partial\Omega \cap \partial\Omega_s \end{align*}
</p>
</li>
<li>As a consequence of the small displacement assumption, we will pose the following boundary conditions on the interface between the fluid and solid: first, we have no slip boundary conditions for the fluid, <p class="formulaDsp">
\begin{align*} \mathbf v = \mathbf 0 \qquad\qquad \text{on}\ \Gamma_{i} = \partial\Omega_s \cap \partial\Omega_f. \end{align*}
</p>
 Secondly, the forces (traction) on the solid equal the normal stress from the fluid, <p class="formulaDsp">
\begin{align*} (C \varepsilon(\mathbf u)) \mathbf n = (2 \eta \varepsilon(\mathbf v) - p \mathbf 1) \mathbf n \qquad\qquad \text{on}\ \Gamma_{i} = \partial\Omega_s \cap \partial\Omega_f, \end{align*}
</p>
 where \(\mathbf{n}\) is the normal vector on \(\Gamma_{i}\) pointing from the solid to the fluid. We get a weak formulation of this problem by following our usual rule ofmultiplying from the left by a test function and integrating over thedomain. It then looks like this: Find \(y = \{\mathbf v, p, \mathbf u\} \in Y \subset H^1(\Omega_f)^d \times L_2(\Omega_f) \times H^1(\Omega_s)^d\) such that <p class="formulaDsp">
\begin{align*} 2 \eta (\varepsilon(\mathbf a), \varepsilon(\mathbf v))_{\Omega_f} - (\nabla \cdot \mathbf a, p)_{\Omega_f} - (q, \nabla \cdot \mathbf v)_{\Omega_f} &amp; \\ + (\varepsilon(\mathbf b), C \varepsilon(\mathbf u))_{\Omega_s} &amp; \\ - (\mathbf b, (2 \eta \varepsilon(\mathbf v) - p \mathbf 1) \mathbf n)_{\Gamma_i} &amp;= 0, \end{align*}
</p>
 for all test functions \(\mathbf a, q, \mathbf b\) ; the first, second, andthird lines correspond to the fluid, solid, and interfacecontributions, respectively.Note that \(Y\) is only a subspace of the spaces listed above to accommodate forthe various Dirichlet boundary conditions. This sort of coupling is of course possible by simply having two Triangulationand two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, one each for each of the two subdomains. On theother hand, deal.II is much simpler to use if there is a single DoFHandlerobject that knows about the discretization of the entire problem. This program is about how this can be achieved. Note that the goal is not topresent a particularly useful physical model (a realistic fluid-structureinteraction model would have to take into account the finite deformation ofthe solid and the effect this has on the fluid): this is, after all, just atutorial program intended to demonstrate techniques, not to solve actualproblems. Furthermore, we will make the assumption that the interface betweenthe subdomains is aligned with coarse mesh cell faces.</li>
</ul>
<p><a class="anchor" id="Thegeneralidea"></a></p><h3>The general idea</h3>
<p>Before going into more details let us state the obvious: this is aproblem with multiple solution variables; for this, you will probablywant to read the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> documentation module first, whichpresents the basic philosophical framework in which we addressproblems with more than one solution variable. But back to the problemat hand: The fundamental idea to implement these sort of problems in deal.II goes asfollows: in the problem formulation, the velocity and pressure variables \(\mathbf v, p\) only live in the fluid subdomain \(\Omega_f\) . But let's assumethat we extend them by zero to the entire domain \(\Omega\) (in the general casethis means that they will be discontinuous along \(\Gamma_i\) ). So what is theappropriate function space for these variables? We know that on \(\Omega_f\) weshould require \(\mathbf v \in H^1(\Omega_f)^d, p \in L_2(\Omega_f)\) , so forthe extensions \(\tilde{\mathbf v}, \tilde p\) to the whole domain the followingappears a useful set of function spaces: </p><p class="formulaDsp">
\begin{align*} \tilde {\mathbf v} &amp;\in V = \{\tilde {\mathbf v}|_{\Omega_f} \in H^1(\Omega_f)^d, \quad \tilde {\mathbf v}|_{\Omega_s} = 0 \} \\ \tilde p &amp;\in P = \{\tilde p|_{\Omega_f} \in L_2(\Omega_f), \quad \tilde p|_{\Omega_s} = 0 \}. \end{align*}
</p>
<p> (Since this is not important for the current discussion, we have omitted thequestion of boundary values from the choice of function spaces; this questionalso affects whether we can choose \(L_2\) for the pressure or whether we haveto choose the space \(L_{2,0}(\Omega_f)=\{q\in L_2(\Omega_f): \int_{\Omega_f} q = 0\}\) for the pressure. None of these questions are relevant to the followingdiscussion, however.) Note that these are indeed a linear function spaces with obvious norm. Since noconfusion is possible in practice, we will henceforth omit the tilde again todenote the extension of a function to the whole domain and simply refer by \(\mathbf v, p\) to both the original and the extended function. For discretization, we need finite dimensional subspaces \(V_h,P_h\) of \(V, P\) . For Stokes, we know from <a class="el" href="step_22.html">step-22</a> that an appropriate choice is \(Q_{p+1}^d\times Q_P\) but this only holds for that part of the domainoccupied by the fluid. For the extended field, let's use the followingsubspaces defined on the triangulation \(\mathbb T\) : </p><p class="formulaDsp">
\begin{align*} V_h &amp;= \{{\mathbf v}_h \quad | \quad \forall K \in {\mathbb T}: {\mathbf v}_h|_K \in Q_{p+1}^d\ \text{if}\ K\subset {\Omega_f}, \quad {\mathbf v}_h|_{\Omega_f}\ \text{is continuous}, \quad {\mathbf v}_h|_K = 0\ \text{if}\ K\subset {\Omega_s}\} &amp;&amp; \subset V \\ P_h &amp;= \{ p_h \quad | \quad \forall K \in {\mathbb T}: p_h|_K \in Q_p\ \text{if}\ K\subset {\Omega_f}, \quad p_h|_{\Omega_f}\ \text{is continuous}, \quad p_h|_K = 0\ \text{if}\ K\subset {\Omega_s}\ \} &amp;&amp; \subset P. \end{align*}
</p>
<p> In other words, on \(\Omega_f\) we choose the usual discrete spaces butwe keep the (discontinuous) extension by zero. The point to make isthat we now need a description of a finite element space for functionsthat are zero on a cell &mdash; and this is where the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> classcomes in: it describes a finite dimensional function space offunctions that are constant zero. A particular property of thispeculiar linear vector space is that it has no degrees of freedom: itisn't just finite dimensional, it is in fact zero dimensional, andconsequently for objects of this type, <a class="el" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">FiniteElement::n_dofs_per_cell()</a> will return zero. For discussion below, let us give this space aproper symbol: </p><p class="formulaDsp">
\[ Z = \{ \varphi: \varphi(x)=0 \}. \]
</p>
<p> symbol \(Z\) reminds of the fact that functions in this space arezero. Obviously, we choose \(Z_h=Z\) . This entire discussion above can be repeated for the variables we use todescribe the elasticity equation. Here, for the extended variables, wehave </p><p class="formulaDsp">
\begin{align*} \tilde {\mathbf u} &amp;\in U = \{\tilde {\mathbf u}|_{\Omega_s} \in H^1(\Omega_f)^d, \quad \tilde {\mathbf u}|_{\Omega_f} \in Z(\Omega_s)^d \}, \end{align*}
</p>
<p> and we will typically use a finite element space of the kind </p><p class="formulaDsp">
\begin{align*} U_h &amp;= \{{\mathbf u}_h \quad | \quad \forall K \in {\mathbb T}: {\mathbf u}_h|_K \in Q_r^d\ \text{if}\ K\subset {\Omega_s}, \quad {\mathbf u}_h|_{\Omega_f}\ \text{is continuous}, \quad {\mathbf u}_h|_K \in Z^d\ \text{if}\ K\subset {\Omega_f}\} &amp;&amp; \subset U \end{align*}
</p>
<p> of polynomial degree \(r\) . So to sum up, we are going to look for a discrete vector-valuedsolution \(y_h = \{\mathbf v_h, p_h, \mathbf u_h\}\) in the followingspace: </p><p class="formulaDsp">
\begin{align*} Y_h = \{ &amp; y_h = \{\mathbf v_h, p_h, \mathbf u_h\} : \\ &amp; y_h|_{\Omega_f} \in Q_{p+1}^d \times Q_p \times Z^d, \\ &amp; y_h|_{\Omega_s} \in Z^d \times Z \times Q_r^d \}. \end{align*}
</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>So how do we implement this sort of thing? First, we realize that the discretespace \(Y_h\) essentially calls for two different finite elements: First, on thefluid subdomain, we need the element \(Q_{p+1}^d \times Q_p \times Z^d\) whichin deal.II is readily implemented by </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(p+1), dim,</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(p), 1,</div><div class="line"><a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), dim),</div></div><!-- fragment --><p> where <code><a class="el" href="classFE__Nothing.html">FE_Nothing</a></code> implements the space of functions that arealways zero. Second, on the solid subdomain, we need the element \(\in Z^d \times Z \times Q_r^d\) , which we get using </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), dim,</div><div class="line"><a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), 1,</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(r), dim),</div></div><!-- fragment --><p>The next step is that we associate each of these two elements with the cellsthat occupy each of the two subdomains. For this we realize that in a sensethe two elements are just variations of each other in that they have the samenumber of vector components but have different polynomial degrees &mdash; thissmells very much like what one would do in \(hp\) finite element methods, and itis exactly what we are going to do here: we are going to (ab)use the classesand facilities of the hp-namespace to assign different elements to differentcells. In other words, we will use collect the two finite elements in an <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>, will integrate with an appropriate <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> using an <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object, and our <a class="el" href="classDoFHandler.html">DoFHandler</a> will be in <em>hp</em>-mode. Youmay wish to take a look at <a class="el" href="step_27.html">step-27</a> for an overview of all of these concepts. Before going on describing the testcase, let us clarify a bit <em>why</em> thisapproach of extending the functions by zero to the entire domain and thenmapping the problem on to the hp-framework makes sense:</p>
<ul>
<li>It makes things uniform: On all cells, the number of vector components is the same (here, <code>2*dim+1</code> ). This makes all sorts of things possible since a uniform description allows for code re-use. For example, counting degrees of freedom per vector component (<a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>), sorting degrees of freedom by component (<a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>), subsequent partitioning of matrices and vectors into blocks and many other functions work as they always did without the need to add special logic to them that describes cases where some of the variables only live on parts of the domain. Consequently, you have all sorts of tools already available to you in programs like the current one that weren't originally written for the multiphysics case but work just fine in the current context.</li>
<li>It allows for easy graphical output: All graphical output formats we support require that each field in the output is defined on all nodes of the mesh. But given that now all solution components live everywhere, our existing <a class="el" href="classDataOut.html">DataOut</a> routines work as they always did, and produce graphical output suitable for visualization</li>
<li>the fields will simply be extended by zero, a value that can easily be filtered out by visualization programs if not desired.</li>
<li>There is essentially no cost: The trick with the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> does not add any degrees of freedom to the overall problem, nor do we ever have to handle a shape function that belongs to these components &mdash; the <a class="el" href="classFE__Nothing.html">FE_Nothing</a> has no degrees of freedom, not does it have shape functions, all it does is take up vector components.</li>
</ul>
<p><a class="anchor" id="Specificsoftheimplementation"></a></p><h3>Specifics of the implementation </h3>
<p>More specifically, in the program we have to address the followingpoints:</p>
<ul>
<li>Implementing the bilinear form, and in particular dealing with the interface term, both in the matrix and the sparsity pattern.</li>
<li>Implementing Dirichlet boundary conditions on the external and internal parts of the boundaries \(\partial\Omega_f,\partial\Omega_s\) .</li>
</ul>
<p><a class="anchor" id="Dealingwiththeinterfaceterms"></a></p><h4>Dealing with the interface terms</h4>
<p>Let us first discuss implementing the bilinear form, which at thediscrete level we recall to be </p><p class="formulaDsp">
\begin{align*} 2 \eta (\varepsilon(\mathbf a_h), \varepsilon(\mathbf v_h))_{\Omega_f} - (\nabla \cdot \mathbf a_h, p_h)_{\Omega_f} - (q_h, \nabla \cdot \mathbf v_h)_{\Omega_f} &amp; \\ + (\varepsilon(\mathbf b_h), C \varepsilon(\mathbf u_h))_{\Omega_s} &amp; \\ - (\mathbf b_h, (2 \eta \varepsilon(\mathbf v_h) - p \mathbf 1) \mathbf n)_{\Gamma_i} &amp;= 0, \end{align*}
</p>
<p> Given that we have extended the fields by zero, we could in principlewrite the integrals over subdomains to the entire domain \(\Omega\) ,though it is little additional effort to first ask whether a cell ispart of the elastic or fluid region before deciding which terms tointegrate. Actually integrating these terms is not very difficult; forthe Stokes equations, the relevant steps have been shown in <a class="el" href="step_22.html">step-22</a> ,whereas for the elasticity equation we take essentially the form shownin the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module (rather than the one from <a class="el" href="step_8.html">step-8</a> ). The term that is of more interest is the interface term, </p><p class="formulaDsp">
\[ -(\mathbf b_h, (2 \eta \varepsilon(\mathbf v_h) - p \mathbf 1) \mathbf n)_{\Gamma_i}. \]
</p>
<p> on our assumption that the interface \(\Gamma_i\) coincides withcell boundaries, this can in fact be written as a set of faceintegrals. If we denote the velocity, pressure and displacementcomponents of shape function \(\psi_i\in Y_h\) using the extractornotation \(\psi_i[\mathbf v],\psi_i[p], \psi_i[\mathbf u]\) , then theterm above yields the following contribution to the global matrixentry \(i,j\) : </p><p class="formulaDsp">
\[ -\sum_K (\psi_i[\mathbf u], (2 \eta \varepsilon(\psi_j[\mathbf v]) - \psi_j[p] \mathbf 1) \mathbf n)_{\partial K \cap \Gamma_i}. \]
</p>
<p> it isn't immediately obvious, this term presents a slightcomplication: while \(\psi_i[\mathbf u]\) and \(\mathbf n\) are evaluatedon the solid side of the interface (they are test functions for thedisplacement and the normal vector to \(\Omega_s\) , respectively, weneed to evaluate \(\psi_j[\mathbf v],\psi_j[p]\) on the fluidside of the interface since they correspond to the stress/forceexerted by the fluid. In other words, in our implementation, we willneed FEFaceValue objects for both sides of the interface. To makethings slightly worse, we may also have to deal with the fact that oneside or the other may be refined, leaving us with the need tointegrate over parts of a face. Take a look at the implementationbelow on how to deal with this. As an additional complication, the matrix entries that result from this termneed to be added to the sparsity pattern of the matrix somehow. This is therealm of various functions in the <a class="el" href="namespaceDoFTools.html">DoFTools</a> namespace like <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> and <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>. Essentially, what these functions do issimulate what happens during assembly of the system matrix: whenever assemblywould write a nonzero entry into the global matrix, the functions in DoFToolswould add an entry to the sparsity pattern. We could therefore do thefollowing: let <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> add all those entries to thesparsity pattern that arise from the regular cell-by-cell integration, andthen do the same by hand that arise from the interface terms. If you look atthe implementation of the interface integrals in the program below, it shouldbe obvious how to do that and would require no more than maybe 100 lines ofcode at most. But we're lazy people: the interface term couples degrees of freedom from twoadjacent cells along a face, which is exactly the kind of thing one would doin discontinuous Galerkin schemes for which the function <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> was written. This is a superset of matrixentries compared to the usual <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>: it will alsoadd all entries that result from computing terms coupling the degrees offreedom from both sides of all faces. Unfortunately, for the simplest versionof this function, this is a pretty big superset. Consider for example thefollowing mesh with two cells and a \(Q_1\) finite element: </p><div class="fragment"><div class="line">2---3---5</div><div class="line">|   |   |</div><div class="line">0---1---4</div></div><!-- fragment --><p> Here, the sparsity pattern produced by <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> willonly have entries for degrees of freedom that couple on a cell. However, itwill not have sparsity pattern entries \((0,4),(0,5),(2,4),(2,5)\) . The sparsitypattern generated by <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> will have theseentries, however: it assumes that you want to build a sparsity pattern for abilinear form that couples <em>all</em> degrees of freedom from adjacentcells. This is not what we want: our interface term acts only on a smallsubset of cells, and we certainly don't need all the extra couplings betweentwo adjacent fluid cells, or two adjacent solid cells. Furthermore, the fact that weuse higher order elements means that we would really generate many many moreentries than we actually need: on the coarsest mesh, in 2d, 44,207 nonzeroentries instead of 16,635 for <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>, leading toplenty of zeros in the matrix we later build (of course, the 16,635 are notenough since they don't include the interface entries). This ratio would beeven worse in 3d. So being extremely lazy comes with a cost: too many entries in the matrix. Butwe can get away with being moderately lazy: there is a variant of <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> that allows usto specify which vector components of the finite element couple with whichother components, both in cell terms as well as in face terms. For cells thatare in the solid subdomain, we couple all displacements with each other; forfluid cells, all velocities with all velocities and the pressure, but not thepressure with itself. Since no cell has both sets ofvariables, there is no need to distinguish between the two kinds of cells, sowe can write the mask like this: </p><div class="fragment"><div class="line"> <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> cell_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                      fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line"><span class="keywordflow">if</span> (((c&lt;dim+1) &amp;&amp; (d&lt;dim+1)</div><div class="line">   &amp;&amp; !((c==dim) &amp;&amp; (d==dim)))</div><div class="line">  ||</div><div class="line">  ((c&gt;=dim+1) &amp;&amp; (d&gt;=dim+1)))</div><div class="line">cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::Coupling::always</a>;</div></div><!-- fragment --><p> Here, we have used the fact that the first <code>dim</code> components of thefinite element are the velocities, then the pressure, and then the <code>dim</code> displacements. (We could as well have stated that thevelocities/pressure also couple with the displacements since no cell ever hasboth sets of variables.) On the other hand, the interface terms require a masklike this: </p><div class="fragment"><div class="line"> <a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> face_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                      fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line"><span class="keywordflow">if</span> ((c&gt;=dim+1) &amp;&amp; (d&lt;dim+1))</div><div class="line">face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::Coupling::always</a>;</div></div><!-- fragment --><p> In other words, all displacement test functions (components <code>c&gt;=dim+1</code> ) couple with all velocity and pressure shape functionson the other side of an interface. This is not entirely true, though close: infact, the exact form of the interface term only those pressure displacementshape functions that are indeed nonzero on the common interface, which is nottrue for all shape functions; on the other hand, it really couples allvelocities (since the integral involves gradients of the velocity shapefunctions, which are all nonzero on all faces of the cell). However, the mask webuild above, is not capable of these subtleties. Nevertheless, through thesemasks we manage to get the number of sparsity pattern entries down to 21,028&mdash; good enough for now.</p>
<p><a class="anchor" id="Velocityboundaryconditionsontheinterface"></a></p><h4>Velocity boundary conditions on the interface</h4>
<p>The second difficulty is that while we know how to enforce a zerovelocity or stress on the external boundary (using <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, called with an appropriatecomponent mask and setting different boundary indicators for solid andfluid external boundaries), we now also needed the velocity to be zeroon the interior interface, i.e. \(\mathbf v|_{\Gamma_i}=0\) . At the timeof writing this, there is no function in deal.II that handles thispart, but it isn't particularly difficult to implement by hand:essentially, we just have to loop over all cells, and if it is a fluidcell and its neighbor is a solid cell, then add constraints thatensure that the velocity degrees of freedom on this face arezero. Some care is necessary to deal with the case that the adjacentsolid cell is refined, yielding the following code: </p><div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; local_face_dof_indices (stokes_fe.dofs_per_face);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell: dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line"><span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell))</div><div class="line"> <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">   <span class="keywordflow">if</span> (!cell-&gt;at_boundary(f))</div><div class="line">     {</div><div class="line">       <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">       <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>)</div><div class="line">        &amp;&amp;</div><div class="line">        (cell_is_in_solid_domain (cell-&gt;neighbor(f))))</div><div class="line">      face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">           <span class="comment">// The neighbor does have children. See if any of the cells</span></div><div class="line">           <span class="comment">// on the other side are elastic</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf=0; sf&lt;cell-&gt;face(f)-&gt;n_children(); ++sf)</div><div class="line">          <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell-&gt;neighbor_child_on_subface(f, sf)))</div><div class="line">            {</div><div class="line">                face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">           <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">      }</div><div class="line"></div><div class="line">       <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">        {</div><div class="line">          cell-&gt;face(f)-&gt;get_dof_indices (local_face_dof_indices, 0);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;local_face_dof_indices.size(); ++i)</div><div class="line">          <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt; dim)</div><div class="line">            constraints.add_line (local_face_dof_indices[i]);</div><div class="line">        }</div><div class="line">     }</div></div><!-- fragment --><p>The call <code>constraints.add_line(t)</code> tells theAffineConstraints to start a new constraint for degree of freedom <code>t</code> of the form \(x_t=\sum_{l=0}^{N-1} c_{tl} x_l + b_t\) . Typically, one would then proceed to set individual coefficients \(c_{tl}\) to nonzero values (using <a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">AffineConstraints::add_entry</a>) or set \(b_t\) to something nonzero (using <a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">AffineConstraints::set_inhomogeneity</a>); doing nothing as above, funny asit looks, simply leaves the constraint to be \(x_t=0\) , which is exactlywhat we need in the current context. The call to <a class="el" href="classFiniteElement.html#aecb73242a6dca33f8da1bb44a5f00d61">FiniteElement::face_system_to_component_index</a> makes sure that we only setboundary values to zero for velocity but not pressure components. Note that there are cases where this may yield incorrect results:notably, once we find a solid neighbor child to a current fluid cell,we assume that all neighbor children on the common face are in thesolid subdomain. But that need not be so; consider, for example, thefollowing mesh: </p><div class="fragment"><div class="line">+---------+----+----+</div><div class="line">|         | f  |    |</div><div class="line">|    f    +----+----+</div><div class="line">|         | s  |    |</div><div class="line">+---------+----+----+</div></div><!-- fragment --><p>In this case, we would set all velocity degrees of freedom on theright face of the left cell to zero, which is incorrect for the topdegree of freedom on that face. That said, that can only happen if thefluid and solid subdomains do not coincide with a set of completecoarse mesh cells &mdash; but this is a contradiction to theassumption stated at the end of the first section of thisintroduction.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>We will consider the following situation as a testcase: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.layout.png"/>
</div>
<p> As discussed at the top of this document, we need to assume in a few placesthat a cell is either entirely in the fluid or solid part of the domain and,furthermore, that all children of an inactive cell also belong to the samesubdomain. This can definitely be ensured if the coarse mesh alreadysubdivides the mesh into solid and fluid coarse mesh cells; given the geometryoutlined above, we can do that by using an \(8\times 8\) coarse mesh,conveniently provided by the <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> function. The fixed boundary at the bottom implies \(\mathbf u=0\) , and we alsoprescribe Dirichlet conditions for the flow at the top so that we getinflow at the left and outflow at the right. At the left and rightboundaries, no boundary conditions are imposed explicitly for theflow, yielding the implicit no-stress condition \((2\eta \varepsilon(\mathbf v) - p \mathbf 1) \cdot \mathbf n = 0\) .The conditions on the interface between the two domains has already beendiscussed above. For simplicity, we choose the material parameters to be \(\eta=\lambda=\mu=1\) . In the results section below, we will also showa 3d simulation that can be obtained from the same program. Theboundary conditions and geometry are defined nearly analogously to the2d situation above.</p>
<p><a class="anchor" id="Identifyingwhichsubdomainacellisin"></a></p><h4>Identifying which subdomain a cell is in</h4>
<p>Secondly, we use an object of type <a class="el" href="classDoFHandler.html">DoFHandler</a> operating in <em>hp</em>-mode. Thisclass needs to know which cells will use the Stokes and which the elasticityfinite element. At the beginning of each refinement cycle we will thereforehave to walk over all cells and set the (in hp-parlance) active FE index towhatever is appropriate in the current situation. While we can use symbolicnames for the material id, the active FE index is in fact a number that willfrequently be used to index into collections of objects (e.g. of type <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> and <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>); that means that the active FE indexactually has to have value zero for the fluid and one for the elastic part ofthe domain.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h4>Linear solvers</h4>
<p>This program is primarily intended to show how to deal with differentphysics in different parts of the domain, and how to implement suchmodels in deal.II. As a consequence, we won't bother coming up with agood solver: we'll just use the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class which alwaysworks, even if not with optimal complexity. We will, however, commenton possible other solvers in the <a href="#Results">results</a> section.</p>
<p><a class="anchor" id="Meshrefinement"></a></p><h4>Mesh refinement</h4>
<p>One of the trickier aspects of this program is how to estimate theerror. Because it works on almost any program, we'd like to use theKellyErrorEstimator, and we can relatively easily do that here as well usingcode like the following: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> stokes_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> elasticity_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; stokes_component_mask (dim+1+dim, <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line"> stokes_component_mask[d] = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                   face_q_collection,</div><div class="line">                                   std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>*&gt;(),</div><div class="line">                                   solution,</div><div class="line">                                   stokes_estimated_error_per_cell,</div><div class="line">                                   stokes_component_mask);</div><div class="line"></div><div class="line">std::vector&lt;bool&gt; elasticity_component_mask (dim+1+dim, <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line"> elasticity_component_mask[dim+1+d] = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                   face_q_collection,</div><div class="line">                                   std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>*&gt;(),</div><div class="line">                                   solution,</div><div class="line">                                   elasticity_estimated_error_per_cell,</div><div class="line">                                   elasticity_component_mask);</div></div><!-- fragment --><p> This gives us two sets of error indicators for each cell. We would thensomehow combine them into one for mesh refinement, for example using somethinglike the following (note that we normalize the squared error indicator in thetwo vectors because error quantities have physical units that do not match inthe current situation, leading to error indicators that may differ by ordersof magnitude between the two subdomains): </p><div class="fragment"><div class="line">stokes_estimated_error_per_cell /= stokes_estimated_error_per_cell.l2_norm();</div><div class="line">elasticity_estimated_error_per_cell /= elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">estimated_error_per_cell += elasticity_estimated_error_per_cell;</div></div><!-- fragment --><p> (In the code, we actually weigh the error indicators 4:1 in favor of the onescomputed on the Stokes subdomain since refinement is otherwise heavily biasedtowards the elastic subdomain, but this is just a technicality. The factor 4has been determined heuristically to work reasonably well.) While this principle is sound, it doesn't quite work as expected. The reasonis that the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class computes error indicators by integratingthe jump in the solution's gradient around the faces of each cell. This jumpis likely to be very large at the locations where the solution isdiscontinuous and extended by zero; it also doesn't become smaller as the meshis refined. The <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class can't just ignore the interfacebecause it essentially only sees a <a class="el" href="classDoFHandler.html">DoFHandler</a> in <em>hp</em>-mode where the elementtype changes from one cell to another &mdash; precisely the thing that the<em>hp</em>-mode was designed for, the interface in the current program looks nodifferent than the interfaces in <a class="el" href="step_27.html">step-27</a> , for example, and certainly no lesslegitimate. Be that as it may, the end results is that there is a layer ofcells on both sides of the interface between the two subdomains where errorindicators are irrationally large. Consequently, most of the mesh refinementis focused on the interface. This clearly wouldn't happen if we had a refinement indicator that actuallyunderstood something about the problem and simply ignore the interface betweensubdomains when integrating jump terms.On the other hand, this program isabout showing how to represent problems where we have different physics indifferent subdomains, not about the peculiarities of the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>,and so we resort to the big hammer called "heuristics": we simply set theerror indicators of cells at the interface to zero. This cuts off the spikesin the error indicators. At first sight one would also think that it preventsthe mesh from being refined at the interface, but the requirement thatneighboring cells may only differ by one level of refinement will still leadto a reasonably refined mesh. While this is clearly a suboptimal solution, it works for now and leaves roomfor future improvement.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The include files for this program are the same as for many others before. The only new one is the one that declares <a class="el" href="classFE__Nothing.html">FE_Nothing</a> as discussed in the introduction. The ones in the hp directory have already been discussed in <a class="el" href="step_27.html">step-27</a> .</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step46</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeFluidStructureProblemcodeclasstemplate"></a> </p><h3>The <code>FluidStructureProblem</code> class template</h3>
<p>This is the main class. It is, if you want, a combination of <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_22.html">step-22</a> in that it has member variables that either address the global problem (the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, as well as the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> and various linear algebra objects) or that pertain to either the elasticity or Stokes sub-problems. The general structure of the class, however, is like that of most of the other programs implementing stationary problems. There are a few helper functions (<code>cell_is_in_fluid_domain, cell_is_in_solid_domain</code>) of self-explanatory nature (operating on the symbolic names for the two subdomains that will be used as material_ids for cells belonging to the subdomains, as explained in the introduction) and a few functions (<code>make_grid, set_active_fe_indices, assemble_interface_terms</code>) that have been broken out of other functions that can be found in many of the other tutorial programs and that will be discussed as we get to their implementation. The final set of variables ( <code>viscosity, lambda, eta</code> ) describes the material properties used for the two physics models.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>FluidStructureProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  FluidStructureProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">enum</span></div><div class="line">  {</div><div class="line">    fluid_domain_id,</div><div class="line">    solid_domain_id</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_fluid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_solid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> set_active_fe_indices();</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_interface_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">    std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">    std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         stokes_fe;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         elasticity_fe;</div><div class="line">  <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>       dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lambda;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3>Boundary values and right hand side</h3>
<p>The following class does as its name suggests. The boundary values for the velocity are \(\mathbf u=(0, \sin(\pi x))^T\) in 2d and \(\mathbf u=(0, 0, \sin(\pi x)\sin(\pi y))^T\) in 3d, respectively. The remaining boundary conditions for this problem are all homogeneous and have been discussed in the introduction. The right hand side forcing term is zero for both the fluid and the solid so we don't need an extra class for it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StokesBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1 + dim)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> StokesBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (component == dim</div><div class="line"></div><div class="line">- 1)</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> p[0]);</div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> p[0]) <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> p[1]);</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesBoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = StokesBoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeFluidStructureProblemcodeimplementation"></a> </p><h3>The <code>FluidStructureProblem</code> implementation</h3>
<p><a class="anchor" id="Constructorsandhelperfunctions"></a> </p><h4>Constructors and helper functions</h4>
<p>Let's now get to the implementation of the primary class of this program. The first few functions are the constructor and the helper functions that can be used to determine which part of the domain a cell is in. Given the discussion of these topics in the introduction, their implementation is rather obvious. In the constructor, note that we have to construct the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> object from the base elements for Stokes and elasticity; using the <a class="el" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">hp::FECollection::push_back</a> function assigns them spots zero and one in this collection, an order that we have to remember and use consistently in the rest of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">FluidStructureProblem&lt;dim&gt;::FluidStructureProblem(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree)</div><div class="line">  : stokes_degree(stokes_degree)</div><div class="line">  , elasticity_degree(elasticity_degree)</div><div class="line">  , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1),</div><div class="line">              dim,</div><div class="line">              <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree),</div><div class="line">              1,</div><div class="line">              <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">              dim)</div><div class="line">  , elasticity_fe(<a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                  dim,</div><div class="line">                  <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                  1,</div><div class="line">                  <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(elasticity_degree),</div><div class="line">                  dim)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , viscosity(2)</div><div class="line">  , lambda(1)</div><div class="line">  , mu(1)</div><div class="line">{</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(stokes_fe);</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(elasticity_fe);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_fluid_domain(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (cell-&gt;material_id() == fluid_domain_id);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_solid_domain(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (cell-&gt;material_id() == solid_domain_id);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Meshesandassigningsubdomains"></a> </p><h4>Meshes and assigning subdomains</h4>
<p>The next pair of functions deals with generating a mesh and making sure all flags that denote subdomains are correct. <code>make_grid</code> , as discussed in the introduction, generates an \(8\times 8\) mesh (or an \(8\times 8\times 8\) mesh in 3d) to make sure that each coarse mesh cell is completely within one of the subdomains. After generating this mesh, we loop over its boundary and set the boundary indicator to one at the top boundary, the only place where we set nonzero Dirichlet boundary conditions. After this, we loop again over all cells to set the material indicator &mdash; used to denote which part of the domain we are in, to either the fluid or solid indicator.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 8,</div><div class="line"></div><div class="line">-1, 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; (face-&gt;center()[dim</div><div class="line"></div><div class="line">- 1] == 1))</div><div class="line">        face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &lt; 0.25) &amp;&amp;</div><div class="line">         (cell-&gt;center()[dim</div><div class="line"></div><div class="line">- 1] &gt; 0.5)) ||</div><div class="line">        ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &gt;= 0.25) &amp;&amp;</div><div class="line">         (cell-&gt;center()[dim</div><div class="line"></div><div class="line">- 1] &gt;</div><div class="line"></div><div class="line">-0.5)))</div><div class="line">      cell-&gt;set_material_id(fluid_domain_id);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      cell-&gt;set_material_id(solid_domain_id);</div><div class="line">}</div></div><!-- fragment --><p>The second part of this pair of functions determines which finite element to use on each cell. Above we have set the material indicator for each coarse mesh cell, and as mentioned in the introduction, this information is inherited from mother to child cell upon mesh refinement. In other words, whenever we have refined (or created) the mesh, we can rely on the material indicators to be a correct description of which part of the domain a cell is in. We then use this to set the active FE index of the cell to the corresponding element of the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> member variable of this class: zero for fluid cells, one for solid cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::set_active_fe_indices()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">        cell-&gt;set_active_fe_index(0);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">        cell-&gt;set_active_fe_index(1);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemsetup_dofscode"></a> </p><h4><code>FluidStructureProblem::setup_dofs</code></h4>
<p>The next step is to setup the data structures for the linear system. To this end, we first have to set the active FE indices with the function immediately above, then distribute degrees of freedom, and then determine constraints on the linear system. The latter includes hanging node constraints as usual, but also the inhomogeneous boundary values at the top fluid boundary, and zero boundary values along the perimeter of the solid subdomain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  set_active_fe_indices();</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_collection);</div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             StokesBoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints,</div><div class="line">                                             fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(</div><div class="line">                                               velocities));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      dof_handler,</div><div class="line">      0,</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1 + dim),</div><div class="line">      constraints,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line">  }</div></div><!-- fragment --><p>There are more constraints we have to handle, though: we have to make sure that the velocity is zero at the interface between fluid and solid. The following piece of code was already presented in the introduction:</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_face_dof_indices(</div><div class="line">    stokes_fe.n_dofs_per_face());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">          {</div><div class="line">            <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (cell_is_in_solid_domain(cell-&gt;neighbor(face_no))))</div><div class="line">              face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf = 0;</div><div class="line">                     sf &lt; cell-&gt;face(face_no)-&gt;n_children();</div><div class="line">                     ++sf)</div><div class="line">                  <span class="keywordflow">if</span> (cell_is_in_solid_domain(</div><div class="line">                        cell-&gt;neighbor_child_on_subface(face_no, sf)))</div><div class="line">                    {</div><div class="line">                      face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                      <span class="keywordflow">break</span>;</div><div class="line">                    }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">              {</div><div class="line">                cell-&gt;face(face_no)-&gt;get_dof_indices(local_face_dof_indices,</div><div class="line">                                                     0);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; local_face_dof_indices.size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt;</div><div class="line">                      dim)</div><div class="line">                    constraints.add_line(local_face_dof_indices[i]);</div><div class="line">              }</div><div class="line">          }</div><div class="line">}</div></div><!-- fragment --><p>At the end of all this, we can declare to the constraints object that we now have all constraints ready to go and that the object can rebuild its internal data structures for better efficiency:</p>
<div class="fragment"><div class="line">constraints.close();</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>In the rest of this function we create a sparsity pattern as discussed extensively in the introduction, and use it to initialize the matrix; then also set vectors to their correct sizes:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> cell_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> face_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (((c &lt; dim + 1) &amp;&amp; (d &lt; dim + 1) &amp;&amp;</div><div class="line">               !((c == dim) &amp;&amp; (d == dim))) ||</div><div class="line">              ((c &gt;= dim + 1) &amp;&amp; (d &gt;= dim + 1)))</div><div class="line">            cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((c &gt;= dim + 1) &amp;&amp; (d &lt; dim + 1))</div><div class="line">            face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler,</div><div class="line">                                         dsp,</div><div class="line">                                         cell_coupling,</div><div class="line">                                         face_coupling);</div><div class="line">    constraints.condense(dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemassemble_systemcode"></a> </p><h4><code>FluidStructureProblem::assemble_system</code></h4>
<p>Following is the central function of this program: the one that assembles the linear system. It has a long section of setting up auxiliary functions at the beginning: from creating the quadrature formulas and setting up the <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects necessary to integrate the cell terms as well as the interface terms for the case where cells along the interface come together at same size or with differing levels of refinement...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> stokes_quadrature(stokes_degree + 2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> elasticity_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a> q_collection;</div><div class="line">  q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_quadrature);</div><div class="line">  q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(elasticity_quadrature);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div><div class="line">                                 q_collection,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; common_face_quadrature(</div><div class="line">    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(stokes_degree + 2, elasticity_degree + 2));</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    stokes_fe_face_values(stokes_fe,</div><div class="line">                                          common_face_quadrature,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    elasticity_fe_face_values(elasticity_fe,</div><div class="line">                                              common_face_quadrature,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> stokes_fe_subface_values(stokes_fe,</div><div class="line">                                                common_face_quadrature,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> elasticity_fe_subface_values(elasticity_fe,</div><div class="line">                                                    common_face_quadrature,</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div></div><!-- fragment --><p>...to objects that are needed to describe the local contributions to the global linear system...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_dofs_per_cell =</div><div class="line">  elasticity_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix;</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_interface_matrix(elasticity_dofs_per_cell,</div><div class="line">                                          stokes_dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs;</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">std::vector&lt;types::global_dof_index&gt; neighbor_dof_indices(</div><div class="line">  stokes_dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> right_hand_side(dim + 1);</div></div><!-- fragment --><p>...to variables that allow us to extract certain components of the shape functions and cache their values rather than having to recompute them at every quadrature point:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; stokes_symgrad_phi_u(</div><div class="line">  stokes_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; stokes_div_phi_u(stokes_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; stokes_phi_p(stokes_dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;2, dim&gt;&gt; elasticity_grad_phi(elasticity_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         elasticity_div_phi(elasticity_dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; elasticity_phi(elasticity_dofs_per_cell);</div></div><!-- fragment --><p>Then comes the main loop over all cells and, as in <a class="el" href="step_27.html">step-27</a> , the initialization of the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object for the current cell and the extraction of a <a class="el" href="classFEValues.html">FEValues</a> object that is appropriate for the current cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    hp_fe_values.reinit(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div><div class="line"></div><div class="line">    local_matrix.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(),</div><div class="line">                        cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">    local_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p>With all of this done, we continue to assemble the cell terms for cells that are part of the Stokes and elastic regions. While we could in principle do this in one formula, in effect implementing the one bilinear form stated in the introduction, we realize that our finite element spaces are chosen in such a way that on each cell, one set of variables (either velocities and pressure, or displacements) are always zero, and consequently a more efficient way of computing local integrals is to do only what's necessary based on an <code>if</code> clause that tests which part of the domain we are in. The actual computation of the local matrix is the same as in <a class="el" href="step_22.html">step-22</a> as well as that given in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> documentation module for the elasticity equations:</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == stokes_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                {</div><div class="line">                  stokes_symgrad_phi_u[k] =</div><div class="line">                    fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                  stokes_div_phi_u[k] =</div><div class="line">                    fe_values[velocities].divergence(k, q);</div><div class="line">                  stokes_phi_p[k] = fe_values[pressure].value(k, q);</div><div class="line">                }</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (2 viscosity stokes_symgrad_phi_u[i]</div><div class="line">                       stokes_symgrad_phi_u[j]</div><div class="line"></div><div class="line">-</div><div class="line">                     stokes_div_phi_u[i] stokes_phi_p[j]</div><div class="line"></div><div class="line">-</div><div class="line">                     stokes_phi_p[i] stokes_div_phi_u[j])</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == elasticity_dofs_per_cell,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                {</div><div class="line">                  elasticity_grad_phi[k] =</div><div class="line">                    fe_values[displacements].gradient(k, q);</div><div class="line">                  elasticity_div_phi[k] =</div><div class="line">                    fe_values[displacements].divergence(k, q);</div><div class="line">                }</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  {</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (lambda elasticity_div_phi[i]</div><div class="line">                         elasticity_div_phi[j] +</div><div class="line">                       mu <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                           elasticity_grad_phi[j]) +</div><div class="line">                       mu</div><div class="line">                         <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                        <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(elasticity_grad_phi[j])))</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                  }</div><div class="line">            }</div><div class="line">        }</div></div><!-- fragment --><p>Once we have the contributions from cell integrals, we copy them into the global matrix (taking care of constraints right away, through the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a> function). Note that we have not written anything into the <code>local_rhs</code> variable, though we still need to pass it along since the elimination of nonzero boundary values requires the modification of local and consequently also global right hand side values:</p>
<div class="fragment"><div class="line">local_dof_indices.resize(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                       local_rhs,</div><div class="line">                                       local_dof_indices,</div><div class="line">                                       system_matrix,</div><div class="line">                                       system_rhs);</div></div><!-- fragment --><p>The more interesting part of this function is where we see about face terms along the interface between the two subdomains. To this end, we first have to make sure that we only assemble them once even though a loop over all faces of all cells would encounter each part of the interface twice. We arbitrarily make the decision that we will only evaluate interface terms if the current cell is part of the solid subdomain and if, consequently, a face is not at the boundary and the potential neighbor behind it is part of the fluid domain. Let's start with these conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">      {</div></div><!-- fragment --><p>At this point we know that the current cell is a candidate for integration and that a neighbor behind face <code>f</code> exists. There are now three possibilities:</p>
<ul>
<li>The neighbor is at the same refinement level and has no children.</li>
<li>The neighbor has children.</li>
<li>The neighbor is coarser. In all three cases, we are only interested in it if it is part of the fluid subdomain. So let us start with the first and simplest case: if the neighbor is at the same level, has no children, and is a fluid cell, then the two cells share a boundary that is part of the interface along which we want to integrate interface terms. All we have to do is initialize two <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object with the current face and the face of the neighboring cell (note how we find out which face of the neighboring cell borders on the current cell) and pass things off to the function that evaluates the interface terms (the third through fifth arguments to this function provide it with scratch arrays). The result is then again copied into the global matrix, using a function that knows that the DoF indices of rows and columns of the local matrix result from different cells:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">    (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">    cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">  {</div><div class="line">    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">    stokes_fe_face_values.reinit(cell-&gt;neighbor(f),</div><div class="line">                                 cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                            stokes_fe_face_values,</div><div class="line">                            elasticity_phi,</div><div class="line">                            stokes_symgrad_phi_u,</div><div class="line">                            stokes_phi_p,</div><div class="line">                            local_interface_matrix);</div><div class="line"></div><div class="line">    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">    constraints.distribute_local_to_global(</div><div class="line">      local_interface_matrix,</div><div class="line">      local_dof_indices,</div><div class="line">      neighbor_dof_indices,</div><div class="line">      system_matrix);</div><div class="line">  }</div></div><!-- fragment --><p>The second case is if the neighbor has further children. In that case, we have to loop over all the children of the neighbor to see if they are part of the fluid subdomain. If they are, then we integrate over the common interface, which is a face for the neighbor and a subface of the current cell, requiring us to use an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for the neighbor and an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> for the current cell:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                       (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>))</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface = 0;</div><div class="line">                       subface &lt; cell-&gt;face(f)-&gt;n_children();</div><div class="line">                       ++subface)</div><div class="line">                    <span class="keywordflow">if</span> (cell_is_in_fluid_domain(</div><div class="line">                          cell-&gt;neighbor_child_on_subface(f, subface)))</div><div class="line">                      {</div><div class="line">                        elasticity_fe_subface_values.reinit(cell, f, subface);</div><div class="line">                        stokes_fe_face_values.reinit(</div><div class="line">                          cell-&gt;neighbor_child_on_subface(f, subface),</div><div class="line">                          cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                        assemble_interface_term(elasticity_fe_subface_values,</div><div class="line">                                                stokes_fe_face_values,</div><div class="line">                                                elasticity_phi,</div><div class="line">                                                stokes_symgrad_phi_u,</div><div class="line">                                                stokes_phi_p,</div><div class="line">                                                local_interface_matrix);</div><div class="line"></div><div class="line">                        cell-&gt;neighbor_child_on_subface(f, subface)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                        constraints.distribute_local_to_global(</div><div class="line">                          local_interface_matrix,</div><div class="line">                          local_dof_indices,</div><div class="line">                          neighbor_dof_indices,</div><div class="line">                          system_matrix);</div><div class="line">                      }</div><div class="line">                }</div></div><!-- fragment --><p>The last option is that the neighbor is coarser. In that case we have to use an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object for the neighbor and a <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for the current cell; the rest is the same as before:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                       cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                {</div><div class="line">                  elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                  stokes_fe_subface_values.reinit(</div><div class="line">                    cell-&gt;neighbor(f),</div><div class="line">                    cell-&gt;neighbor_of_coarser_neighbor(f).first,</div><div class="line">                    cell-&gt;neighbor_of_coarser_neighbor(f).second);</div><div class="line"></div><div class="line">                  assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                          stokes_fe_subface_values,</div><div class="line">                                          elasticity_phi,</div><div class="line">                                          stokes_symgrad_phi_u,</div><div class="line">                                          stokes_phi_p,</div><div class="line">                                          local_interface_matrix);</div><div class="line"></div><div class="line">                  cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                  constraints.distribute_local_to_global(</div><div class="line">                    local_interface_matrix,</div><div class="line">                    local_dof_indices,</div><div class="line">                    neighbor_dof_indices,</div><div class="line">                    system_matrix);</div><div class="line">                }</div><div class="line">            }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the function that assembles the global system, we passed computing interface terms to a separate function we discuss here. The key is that even though we can't predict the combination of <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects, they are both derived from the <a class="el" href="classFEFaceValuesBase.html">FEFaceValuesBase</a> class and consequently we don't have to care: the function is simply called with two such objects denoting the values of the shape functions on the quadrature points of the two sides of the face. We then do what we always do: we fill the scratch arrays with the values of shape functions and their derivatives, and then loop over all entries of the matrix to compute the local integrals. The details of the bilinear form we evaluate here are given in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_interface_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">  std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">  std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a> ==</div><div class="line">           elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_quadrature_points =</div><div class="line">    elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">  local_interface_matrix = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">        elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">        {</div><div class="line">          stokes_symgrad_phi_u[k] =</div><div class="line">            stokes_fe_face_values[velocities].symmetric_gradient(k, q);</div><div class="line">          stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">           ++k)</div><div class="line">        elasticity_phi[k] =</div><div class="line">          elasticity_fe_face_values[displacements].value(k, q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">           ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">          local_interface_matrix(i, j) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-((2 viscosity (stokes_symgrad_phi_u[j] normal_vector)</div><div class="line"></div><div class="line">-</div><div class="line">               stokes_phi_p[j] normal_vector)</div><div class="line">              elasticity_phi[i] stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemsolvecode"></a> </p><h4><code>FluidStructureProblem::solve</code></h4>
<p>As discussed in the introduction, we use a rather trivial solver here: we just pass the linear system off to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct solver (see, for example, <a class="el" href="step_29.html">step-29</a> ). The only thing we have to do after solving is ensure that hanging node and boundary value constraints are correct.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemoutput_resultscode"></a> </p><h4><code>FluidStructureProblem::output_results</code></h4>
<p>Generating graphical output is rather trivial here: all we have to do is identify which components of the solution vector belong to scalars and/or vectors (see, for example, <a class="el" href="step_22.html">step-22</a> for a previous example), and then pass it all on to the <a class="el" href="classDataOut.html">DataOut</a> class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemrefine_meshcode"></a> </p><h4><code>FluidStructureProblem::refine_mesh</code></h4>
<p>The next step is to refine the mesh. As was discussed in the introduction, this is a bit tricky primarily because the fluid and the solid subdomains use variables that have different physical dimensions and for which the absolute magnitude of error estimates is consequently not directly comparable. We will therefore have to scale them. At the top of the function, we therefore first compute error estimates for the different variables separately (using the velocities but not the pressure for the fluid domain, and the displacements in the solid domain):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> stokes_estimated_error_per_cell(</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> elasticity_estimated_error_per_cell(</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; stokes_face_quadrature(stokes_degree + 2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; elasticity_face_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_q_collection;</div><div class="line">  face_q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_face_quadrature);</div><div class="line">  face_q_collection.push_back(elasticity_face_quadrature);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    face_q_collection,</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">    solution,</div><div class="line">    stokes_estimated_error_per_cell,</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    face_q_collection,</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">    solution,</div><div class="line">    elasticity_estimated_error_per_cell,</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div></div><!-- fragment --><p>We then normalize error estimates by dividing by their norm and scale the fluid error indicators by a factor of 4 as discussed in the introduction. The results are then added together into a vector that contains error indicators for all cells:</p>
<div class="fragment"><div class="line">stokes_estimated_error_per_cell=</div><div class="line">  4. / stokes_estimated_error_per_cell.l2_norm();</div><div class="line">elasticity_estimated_error_per_cell=</div><div class="line">  1. / elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">estimated_error_per_cell += elasticity_estimated_error_per_cell;</div></div><!-- fragment --><p>The second to last part of the function, before actually refining the mesh, involves a heuristic that we have already mentioned in the introduction: because the solution is discontinuous, the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class gets all confused about cells that sit at the boundary between subdomains: it believes that the error is large there because the jump in the gradient is large, even though this is entirely expected and a feature that is in fact present in the exact solution as well and therefore not indicative of any numerical error. Consequently, we set the error indicators to zero for all cells at the interface; the conditions determining which cells this affects are slightly awkward because we have to account for the possibility of adaptively refined meshes, meaning that the neighboring cell can be coarser than the current one, or could in fact be refined some more. The structure of these nested conditions is much the same as we encountered when assembling interface terms in <code>assemble_system</code> .</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">              (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                cell_is_in_fluid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">               ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                (cell_is_in_fluid_domain(</div><div class="line">                  cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">               (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                cell_is_in_fluid_domain(cell-&gt;neighbor(f)))))</div><div class="line">            estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">              (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                cell_is_in_solid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">               ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                (cell_is_in_solid_domain(</div><div class="line">                  cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">               (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                cell_is_in_solid_domain(cell-&gt;neighbor(f)))))</div><div class="line">            estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.0);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemruncode"></a> </p><h4><code>FluidStructureProblem::run</code></h4>
<p>This is, as usual, the function that controls the overall flow of operation. If you've read through tutorial programs <a class="el" href="step_1.html">step-1</a> through <a class="el" href="step_6.html">step-6</a> , for example, then you are already quite familiar with the following structure:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">FluidStructureProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  make_grid();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 10</div><div class="line"></div><div class="line">- 2 dim;</div><div class="line">       ++refinement_cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">        refine_mesh();</div><div class="line"></div><div class="line">      setup_dofs();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl;</div><div class="line">      assemble_system();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line">      solve();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing output...&quot;</span> &lt;&lt; std::endl;</div><div class="line">      output_results(refinement_cycle);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step46</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main()</code> function</h4>
<p>This, final, function contains pretty much exactly what most of the other tutorial programs have:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>Step46;</div><div class="line"></div><div class="line">    FluidStructureProblem&lt;2&gt; flow_problem(1, 1);</div><div class="line">    flow_problem.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="2dresults"></a></p><h3>2d results</h3>
<p>When running the program, you should get output like the following: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">Number of active cells: 64</div><div class="line">Number of degrees of freedom: 531</div><div class="line">Assembling...</div><div class="line">Solving...</div><div class="line">Writing output...</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">Number of active cells: 136</div><div class="line">Number of degrees of freedom: 1260</div><div class="line">Assembling...</div><div class="line">Solving...</div><div class="line">Writing output...</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">Number of active cells: 436</div><div class="line">Number of degrees of freedom: 3723</div><div class="line">Assembling...</div><div class="line">Solving...</div><div class="line">Writing output...</div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">Number of active cells: 1072</div><div class="line">Number of degrees of freedom: 7493</div><div class="line">Assembling...</div><div class="line">Solving...</div><div class="line">Writing output...</div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">Number of active cells: 2632</div><div class="line">Number of degrees of freedom: 15005</div><div class="line">Assembling...</div><div class="line">Solving...</div><div class="line">Writing output...</div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">Number of active cells: 5944</div><div class="line">Number of degrees of freedom: 29437</div><div class="line">Assembling...</div><div class="line">Solving...</div><div class="line">Writing output...</div></div><!-- fragment --><p>The results are easily visualized: </p><table width="80%" align="center">
<tr valign="top">
<td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.velocity-2d.png"/>
</div>
 <p>Magnitude and vectors for the fluid velocity. </p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.pressure-2d.png"/>
</div>
 <p>Fluid pressure. The dynamic range has been truncated to cut off the pressure singularities at the top left and right corners of the domain as well as the top corners of the solid that forms re-entrant corners into the fluid domain. </p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.displacement-2d.png"/>
</div>
 <p>Magnitude and vectors for the solid displacement. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>The plots are easily interpreted: as the flow drives down on the left side andup on the right side of the upright part of the solid, it produces apressure that is high on the left and low on the right, and theseforces bend the vertical part of the solid to the right.</p>
<p><a class="anchor" id="3dresults"></a></p><h3>3d results</h3>
<p>By changing the dimension of the <code>FluidStructureProblem</code> class in <code>main()</code> to 3, we can also run the same problem3d. You'd get output along the following lines: </p><div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">Number of active cells: 512</div><div class="line">Number of degrees of freedom: 11631</div><div class="line">Assembling...</div><div class="line">Solving...</div><div class="line">Writing output...</div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">Number of active cells: 1716</div><div class="line">Number of degrees of freedom: 48984</div><div class="line">Assembling...</div><div class="line">Solving...</div><div class="line">Writing output...</div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">Number of active cells: 8548</div><div class="line">Number of degrees of freedom: 245746</div><div class="line">Assembling...</div><div class="line">Solving...</div></div><!-- fragment --><p> You'll notice that the big bottleneck is the solver: SparseDirectUmfpack needsnearly 5 hours and some 80 GB of memory to solve the last iteration ofthis problem on a 2016 workstation (the second to last iteration took only 16minutes). Clearly a better solver is needed here, a topic discussed below. The results can also be visualized and yield good pictures aswell. Here is one, showing both a vector plot for the velocity (inoranges), the solid displacement (in blues), and shading the solid region: </p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.3d.png"/>
</div>
 <p>In addition to the lack of a good solver, the mesh is a bitunbalanced: mesh refinement heavily favors the fluid subdomain (in 2d,it was the other way around, prompting us to weigh the fluid errorindicators higher). Clearly, some tweaking of the relative importanceof error indicators in the two subdomains is important if one wantedto go on doing more 3d computations.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Linearsolversandpreconditioners"></a></p><h4>Linear solvers and preconditioners</h4>
<p>An obvious place to improve the program would be to use a moresophisticated solver &mdash; in particular one that scales well andwill also work for realistic 3d problems. This shouldn't actually betoo hard to achieve here, because of the one-way coupling from fluidinto solid. To this end, assume we had re-ordered degrees of freedomin such a way that we first have all velocity and pressure degrees offreedom, and then all displacements (this is easily possible using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>). Then the system matrix could be splitinto the following block form: </p><p class="formulaDsp">
\[ A_\text{global} = \begin{pmatrix} A_{\text{fluid}} &amp; 0 \\ B &amp; A_{\text{solid}} \end{pmatrix} \]
</p>
<p> \(A_{\text{fluid}}\) is the Stokes matrix for velocity and pressure (itcould be further subdivided into a \(2\times 2\) matrix as in <a class="el" href="step_22.html">step-22</a> , thoughthis is immaterial for the current purpose), \(A_{\text{solid}}\) results from the elasticity equations for thedisplacements, and \(B\) is the matrix that comes from the interfaceconditions. Now notice that the matrix </p><p class="formulaDsp">
\[ A_\text{global}^{-1} = \begin{pmatrix} A_{\text{fluid}}^{-1} &amp; 0 \\ -A_\text{solid}^{-1} B A_\text{fluid}^{-1} &amp; A_{\text{solid}}^{-1} \end{pmatrix} \]
</p>
<p> the inverse of \(A_\text{global}\) . Applying this matrix requiresonly one solve with \(A_\text{fluid}\) and \(A_\text{solid}\) each since </p><p class="formulaDsp">
\[ \begin{pmatrix} p_x \\ p_y \end{pmatrix} = \begin{pmatrix} A_{\text{fluid}}^{-1} &amp; 0 \\ -A_\text{solid}^{-1} B A_\text{fluid}^{-1} &amp; A_{\text{solid}}^{-1} \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} \]
</p>
<p> be computed as \(p_x = A_{\text{fluid}}^{-1} x\) followed by \(p_y = A_{\text{solid}}^{-1} (y-Bp_x)\) . One can therefore expect that </p><p class="formulaDsp">
\[ \widetilde{A_\text{global}^{-1}} = \begin{pmatrix} \widetilde{A_{\text{fluid}}^{-1}} &amp; 0 \\ -\widetilde{A_\text{solid}^{-1}} B \widetilde{A_\text{fluid}^{-1}} &amp; \widetilde{A_{\text{solid}}^{-1}} \end{pmatrix} \]
</p>
<p> be a good preconditioner if \(\widetilde{A_{\text{fluid}}^{-1}} \approx A_{\text{fluid}}^{-1}, \widetilde{A_{\text{solid}}^{-1}} \approx A_{\text{solid}}^{-1}\) . That means, we only need good preconditioners for Stokes and theelasticity equations separately. These are well known: forStokes, we can use the preconditioner discussed in the results sectionof <a class="el" href="step_22.html">step-22</a> ; for elasticity, a good preconditioner would be a singleV-cycle of a geometric or algebraic multigrid. There are more openquestions, however: For an "optimized" solver block-triangularpreconditioner built from two sub-preconditioners, one point thatoften comes up is that, when choosing parameters for thesub-preconditioners, values that work well when solving the twoproblems separately may not be optimal when combined into amultiphysics preconditioner. In particular, when solving just a solidor fluid mechanics problem separately, the balancing act between thenumber of iterations to convergence and the cost of applying thepreconditioner on a per iteration basis may lead one to choose anexpensive preconditioner for the Stokes problem and a cheappreconditioner for the elasticity problem (or vice versa). Whencombined, however, there is the additional constraint that you wantthe two sub-preconditioners to converge at roughly the same rate, orelse the cheap one may drive up the global number of iterations whilethe expensive one drives up the cost-per-iteration. For example, while a single AMGV-cycle is a good approach for elasticity by itself, when combinedinto a multiphysics problem there may be an incentive to using a fullW-cycle or multiple cycles to help drive down the total solve time.</p>
<p><a class="anchor" id="Refinementindicators"></a></p><h4>Refinement indicators</h4>
<p>As mentioned in the introduction, the refinement indicator we use for thisprogram is rather ad hoc. A better one would understand that the jump in thegradient of the solution across the interface is not indicative of the errorbut to be expected and ignore the interface when integrating the jumpterms. Nevertheless, this is not what the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> classdoes. Another, bigger question, is whether this kind of estimator is a goodstrategy in the first place: for example, if we want to have maximal accuracyin one particular aspect of the displacement (e.g. the displacement at the topright corner of the solid), then is it appropriate to scale the errorindicators for fluid and solid to the same magnitude? Maybe it is necessary tosolve the fluid problem with more accuracy than the solid because the fluidsolution directly affects the solids solution? Maybe the other way around? Consequently, an obvious possibility for improving the program would be toimplement a better refinement criterion. There is some literature on thistopic; one of a variety of possible starting points would be the paper byThomas Wick on "Adaptive finite elements for monolithic fluid-structureinteraction on a prolongated domain: Applied to an heart valve simulation",Proceedings of the Computer Methods in Mechanics Conference 2011 (CMM-2011),9-12 May 2011, Warszaw, Poland.</p>
<p><a class="anchor" id="Verification"></a></p><h4>Verification</h4>
<p>The results above are purely qualitative as there is no evidence that ourscheme in fact converges. An obvious thing to do would therefore be to addsome quantitative measures to check that the scheme at least converges to<em>something</em>. For example, we could output for each refinement cycle thedeflection of the top right corner of the part of the solid that protrudesinto the fluid subdomain. Or we could compute the net force vector or torquethe fluid exerts on the solid.</p>
<p><a class="anchor" id="Bettermodels"></a></p><h4>Better models</h4>
<p>In reality, most fluid structure interaction problems are so that the movementof the solid does affect the flow of the fluid. For example, the forces of theair around an air foil cause it to flex and to change its shape. Likewise, aflag flaps in the wind, completely changing its shape. Such problems where the coupling goes both ways are typically handled in anArbitrary Lagrangian Eulerian (ALE) framework, in which the displacement ofthe solid is extended into the fluid domain in some smooth way, rather than byzero as we do here. The extended displacement field is then used to deform themesh on which we compute the fluid flow. Furthermore, the boundary conditionsfor the fluid on the interface are no longer that the velocity is zero;rather, in a time dependent program, the fluid velocity must be equal to thetime derivative of the displacement along the interface.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step46</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>FluidStructureProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    FluidStructureProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span></div><div class="line">    {</div><div class="line">      fluid_domain_id,</div><div class="line">      solid_domain_id</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_fluid_domain(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_solid_domain(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> set_active_fe_indices();</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_interface_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">      std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">      std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         stokes_fe;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         elasticity_fe;</div><div class="line">    <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>       dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lambda;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1 + dim)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> StokesBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (component == dim - 1)</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> 2:</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]);</div><div class="line">          <span class="keywordflow">case</span> 3:</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[1]);</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesBoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                               Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = StokesBoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  FluidStructureProblem&lt;dim&gt;::FluidStructureProblem(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree)</div><div class="line">    : stokes_degree(stokes_degree)</div><div class="line">    , elasticity_degree(elasticity_degree)</div><div class="line">    , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1),</div><div class="line">                dim,</div><div class="line">                <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree),</div><div class="line">                1,</div><div class="line">                <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                dim)</div><div class="line">    , elasticity_fe(<a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                    dim,</div><div class="line">                    <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                    1,</div><div class="line">                    <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(elasticity_degree),</div><div class="line">                    dim)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , viscosity(2)</div><div class="line">    , lambda(1)</div><div class="line">    , mu(1)</div><div class="line">  {</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(stokes_fe);</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(elasticity_fe);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_fluid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (cell-&gt;material_id() == fluid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_solid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (cell-&gt;material_id() == solid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 8, -1, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; (face-&gt;center()[dim - 1] == 1))</div><div class="line">          face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &lt; 0.25) &amp;&amp;</div><div class="line">           (cell-&gt;center()[dim - 1] &gt; 0.5)) ||</div><div class="line">          ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &gt;= 0.25) &amp;&amp;</div><div class="line">           (cell-&gt;center()[dim - 1] &gt; -0.5)))</div><div class="line">        cell-&gt;set_material_id(fluid_domain_id);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        cell-&gt;set_material_id(solid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::set_active_fe_indices()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          cell-&gt;set_active_fe_index(0);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          cell-&gt;set_active_fe_index(1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    set_active_fe_indices();</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_collection);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               1,</div><div class="line">                                               StokesBoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(</div><div class="line">                                                 velocities));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        0,</div><div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1 + dim),</div><div class="line">        constraints,</div><div class="line">        fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_face_dof_indices(</div><div class="line">        stokes_fe.n_dofs_per_face());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                    (cell_is_in_solid_domain(cell-&gt;neighbor(face_no))))</div><div class="line">                  face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf = 0;</div><div class="line">                         sf &lt; cell-&gt;face(face_no)-&gt;n_children();</div><div class="line">                         ++sf)</div><div class="line">                      <span class="keywordflow">if</span> (cell_is_in_solid_domain(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(face_no, sf)))</div><div class="line">                        {</div><div class="line">                          face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                          <span class="keywordflow">break</span>;</div><div class="line">                        }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">                  {</div><div class="line">                    cell-&gt;face(face_no)-&gt;get_dof_indices(local_face_dof_indices,</div><div class="line">                                                         0);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; local_face_dof_indices.size();</div><div class="line">                         ++i)</div><div class="line">                      <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt;</div><div class="line">                          dim)</div><div class="line">                        constraints.add_line(local_face_dof_indices[i]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">    }</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> cell_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                                 fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> face_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                                 fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (((c &lt; dim + 1) &amp;&amp; (d &lt; dim + 1) &amp;&amp;</div><div class="line">                 !((c == dim) &amp;&amp; (d == dim))) ||</div><div class="line">                ((c &gt;= dim + 1) &amp;&amp; (d &gt;= dim + 1)))</div><div class="line">              cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ((c &gt;= dim + 1) &amp;&amp; (d &lt; dim + 1))</div><div class="line">              face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          }</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler,</div><div class="line">                                           dsp,</div><div class="line">                                           cell_coupling,</div><div class="line">                                           face_coupling);</div><div class="line">      constraints.condense(dsp);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> stokes_quadrature(stokes_degree + 2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> elasticity_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a> q_collection;</div><div class="line">    q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_quadrature);</div><div class="line">    q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(elasticity_quadrature);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div><div class="line">                                   q_collection,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; common_face_quadrature(</div><div class="line">      <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(stokes_degree + 2, elasticity_degree + 2));</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    stokes_fe_face_values(stokes_fe,</div><div class="line">                                            common_face_quadrature,</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    elasticity_fe_face_values(elasticity_fe,</div><div class="line">                                                common_face_quadrature,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> stokes_fe_subface_values(stokes_fe,</div><div class="line">                                                  common_face_quadrature,</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> elasticity_fe_subface_values(elasticity_fe,</div><div class="line">                                                      common_face_quadrature,</div><div class="line">                                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_dofs_per_cell =</div><div class="line">      elasticity_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_interface_matrix(elasticity_dofs_per_cell,</div><div class="line">                                              stokes_dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; neighbor_dof_indices(</div><div class="line">      stokes_dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> right_hand_side(dim + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; stokes_symgrad_phi_u(</div><div class="line">      stokes_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt; stokes_div_phi_u(stokes_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt; stokes_phi_p(stokes_dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; elasticity_grad_phi(elasticity_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         elasticity_div_phi(elasticity_dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; elasticity_phi(elasticity_dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        hp_fe_values.reinit(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div><div class="line"></div><div class="line">        local_matrix.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(),</div><div class="line">                            cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">        local_rhs.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == stokes_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                  {</div><div class="line">                    stokes_symgrad_phi_u[k] =</div><div class="line">                      fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                    stokes_div_phi_u[k] =</div><div class="line">                      fe_values[velocities].divergence(k, q);</div><div class="line">                    stokes_phi_p[k] = fe_values[pressure].value(k, q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (2 * viscosity * stokes_symgrad_phi_u[i] *</div><div class="line">                         stokes_symgrad_phi_u[j] -</div><div class="line">                       stokes_div_phi_u[i] * stokes_phi_p[j] -</div><div class="line">                       stokes_phi_p[i] * stokes_div_phi_u[j]) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == elasticity_dofs_per_cell,</div><div class="line">                   <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                  {</div><div class="line">                    elasticity_grad_phi[k] =</div><div class="line">                      fe_values[displacements].gradient(k, q);</div><div class="line">                    elasticity_div_phi[k] =</div><div class="line">                      fe_values[displacements].divergence(k, q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    {</div><div class="line">                      local_matrix(i, j) +=</div><div class="line">                        (lambda * elasticity_div_phi[i] *</div><div class="line">                           elasticity_div_phi[j] +</div><div class="line">                         mu * <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                             elasticity_grad_phi[j]) +</div><div class="line">                         mu *</div><div class="line">                           <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                          <a class="code" href="derivative__form_8h.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(elasticity_grad_phi[j]))) *</div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                    }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        local_dof_indices.resize(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                    (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                    cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                  {</div><div class="line">                    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                    stokes_fe_face_values.reinit(cell-&gt;neighbor(f),</div><div class="line">                                                 cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                            stokes_fe_face_values,</div><div class="line">                                            elasticity_phi,</div><div class="line">                                            stokes_symgrad_phi_u,</div><div class="line">                                            stokes_phi_p,</div><div class="line">                                            local_interface_matrix);</div><div class="line"></div><div class="line">                    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                    constraints.distribute_local_to_global(</div><div class="line">                      local_interface_matrix,</div><div class="line">                      local_dof_indices,</div><div class="line">                      neighbor_dof_indices,</div><div class="line">                      system_matrix);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                         (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>))</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface = 0;</div><div class="line">                         subface &lt; cell-&gt;face(f)-&gt;n_children();</div><div class="line">                         ++subface)</div><div class="line">                      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(f, subface)))</div><div class="line">                        {</div><div class="line">                          elasticity_fe_subface_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell, f, subface);</div><div class="line">                          stokes_fe_face_values.reinit(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(f, subface),</div><div class="line">                            cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                          assemble_interface_term(elasticity_fe_subface_values,</div><div class="line">                                                  stokes_fe_face_values,</div><div class="line">                                                  elasticity_phi,</div><div class="line">                                                  stokes_symgrad_phi_u,</div><div class="line">                                                  stokes_phi_p,</div><div class="line">                                                  local_interface_matrix);</div><div class="line"></div><div class="line">                          cell-&gt;neighbor_child_on_subface(f, subface)</div><div class="line">                            -&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                          constraints.distribute_local_to_global(</div><div class="line">                            local_interface_matrix,</div><div class="line">                            local_dof_indices,</div><div class="line">                            neighbor_dof_indices,</div><div class="line">                            system_matrix);</div><div class="line">                        }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                         cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                  {</div><div class="line">                    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                    stokes_fe_subface_values.reinit(</div><div class="line">                      cell-&gt;neighbor(f),</div><div class="line">                      cell-&gt;neighbor_of_coarser_neighbor(f).first,</div><div class="line">                      cell-&gt;neighbor_of_coarser_neighbor(f).second);</div><div class="line"></div><div class="line">                    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                            stokes_fe_subface_values,</div><div class="line">                                            elasticity_phi,</div><div class="line">                                            stokes_symgrad_phi_u,</div><div class="line">                                            stokes_phi_p,</div><div class="line">                                            local_interface_matrix);</div><div class="line"></div><div class="line">                    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                    constraints.distribute_local_to_global(</div><div class="line">                      local_interface_matrix,</div><div class="line">                      local_dof_indices,</div><div class="line">                      neighbor_dof_indices,</div><div class="line">                      system_matrix);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_interface_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">    std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">    std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a> ==</div><div class="line">             elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_quadrature_points =</div><div class="line">      elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">    local_interface_matrix = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_quadrature_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">          elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">          {</div><div class="line">            stokes_symgrad_phi_u[k] =</div><div class="line">              stokes_fe_face_values[velocities].symmetric_gradient(k, q);</div><div class="line">            stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">             ++k)</div><div class="line">          elasticity_phi[k] =</div><div class="line">            elasticity_fe_face_values[displacements].value(k, q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">             ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">            local_interface_matrix(i, j) +=</div><div class="line">              -((2 * viscosity * (stokes_symgrad_phi_u[j] * normal_vector) -</div><div class="line">                 stokes_phi_p[j] * normal_vector) *</div><div class="line">                elasticity_phi[i] * stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; stokes_estimated_error_per_cell(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    Vector&lt;float&gt; elasticity_estimated_error_per_cell(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; stokes_face_quadrature(stokes_degree + 2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; elasticity_face_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim - 1&gt; face_q_collection;</div><div class="line">    face_q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_face_quadrature);</div><div class="line">    face_q_collection.push_back(elasticity_face_quadrature);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      face_q_collection,</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      stokes_estimated_error_per_cell,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      face_q_collection,</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      elasticity_estimated_error_per_cell,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line"></div><div class="line">    stokes_estimated_error_per_cell *=</div><div class="line">      4. / stokes_estimated_error_per_cell.l2_norm();</div><div class="line">    elasticity_estimated_error_per_cell *=</div><div class="line">      1. / elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">    estimated_error_per_cell += elasticity_estimated_error_per_cell;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                  cell_is_in_fluid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">                 ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                  (cell_is_in_fluid_domain(</div><div class="line">                    cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">                 (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                  cell_is_in_fluid_domain(cell-&gt;neighbor(f)))))</div><div class="line">              estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                  cell_is_in_solid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">                 ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                  (cell_is_in_solid_domain(</div><div class="line">                    cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">                 (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                  cell_is_in_solid_domain(cell-&gt;neighbor(f)))))</div><div class="line">              estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">          }</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.0);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">FluidStructureProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 10 - 2 * dim;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing output...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step46</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step46;</div><div class="line"></div><div class="line">      FluidStructureProblem&lt;2&gt; flow_problem(1, 1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_22.html">step-22</a>, <a class="el" href="step_27.html">step-27</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thegeneralidea">The general idea</a>
        <li><a href="#Implementation">Implementation</a>
        <li><a href="#Specificsoftheimplementation"> Specifics of the implementation </a>
      <ul>
        <li><a href="#Dealingwiththeinterfaceterms">Dealing with the interface terms</a>
        <li><a href="#Velocityboundaryconditionsontheinterface">Velocity boundary conditions on the interface</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
      <ul>
        <li><a href="#Identifyingwhichsubdomainacellisin">Identifying which subdomain a cell is in</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Meshrefinement">Mesh refinement</a>
    </ul>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeFluidStructureProblemcodeclasstemplate">The <code>FluidStructureProblem</code> class template</a>
        <li><a href="#Boundaryvaluesandrighthandside">Boundary values and right hand side</a>
        <li><a href="#ThecodeFluidStructureProblemcodeimplementation">The <code>FluidStructureProblem</code> implementation</a>
      <ul>
        <li><a href="#Constructorsandhelperfunctions">Constructors and helper functions</a>
        <li><a href="#Meshesandassigningsubdomains">Meshes and assigning subdomains</a>
        <li><a href="#codeFluidStructureProblemsetup_dofscode"><code>FluidStructureProblem::setup_dofs</code></a>
        <li><a href="#codeFluidStructureProblemassemble_systemcode"><code>FluidStructureProblem::assemble_system</code></a>
        <li><a href="#codeFluidStructureProblemsolvecode"><code>FluidStructureProblem::solve</code></a>
        <li><a href="#codeFluidStructureProblemoutput_resultscode"><code>FluidStructureProblem::output_results</code></a>
        <li><a href="#codeFluidStructureProblemrefine_meshcode"><code>FluidStructureProblem::refine_mesh</code></a>
        <li><a href="#codeFluidStructureProblemruncode"><code>FluidStructureProblem::run</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#2dresults">2d results</a>
        <li><a href="#3dresults">3d results</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
        <li><a href="#Refinementindicators">Refinement indicators</a>
        <li><a href="#Verification">Verification</a>
        <li><a href="#Bettermodels">Better models</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-46/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The University of California &ndash; Davis. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>这个程序处理的是在领域的不同部分耦合不同物理学的问题。具体来说，让我们考虑以下情况，即把斯托克斯流体与弹性固体耦合起来（这两个问题以前在步骤22和步骤8中分别讨论过，你可能想在那里阅读一下各个方程式）。</p>
<ul>
<li><p class="startli">在 \(\Omega\) 的 \(\Omega_f\) 部分，我们有一个流动的流体，满足与时间无关的斯托克斯方程（以涉及应变张量的形式）。 </p><p class="formulaDsp">
\begin{align*} -2\eta\nabla \cdot \varepsilon(\mathbf v) + \nabla p &amp;= 0, \qquad \qquad &amp;&amp; \text{in}\ \Omega_f\\ -\nabla \cdot \mathbf v &amp;= 0 &amp;&amp; \text{in}\ \Omega_f. \end{align*}
</p>
<p class="startli">这里， \(\mathbf v, p\) 分别是流体的速度和压力。 我们规定了部分外部边界上的速度， </p><p class="formulaDsp">
\begin{align*} \mathbf v = \mathbf v_0 \qquad\qquad \text{on}\ \Gamma_{f,1} \subset \partial\Omega \cap \partial\Omega_f \end{align*}
</p>
<p> 。</p>
<p class="startli">而我们假设外部边界的其余部分为自由流动条件， </p><p class="formulaDsp">
\begin{align*} (2\eta \varepsilon(\mathbf v) - p \mathbf 1) \cdot \mathbf n = 0 \qquad\qquad \text{on}\ \Gamma_{f,2} = \partial\Omega \cap \partial\Omega_f \backslash \Gamma_{f,1}. \end{align*}
</p>
</li>
<li><p class="startli">域的其余部分， \(\Omega_s = \Omega \backslash \Omega_f\) 被一个固体占据，其变形场 \(\mathbf u\) 满足弹性方程， </p><p class="formulaDsp">
\begin{align*} -\nabla \cdot C \varepsilon(\mathbf u) = 0 \qquad\qquad &amp; \text{in}\ \Omega_s, \end{align*}
</p>
<p>。</p>
<p class="startli">其中 \(C\) 是等级4的弹性张量（我们将使用一个特别简单的形式，假设固体是各向异性的）。 它在对沿固体边界流动的流体所施加的力的反应中发生变形。我们假设这种变形非常小，以至于它对流体没有反馈作用，也就是说，这种耦合只是在一个方向。为了简单起见，我们将假设固体的外部边界是被夹紧的，即 </p><p class="formulaDsp">
\begin{align*} \mathbf u = \mathbf 0 \qquad\qquad \text{on}\ \Gamma_{s,1} = \partial\Omega \cap \partial\Omega_s \end{align*}
</p>
<p> 。</p>
</li>
<li><p class="startli">作为小位移假设的结果，我们将对流体和固体之间的界面提出以下边界条件：首先，我们对流体没有滑移的边界条件， </p><p class="formulaDsp">
\begin{align*} \mathbf v = \mathbf 0 \qquad\qquad \text{on}\ \Gamma_{i} = \partial\Omega_s \cap \partial\Omega_f. \end{align*}
</p>
<p> 。</p>
<p class="startli">其次，固体上的力（牵引力）等于来自流体的法向应力， </p><p class="formulaDsp">
\begin{align*} (C \varepsilon(\mathbf u)) \mathbf n = (2 \eta \varepsilon(\mathbf v) - p \mathbf 1) \mathbf n \qquad\qquad \text{on}\ \Gamma_{i} = \partial\Omega_s \cap \partial\Omega_f, \end{align*}
</p>
<p> 。</p>
<p class="startli">其中 \(\mathbf{n}\) 是 \(\Gamma_{i}\) 上的法向量，从固体指向流体。</p>
</li>
</ul>
<p>我们通过遵循我们通常的规则，即从左边乘以一个测试函数并在域上进行积分，得到这个问题的弱表述。那么它看起来像这样。找到 \(y = \{\mathbf v, p, \mathbf u\} \in Y \subset H^1(\Omega_f)^d \times L_2(\Omega_f) \times H^1(\Omega_s)^d\) ，使得</p>
<p class="formulaDsp">
\begin{align*} 2 \eta (\varepsilon(\mathbf a), \varepsilon(\mathbf v))_{\Omega_f} - (\nabla \cdot \mathbf a, p)_{\Omega_f} - (q, \nabla \cdot \mathbf v)_{\Omega_f} &amp; \\ + (\varepsilon(\mathbf b), C \varepsilon(\mathbf u))_{\Omega_s} &amp; \\ - (\mathbf b, (2 \eta \varepsilon(\mathbf v) - p \mathbf 1) \mathbf n)_{\Gamma_i} &amp;= 0, \end{align*}
</p>
<p>为所有测试函数 \(\mathbf a, q, \mathbf b\) ；第一、第二和第三行分别对应于流体、固体和界面贡献。请注意， \(Y\) 只是上述空间的一个子空间，以适应各种迪里切特边界条件。</p>
<p>当然，只要有两个Triangulation和两个DoFHandler对象，两个子域各一个，就可以实现这种耦合。另一方面，如果有一个知道整个问题离散化的单一DoFHandler对象，那么deal.II的使用就简单多了。</p>
<p>这个程序是关于如何实现这一点的。请注意，我们的目标并不是要提出一个特别有用的物理模型（一个现实的流固交互模型必须考虑到固体的有限变形和它对流体的影响）：这毕竟只是一个旨在演示技术的教程程序，而不是为了解决实际问题。此外，我们将假设子域之间的界面与粗略的网格单元面对齐。</p>
<p><a class="anchor" id="Thegeneralidea"></a></p><h3>The general idea</h3>
<p>在讨论更多细节之前，让我们先说明一下：这是一个有多个解变量的问题；为此，你可能想先阅读一下 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 文档模块，它介绍了我们处理有多个解变量问题的基本哲学框架。但回到手头的问题上。</p>
<p>在deal.II中实现这类问题的基本思路如下：在问题表述中，速度和压力变量 \(\mathbf v, p\) 只存在于流体子域 \(\Omega_f\) 中。但我们假设将它们以零点扩展到整个域 \(\Omega\) （在一般情况下，这意味着它们沿 \(\Gamma_i\) 将是不连续的）。那么，什么是这些变量的适当函数空间呢？我们知道，在 \(\Omega_f\) 上我们应该要求 \(\mathbf v \in H^1(\Omega_f)^d, p \in L_2(\Omega_f)\) ，所以对于 \(\tilde{\mathbf v}, \tilde p\) 到整个域的扩展，下面出现了一组有用的函数空间。</p>
<p class="formulaDsp">
\begin{align*} \tilde {\mathbf v} &amp;\in V = \{\tilde {\mathbf v}|_{\Omega_f} \in H^1(\Omega_f)^d, \quad \tilde {\mathbf v}|_{\Omega_s} = 0 \} \\ \tilde p &amp;\in P = \{\tilde p|_{\Omega_f} \in L_2(\Omega_f), \quad \tilde p|_{\Omega_s} = 0 \}. \end{align*}
</p>
<p>(由于这对目前的讨论并不重要，我们从函数空间的选择中省略了边界值的问题；这个问题也影响到我们是否可以为压力选择 \(L_2\) 或者我们是否必须为压力选择空间 \(L_{2,0}(\Omega_f)=\{q\in L_2(\Omega_f): \int_{\Omega_f} q = 0\}\) 。不过，这些问题都与下面的讨论无关)。</p>
<p>请注意，这些确实是一个具有明显规范的线性函数空间。由于在实践中不可能发生混淆，因此我们今后将再次省略省略号，以表示一个函数对整个域的扩展，并简单地用 \(\mathbf v, p\) 来指代原始函数和扩展函数。</p>
<p>对于离散化，我们需要 \(V_h,P_h\) 的有限维子空间 \(V, P\) 。对于斯托克斯，我们从步骤22中知道，适当的选择是 \(Q_{p+1}^d\times Q_P\) ，但这只适用于流体占据的那部分域。对于扩展场，让我们使用以下定义在三角形上的子空间 \(\mathbb T\) 。</p>
<p class="formulaDsp">
\begin{align*} V_h &amp;= \{{\mathbf v}_h \quad | \quad \forall K \in {\mathbb T}: {\mathbf v}_h|_K \in Q_{p+1}^d\ \text{if}\ K\subset {\Omega_f}, \quad {\mathbf v}_h|_{\Omega_f}\ \text{is continuous}, \quad {\mathbf v}_h|_K = 0\ \text{if}\ K\subset {\Omega_s}\} &amp;&amp; \subset V \\ P_h &amp;= \{ p_h \quad | \quad \forall K \in {\mathbb T}: p_h|_K \in Q_p\ \text{if}\ K\subset {\Omega_f}, \quad p_h|_{\Omega_f}\ \text{is continuous}, \quad p_h|_K = 0\ \text{if}\ K\subset {\Omega_s}\ \} &amp;&amp; \subset P. \end{align*}
</p>
<p>换句话说，在 \(\Omega_f\) 上，我们选择了通常的离散空间，但我们保留了由零扩展的（不连续的）。要说明的是，我们现在需要一个描述在单元上为零的函数的有限元空间&mdash;而这正是FE_Nothing类的用武之地：它描述了一个常数为零的函数的有限维函数空间。这个奇特的线性向量空间的一个特殊属性是它没有自由度：它不仅仅是有限维度的，它实际上是零维的，因此对于这种类型的对象， <a class="el" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">FiniteElement::n_dofs_per_cell()</a> 将返回零。为了下面的讨论，让我们给这个空间一个合适的符号。</p>
<p class="formulaDsp">
\[ Z = \{ \varphi: \varphi(x)=0 \}. \]
</p>
<p>符号 \(Z\) 提醒了这个空间的函数为零的事实。很明显，我们选择 \(Z_h=Z\) 。</p>
<p>对于我们用来描述弹性方程的变量，上面的整个讨论都可以重复。在这里，对于扩展变量，我们有</p>
<p class="formulaDsp">
\begin{align*} \tilde {\mathbf u} &amp;\in U = \{\tilde {\mathbf u}|_{\Omega_s} \in H^1(\Omega_f)^d, \quad \tilde {\mathbf u}|_{\Omega_f} \in Z(\Omega_s)^d \}, \end{align*}
</p>
<p>而我们通常会使用这样的一个有限元空间</p>
<p class="formulaDsp">
\begin{align*} U_h &amp;= \{{\mathbf u}_h \quad | \quad \forall K \in {\mathbb T}: {\mathbf u}_h|_K \in Q_r^d\ \text{if}\ K\subset {\Omega_s}, \quad {\mathbf u}_h|_{\Omega_f}\ \text{is continuous}, \quad {\mathbf u}_h|_K \in Z^d\ \text{if}\ K\subset {\Omega_f}\} &amp;&amp; \subset U \end{align*}
</p>
<p>的多项式程度 \(r\) 。</p>
<p>因此，总结起来，我们要在以下空间寻找一个离散的矢量值解 \(y_h = \{\mathbf v_h, p_h, \mathbf u_h\}\) 。</p>
<p class="formulaDsp">
\begin{align*} Y_h = \{ &amp; y_h = \{\mathbf v_h, p_h, \mathbf u_h\} : \\ &amp; y_h|_{\Omega_f} \in Q_{p+1}^d \times Q_p \times Z^d, \\ &amp; y_h|_{\Omega_s} \in Z^d \times Z \times Q_r^d \}. \end{align*}
</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>那么，我们如何实现这种事情呢？首先，我们意识到，离散空间 \(Y_h\) 本质上需要两个不同的有限元。首先，在流体子域上，我们需要元素 \(Q_{p+1}^d \times Q_p \times Z^d\) ，这在deal.II中很容易通过以下方式实现</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(p+1), dim,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(p), 1,</div><div class="line">               <a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), dim),</div></div><!-- fragment --><p>其中 <code><a class="el" href="classFE__Nothing.html">FE_Nothing</a></code> 实现了永远为零的函数的空间。其次，在实体子域上，我们需要元素 \(\in Z^d \times Z \times Q_r^d\) ，我们用以下方法得到它</p>
<div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> (<a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), dim,</div><div class="line">               <a class="code" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a>(), 1,</div><div class="line">               <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(r), dim),</div></div><!-- fragment --><p>下一步是，我们将这两个元素中的每一个都与占据两个子域的细胞联系起来。为此，我们认识到，从某种意义上说，这两个元素只是彼此的变化，因为它们具有相同数量的向量分量，但具有不同的多项式度数&amp;mdash；这很像人们在 \(hp\) 有限元方法中的做法，这也正是我们在这里要做的：我们将（ab）使用hp-namespace的类和设施，将不同的元素分配给不同的单元。换句话说，我们将使用 <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>, 中的两个有限元与一个适当的 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 集成，使用 <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> 对象，而我们的DoFHandler将处于<em>hp</em>模式下。你不妨看一下步骤27，了解所有这些概念的概况。</p>
<p>在继续描述测试案例之前，让我们先澄清一下<em>why</em>这种将函数以零为单位扩展到整个领域，然后将问题映射到hp-framework上的方法是有意义的。</p>
<ul>
<li>它使事情变得统一。在所有单元格中，向量分量的数量是相同的（这里是 <code>2*dim+1</code> ）。这使得各种事情都成为可能，因为统一的描述允许代码的重复使用。例如，计算每个向量分量的自由度 (<a class="el" href="namespaceDoFTools.html#a956ac5c6aab03ec1c04f1ad955301db9">DoFTools::count_dofs_per_fe_component</a>), 按分量对自由度进行排序 (<a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>), ，随后将矩阵和向量分割成块，以及其他许多函数都能一如既往地工作，而不需要为它们添加特殊的逻辑来描述某些变量只存在于部分领域的情况。因此，在像现在这样的程序中，你已经有了各种工具，这些工具最初并不是为多物理场情况编写的，但在目前的背景下却能正常工作。</li>
<li>它可以方便地进行图形化输出。我们支持的所有图形输出格式都要求输出中的每个字段都定义在网格的所有节点上。但是考虑到现在所有的解决方案组件都存在于各个地方，我们现有的DataOut例程可以像以前一样工作，并产生适合于可视化的图形输出&ndash;这些字段将简单地被扩展为0，如果不需要，可视化程序可以很容易地过滤掉这个值。</li>
<li>基本上没有成本。FE_Nothing的技巧并没有给整个问题增加任何自由度，我们也不需要处理属于这些分量的形状函数&amp;mdash；FE_Nothing没有自由度，也没有形状函数，它所做的只是占用了矢量分量。</li>
</ul>
<p><a class="anchor" id="Specificsoftheimplementation"></a></p><h3>Specifics of the implementation </h3>
<p>更具体地说，在该方案中，我们必须解决以下几点。</p>
<ul>
<li>实现双线性形式，特别是处理界面项，在矩阵和稀疏模式中都是如此。</li>
<li>在边界的外部和内部部分实施迪里希特边界条件 \(\partial\Omega_f,\partial\Omega_s\) 。</li>
</ul>
<p><a class="anchor" id="Dealingwiththeinterfaceterms"></a></p><h4>Dealing with the interface terms</h4>
<p>让我们首先讨论实现双线性形式，在离散水平上，我们记得它是</p>
<p class="formulaDsp">
\begin{align*} 2 \eta (\varepsilon(\mathbf a_h), \varepsilon(\mathbf v_h))_{\Omega_f} - (\nabla \cdot \mathbf a_h, p_h)_{\Omega_f} - (q_h, \nabla \cdot \mathbf v_h)_{\Omega_f} &amp; \\ + (\varepsilon(\mathbf b_h), C \varepsilon(\mathbf u_h))_{\Omega_s} &amp; \\ - (\mathbf b_h, (2 \eta \varepsilon(\mathbf v_h) - p \mathbf 1) \mathbf n)_{\Gamma_i} &amp;= 0, \end{align*}
</p>
<p>鉴于我们已经将场扩展为零，原则上我们可以将子域上的积分写成整个域 \(\Omega\) ，尽管在决定对哪些项进行积分之前，首先询问一个单元是弹性区域还是流体区域的一部分，这没有什么额外的努力。实际上，对这些项进行积分并不十分困难；对于斯托克斯方程，相关步骤已在步骤22中显示，而对于弹性方程，我们基本上采取 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中的形式（而不是步骤8中的形式）。</p>
<p>更值得关注的是界面术语。</p>
<p class="formulaDsp">
\[ -(\mathbf b_h, (2 \eta \varepsilon(\mathbf v_h) - p \mathbf 1) \mathbf n)_{\Gamma_i}. \]
</p>
<p>基于我们假设界面 \(\Gamma_i\) 与细胞边界重合，这实际上可以写成一组面积分。如果我们用提取器符号 \(\psi_i\in Y_h\) 表示形状函数 \(\psi_i[\mathbf v],\psi_i[p], \psi_i[\mathbf u]\) 的速度、压力和位移分量，那么上述项就会产生对全局矩阵项 \(i,j\) 的如下贡献。</p>
<p class="formulaDsp">
\[ -\sum_K (\psi_i[\mathbf u], (2 \eta \varepsilon(\psi_j[\mathbf v]) - \psi_j[p] \mathbf 1) \mathbf n)_{\partial K \cap \Gamma_i}. \]
</p>
<p>虽然不是很明显，但这个术语带来了一点复杂的问题：虽然 \(\psi_i[\mathbf u]\) 和 \(\mathbf n\) 是在界面的实体一侧评估的（它们分别是位移和对 \(\Omega_s\) 的法向量的测试函数，我们需要在界面的流体一侧评估 \(\psi_j[\mathbf v],\psi_j[p]\) ，因为它们对应于流体施加的应力/力。换句话说，在我们的实现中，我们将需要界面两边的FEFaceValue对象。让事情变得更糟糕的是，我们可能还必须处理这样一个事实，即一方或另一方可能被细化，使我们需要在一个面的部分区域进行整合。请看下面的实现，如何处理这个问题。</p>
<p>作为一个额外的复杂问题，由这个术语产生的矩阵条目需要以某种方式添加到矩阵的稀疏模式中。这是DoFTools命名空间中各种函数的领域，比如 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> 和 <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>. 本质上，这些函数所做的是模拟系统矩阵装配过程中发生的事情：每当装配将非零条目写入全局矩阵，DoFTools中的函数将添加一个条目到稀疏模式中。因此，我们可以这样做：让 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> 将所有由常规的逐个单元积分产生的条目添加到稀疏性模式中，然后用手做同样的事情，即由接口项产生的条目。如果你看一下下面的程序中界面积分的实现，那么如何做应该是显而易见的，最多只需要不超过100行的代码。</p>
<p>但我们是懒人：界面项是沿一个面耦合两个相邻单元的自由度，这正是人们在非连续Galerkin方案中要做的事情，函数 <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> 就是为此而写。与通常的 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>: 相比，这是一个矩阵条目的超集，它还将添加所有计算来自所有面的两侧自由度的耦合项的条目。不幸的是，对于这个函数的最简单版本，这是一个相当大的超集。例如，考虑下面这个有两个单元和一个 \(Q_1\) 有限元的网格。</p>
<div class="fragment"><div class="line">2---3---5</div><div class="line">|   |   |</div><div class="line">0---1---4</div></div><!-- fragment --><p>这里，由 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> 产生的稀疏模式将只有在一个单元上耦合的自由度的条目。然而，它不会有稀疏模式条目 \((0,4),(0,5),(2,4),(2,5)\) 。然而，由 <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> 生成的稀疏模式将有这些条目：它假定你想为一个双线性形式建立一个稀疏模式，该形式将<em>all</em>自由度从相邻的单元上耦合起来。这不是我们想要的：我们的界面项只作用于一小部分单元，我们当然不需要两个相邻流体单元或两个相邻固体单元之间的所有额外耦合。此外，我们使用高阶元素的事实意味着我们确实会产生比实际需要多得多的条目：在最粗的网格上，在2D中，44,207个非零条目而不是16,635个 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>, ，导致我们后来建立的矩阵中出现大量的零（当然，16,635是不够的，因为它们不包括界面条目）。这个比例在3D中会更糟糕。</p>
<p>所以极度懒惰是有代价的：矩阵中的条目太多。但我们可以适度偷懒：有一个 <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> 的变体，允许我们指定有限元的哪些矢量分量与哪些其他分量耦合，既可以用单元术语，也可以用面术语。对于实体子域中的单元，我们将所有位移相互耦合；对于流体单元，所有速度与所有速度和压力耦合，但压力不与自身耦合。由于没有一个单元同时拥有两组变量，因此没有必要区分这两种单元，所以我们可以这样写掩码。</p>
<div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> cell_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                           fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    <span class="keywordflow">if</span> (((c&lt;dim+1) &amp;&amp; (d&lt;dim+1)</div><div class="line">         &amp;&amp; !((c==dim) &amp;&amp; (d==dim)))</div><div class="line">        ||</div><div class="line">        ((c&gt;=dim+1) &amp;&amp; (d&gt;=dim+1)))</div><div class="line">      cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::Coupling::always</a>;</div></div><!-- fragment --><p>在这里，我们使用了这样一个事实：有限元的第一个 <code>dim</code> 分量是速度，然后是压力，最后是 <code>dim</code> 位移。(我们也可以说，速度/压力也与位移耦合，因为没有一个单元同时拥有两组变量)。另一方面，界面条款需要一个像这样的掩码。</p>
<div class="fragment"><div class="line"><a class="code" href="classTable.html">Table&lt;2,DoFTools::Coupling&gt;</a> face_coupling (fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                           fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c=0; c&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    <span class="keywordflow">if</span> ((c&gt;=dim+1) &amp;&amp; (d&lt;dim+1))</div><div class="line">      face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::Coupling::always</a>;</div></div><!-- fragment --><p>换句话说，所有的位移测试函数（组件 <code>c&gt;=dim+1</code> ）与界面另一侧的所有速度和压力形状函数耦合。这并不完全正确，尽管很接近：事实上，界面的确切形式仅指那些在共同界面上确实为非零的压力位移形状函数，这对所有形状函数来说并不正确；另一方面，它确实耦合了所有速度（因为积分涉及速度形状函数的梯度，这些梯度在单元的所有面上均为非零）。然而，我们在上面建立的掩码，并不具备这些微妙的能力。尽管如此，通过这些掩码，我们设法将稀疏模式的条目数降低到21028个&amp;mdash；目前来说已经足够了。</p>
<p><a class="anchor" id="Velocityboundaryconditionsontheinterface"></a></p><h4>Velocity boundary conditions on the interface</h4>
<p>第二个困难是，虽然我们知道如何在外部边界上强制执行速度或应力为零（使用 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>, 调用适当的分量掩码，并为固体和流体外部边界设置不同的边界指标），但现在我们还需要在内部界面上的速度为零，即 \(\mathbf v|_{\Gamma_i}=0\) 。在写这篇文章时，deal.II中没有处理这部分的函数，但用手实现并不特别困难：基本上，我们只需要在所有单元上循环，如果它是一个流体单元，而它的邻居是一个固体单元，然后添加约束，确保这个面上的速度自由度为零。在处理相邻的固体单元被细化的情况下，有必要进行一些处理，产生以下代码。</p>
<div class="fragment"><div class="line">std::vector&lt;unsigned int&gt; local_face_dof_indices (stokes_fe.dofs_per_face);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell: dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell_is_in_fluid_domain (cell))</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">      <span class="keywordflow">if</span> (!cell-&gt;at_boundary(f))</div><div class="line">        {</div><div class="line">          <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>)</div><div class="line">                  &amp;&amp;</div><div class="line">                  (cell_is_in_solid_domain (cell-&gt;neighbor(f))))</div><div class="line">                face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">                {</div><div class="line">              <span class="comment">// The neighbor does have children. See if any of the cells</span></div><div class="line">              <span class="comment">// on the other side are elastic</span></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf=0; sf&lt;cell-&gt;face(f)-&gt;n_children(); ++sf)</div><div class="line">                    <span class="keywordflow">if</span> (cell_is_in_solid_domain (cell-&gt;neighbor_child_on_subface(f, sf)))</div><div class="line">                      {</div><div class="line">                   face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                            <span class="keywordflow">break</span>;</div><div class="line">                      }</div><div class="line">                }</div><div class="line"></div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">           {</div><div class="line">             cell-&gt;face(f)-&gt;get_dof_indices (local_face_dof_indices, 0);</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;local_face_dof_indices.size(); ++i)</div><div class="line">             <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt; dim)</div><div class="line">               constraints.add_line (local_face_dof_indices[i]);</div><div class="line">           }</div><div class="line">        }</div></div><!-- fragment --><p>调用 <code>constraints.add_line(t)</code> 告诉AffineConstraints为自由度 <code>t</code> 启动一个新的约束，其形式为 \(x_t=\sum_{l=0}^{N-1} c_{tl} x_l + b_t\) 。通常情况下，我们会将单个系数 \(c_{tl}\) 设置为非零值（使用 <a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">AffineConstraints::add_entry</a>) 或将 \(b_t\) 设置为非零值（使用 <a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">AffineConstraints::set_inhomogeneity</a>); 像上面那样什么都不做，虽然看起来很有趣，但只是让约束成为 \(x_t=0\) ，这正是我们在当前情况下需要的。对 <a class="el" href="classFiniteElement.html#aecb73242a6dca33f8da1bb44a5f00d61">FiniteElement::face_system_to_component_index</a> 的调用确保了我们只将速度分量的边界值设置为零，而不是压力分量。</p>
<p>请注意，在有些情况下，这可能会产生不正确的结果：特别是，一旦我们找到当前流体单元的一个实体邻接子，我们就会假设共同面上的所有邻接子都在实体子域。但事实并非如此，例如，考虑以下的网格。</p>
<div class="fragment"><div class="line">+---------+----+----+</div><div class="line">|         | f  |    |</div><div class="line">|    f    +----+----+</div><div class="line">|         | s  |    |</div><div class="line">+---------+----+----+</div></div><!-- fragment --><p>在这种情况下，我们将把左单元右面的所有速度自由度设置为零，这对该面的顶部自由度来说是不正确的。也就是说，只有当流体和固体子域不与一组完整的粗网格单元重合时才会发生这种情况&mdash;但这与本介绍第一节末尾所述的假设是矛盾的。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>我们将考虑以下情况作为一个测试案例。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.layout.png"/>
</div>
<p>正如本文顶部所讨论的，我们需要在一些地方假设一个单元完全处于域的流体部分或固体部分，此外，一个不活动单元的所有子域也属于同一个子域。如果粗略网格已经将网格细分为实体和流体粗略网格单元，这一点肯定可以得到保证；考虑到上面概述的几何形状，我们可以通过使用 \(8\times 8\) 粗略网格，方便地提供 <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a> 函数来实现。</p>
<p>底部的固定边界意味着 \(\mathbf u=0\) ，我们也为顶部的流动规定了迪里希特条件，因此我们在左边得到流入，在右边得到流出。在左边和右边的边界，没有对流动施加明确的边界条件，产生隐性的无应力条件 \((2\eta \varepsilon(\mathbf v) - p \mathbf 1) \cdot \mathbf n = 0\) 。上面已经讨论了两个域之间的界面条件。</p>
<p>为了简单起见，我们选择材料参数为 \(\eta=\lambda=\mu=1\) 。在下面的结果部分，我们还将展示一个可以从同一程序中获得的三维模拟。边界条件和几何形状的定义几乎与上面的2d情况类似。</p>
<p><a class="anchor" id="Identifyingwhichsubdomainacellisin"></a></p><h4>Identifying which subdomain a cell is in</h4>
<p>在程序中，我们需要一种方法来识别一个细胞处于域的哪一部分。有许多不同的方法可以做到这一点。一个典型的方法是使用每个单元的 <a class="el" href="DEALGlossary.html#GlossSubdomainId">subdomain_id </a>标签，尽管这个字段在并行计算中具有特殊意义。另一种方法是 <a class="el" href="DEALGlossary.html#GlossMaterialId">material_id </a>字段，也是每个单元格都有的。它有一个额外的优点，就是在网格细化时，它可以从母体继承到子体；换句话说，我们在创建网格时设置一次材料ID，即使经过几次细化循环，它对所有活动单元都是正确的。因此，我们采用这种方法：我们定义一个 <code>enum</code> ，用符号名称来表示材料ID的数字，并使用它们来识别单元在域的哪一部分。</p>
<p>其次，我们使用一个在<em>hp</em>模式下运行的DoFHandler类型的对象。该类需要知道哪些单元将使用斯托克斯有限元，哪些使用弹性有限元。因此，在每个细化周期的开始，我们必须走过所有的单元，并将（在hp-parlance中）活动FE索引设置为任何适合当前情况的索引。虽然我们可以使用符号名称来表示材料ID，但主动FE索引实际上是一个数字，经常用于索引对象的集合（例如 <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> 和 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>); 类型），这意味着主动FE索引实际上对于领域的流体部分必须是0，对于弹性部分必须是1。</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h4>Linear solvers</h4>
<p>这个程序主要是为了展示如何处理领域内不同部分的不同物理现象，以及如何在deal.II中实现这样的模型。因此，我们不会费力想出一个好的求解器：我们只是使用SparseDirectUMFPACK类，它总是有效的，即使不是最佳的复杂性。然而，我们将在<a href="#Results">results</a>部分对可能的其他求解器进行评论。</p>
<p><a class="anchor" id="Meshrefinement"></a></p><h4>Mesh refinement</h4>
<p>这个程序的一个比较棘手的方面是如何估计误差。因为它几乎适用于任何程序，所以我们想使用KellyErrorEstimator，在这里我们也可以用下面这样的代码相对容易地做到。</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> stokes_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> elasticity_estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;bool&gt; stokes_component_mask (dim+1+dim, <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">  stokes_component_mask[d] = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                    face_q_collection,</div><div class="line">                                    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>*&gt;(),</div><div class="line">                                    solution,</div><div class="line">                                    stokes_estimated_error_per_cell,</div><div class="line">                                    stokes_component_mask);</div><div class="line"></div><div class="line"></div><div class="line">std::vector&lt;bool&gt; elasticity_component_mask (dim+1+dim, <span class="keyword">false</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">  elasticity_component_mask[dim+1+d] = <span class="keyword">true</span>;</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a> (dof_handler,</div><div class="line">                                    face_q_collection,</div><div class="line">                                    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>*&gt;(),</div><div class="line">                                    solution,</div><div class="line">                                    elasticity_estimated_error_per_cell,</div><div class="line">                                    elasticity_component_mask);</div></div><!-- fragment --><p>这就为每个单元提供了两套误差指标。然后我们会以某种方式将它们合并成一个用于网格细化，例如使用类似下面的方法（注意，我们将两个向量中的平方误差指标归一化，因为误差量的物理单位在当前情况下并不匹配，导致两个子域之间的误差指标可能存在数量级的差异）。</p>
<div class="fragment"><div class="line">stokes_estimated_error_per_cell /= stokes_estimated_error_per_cell.l2_norm();</div><div class="line">elasticity_estimated_error_per_cell /= elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">estimated_error_per_cell += elasticity_estimated_error_per_cell;</div></div><!-- fragment --><p>(在代码中，我们实际上以4:1的比例权衡误差指标，以支持在斯托克斯子域上计算的误差指标，因为细化在其他方面严重偏向弹性子域，但这只是一个技术问题。因素4已经被启发式地确定为相当好的工作。)</p>
<p>虽然这个原则是合理的，但它并不完全像预期的那样工作。原因是KellyErrorEstimator类是通过整合每个单元面周围的解的梯度跳跃来计算误差指标。这个跳跃在解不连续和扩展为零的地方可能非常大；它也不会随着网格的细化而变小。KellyErrorEstimator类不能忽视这个接口，因为它基本上只看到<em>hp</em>模式下的DoFHandler，其中元素类型从一个单元改变到另一个单元&amp;mdash；正是<em>hp</em>模式所设计的东西，当前程序中的接口看起来与步骤27中的接口没有什么不同，例如，当然也没有更合理的。尽管如此，最终的结果是，在两个子域之间的界面两侧都有一层单元，其误差指标大得不合理。因此，大部分的网格细化工作都集中在界面上。</p>
<p>如果我们有一个真正理解问题的细化指标，并且在积分跳跃项时简单地忽略子域之间的界面，这显然就不会发生。另一方面，这个程序是关于展示如何表示我们在不同子域有不同物理学的问题，而不是关于KellyErrorEstimator的特殊性，因此我们诉诸于被称为 "启发式 "的大锤子：我们简单地把界面上的单元格的误差指标设置为零。这就切断了误差指标中的尖峰。乍看之下，人们也会认为它阻止了网格在界面上的细化，但是相邻的单元只能有一级细化的要求，仍然会导致一个合理的细化网格。</p>
<p>虽然这显然是一个次优的解决方案，但它目前是可行的，并为未来的改进留下了空间。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The include files for this program are the same as for many others before. The only new one is the one that declares <a class="el" href="classFE__Nothing.html">FE_Nothing</a> as discussed in the introduction. The ones in the hp directory have already been discussed in <a class="el" href="step_27.html">step-27</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step46</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeFluidStructureProblemcodeclasstemplate"></a> </p><h3>The <code>FluidStructureProblem</code> class template</h3>
<p>This is the main class. It is, if you want, a combination of <a class="el" href="step_8.html">step-8</a> and <a class="el" href="step_22.html">step-22</a> in that it has member variables that either address the global problem (the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, as well as the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> and various linear algebra objects) or that pertain to either the elasticity or Stokes sub-problems. The general structure of the class, however, is like that of most of the other programs implementing stationary problems.</p>
<p>There are a few helper functions (<code>cell_is_in_fluid_domain, cell_is_in_solid_domain</code>) of self-explanatory nature (operating on the symbolic names for the two subdomains that will be used as material_ids for cells belonging to the subdomains, as explained in the introduction) and a few functions (<code>make_grid, set_active_fe_indices, assemble_interface_terms</code>) that have been broken out of other functions that can be found in many of the other tutorial programs and that will be discussed as we get to their implementation.</p>
<p>The final set of variables (<code>viscosity, lambda, eta</code>) describes the material properties used for the two physics models.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>FluidStructureProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  FluidStructureProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">enum</span></div><div class="line">  {</div><div class="line">    fluid_domain_id,</div><div class="line">    solid_domain_id</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_fluid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_solid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> set_active_fe_indices();</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_interface_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">    std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">    std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         stokes_fe;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         elasticity_fe;</div><div class="line">  <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>       dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> lambda;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundaryvaluesandrighthandside"></a> </p><h3>Boundary values and right hand side</h3>
<p>The following class does as its name suggests. The boundary values for the velocity are \(\mathbf u=(0, \sin(\pi x))^T\) in 2d and \(\mathbf u=(0, 0, \sin(\pi x)\sin(\pi y))^T\) in 3d, respectively. The remaining boundary conditions for this problem are all homogeneous and have been discussed in the introduction. The right hand side forcing term is zero for both the fluid and the solid so we don't need an extra class for it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>StokesBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1 + dim)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> StokesBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (component == dim - 1)</div><div class="line">    <span class="keywordflow">switch</span> (dim)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 2:</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]);</div><div class="line">        <span class="keywordflow">case</span> 3:</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[1]);</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesBoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                             <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = StokesBoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeFluidStructureProblemcodeimplementation"></a> </p><h3>The <code>FluidStructureProblem</code> implementation</h3>
<p><a class="anchor" id="Constructorsandhelperfunctions"></a> </p><h4>Constructors and helper functions</h4>
<p>Let's now get to the implementation of the primary class of this program. The first few functions are the constructor and the helper functions that can be used to determine which part of the domain a cell is in. Given the discussion of these topics in the introduction, their implementation is rather obvious. In the constructor, note that we have to construct the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> object from the base elements for Stokes and elasticity; using the <a class="el" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">hp::FECollection::push_back</a> function assigns them spots zero and one in this collection, an order that we have to remember and use consistently in the rest of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">FluidStructureProblem&lt;dim&gt;::FluidStructureProblem(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree)</div><div class="line">  : stokes_degree(stokes_degree)</div><div class="line">  , elasticity_degree(elasticity_degree)</div><div class="line">  , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1),</div><div class="line">              dim,</div><div class="line">              <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree),</div><div class="line">              1,</div><div class="line">              <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">              dim)</div><div class="line">  , elasticity_fe(<a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                  dim,</div><div class="line">                  <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                  1,</div><div class="line">                  <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(elasticity_degree),</div><div class="line">                  dim)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , viscosity(2)</div><div class="line">  , lambda(1)</div><div class="line">  , mu(1)</div><div class="line">{</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(stokes_fe);</div><div class="line">  fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(elasticity_fe);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_fluid_domain(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (cell-&gt;material_id() == fluid_domain_id);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_solid_domain(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (cell-&gt;material_id() == solid_domain_id);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Meshesandassigningsubdomains"></a> </p><h4>Meshes and assigning subdomains</h4>
<p>The next pair of functions deals with generating a mesh and making sure all flags that denote subdomains are correct. <code>make_grid</code>, as discussed in the introduction, generates an \(8\times 8\) mesh (or an \(8\times 8\times 8\) mesh in 3d) to make sure that each coarse mesh cell is completely within one of the subdomains. After generating this mesh, we loop over its boundary and set the boundary indicator to one at the top boundary, the only place where we set nonzero Dirichlet boundary conditions. After this, we loop again over all cells to set the material indicator &mdash; used to denote which part of the domain we are in, to either the fluid or solid indicator.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 8, -1, 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; (face-&gt;center()[dim - 1] == 1))</div><div class="line">        face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &lt; 0.25) &amp;&amp;</div><div class="line">         (cell-&gt;center()[dim - 1] &gt; 0.5)) ||</div><div class="line">        ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &gt;= 0.25) &amp;&amp;</div><div class="line">         (cell-&gt;center()[dim - 1] &gt; -0.5)))</div><div class="line">      cell-&gt;set_material_id(fluid_domain_id);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      cell-&gt;set_material_id(solid_domain_id);</div><div class="line">}</div></div><!-- fragment --><p>The second part of this pair of functions determines which finite element to use on each cell. Above we have set the material indicator for each coarse mesh cell, and as mentioned in the introduction, this information is inherited from mother to child cell upon mesh refinement.</p>
<p>In other words, whenever we have refined (or created) the mesh, we can rely on the material indicators to be a correct description of which part of the domain a cell is in. We then use this to set the active FE index of the cell to the corresponding element of the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> member variable of this class: zero for fluid cells, one for solid cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::set_active_fe_indices()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">        cell-&gt;set_active_fe_index(0);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">        cell-&gt;set_active_fe_index(1);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemsetup_dofscode"></a> </p><h4><code>FluidStructureProblem::setup_dofs</code></h4>
<p>The next step is to setup the data structures for the linear system. To this end, we first have to set the active FE indices with the function immediately above, then distribute degrees of freedom, and then determine constraints on the linear system. The latter includes hanging node constraints as usual, but also the inhomogeneous boundary values at the top fluid boundary, and zero boundary values along the perimeter of the solid subdomain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  set_active_fe_indices();</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_collection);</div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             StokesBoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints,</div><div class="line">                                             fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(</div><div class="line">                                               velocities));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      dof_handler,</div><div class="line">      0,</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1 + dim),</div><div class="line">      constraints,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line">  }</div></div><!-- fragment --><p>There are more constraints we have to handle, though: we have to make sure that the velocity is zero at the interface between fluid and solid. The following piece of code was already presented in the introduction:</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_face_dof_indices(</div><div class="line">    stokes_fe.n_dofs_per_face());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">          {</div><div class="line">            <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (cell_is_in_solid_domain(cell-&gt;neighbor(face_no))))</div><div class="line">              face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf = 0;</div><div class="line">                     sf &lt; cell-&gt;face(face_no)-&gt;n_children();</div><div class="line">                     ++sf)</div><div class="line">                  <span class="keywordflow">if</span> (cell_is_in_solid_domain(</div><div class="line">                        cell-&gt;neighbor_child_on_subface(face_no, sf)))</div><div class="line">                    {</div><div class="line">                      face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                      <span class="keywordflow">break</span>;</div><div class="line">                    }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">              {</div><div class="line">                cell-&gt;face(face_no)-&gt;get_dof_indices(local_face_dof_indices,</div><div class="line">                                                     0);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; local_face_dof_indices.size();</div><div class="line">                     ++i)</div><div class="line">                  <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt;</div><div class="line">                      dim)</div><div class="line">                    constraints.add_line(local_face_dof_indices[i]);</div><div class="line">              }</div><div class="line">          }</div><div class="line">}</div></div><!-- fragment --><p>At the end of all this, we can declare to the constraints object that we now have all constraints ready to go and that the object can rebuild its internal data structures for better efficiency:</p>
<div class="fragment"><div class="line">constraints.close();</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">          &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; std::endl;</div></div><!-- fragment --><p>In the rest of this function we create a sparsity pattern as discussed extensively in the introduction, and use it to initialize the matrix; then also set vectors to their correct sizes:</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> cell_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> face_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (((c &lt; dim + 1) &amp;&amp; (d &lt; dim + 1) &amp;&amp;</div><div class="line">               !((c == dim) &amp;&amp; (d == dim))) ||</div><div class="line">              ((c &gt;= dim + 1) &amp;&amp; (d &gt;= dim + 1)))</div><div class="line">            cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((c &gt;= dim + 1) &amp;&amp; (d &lt; dim + 1))</div><div class="line">            face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler,</div><div class="line">                                         dsp,</div><div class="line">                                         cell_coupling,</div><div class="line">                                         face_coupling);</div><div class="line">    constraints.condense(dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemassemble_systemcode"></a> </p><h4><code>FluidStructureProblem::assemble_system</code></h4>
<p>Following is the central function of this program: the one that assembles the linear system. It has a long section of setting up auxiliary functions at the beginning: from creating the quadrature formulas and setting up the <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects necessary to integrate the cell terms as well as the interface terms for the case where cells along the interface come together at same size or with differing levels of refinement...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> stokes_quadrature(stokes_degree + 2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> elasticity_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a> q_collection;</div><div class="line">  q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_quadrature);</div><div class="line">  q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(elasticity_quadrature);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div><div class="line">                                 q_collection,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; common_face_quadrature(</div><div class="line">    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(stokes_degree + 2, elasticity_degree + 2));</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    stokes_fe_face_values(stokes_fe,</div><div class="line">                                          common_face_quadrature,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    elasticity_fe_face_values(elasticity_fe,</div><div class="line">                                              common_face_quadrature,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> stokes_fe_subface_values(stokes_fe,</div><div class="line">                                                common_face_quadrature,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> elasticity_fe_subface_values(elasticity_fe,</div><div class="line">                                                    common_face_quadrature,</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div></div><!-- fragment --><p>...to objects that are needed to describe the local contributions to the global linear system...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_dofs_per_cell =</div><div class="line">  elasticity_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix;</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_interface_matrix(elasticity_dofs_per_cell,</div><div class="line">                                          stokes_dofs_per_cell);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs;</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">std::vector&lt;types::global_dof_index&gt; neighbor_dof_indices(</div><div class="line">  stokes_dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> right_hand_side(dim + 1);</div></div><!-- fragment --><p>...to variables that allow us to extract certain components of the shape functions and cache their values rather than having to recompute them at every quadrature point:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; stokes_symgrad_phi_u(</div><div class="line">  stokes_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; stokes_div_phi_u(stokes_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt; stokes_phi_p(stokes_dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;2, dim&gt;&gt; elasticity_grad_phi(elasticity_dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         elasticity_div_phi(elasticity_dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; elasticity_phi(elasticity_dofs_per_cell);</div></div><!-- fragment --><p>Then comes the main loop over all cells and, as in <a class="el" href="step_27.html">step-27</a>, the initialization of the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object for the current cell and the extraction of a <a class="el" href="classFEValues.html">FEValues</a> object that is appropriate for the current cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    hp_fe_values.reinit(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div><div class="line"></div><div class="line">    local_matrix.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(),</div><div class="line">                        cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">    local_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p>With all of this done, we continue to assemble the cell terms for cells that are part of the Stokes and elastic regions. While we could in principle do this in one formula, in effect implementing the one bilinear form stated in the introduction, we realize that our finite element spaces are chosen in such a way that on each cell, one set of variables (either velocities and pressure, or displacements) are always zero, and consequently a more efficient way of computing local integrals is to do only what's necessary based on an <code>if</code> clause that tests which part of the domain we are in.</p>
<p>The actual computation of the local matrix is the same as in <a class="el" href="step_22.html">step-22</a> as well as that given in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> documentation module for the elasticity equations:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == stokes_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            stokes_symgrad_phi_u[k] =</div><div class="line">              fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">            stokes_div_phi_u[k] =</div><div class="line">              fe_values[velocities].divergence(k, q);</div><div class="line">            stokes_phi_p[k] = fe_values[pressure].value(k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            local_matrix(i, j) +=</div><div class="line">              (2 * viscosity * stokes_symgrad_phi_u[i] *</div><div class="line">                 stokes_symgrad_phi_u[j] -</div><div class="line">               stokes_div_phi_u[i] * stokes_phi_p[j] -</div><div class="line">               stokes_phi_p[i] * stokes_div_phi_u[j]) *</div><div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == elasticity_dofs_per_cell,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            elasticity_grad_phi[k] =</div><div class="line">              fe_values[displacements].gradient(k, q);</div><div class="line">            elasticity_div_phi[k] =</div><div class="line">              fe_values[displacements].divergence(k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              local_matrix(i, j) +=</div><div class="line">                (lambda * elasticity_div_phi[i] *</div><div class="line">                   elasticity_div_phi[j] +</div><div class="line">                 mu * <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                     elasticity_grad_phi[j]) +</div><div class="line">                 mu *</div><div class="line">                   <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                  <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(elasticity_grad_phi[j]))) *</div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Once we have the contributions from cell integrals, we copy them into the global matrix (taking care of constraints right away, through the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a> function). Note that we have not written anything into the <code>local_rhs</code> variable, though we still need to pass it along since the elimination of nonzero boundary values requires the modification of local and consequently also global right hand side values:</p>
<div class="fragment"><div class="line">local_dof_indices.resize(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                       local_rhs,</div><div class="line">                                       local_dof_indices,</div><div class="line">                                       system_matrix,</div><div class="line">                                       system_rhs);</div></div><!-- fragment --><p>The more interesting part of this function is where we see about face terms along the interface between the two subdomains. To this end, we first have to make sure that we only assemble them once even though a loop over all faces of all cells would encounter each part of the interface twice. We arbitrarily make the decision that we will only evaluate interface terms if the current cell is part of the solid subdomain and if, consequently, a face is not at the boundary and the potential neighbor behind it is part of the fluid domain. Let's start with these conditions:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">      {</div></div><!-- fragment --><p>At this point we know that the current cell is a candidate for integration and that a neighbor behind face <code>f</code> exists. There are now three possibilities:</p>
<ul>
<li>The neighbor is at the same refinement level and has no children.</li>
<li>The neighbor has children.</li>
<li>The neighbor is coarser.</li>
</ul>
<p>In all three cases, we are only interested in it if it is part of the fluid subdomain. So let us start with the first and simplest case: if the neighbor is at the same level, has no children, and is a fluid cell, then the two cells share a boundary that is part of the interface along which we want to integrate interface terms. All we have to do is initialize two <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object with the current face and the face of the neighboring cell (note how we find out which face of the neighboring cell borders on the current cell) and pass things off to the function that evaluates the interface terms (the third through fifth arguments to this function provide it with scratch arrays). The result is then again copied into the global matrix, using a function that knows that the DoF indices of rows and columns of the local matrix result from different cells:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">    (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">    cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">  {</div><div class="line">    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">    stokes_fe_face_values.reinit(cell-&gt;neighbor(f),</div><div class="line">                                 cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                            stokes_fe_face_values,</div><div class="line">                            elasticity_phi,</div><div class="line">                            stokes_symgrad_phi_u,</div><div class="line">                            stokes_phi_p,</div><div class="line">                            local_interface_matrix);</div><div class="line"></div><div class="line">    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">    constraints.distribute_local_to_global(</div><div class="line">      local_interface_matrix,</div><div class="line">      local_dof_indices,</div><div class="line">      neighbor_dof_indices,</div><div class="line">      system_matrix);</div><div class="line">  }</div></div><!-- fragment --><p>The second case is if the neighbor has further children. In that case, we have to loop over all the children of the neighbor to see if they are part of the fluid subdomain. If they are, then we integrate over the common interface, which is a face for the neighbor and a subface of the current cell, requiring us to use an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for the neighbor and an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> for the current cell:</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">         (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>))</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface = 0;</div><div class="line">         subface &lt; cell-&gt;face(f)-&gt;n_children();</div><div class="line">         ++subface)</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(</div><div class="line">            cell-&gt;neighbor_child_on_subface(f, subface)))</div><div class="line">        {</div><div class="line">          elasticity_fe_subface_values.reinit(cell, f, subface);</div><div class="line">          stokes_fe_face_values.reinit(</div><div class="line">            cell-&gt;neighbor_child_on_subface(f, subface),</div><div class="line">            cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">          assemble_interface_term(elasticity_fe_subface_values,</div><div class="line">                                  stokes_fe_face_values,</div><div class="line">                                  elasticity_phi,</div><div class="line">                                  stokes_symgrad_phi_u,</div><div class="line">                                  stokes_phi_p,</div><div class="line">                                  local_interface_matrix);</div><div class="line"></div><div class="line">          cell-&gt;neighbor_child_on_subface(f, subface)</div><div class="line">            -&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(</div><div class="line">            local_interface_matrix,</div><div class="line">            local_dof_indices,</div><div class="line">            neighbor_dof_indices,</div><div class="line">            system_matrix);</div><div class="line">        }</div><div class="line">  }</div></div><!-- fragment --><p>The last option is that the neighbor is coarser. In that case we have to use an <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object for the neighbor and a <a class="el" href="classFEFaceValues.html">FEFaceValues</a> for the current cell; the rest is the same as before:</p>
<div class="fragment"><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                       cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                {</div><div class="line">                  elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                  stokes_fe_subface_values.reinit(</div><div class="line">                    cell-&gt;neighbor(f),</div><div class="line">                    cell-&gt;neighbor_of_coarser_neighbor(f).first,</div><div class="line">                    cell-&gt;neighbor_of_coarser_neighbor(f).second);</div><div class="line"></div><div class="line">                  assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                          stokes_fe_subface_values,</div><div class="line">                                          elasticity_phi,</div><div class="line">                                          stokes_symgrad_phi_u,</div><div class="line">                                          stokes_phi_p,</div><div class="line">                                          local_interface_matrix);</div><div class="line"></div><div class="line">                  cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                  constraints.distribute_local_to_global(</div><div class="line">                    local_interface_matrix,</div><div class="line">                    local_dof_indices,</div><div class="line">                    neighbor_dof_indices,</div><div class="line">                    system_matrix);</div><div class="line">                }</div><div class="line">            }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>In the function that assembles the global system, we passed computing interface terms to a separate function we discuss here. The key is that even though we can't predict the combination of <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> objects, they are both derived from the <a class="el" href="classFEFaceValuesBase.html">FEFaceValuesBase</a> class and consequently we don't have to care: the function is simply called with two such objects denoting the values of the shape functions on the quadrature points of the two sides of the face. We then do what we always do: we fill the scratch arrays with the values of shape functions and their derivatives, and then loop over all entries of the matrix to compute the local integrals. The details of the bilinear form we evaluate here are given in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_interface_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">  std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">  std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a> ==</div><div class="line">           elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_quadrature_points =</div><div class="line">    elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">  local_interface_matrix = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">        elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">        {</div><div class="line">          stokes_symgrad_phi_u[k] =</div><div class="line">            stokes_fe_face_values[velocities].symmetric_gradient(k, q);</div><div class="line">          stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">           ++k)</div><div class="line">        elasticity_phi[k] =</div><div class="line">          elasticity_fe_face_values[displacements].value(k, q);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">           ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">          local_interface_matrix(i, j) +=</div><div class="line">            -((2 * viscosity * (stokes_symgrad_phi_u[j] * normal_vector) -</div><div class="line">               stokes_phi_p[j] * normal_vector) *</div><div class="line">              elasticity_phi[i] * stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemsolvecode"></a> </p><h4><code>FluidStructureProblem::solve</code></h4>
<p>As discussed in the introduction, we use a rather trivial solver here: we just pass the linear system off to the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct solver (see, for example, <a class="el" href="step_29.html">step-29</a>). The only thing we have to do after solving is ensure that hanging node and boundary value constraints are correct.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemoutput_resultscode"></a> </p><h4><code>FluidStructureProblem::output_results</code></h4>
<p>Generating graphical output is rather trivial here: all we have to do is identify which components of the solution vector belong to scalars and/or vectors (see, for example, <a class="el" href="step_22.html">step-22</a> for a previous example), and then pass it all on to the <a class="el" href="classDataOut.html">DataOut</a> class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemrefine_meshcode"></a> </p><h4><code>FluidStructureProblem::refine_mesh</code></h4>
<p>The next step is to refine the mesh. As was discussed in the introduction, this is a bit tricky primarily because the fluid and the solid subdomains use variables that have different physical dimensions and for which the absolute magnitude of error estimates is consequently not directly comparable. We will therefore have to scale them. At the top of the function, we therefore first compute error estimates for the different variables separately (using the velocities but not the pressure for the fluid domain, and the displacements in the solid domain):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> stokes_estimated_error_per_cell(</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> elasticity_estimated_error_per_cell(</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; stokes_face_quadrature(stokes_degree + 2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; elasticity_face_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim - 1&gt; face_q_collection;</div><div class="line">  face_q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_face_quadrature);</div><div class="line">  face_q_collection.push_back(elasticity_face_quadrature);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    face_q_collection,</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    stokes_estimated_error_per_cell,</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    face_q_collection,</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    elasticity_estimated_error_per_cell,</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div></div><!-- fragment --><p>We then normalize error estimates by dividing by their norm and scale the fluid error indicators by a factor of 4 as discussed in the introduction. The results are then added together into a vector that contains error indicators for all cells:</p>
<div class="fragment"><div class="line">stokes_estimated_error_per_cell *=</div><div class="line">  4. / stokes_estimated_error_per_cell.l2_norm();</div><div class="line">elasticity_estimated_error_per_cell *=</div><div class="line">  1. / elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">estimated_error_per_cell += elasticity_estimated_error_per_cell;</div></div><!-- fragment --><p>The second to last part of the function, before actually refining the mesh, involves a heuristic that we have already mentioned in the introduction: because the solution is discontinuous, the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class gets all confused about cells that sit at the boundary between subdomains: it believes that the error is large there because the jump in the gradient is large, even though this is entirely expected and a feature that is in fact present in the exact solution as well and therefore not indicative of any numerical error.</p>
<p>Consequently, we set the error indicators to zero for all cells at the interface; the conditions determining which cells this affects are slightly awkward because we have to account for the possibility of adaptively refined meshes, meaning that the neighboring cell can be coarser than the current one, or could in fact be refined some more. The structure of these nested conditions is much the same as we encountered when assembling interface terms in <code>assemble_system</code>.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">      <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">              (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                cell_is_in_fluid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">               ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                (cell_is_in_fluid_domain(</div><div class="line">                  cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">               (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                cell_is_in_fluid_domain(cell-&gt;neighbor(f)))))</div><div class="line">            estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">              (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                cell_is_in_solid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">               ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                (cell_is_in_solid_domain(</div><div class="line">                  cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">               (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                cell_is_in_solid_domain(cell-&gt;neighbor(f)))))</div><div class="line">            estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">        }</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.0);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeFluidStructureProblemruncode"></a> </p><h4><code>FluidStructureProblem::run</code></h4>
<p>This is, as usual, the function that controls the overall flow of operation. If you've read through tutorial programs <a class="el" href="step_1.html">step-1</a> through <a class="el" href="step_6.html">step-6</a>, for example, then you are already quite familiar with the following structure:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">FluidStructureProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 10 - 2 * dim;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing output...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step46</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h4>The <code>main()</code> function</h4>
<p>This, final, function contains pretty much exactly what most of the other tutorial programs have:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step46;</div><div class="line"></div><div class="line">      FluidStructureProblem&lt;2&gt; flow_problem(1, 1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-46/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="2dresults"></a></p><h3>2d results</h3>
<p>当运行该程序时，你应该得到如下输出。</p>
<div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 64</div><div class="line">   Number of degrees of freedom: 531</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 136</div><div class="line">   Number of degrees of freedom: 1260</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 436</div><div class="line">   Number of degrees of freedom: 3723</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 3</div><div class="line">   Number of active cells: 1072</div><div class="line">   Number of degrees of freedom: 7493</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 4</div><div class="line">   Number of active cells: 2632</div><div class="line">   Number of degrees of freedom: 15005</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 5</div><div class="line">   Number of active cells: 5944</div><div class="line">   Number of degrees of freedom: 29437</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div></div><!-- fragment --><p>结果很容易被可视化。</p>
<table width="80%" align="center">
<tr valign="top">
<td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.velocity-2d.png"/>
</div>
 <p>Magnitude and vectors for the fluid velocity. </p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.pressure-2d.png"/>
</div>
 <p>Fluid pressure. The dynamic range has been truncated to cut off the pressure singularities at the top left and right corners of the domain as well as the top corners of the solid that forms re-entrant corners into the fluid domain. </p>
<p class="endtd"></p>
</td><td valign="top" align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.displacement-2d.png"/>
</div>
 <p>Magnitude and vectors for the solid displacement. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>这些图很容易解释：当水流在固体直立部分的左边向下、右边向上时，它产生的压力在左边高，在右边低，这些力量使固体的垂直部分向右弯曲。</p>
<p><a class="anchor" id="3dresults"></a></p><h3>3d results</h3>
<p>通过将 <code>FluidStructureProblem</code> 类中的维度改为3，我们也可以运行同样的问题3D。你会得到如下的输出。</p>
<div class="fragment"><div class="line">Refinement cycle 0</div><div class="line">   Number of active cells: 512</div><div class="line">   Number of degrees of freedom: 11631</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 1</div><div class="line">   Number of active cells: 1716</div><div class="line">   Number of degrees of freedom: 48984</div><div class="line">   Assembling...</div><div class="line">   Solving...</div><div class="line">   Writing output...</div><div class="line"></div><div class="line"></div><div class="line">Refinement cycle 2</div><div class="line">   Number of active cells: 8548</div><div class="line">   Number of degrees of freedom: 245746</div><div class="line">   Assembling...</div><div class="line">   Solving...</div></div><!-- fragment --><p>你会发现，最大的瓶颈是求解器。SparseDirectUmfpack在2016年的工作站上解决这个问题的最后一次迭代需要将近5个小时和大约80GB的内存（倒数第二次迭代只用了16分钟）。显然，这里需要一个更好的求解器，这个话题在下面讨论。</p>
<p>结果也可以被可视化，并产生良好的图片。这里有一张，显示了速度的矢量图（橙色），实体位移（蓝色），以及实体区域的阴影。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-46.9.2.3d.png"/>
</div>
 <p>。</p>
<p>除了缺乏一个好的求解器之外，网格也有点不平衡：网格细化严重偏向于流体子域（在2D中，情况恰恰相反，促使我们对流体误差指标的权重更高）。显然，如果想继续做更多的三维计算，对两个子域中误差指标的相对重要性进行一些调整是很重要的。</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Linearsolversandpreconditioners"></a></p><h4>Linear solvers and preconditioners</h4>
<p>改进程序的一个明显的地方是使用一个更复杂的求解器&amp;mdash；特别是一个能很好地扩展并能解决现实的三维问题的求解器。这在这里其实不难实现，因为从流体到固体的单向耦合。为此，假设我们将自由度重新排序，首先是所有的速度和压力自由度，然后是所有的位移（使用 <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>). 很容易实现），那么系统矩阵可以被分成以下的块状形式。</p>
<p class="formulaDsp">
\[ A_\text{global} = \begin{pmatrix} A_{\text{fluid}} &amp; 0 \\ B &amp; A_{\text{solid}} \end{pmatrix} \]
</p>
<p>其中 \(A_{\text{fluid}}\) 是速度和压力的斯托克斯矩阵（它可以进一步细分为 \(2\times 2\) 矩阵，如步骤22，尽管这对目前的目的不重要）， \(A_{\text{solid}}\) 是位移的弹性方程的结果， \(B\) 是来自界面条件的矩阵。现在注意到，这个矩阵</p>
<p class="formulaDsp">
\[ A_\text{global}^{-1} = \begin{pmatrix} A_{\text{fluid}}^{-1} &amp; 0 \\ -A_\text{solid}^{-1} B A_\text{fluid}^{-1} &amp; A_{\text{solid}}^{-1} \end{pmatrix} \]
</p>
<p>是 \(A_\text{global}\) 的逆数。应用这个矩阵只需要与 \(A_\text{fluid}\) 和 \(A_\text{solid}\) 各解一次，因为</p>
<p class="formulaDsp">
\[ \begin{pmatrix} p_x \\ p_y \end{pmatrix} = \begin{pmatrix} A_{\text{fluid}}^{-1} &amp; 0 \\ -A_\text{solid}^{-1} B A_\text{fluid}^{-1} &amp; A_{\text{solid}}^{-1} \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} \]
</p>
<p>可以计算为 \(p_x = A_{\text{fluid}}^{-1} x\) ，然后是 \(p_y = A_{\text{solid}}^{-1} (y-Bp_x)\) 。</p>
<p>因此，人们可以预期，</p>
<p class="formulaDsp">
\[ \widetilde{A_\text{global}^{-1}} = \begin{pmatrix} \widetilde{A_{\text{fluid}}^{-1}} &amp; 0 \\ -\widetilde{A_\text{solid}^{-1}} B \widetilde{A_\text{fluid}^{-1}} &amp; \widetilde{A_{\text{solid}}^{-1}} \end{pmatrix} \]
</p>
<p>如果 \(\widetilde{A_{\text{fluid}}^{-1}} \approx A_{\text{fluid}}^{-1}, \widetilde{A_{\text{solid}}^{-1}} \approx A_{\text{solid}}^{-1}\) ，将是一个好的预处理程序。</p>
<p>这意味着，我们只需要为斯托克斯和弹性方程分别提供良好的预处理。这些都是众所周知的：对于斯托克斯，我们可以使用<a class="el" href="step_22.html">step-22</a>的结果部分所讨论的预处理程序；对于弹性，一个好的预处理程序将是一个几何或代数多重网格的单一V形周期。然而，还有更多的开放性问题。对于由两个子调节器构建的 "优化 "求解器块-三角调节器，经常出现的一点是，在为子调节器选择参数时，在单独解决两个问题时效果好的值，在组合成多物理学调节器时可能不是最佳值。 特别是，当单独解决固体或流体力学问题时，在收敛所需的迭代次数和每次迭代应用预调节器的成本之间进行平衡，可能导致人们为斯托克斯问题选择昂贵的预调节器，为弹性问题选择便宜的预调节器（或者反之）。 然而，当结合在一起时，还有一个额外的约束，即你希望两个子预处理程序以大致相同的速度收敛，否则便宜的预处理程序可能会增加全局的迭代次数，而昂贵的预处理程序则会增加每迭代的成本。例如，虽然单一的AMG V型循环本身是一个很好的弹性方法，但当结合到一个多物理问题时，可能会有动力使用一个完整的W型循环或多个循环来帮助降低总求解时间。</p>
<p><a class="anchor" id="Refinementindicators"></a></p><h4>Refinement indicators</h4>
<p>正如介绍中提到的，我们在这个程序中使用的细化指标是相当临时的。一个更好的会明白，解的梯度在界面上的跳跃并不是错误的指示，而是可以预期的，并且在积分跳跃项的时候忽略界面。然而，这并不是KellyErrorEstimator类所做的。另一个更大的问题是，这种估计器首先是否是一个好的策略：例如，如果我们想在位移的某个特定方面（例如实体右上角的位移）有最大的准确性，那么将流体和实体的误差指标放大到相同的程度是否合适？也许有必要用比固体更高的精度来解决流体问题，因为流体的解决方案直接影响到固体的解决方案？也许正好相反？</p>
<p>因此，改进该程序的一个明显的可能性是实施一个更好的细化标准。关于这个话题有一些文献；各种可能的起点之一是Thomas Wick的论文 "Adaptive finite elements for monolithic fluid-structure interaction on a prolongated domain:应用于心脏瓣膜模拟"，2011年机械学计算机方法会议论文集（CMM-2011），2011年5月9-12日，波兰华沙。</p>
<p><a class="anchor" id="Verification"></a></p><h4>Verification</h4>
<p>上面的结果纯粹是定性的，因为没有证据表明我们的方案实际上是收敛的。因此，一个显而易见的事情是增加一些量化的措施来检查该方案至少收敛到<em>something</em>。例如，我们可以为每个细化周期输出实体的右上角突出到流体子域的部分的偏移。或者我们可以计算出流体对实体施加的净力向量或扭矩。</p>
<p><a class="anchor" id="Bettermodels"></a></p><h4>Better models</h4>
<p>在现实中，大多数流体结构的相互作用问题是这样的：固体的运动确实影响了流体的流动。例如，空气在气箔周围的作用力导致它弯曲并改变其形状。同样地，一面旗帜在风中飘动，完全改变了它的形状。</p>
<p>这种双向耦合的问题通常在任意拉格朗日欧拉（ALE）框架下处理，其中固体的位移以某种平滑的方式扩展到流体领域，而不是像我们在这里所做的那样以零为单位。然后，扩展的位移场被用来对我们计算流体流动的网格进行变形。此外，界面上流体的边界条件不再是速度为零；相反，在一个时间相关的程序中，流体速度必须等于沿界面的位移的时间导数。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2011 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Texas A&amp;M University, 2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__collection_8h.html">deal.II/hp/fe_collection.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hp_2fe__values_8h.html">deal.II/hp/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step46</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>FluidStructureProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    FluidStructureProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">enum</span></div><div class="line">    {</div><div class="line">      fluid_domain_id,</div><div class="line">      solid_domain_id</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_fluid_domain(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> cell_is_in_solid_domain(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> set_active_fe_indices();</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_interface_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">      std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">      std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         stokes_fe;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>         elasticity_fe;</div><div class="line">    <a class="code" href="classhp_1_1FECollection.html">hp::FECollection&lt;dim&gt;</a> fe_collection;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>       dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> lambda;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim + 1 + dim)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> StokesBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component &lt; this-&gt;n_components,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, this-&gt;n_components));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (component == dim - 1)</div><div class="line">      <span class="keywordflow">switch</span> (dim)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> 2:</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]);</div><div class="line">          <span class="keywordflow">case</span> 3:</div><div class="line">            <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * p[1]);</div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesBoundaryValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                               Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = StokesBoundaryValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  FluidStructureProblem&lt;dim&gt;::FluidStructureProblem(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_degree,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_degree)</div><div class="line">    : stokes_degree(stokes_degree)</div><div class="line">    , elasticity_degree(elasticity_degree)</div><div class="line">    , triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1),</div><div class="line">                dim,</div><div class="line">                <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree),</div><div class="line">                1,</div><div class="line">                <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                dim)</div><div class="line">    , elasticity_fe(<a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                    dim,</div><div class="line">                    <a class="code" href="classFE__Nothing.html">FE_Nothing</a>&lt;dim&gt;(),</div><div class="line">                    1,</div><div class="line">                    <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(elasticity_degree),</div><div class="line">                    dim)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , viscosity(2)</div><div class="line">    , lambda(1)</div><div class="line">    , mu(1)</div><div class="line">  {</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(stokes_fe);</div><div class="line">    fe_collection.<a class="code" href="classhp_1_1FECollection.html#a4b0e75a805ff012e76d33ad6d4c3eac8">push_back</a>(elasticity_fe);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_fluid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (cell-&gt;material_id() == fluid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> FluidStructureProblem&lt;dim&gt;::cell_is_in_solid_domain(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::cell_iterator</a> &amp;cell)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (cell-&gt;material_id() == solid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">GridGenerator::subdivided_hyper_cube</a>(triangulation, 8, -1, 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; (face-&gt;center()[dim - 1] == 1))</div><div class="line">          face-&gt;set_all_boundary_ids(1);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &lt; 0.25) &amp;&amp;</div><div class="line">           (cell-&gt;center()[dim - 1] &gt; 0.5)) ||</div><div class="line">          ((<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(cell-&gt;center()[0]) &gt;= 0.25) &amp;&amp;</div><div class="line">           (cell-&gt;center()[dim - 1] &gt; -0.5)))</div><div class="line">        cell-&gt;set_material_id(fluid_domain_id);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        cell-&gt;set_material_id(solid_domain_id);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::set_active_fe_indices()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          cell-&gt;set_active_fe_index(0);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          cell-&gt;set_active_fe_index(1);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    set_active_fe_indices();</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe_collection);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               1,</div><div class="line">                                               StokesBoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(</div><div class="line">                                                 velocities));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        0,</div><div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1 + dim),</div><div class="line">        constraints,</div><div class="line">        fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_face_dof_indices(</div><div class="line">        stokes_fe.n_dofs_per_face());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(face_no)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordtype">bool</span> face_is_on_interface = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                    (cell_is_in_solid_domain(cell-&gt;neighbor(face_no))))</div><div class="line">                  face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor(face_no)-&gt;has_children() == <span class="keyword">true</span>)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sf = 0;</div><div class="line">                         sf &lt; cell-&gt;face(face_no)-&gt;n_children();</div><div class="line">                         ++sf)</div><div class="line">                      <span class="keywordflow">if</span> (cell_is_in_solid_domain(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(face_no, sf)))</div><div class="line">                        {</div><div class="line">                          face_is_on_interface = <span class="keyword">true</span>;</div><div class="line">                          <span class="keywordflow">break</span>;</div><div class="line">                        }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (face_is_on_interface)</div><div class="line">                  {</div><div class="line">                    cell-&gt;face(face_no)-&gt;get_dof_indices(local_face_dof_indices,</div><div class="line">                                                         0);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; local_face_dof_indices.size();</div><div class="line">                         ++i)</div><div class="line">                      <span class="keywordflow">if</span> (stokes_fe.face_system_to_component_index(i).first &lt;</div><div class="line">                          dim)</div><div class="line">                        constraints.add_line(local_face_dof_indices[i]);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">    }</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> cell_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                                 fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> face_coupling(fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(),</div><div class="line">                                                 fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; fe_collection.<a class="code" href="classhp_1_1FECollection.html#add4bafb2f8e59ae8c0165f31db334205">n_components</a>(); ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> (((c &lt; dim + 1) &amp;&amp; (d &lt; dim + 1) &amp;&amp;</div><div class="line">                 !((c == dim) &amp;&amp; (d == dim))) ||</div><div class="line">                ((c &gt;= dim + 1) &amp;&amp; (d &gt;= dim + 1)))</div><div class="line">              cell_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ((c &gt;= dim + 1) &amp;&amp; (d &lt; dim + 1))</div><div class="line">              face_coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          }</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler,</div><div class="line">                                           dsp,</div><div class="line">                                           cell_coupling,</div><div class="line">                                           face_coupling);</div><div class="line">      constraints.condense(dsp);</div><div class="line">      sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0;</div><div class="line">    system_rhs    = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> stokes_quadrature(stokes_degree + 2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> elasticity_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection&lt;dim&gt;</a> q_collection;</div><div class="line">    q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_quadrature);</div><div class="line">    q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(elasticity_quadrature);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1FEValues.html">hp::FEValues&lt;dim&gt;</a> hp_fe_values(fe_collection,</div><div class="line">                                   q_collection,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; common_face_quadrature(</div><div class="line">      <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(stokes_degree + 2, elasticity_degree + 2));</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    stokes_fe_face_values(stokes_fe,</div><div class="line">                                            common_face_quadrature,</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>    elasticity_fe_face_values(elasticity_fe,</div><div class="line">                                                common_face_quadrature,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> stokes_fe_subface_values(stokes_fe,</div><div class="line">                                                  common_face_quadrature,</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFESubfaceValues.html">FESubfaceValues&lt;dim&gt;</a> elasticity_fe_subface_values(elasticity_fe,</div><div class="line">                                                      common_face_quadrature,</div><div class="line">                                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elasticity_dofs_per_cell =</div><div class="line">      elasticity_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_interface_matrix(elasticity_dofs_per_cell,</div><div class="line">                                              stokes_dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs;</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; neighbor_dof_indices(</div><div class="line">      stokes_dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> right_hand_side(dim + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; stokes_symgrad_phi_u(</div><div class="line">      stokes_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt; stokes_div_phi_u(stokes_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt; stokes_phi_p(stokes_dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; elasticity_grad_phi(elasticity_dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         elasticity_div_phi(elasticity_dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; elasticity_phi(elasticity_dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        hp_fe_values.reinit(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = hp_fe_values.<a class="code" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a>();</div><div class="line"></div><div class="line">        local_matrix.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(),</div><div class="line">                            cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">        local_rhs.reinit(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_fluid_domain(cell))</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == stokes_dofs_per_cell, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                  {</div><div class="line">                    stokes_symgrad_phi_u[k] =</div><div class="line">                      fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                    stokes_div_phi_u[k] =</div><div class="line">                      fe_values[velocities].divergence(k, q);</div><div class="line">                    stokes_phi_p[k] = fe_values[pressure].value(k, q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (2 * viscosity * stokes_symgrad_phi_u[i] *</div><div class="line">                         stokes_symgrad_phi_u[j] -</div><div class="line">                       stokes_div_phi_u[i] * stokes_phi_p[j] -</div><div class="line">                       stokes_phi_p[i] * stokes_div_phi_u[j]) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">            <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dofs_per_cell == elasticity_dofs_per_cell,</div><div class="line">                   <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++q)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                  {</div><div class="line">                    elasticity_grad_phi[k] =</div><div class="line">                      fe_values[displacements].gradient(k, q);</div><div class="line">                    elasticity_div_phi[k] =</div><div class="line">                      fe_values[displacements].divergence(k, q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    {</div><div class="line">                      local_matrix(i, j) +=</div><div class="line">                        (lambda * elasticity_div_phi[i] *</div><div class="line">                           elasticity_div_phi[j] +</div><div class="line">                         mu * <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                             elasticity_grad_phi[j]) +</div><div class="line">                         mu *</div><div class="line">                           <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(elasticity_grad_phi[i],</div><div class="line">                                          <a class="code" href="derivative__form_8h.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(elasticity_grad_phi[j]))) *</div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                    }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        local_dof_indices.resize(cell-&gt;<a class="code" href="classDoFHandler.html#ac1fedeb50b5f03b13d8b69f86e33f726">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;face(f)-&gt;at_boundary() == <span class="keyword">false</span>)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                    (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                    cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                  {</div><div class="line">                    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                    stokes_fe_face_values.reinit(cell-&gt;neighbor(f),</div><div class="line">                                                 cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                            stokes_fe_face_values,</div><div class="line">                                            elasticity_phi,</div><div class="line">                                            stokes_symgrad_phi_u,</div><div class="line">                                            stokes_phi_p,</div><div class="line">                                            local_interface_matrix);</div><div class="line"></div><div class="line">                    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                    constraints.distribute_local_to_global(</div><div class="line">                      local_interface_matrix,</div><div class="line">                      local_dof_indices,</div><div class="line">                      neighbor_dof_indices,</div><div class="line">                      system_matrix);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                         (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>))</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> subface = 0;</div><div class="line">                         subface &lt; cell-&gt;face(f)-&gt;n_children();</div><div class="line">                         ++subface)</div><div class="line">                      <span class="keywordflow">if</span> (cell_is_in_fluid_domain(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(f, subface)))</div><div class="line">                        {</div><div class="line">                          elasticity_fe_subface_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell, f, subface);</div><div class="line">                          stokes_fe_face_values.reinit(</div><div class="line">                            cell-&gt;neighbor_child_on_subface(f, subface),</div><div class="line">                            cell-&gt;neighbor_of_neighbor(f));</div><div class="line"></div><div class="line">                          assemble_interface_term(elasticity_fe_subface_values,</div><div class="line">                                                  stokes_fe_face_values,</div><div class="line">                                                  elasticity_phi,</div><div class="line">                                                  stokes_symgrad_phi_u,</div><div class="line">                                                  stokes_phi_p,</div><div class="line">                                                  local_interface_matrix);</div><div class="line"></div><div class="line">                          cell-&gt;neighbor_child_on_subface(f, subface)</div><div class="line">                            -&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                          constraints.distribute_local_to_global(</div><div class="line">                            local_interface_matrix,</div><div class="line">                            local_dof_indices,</div><div class="line">                            neighbor_dof_indices,</div><div class="line">                            system_matrix);</div><div class="line">                        }</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                         cell_is_in_fluid_domain(cell-&gt;neighbor(f)))</div><div class="line">                  {</div><div class="line">                    elasticity_fe_face_values.reinit(cell, f);</div><div class="line">                    stokes_fe_subface_values.reinit(</div><div class="line">                      cell-&gt;neighbor(f),</div><div class="line">                      cell-&gt;neighbor_of_coarser_neighbor(f).first,</div><div class="line">                      cell-&gt;neighbor_of_coarser_neighbor(f).second);</div><div class="line"></div><div class="line">                    assemble_interface_term(elasticity_fe_face_values,</div><div class="line">                                            stokes_fe_subface_values,</div><div class="line">                                            elasticity_phi,</div><div class="line">                                            stokes_symgrad_phi_u,</div><div class="line">                                            stokes_phi_p,</div><div class="line">                                            local_interface_matrix);</div><div class="line"></div><div class="line">                    cell-&gt;neighbor(f)-&gt;get_dof_indices(neighbor_dof_indices);</div><div class="line">                    constraints.distribute_local_to_global(</div><div class="line">                      local_interface_matrix,</div><div class="line">                      local_dof_indices,</div><div class="line">                      neighbor_dof_indices,</div><div class="line">                      system_matrix);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::assemble_interface_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         elasticity_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;         stokes_fe_face_values,</div><div class="line">    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         elasticity_phi,</div><div class="line">    std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;stokes_symgrad_phi_u,</div><div class="line">    std::vector&lt;double&gt; &amp;                 stokes_phi_p,</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  local_interface_matrix)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a> ==</div><div class="line">             elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_quadrature_points =</div><div class="line">      elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line"></div><div class="line">    local_interface_matrix = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_quadrature_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> normal_vector =</div><div class="line">          elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++k)</div><div class="line">          {</div><div class="line">            stokes_symgrad_phi_u[k] =</div><div class="line">              stokes_fe_face_values[velocities].symmetric_gradient(k, q);</div><div class="line">            stokes_phi_p[k] = stokes_fe_face_values[pressure].value(k, q);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">             ++k)</div><div class="line">          elasticity_phi[k] =</div><div class="line">            elasticity_fe_face_values[displacements].value(k, q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; elasticity_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">             ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">            local_interface_matrix(i, j) +=</div><div class="line">              -((2 * viscosity * (stokes_symgrad_phi_u[j] * normal_vector) -</div><div class="line">                 stokes_phi_p[j] * normal_vector) *</div><div class="line">                elasticity_phi[i] * stokes_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      solution_names.emplace_back(<span class="stringliteral">&quot;displacement&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      data_component_interpretation.push_back(</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> FluidStructureProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; stokes_estimated_error_per_cell(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    Vector&lt;float&gt; elasticity_estimated_error_per_cell(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; stokes_face_quadrature(stokes_degree + 2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; elasticity_face_quadrature(elasticity_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;dim - 1&gt; face_q_collection;</div><div class="line">    face_q_collection.<a class="code" href="classhp_1_1QCollection.html#a87ec95076ccc4b7c10fa24523bb926df">push_back</a>(stokes_face_quadrature);</div><div class="line">    face_q_collection.push_back(elasticity_face_quadrature);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      face_q_collection,</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      stokes_estimated_error_per_cell,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(velocities));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements(dim + 1);</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      face_q_collection,</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      elasticity_estimated_error_per_cell,</div><div class="line">      fe_collection.<a class="code" href="classhp_1_1FECollection.html#a7cdf2f55585aa8a5777535b57b220a17">component_mask</a>(displacements));</div><div class="line"></div><div class="line">    stokes_estimated_error_per_cell *=</div><div class="line">      4. / stokes_estimated_error_per_cell.l2_norm();</div><div class="line">    elasticity_estimated_error_per_cell *=</div><div class="line">      1. / elasticity_estimated_error_per_cell.l2_norm();</div><div class="line"></div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    estimated_error_per_cell += stokes_estimated_error_per_cell;</div><div class="line">    estimated_error_per_cell += elasticity_estimated_error_per_cell;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> f : cell-&gt;face_indices())</div><div class="line">        <span class="keywordflow">if</span> (cell_is_in_solid_domain(cell))</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                  cell_is_in_fluid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">                 ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                  (cell_is_in_fluid_domain(</div><div class="line">                    cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">                 (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                  cell_is_in_fluid_domain(cell-&gt;neighbor(f)))))</div><div class="line">              estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((cell-&gt;at_boundary(f) == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                (((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">false</span>) &amp;&amp;</div><div class="line">                  cell_is_in_solid_domain(cell-&gt;neighbor(f))) ||</div><div class="line">                 ((cell-&gt;neighbor(f)-&gt;level() == cell-&gt;level()) &amp;&amp;</div><div class="line">                  (cell-&gt;neighbor(f)-&gt;has_children() == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">                  (cell_is_in_solid_domain(</div><div class="line">                    cell-&gt;neighbor_child_on_subface(f, 0)))) ||</div><div class="line">                 (cell-&gt;neighbor_is_coarser(f) &amp;&amp;</div><div class="line">                  cell_is_in_solid_domain(cell-&gt;neighbor(f)))))</div><div class="line">              estimated_error_per_cell(cell-&gt;active_cell_index()) = 0;</div><div class="line">          }</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.0);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">FluidStructureProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 10 - 2 * dim;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle &gt; 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        setup_dofs();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        assemble_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Writing output...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step46</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step46;</div><div class="line"></div><div class="line">      FluidStructureProblem&lt;2&gt; flow_problem(1, 1);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
