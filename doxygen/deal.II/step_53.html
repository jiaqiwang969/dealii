<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_53.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-53 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-53 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_49.html">step-49</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Wheregeometryandmeshesintersect">Where geometry and meshes intersect</a>
        <li><a href="#Theexamplecase">The example case</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#DescribingtopographyAfricaTopography">Describing topography: AfricaTopography</a>
        <li><a href="#DescribingthegeometryAfricaGeometry">Describing the geometry: AfricaGeometry</a>
        <li><a href="#Creatingthemesh">Creating the mesh</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Issueswithadaptivelyrefinedmeshesgeneratedthisway">Issues with adaptively refined meshes generated this way</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Wolfgang Bangerth and Luca Heltai, using data provided by D. Sarah Stamps.</em></p>
<dl class="section note"><dt>Note</dt><dd>This program elaborates on concepts of geometry and the classes that implement it. These classes are grouped into the documentation module on <a class="el" href="group__manifold.html">Manifold description for triangulations</a>. See there for additional information.</dd>
<dd>
This tutorial is also available as a Jupyter Python notebook that uses the deal.II python interface. The notebook is available in the same directory as the original C++ program. Rendered notebook can also be viewed on the <a href="https://github.com/dealii/dealii/blob/master/examples/step-53/step-53.ipynb">github</a>.</dd></dl>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>Partial differential equations for realistic problems are often posed on domains with complicated geometries. To provide just a few examples, consider these cases:</p><ul>
<li>Among the two arguably most important industrial applications for the finite element method, aerodynamics and more generally fluid dynamics is one. Computer simulations today are used in the design of every airplane, car, train and ship. The domain in which the partial differential equation is posed is, in these cases, the air surrounding the plane with its wings, flaps and engines; the air surrounding the car with its wheel, wheel wells, mirrors and, in the case of race cars, all sorts of aerodynamic equipment; the air surrounding the train with its wheels and gaps between cars. In the case of ships, the domain is the water surrounding the ship with its rudders and propellers.</li>
<li>The other of the two big applications of the finite element method is structural engineering in which the domains are bridges, airplane nacelles and wings, and other solid bodies of often complicated shapes.</li>
<li>Finite element modeling is also often used to describe the generation and propagation of earthquake waves. In these cases, one needs to accurately represent the geometry of faults in the Earth crust. Since faults intersect, dip at angles, and are often not completely straight, domains are frequently very complex. One could cite many more examples of complicated geometries in which one wants to pose and solve a partial differential equation. What this shows is that the "real" world is much more complicated than what we have shown in almost all of the tutorial programs preceding this one.</li>
</ul>
<p>This program is therefore devoted to showing how one deals with complex geometries using a concrete application. In particular, what it shows is how we make a mesh fit the domain we want to solve on. On the other hand, what the program does not show is how to create a coarse for a domain. The process to arrive at a coarse mesh is called "mesh generation" and there are a number of high-quality programs that do this much better than we could ever implement. However, deal.II does have the ability to read in meshes in many formats generated by mesh generators and then make them fit a given shape, either by deforming a mesh or refining it a number of times until it fits. The deal.II Frequently Asked Questions page referenced from <a href="http://www.dealii.org/">http://www.dealii.org/</a> provides resources to mesh generators.</p>
<p><a class="anchor" id="Wheregeometryandmeshesintersect"></a></p><h3>Where geometry and meshes intersect</h3>
<p>Let us assume that you have a complex domain and that you already have a coarse mesh that somehow represents the general features of the domain. Then there are two situations in which it is necessary to describe to a deal.II program the details of your geometry:</p>
<ul>
<li>Mesh refinement: Whenever a cell is refined, it is necessary to introduce new vertices in the <a class="el" href="classTriangulation.html">Triangulation</a>. In the simplest case, one assumes that the objects that make up the <a class="el" href="classTriangulation.html">Triangulation</a> are straight line segments, a bi-linear surface or a tri-linear volume. The next vertex is then simply put into the middle of the old ones. However, for curved boundaries or if we want to solve a PDE on a curved, lower-dimensional manifold embedded in a higher-dimensional space, this is insufficient since it will not respect the actual geometry. We will therefore have to tell <a class="el" href="classTriangulation.html">Triangulation</a> where to put new points.</li>
<li>Integration: When using higher order finite element methods, it is often necessary to compute integrals using curved approximations of the boundary, i.e., describe each edge or face of cells as curves, instead of straight line segments or bilinear patches. The same is, of course, true when integrating boundary terms (e.g., inhomogeneous Neumann boundary conditions). For the purpose of integration, the various <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> classes then provide the transformation from the reference cell to the actual cell.</li>
</ul>
<p>In both cases, we need a way to provide information about the geometry of the domain at the level of an individual cell, its faces and edges. This is where the <a class="el" href="classManifold.html">Manifold</a> class comes into play. <a class="el" href="classManifold.html">Manifold</a> is an abstract base class that only defines an interface by which the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> classes can query geometric information about the domain. Conceptually, <a class="el" href="classManifold.html">Manifold</a> sees the world in a way not dissimilar to how the mathematical subdiscipline geometry sees it: a domain is essentially just a collection of points that is somehow equipped with the notion of a distance between points so that we can obtain a point "in the middle" of some other points.</p>
<p>deal.II provides a number of classes that implement the interface provided by <a class="el" href="classManifold.html">Manifold</a> for a variety of common geometries. On the other hand, in this program we will consider only a very common and much simpler case, namely the situation where (a part of) the domain we want to solve on can be described by transforming a much simpler domain (we will call this the "reference domain"). In the language of mathematics, this means that the (part of the) domain is a <a href="http://en.wikipedia.org/wiki/Chart_%28topology%29">chart</a>. Charts are described by a smooth function that maps from the simpler domain to the chart (the "push-forward" function) and its inverse (the "pull-back" function). If the domain as a whole is not a chart (e.g., the surface of a sphere), then it can often be described as a collection of charts (e.g., the northern hemisphere and the southern hemisphere are each charts) and the domain can then be describe by an <a href="http://en.wikipedia.org/wiki/Atlas_%28topology%29">atlas</a>.</p>
<p>If a domain can be decomposed into an atlas, all we need to do is provide the pull-back and push-forward functions for each of the charts. In deal.II, this means providing a class derived from <a class="el" href="classChartManifold.html">ChartManifold</a>, and this is precisely what we will do in this program.</p>
<p><a class="anchor" id="Theexamplecase"></a></p><h3>The example case</h3>
<p>To illustrate how one describes geometries using charts in deal.II, we will consider a case that originates in an application of the <a href="https://aspect.geodynamics.org">ASPECT mantle convection code</a>, using a data set provided by D. Sarah Stamps. In the concrete application, we were interested in describing flow in the Earth mantle under the <a href="http://en.wikipedia.org/wiki/East_African_rift">East African Rift</a>, a zone where two continental plates drift apart. Not to beat around the bush, the geometry we want to describe looks like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topo.png"/>
</div>
<p>In particular, though you cannot see this here, the top surface is not just colored by the elevation but is, in fact, deformed to follow the correct topography. While the actual application is not relevant here, the geometry is. The domain we are interested in is a part of the Earth that ranges from the surface to a depth of 500km, from 26 to 35 degrees East of the Greenwich meridian, and from 5 degrees North of the equator to 10 degrees South.</p>
<p>This description of the geometry suggests to start with a box \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\) (measured in degrees, degrees, and meters) and to provide a map \(\varphi\) so that \(\varphi^{-1}(\hat U)=\Omega\) where \(\Omega\) is the domain we seek. \((\Omega,\varphi)\) is then a chart, \(\varphi\) the pull-back operator, and \(\varphi^{-1}\) the push-forward operator. If we need a point \(q\) that is the "average" of other points \(q_i\in\Omega\), the <a class="el" href="classChartManifold.html">ChartManifold</a> class then first applies the pull-back to obtain \(\hat q_i=\varphi(q_i)\), averages these to a point \(\hat p\) and then computes \(p=\varphi^{-1}(\hat p)\).</p>
<p>Our goal here is therefore to implement a class that describes \(\varphi\) and \(\varphi^{-1}\). If Earth was a sphere, then this would not be difficult: if we denote by \((\hat \phi,\hat \theta,\hat d)\) the points of \(\hat U\) (i.e., longitude counted eastward, latitude counted northward, and elevation relative to zero depth), then </p><p class="formulaDsp">
\[ \mathbf x = \varphi^{-1}(\hat \phi,\hat \theta,\hat d) = (R+\hat d) (\cos\hat \phi\cos\hat \theta, \sin\hat \phi\cos\hat \theta, \sin\hat \theta)^T \]
</p>
<p> provides coordinates in a Cartesian coordinate system, where \(R\) is the radius of the sphere. However, the Earth is not a sphere:</p>
<ol>
<li>
<p class="startli">It is flattened at the poles and larger at the equator: the semi-major axis is approximately 22km longer than the semi-minor axis. We will account for this using the <a href="http://en.wikipedia.org/wiki/WGS84">WGS 84</a> reference standard for the Earth shape. The formula used in WGS 84 to obtain a position in Cartesian coordinates from longitude, latitude, and elevation is </p><p class="formulaDsp">
\[ \mathbf x = \varphi_\text{WGS84}^{-1}(\phi,\theta,d) = \left( \begin{array}{c} (\bar R(\theta)+d) \cos\phi\cos\theta, \\ (\bar R(\theta)+d) \sin\phi\cos\theta, \\ ((1-e^2)\bar R(\theta)+d) \sin\theta \end{array} \right), \]
</p>
<p> where \(\bar R(\theta)=\frac{R}{\sqrt{1-(e \sin\theta)^2}}\), and radius and ellipticity are given by \(R=6378137\text{m}, e=0.081819190842622\). In this formula, we assume that the arguments to sines and cosines are evaluated in degree, not radians (though we will have to change this assumption in the code).</p>
<p class="endli"></p>
</li>
<li>
It has topography in the form of mountains and valleys. We will account for this using real topography data (see below for a description of where this data comes from). Using this data set, we can look up elevations on a latitude-longitude mesh laid over the surface of the Earth. Starting with the box \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\), we will therefore first stretch it in vertical direction before handing it off to the WGS 84 function: if \(h(\hat\phi,\hat\theta)\) is the height at longitude \(\hat\phi\) and latitude \(\hat\theta\), then we define <p class="formulaDsp">
\[ (\phi,\theta,d) = \varphi_\text{topo}^{-1}(\hat\phi,\hat\theta,\hat d) = \left( \hat\phi, \hat\theta, \hat d + \frac{\hat d+500000}{500000}h(\hat\phi,\hat\theta) \right). \]
</p>
 Using this function, the top surface of the box \(\hat U\) is displaced to the correct topography, the bottom surface remains where it was, and points in between are linearly interpolated. </li>
</ol>
<p>Using these two functions, we can then define the entire push-forward function \(\varphi^{-1}: \hat U \rightarrow \Omega\) as </p><p class="formulaDsp">
\[ \mathbf x = \varphi^{-1}(\hat\phi,\hat\theta,\hat d) = \varphi_\text{WGS84}^{-1}(\varphi_\text{topo}^{-1}(\hat\phi,\hat\theta,\hat d)). \]
</p>
<p> In addition, we will have to define the inverse of this function, the pull-back operation, which we can write as </p><p class="formulaDsp">
\[ (\hat\phi,\hat\theta,\hat d) = \varphi(\mathbf x) = \varphi_\text{topo}(\varphi_\text{WGS84}(\mathbf x)). \]
</p>
<p> We can obtain one of the components of this function by inverting the formula above: </p><p class="formulaDsp">
\[ (\hat\phi,\hat\theta,\hat d) = \varphi_\text{topo}(\phi,\theta,d) = \left( \phi, \theta, 500000\frac{d-h(\phi,\theta)}{500000+h(\phi,\theta)} \right). \]
</p>
<p> Computing \(\varphi_\text{WGS84}(\mathbf x)\) is also possible though a lot more awkward. We won't show the formula here but instead only provide the implementation in the program.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>There are a number of issues we need to address in the program. At the largest scale, we need to write a class that implements the interface of <a class="el" href="classChartManifold.html">ChartManifold</a>. This involves a function <code><a class="el" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">push_forward()</a></code> that takes a point in the reference domain \(\hat U\) and transform it into real space using the function \(\varphi^{-1}\) outlined above, and its inverse function <code><a class="el" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">pull_back()</a></code> implementing \(\varphi\). We will do so in the <code>AfricaGeometry</code> class below that looks, in essence, like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3,3&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  <a class="code" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  <a class="code" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  ... some member variables and other member <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a>...;</div><div class="line">};</div></div><!-- fragment --><p>The transformations above have two parts: the WGS 84 transformations and the topography transformation. Consequently, the <code>AfricaGeometry</code> class will have additional (non-virtual) member functions <code>AfricaGeometry::push_forward_wgs84()</code> and <code>AfricaGeometry::push_forward_topo()</code> that implement these two pieces, and corresponding pull back functions.</p>
<p>The WGS 84 transformation functions are not particularly interesting (even though the formulas they implement are impressive). The more interesting part is the topography transformation. Recall that for this, we needed to evaluate the elevation function \(h(\hat\phi,\hat\theta)\). There is of course no formula for this: Earth is what it is, the best one can do is look up the altitude from some table. This is, in fact what we will do.</p>
<p>The data we use was originally created by the <a href="http://en.wikipedia.org/wiki/Shuttle_Radar_Topography_Mission">Shuttle Radar Topography Mission</a>, was downloaded from the US Geologic Survey (USGS) and processed by D. Sarah Stamps who also wrote the initial version of the WGS 84 transformation functions. The topography data so processed is stored in a file <code>topography.txt.gz</code> that, when unpacked looks like this: </p><div class="fragment"><div class="line">6.983333 25.000000 700</div><div class="line">6.983333 25.016667 692</div><div class="line">6.983333 25.033333 701</div><div class="line">6.983333 25.050000 695</div><div class="line">6.983333 25.066667 710</div><div class="line">6.983333 25.083333 702</div><div class="line">...</div><div class="line">-11.983333 35.950000 707</div><div class="line">-11.983333 35.966667 687</div><div class="line">-11.983333 35.983333 659</div></div><!-- fragment --><p> The data is formatted as <code>latitude longitude elevation</code> where the first two columns are provided in degrees North of the equator and degrees East of the Greenwich meridian. The final column is given in meters above the WGS 84 zero elevation.</p>
<p>In the transformation functions, we need to evaluate \(h(\hat\phi,\hat\theta)\) for a given longitude \(\hat\phi\) and latitude \(\hat\theta\). In general, this data point will not be available and we will have to interpolate between adjacent data points. Writing such an interpolation routine is not particularly difficult, but it is a bit tedious and error prone. Fortunately, we can somehow shoehorn this data set into an existing class: <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> . Unfortunately, the class does not fit the bill quite exactly and so we need to work around it a bit. The problem comes from the way we initialize this class: in its simplest form, it takes a stream of values that it assumes form an equispaced mesh in the \(x-y\) plane (or, here, the \(\phi-\theta\) plane). Which is what they do here, sort of: they are ordered latitude first, longitude second; and more awkwardly, the first column starts at the largest values and counts down, rather than the usual other way around.</p>
<p>Now, while tutorial programs are meant to illustrate how to code with deal.II, they do not necessarily have to satisfy the same quality standards as one would have to do with production codes. In a production code, we would write a function that reads the data and (i) automatically determines the extents of the first and second column, (ii) automatically determines the number of data points in each direction, (iii) does the interpolation regardless of the order in which data is arranged, if necessary by switching the order between reading and presenting it to the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> class.</p>
<p>On the other hand, tutorial programs are best if they are short and demonstrate key points rather than dwell on unimportant aspects and, thereby, obscure what we really want to show. Consequently, we will allow ourselves a bit of leeway:</p><ul>
<li>since this program is intended solely for a particular geometry around the area of the East-African rift and since this is precisely the area described by the data file, we will hardcode in the program that there are \(1139\times 660\) pieces of data;</li>
<li>we will hardcode the boundaries of the data \([-11.98333^\circ,6.983333^\circ]\times[25^\circ,35.98333^\circ]\);</li>
<li>we will lie to the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> class: the class will only see the data in the last column of this data file, and we will pretend that the data is arranged in a way that there are 1139 data points in the first coordinate direction that are arranged in <em>ascending</em> order but in an interval \([-6.983333^\circ,11.98333^\circ]\) (not the negated bounds). Then, when we need to look something up for a latitude \(\hat\theta\), we can ask the interpolating table class for a value at \(-\hat\theta\). With this little trick, we can avoid having to switch around the order of data as read from file.</li>
</ul>
<p>All of this then calls for a class that essentially looks like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>AfricaTopography</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AfricaTopography ()</div><div class="line">    :</div><div class="line">    topography_data (...initialize somehow...)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> value (<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> topography_data.value (<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat * 180/<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>,</div><div class="line">                                           lon * 180/<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>));</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line">};</div></div><!-- fragment --><p>Note how the <code>value()</code> function negates the latitude. It also switches from the format \(\phi,\theta\) that we use everywhere else to the latitude-longitude format used in the table. Finally, it takes its arguments in radians as that is what we do everywhere else in the program, but then converts them to the degree-based system used for table lookup. As you will see in the implementation below, the function has a few more (static) member functions that we will call in the initialization of the <code>topography_data</code> member variable: the class type of this variable has a constructor that allows us to set everything right at construction time, rather than having to fill data later on, but this constructor takes a number of objects that can't be constructed in-place (at least not in C++98). Consequently, the construction of each of the objects we want to pass in the initialization happens in a number of static member functions.</p>
<p>Having discussed the general outline of how we want to implement things, let us go to the program and show how it is done in practice.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>Let us start with the include files we need here. Obviously, we need the ones that describe the triangulation (<code>tria.h</code>), and that allow us to create and output triangulations (<code><a class="el" href="grid__generator_8h.html">grid_generator.h</a></code> and <code><a class="el" href="grid__out_8h.html">grid_out.h</a></code>). Furthermore, we need the header file that declares the <a class="el" href="classManifold.html">Manifold</a> and <a class="el" href="classChartManifold.html">ChartManifold</a> classes that we will need to describe the geometry (<code>manifold.h</code>). We will then also need the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function from the last of the following header files; the purpose for this function will become discussed at the point where we use it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2grid_2manifold_8h.html">deal.II/grid/manifold.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The remainder of the include files relate to reading the topography data. As explained in the introduction, we will read it from a file and then use the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> class that is declared in the first of the following header files. Because the data is large, the file we read from is stored as gzip compressed data and we make use of some BOOST-provided functionality to read directly from gzipped data.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__lib_8h.html">deal.II/base/function_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filtering_stream.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filter/gzip.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/device/file.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>The final part of the top matter is to open a namespace into which to put everything, and then to import the dealii namespace into it.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step53</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="DescribingtopographyAfricaTopography"></a> </p><h3>Describing topography: AfricaTopography</h3>
<p>The first significant part of this program is the class that describes the topography \(h(\hat phi,\hat \theta)\) as a function of longitude and latitude. As discussed in the introduction, we will make our life a bit easier here by not writing the class in the most general way possible but by only writing it for the particular purpose we are interested in here: interpolating data obtained from one very specific data file that contains information about a particular area of the world for which we know the extents.</p>
<p>The general layout of the class has been discussed already above. Following is its declaration, including three static member functions that we will need in initializing the <code>topography_data</code> member variable.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AfricaTopography</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AfricaTopography();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;double&gt; get_data();</div><div class="line">};</div></div><!-- fragment --><p>Let us move to the implementation of the class. The interesting parts of the class are the constructor and the <code>value()</code> function. The former initializes the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> member variable and we will use the constructor that requires us to pass in the end points of the 2-dimensional data set we want to interpolate (which are here given by the intervals \([-6.983333, 11.98333]\), using the trick of switching end points discussed in the introduction, and \([25, 35.983333]\), both given in degrees), the number of intervals into which the data is split (379 in latitude direction and 219 in longitude direction, for a total of \(380\times 220\) data points), and a <a class="el" href="classTable.html">Table</a> object that contains the data. The data then of course has size \(380\times 220\) and we initialize it by providing an iterator to the first of the 83,600 elements of a std::vector object returned by the <code>get_data()</code> function below. Note that all of the member functions we call here are static because (i) they do not access any member variables of the class, and (ii) because they are called at a time when the object is not initialized fully anyway.</p>
<div class="fragment"><div class="line">AfricaTopography::AfricaTopography()</div><div class="line">  : topography_data({{std::make_pair(-6.983333, 11.966667),</div><div class="line">                      std::make_pair(25, 35.95)}},</div><div class="line">                    {{379, 219}},</div><div class="line">                    <a class="code" href="classTable.html">Table&lt;2, double&gt;</a>(380, 220, get_data().begin()))</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> AfricaTopography::value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> topography_data.value(</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat * 180 / <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>, lon * 180 / <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>));</div><div class="line">}</div></div><!-- fragment --><p>The only other function of greater interest is the <code>get_data()</code> function. It returns a temporary vector that contains all 83,600 data points describing the altitude and is read from the file <code>topography.txt.gz</code>. Because the file is compressed by gzip, we cannot just read it through an object of type std::ifstream, but there are convenient methods in the BOOST library (see <a href="http://www.boost.org">http://www.boost.org</a>) that allows us to read from compressed files without first having to uncompress it on disk. The result is, basically, just another input stream that, for all practical purposes, looks just like the ones we always use.</p>
<p>When reading the data, we read the three columns but throw ignore the first two. The datum in the last column is appended to an array that we the return and that will be copied into the table from which <code>topography_data</code> is initialized. Since the BOOST.iostreams library does not provide a very useful exception when the input file does not exist, is not readable, or does not contain the correct number of data lines, we catch all exceptions it may produce and create our own one. To this end, in the <code>catch</code> clause, we let the program run into an <code>AssertThrow(false, ...)</code> statement. Since the condition is always false, this always triggers an exception. In other words, this is equivalent to writing <code>throw ExcMessage("...")</code> but it also fills certain fields in the exception object that will later be printed on the screen identifying the function, file and line where the exception happened.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; AfricaTopography::get_data()</div><div class="line">{</div><div class="line">  std::vector&lt;double&gt; data;</div></div><!-- fragment --><p>create a stream where we read from gzipped data</p>
<div class="fragment"><div class="line">  boost::iostreams::filtering_istream in;</div><div class="line">  in.push(boost::iostreams::basic_gzip_decompressor&lt;&gt;());</div><div class="line">  in.push(boost::iostreams::file_source(<span class="stringliteral">&quot;topography.txt.gz&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line = 0; line &lt; 83600; ++line)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          <span class="keywordtype">double</span> lat, lon, elevation;</div><div class="line">          in &gt;&gt; lat &gt;&gt; lon &gt;&gt; elevation;</div><div class="line"></div><div class="line">          data.push_back(elevation);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (...)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Could not read all 83,600 data points &quot;</span></div><div class="line">                                 <span class="stringliteral">&quot;from the file &lt;topography.txt.gz&gt;!&quot;</span>));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> data;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DescribingthegeometryAfricaGeometry"></a> </p><h3>Describing the geometry: AfricaGeometry</h3>
<p>The following class is then the main one of this program. Its structure has been described in much detail in the introduction and does not need much introduction any more.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3, 3&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; <a class="code" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">clone</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> R;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> AfricaTopography topography;</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat) <span class="keyword">const</span>;</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::R           = 6378137;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::ellipticity = 8.1819190842622e-2;</div></div><!-- fragment --><p>The implementation, as well, is pretty straightforward if you have read the introduction. In particular, both of the pull back and push forward functions are just concatenations of the respective functions of the WGS 84 and topography mappings:</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">AfricaGeometry::pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> pull_back_topo(pull_back_wgs84(space_point));</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">AfricaGeometry::push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> push_forward_wgs84(push_forward_topo(chart_point));</div><div class="line">}</div></div><!-- fragment --><p>The next function is required by the interface of the <a class="el" href="classManifold.html">Manifold</a> base class, and allows cloning the AfricaGeometry class. Notice that, while the function returns a <code>std::unique_ptr&lt;<a class="el" href="classManifold.html">Manifold</a>&lt;3,3&gt;&gt;</code>, we internally create a <code>unique_ptr&lt;AfricaGeometry&gt;</code>. In other words, the library requires a pointer-to-base-class, which we provide by creating a pointer-to-derived-class.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; AfricaGeometry::clone()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> std::make_unique&lt;AfricaGeometry&gt;();</div><div class="line">}</div></div><!-- fragment --><p>The following two functions then define the forward and inverse transformations that correspond to the WGS 84 reference shape of Earth. The forward transform follows the formula shown in the introduction. The inverse transform is significantly more complicated and is, at the very least, not intuitive. It also suffers from the fact that it returns an angle that at the end of the function we need to clip back into the interval \([0,2\pi]\) if it should have escaped from there.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = phi_theta_d[0];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta = phi_theta_d[1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - (ellipticity * ellipticity *</div><div class="line">                                          std::sin(theta) * std::sin(theta)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {(R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::cos(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">          (R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::sin(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">          ((1 - ellipticity * ellipticity) * R_bar + d) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta)};</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> b   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R * R * (1 - ellipticity * ellipticity));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> ep  = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R * R - b * b) / (b * b));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> p   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) * x(0) + x(1) * x(1));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> th  = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R * x(2), b * p);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(1), x(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta =</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(2) + ep * ep * b * std::pow(std::sin(th), 3),</div><div class="line">               (p -</div><div class="line">                (ellipticity * ellipticity * R * std::pow(std::cos(th), 3))));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar =</div><div class="line">    R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - ellipticity * ellipticity * std::sin(theta) *</div><div class="line">                         std::sin(theta)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> phi_theta_d;</div><div class="line">  <span class="keywordflow">if</span> (phi &lt; 0)</div><div class="line">    phi_theta_d[0] = phi + 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phi &gt; 2 * numbers::PI)</div><div class="line">    phi_theta_d[0] = phi - 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    phi_theta_d[0] = phi;</div><div class="line">  phi_theta_d[1] = theta;</div><div class="line">  phi_theta_d[2] = R_plus_d - R_bar;</div><div class="line">  <span class="keywordflow">return</span> phi_theta_d;</div><div class="line">}</div></div><!-- fragment --><p>In contrast, the topography transformations follow exactly the description in the introduction. There is not consequently not much to add:</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">AfricaGeometry::push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = phi_theta_d_hat[2];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d = d_hat + (d_hat + 500000) / 500000 * h;</div><div class="line">  <span class="keywordflow">return</span> {phi_theta_d_hat[0], phi_theta_d_hat[1], d};</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h     = topography.value(phi_theta_d[0], phi_theta_d[1]);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = 500000 * (d - h) / (500000 + h);</div><div class="line">  <span class="keywordflow">return</span> {phi_theta_d[0], phi_theta_d[1], d_hat};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthemesh"></a> </p><h3>Creating the mesh</h3>
<p>Having so described the properties of the geometry, not it is time to deal with the mesh used to discretize it. To this end, we create objects for the geometry and triangulation, and then proceed to create a \(1\times 2\times 1\) rectangular mesh that corresponds to the reference domain \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\). We choose this number of subdivisions because it leads to cells that are roughly like cubes instead of stretched in one direction or another.</p>
<p>Of course, we are not actually interested in meshing the reference domain. We are interested in meshing the real domain. Consequently, we will use the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function that simply moves every point of a triangulation according to a given transformation. The transformation function it wants is a function that takes as its single argument a point in the reference domain and returns the corresponding location in the domain that we want to map to. This is, of course, exactly the push forward function of the geometry we use. We wrap it by a lambda function to obtain the kind of function object required for the transformation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">{</div><div class="line">  AfricaGeometry   geometry;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> corner_points[2] = {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(26 * numbers::PI / 180, -10 * numbers::PI / 180, -500000),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(35 * numbers::PI / 180, 5 * numbers::PI / 180, 0)};</div><div class="line">    std::vector&lt;unsigned int&gt; subdivisions(3);</div><div class="line">    subdivisions[0] = 1;</div><div class="line">    subdivisions[1] = 2;</div><div class="line">    subdivisions[2] = 1;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(</div><div class="line">      triangulation, subdivisions, corner_points[0], corner_points[1], <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">      [&amp;geometry](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) {</div><div class="line">        <span class="keywordflow">return</span> geometry.push_forward(chart_point);</div><div class="line">      },</div><div class="line">      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">  }</div></div><!-- fragment --><p>The next step is to explain to the triangulation to use our geometry object whenever a new point is needed upon refining the mesh. We do this by telling the triangulation to use our geometry for everything that has manifold indicator zero, and then proceed to mark all cells and their bounding faces and edges with manifold indicator zero. This ensures that the triangulation consults our geometry object every time a new vertex is needed. Since manifold indicators are inherited from mother to children, this also happens after several recursive refinement steps.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, geometry);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  cell-&gt;set_all_manifold_ids(0);</div></div><!-- fragment --><p>The last step is to refine the mesh beyond its initial \(1\times 2\times 1\) coarse mesh. We could just refine globally a number of times, but since for the purpose of this tutorial program we're really only interested in what is happening close to the surface, we just refine 6 times all of the cells that have a face at a boundary with indicator 5. Looking this up in the documentation of the <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> function we have used above reveals that boundary indicator 5 corresponds to the top surface of the domain (and this is what the last <code>true</code> argument in the call to <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> above meant: to "color" the boundaries by assigning each boundary a unique boundary indicator).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;boundary_id() == 5)</div><div class="line">          {</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement step &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; cells, &quot;</span></div><div class="line">              &lt;&lt; <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / 1000</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;km minimal cell diameter&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>Having done this all, we can now output the mesh into a file of its own:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;mesh.vtu&quot;</span>;</div><div class="line">    std::ofstream     out(filename);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>           grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step53</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function, which follows the same scheme used in all tutorial programs starting with <a class="el" href="step_6.html">step-6</a>. There isn't much to do here, only to call the single <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step53::run</a>();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the program produces a mesh file <code>mesh.vtu</code> that we can visualize with any of the usual visualization programs that can read the VTU file format. If one just looks at the mesh itself, it is actually very difficult to see anything that doesn't just look like a perfectly round piece of a sphere (though if one modified the program so that it does produce a sphere and looked at them at the same time, the difference between the overall sphere and WGS 84 shape is quite apparent). Apparently, Earth is actually quite a flat place. Of course we already know this from satellite pictures. However, we can tease out something more by coloring cells by their volume. This both produces slight variations in hue along the top surface and something for the visualization programs to apply their shading algorithms to (because the top surfaces of the cells are now no longer just tangential to a sphere but tilted):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.mesh.png"/>
</div>
<p>Yet, at least as far as visualizations are concerned, this is still not too impressive. Rather, let us visualize things in a way so that we show the actual elevation along the top surface. In other words, we want a picture like this, with an incredible amount of detail:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topo.png"/>
</div>
<p>A zoom-in of this picture shows the vertical displacement quite clearly (here, looking from the West-Northwest over the rift valley, the triple peaks of <a href="http://en.wikipedia.org/wiki/Mount_Stanley">Mount Stanley</a>, <a href="http://en.wikipedia.org/wiki/Mount_Speke">Mount Speke</a>, and <a href="http://en.wikipedia.org/wiki/Mount_Baker_%28Uganda%29">Mount Baker</a> in the <a href="http://en.wikipedia.org/wiki/Rwenzori_Mountains">Rwenzori Range</a>, <a href="http://en.wikipedia.org/wiki/Lake_George_%28Uganda%29">Lake George</a> and toward the great flatness of <a href="http://en.wikipedia.org/wiki/Lake_Victoria">Lake Victoria</a>):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topozoom.png"/>
</div>
<p>These image were produced with three small modifications: </p><ol>
<li>
<p class="startli">An additional seventh mesh refinement towards the top surface for the first of these two pictures, and a total of nine for the second. In the second image, the horizontal mesh size is approximately 1.5km, and just under 1km in vertical direction. (The picture was also created using a more resolved data set; however, it is too big to distribute as part of the tutorial.)</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The addition of the following function that, given a point <code>x</code> computes the elevation by converting the point to reference WGS 84 coordinates and only keeping the depth variable (the function is, consequently, a simplified version of the <code>AfricaGeometry::pull_back_wgs84()</code> function):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_elevation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R           = 6378137;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity = 8.1819190842622e-2;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R * R * (1 - ellipticity * ellipticity));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> ep    = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R * R - b * b) / (b * b));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> p     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) * x(0) + x(1) * x(1));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> th    = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R * x(2), b * p);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>((x(2) + ep * ep * b * std::sin(th) * std::sin(th) * std::sin(th)),</div><div class="line">                                      (p - (ellipticity * ellipticity * R  * (std::cos(th) * std::cos(th) * std::cos(th)))));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - ellipticity * ellipticity * std::sin(theta) * std::sin(theta)));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> R_plus_d - R_bar;</div><div class="line">  }</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
<p class="startli">Adding the following piece to the bottom of the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function:</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>       fe(1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;3&gt;</a> dof_handler (triangulation);</div><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> elevation (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">{</div><div class="line">  std::map&lt;unsigned int,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           5,</div><div class="line">                                           <a class="code" href="classScalarFunctionFromFunctionObject.html">ScalarFunctionFromFunctionObject&lt;3&gt;</a>(get_elevation),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (std::map&lt;unsigned int,double&gt;::const_iterator p = boundary_values.begin();</div><div class="line">       p!=boundary_values.end(); ++p)</div><div class="line">    elevation[p-&gt;first] = p-&gt;second;</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;3&gt;</a>    data_out;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (elevation, <span class="stringliteral">&quot;elevation&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">std::ofstream out (<span class="stringliteral">&quot;data.vtu&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (out);</div></div><!-- fragment --> </li>
</ol>
<p>This last piece of code first creates a \(Q_1\) finite element space on the mesh. It then (ab)uses <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> to evaluate the elevation function for every node at the top boundary (the one with boundary indicator 5). We here wrap the call to <code>get_elevation()</code> with the <a class="el" href="classScalarFunctionFromFunctionObject.html">ScalarFunctionFromFunctionObject</a> class to make a regular C++ function look like an object of a class derived from the <a class="el" href="classFunction.html">Function</a> class that we want to use in <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>. Having so gotten a list of degrees of freedom located at the top boundary and corresponding elevation values, we just go down this list and set these elevations in the <code>elevation</code> vector (leaving all interior degrees of freedom at their original zero value). This vector is then output using <a class="el" href="classDataOut.html">DataOut</a> as usual and can be visualized as shown above.</p>
<p><a class="anchor" id="Issueswithadaptivelyrefinedmeshesgeneratedthisway"></a></p><h3>Issues with adaptively refined meshes generated this way</h3>
<p>If you zoomed in on the mesh shown above and looked closely enough, you would find that at hanging nodes, the two small edges connecting to the hanging nodes are not in exactly the same location as the large edge of the neighboring cell. This can be shown more clearly by using a different surface description in which we enlarge the vertical topography to enhance the effect (courtesy of Alexander Grayver):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.smooth-geometry.png"/>
</div>
<p>So what is happening here? Partly, this is only a result of visualization, but there is an underlying real cause as well:</p>
<ul>
<li>
<p class="startli">When you visualize a mesh using any of the common visualization programs, what they really show you is just a set of edges that are plotted as straight lines in three-dimensional space. This is so because almost all data file formats for visualizing data only describe hexahedral cells as a collection of eight vertices in 3d space, and do not allow to any more complicated descriptions. (This is the main reason why <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> takes an argument that can be set to something larger than one.) These linear edges may be the edges of the cell you do actual computations on, or they may not, depending on what kind of mapping you use when you do your integrations using <a class="el" href="classFEValues.html">FEValues</a>. By default, of course, <a class="el" href="classFEValues.html">FEValues</a> uses a linear mapping (i.e., an object of class <a class="el" href="classMappingQ1.html">MappingQ1</a>) and in that case a 3d cell is indeed described exclusively by its 8 vertices and the volume it fills is a trilinear interpolation between these points, resulting in linear edges. But, you could also have used tri-quadratic, tri-cubic, or even higher order mappings and in these cases the volume of each cell will be bounded by quadratic, cubic or higher order polynomial curves. Yet, you only get to see these with linear edges in the visualization program because, as mentioned, file formats do not allow to describe the real geometry of cells.</p>
<p class="endli"></p>
</li>
<li>
That said, let us for simplicity assume that you are indeed using a trilinear mapping, then the image shown above is a faithful representation of the cells on which you form your integrals. In this case, indeed the small cells at a hanging nodes do not, in general, snugly fit against the large cell but leave a gap or may intersect the larger cell. Why is this? Because when the triangulation needs a new vertex on an edge it wants to refine, it asks the manifold description where this new vertex is supposed to be, and the manifold description duly returns such a point by (in the case of a geometry derived from <a class="el" href="classChartManifold.html">ChartManifold</a>) pulling the adjacent points of the line back to the reference domain, averaging their locations, and pushing forward this new location to the real domain. But this new location is not usually along a straight line (in real space) between the adjacent vertices and consequently the two small straight lines forming the refined edge do not lie exactly on the one large straight line forming the unrefined side of the hanging node. </li>
</ul>
<p>The situation is slightly more complicated if you use a higher order mapping using the <a class="el" href="classMappingQ.html">MappingQ</a> class, but not fundamentally different. Let's take a quadratic mapping for the moment (nothing fundamental changes with even higher order mappings). Then you need to imagine each edge of the cells you integrate on as a quadratic curve despite the fact that you will never actually see it plotted that way by a visualization program. But imagine it that way for a second. So which quadratic curve does <a class="el" href="classMappingQ.html">MappingQ</a> take? It is the quadratic curve that goes through the two vertices at the end of the edge as well as a point in the middle that it queries from the manifold. In the case of the long edge on the unrefined side, that's of course exactly the location of the hanging node, so the quadratic curve describing the long edge does go through the hanging node, unlike in the case of the linear mapping. But the two small edges are also quadratic curves; for example, the left small edge will go through the left vertex of the long edge and the hanging node, plus a point it queries halfway in between from the manifold. Because, as before, the point the manifold returns halfway along the left small edge is rarely exactly on the quadratic curve describing the long edge, the quadratic short edge will typically not coincide with the left half of the quadratic long edge, and the same is true for the right short edge. In other words, again, the geometries of the large cell and its smaller neighbors at hanging nodes do not touch snuggly.</p>
<p>This all begs two questions: first, does it matter, and second, could this be fixed. Let us discuss these in the following:</p>
<ul>
<li>
<p class="startli">Does it matter? It is almost certainly true that this depends on the equation you are solving. For example, it is known that solving the Euler equations of gas dynamics on complex geometries requires highly accurate boundary descriptions to ensure convergence of quantities that are measure the flow close to the boundary. On the other hand, equations with elliptic components (e.g., the Laplace or Stokes equations) are typically rather forgiving of these issues: one does quadrature anyway to approximate integrals, and further approximating the geometry may not do as much harm as one could fear given that the volume of the overlaps or gaps at every hanging node is only \({\cal O}(h^d)\) even with a linear mapping and \({\cal O}(h^{d+p-1})\) for a mapping of degree \(p\). (You can see this by considering that in 2d the gap/overlap is a triangle with base \(h\) and height \({\cal O}(h)\); in 3d, it is a pyramid-like structure with base area \(h^2\) and height \({\cal O}(h)\). Similar considerations apply for higher order mappings where the height of the gaps/overlaps is \({\cal O}(h^p)\).) In other words, if you use a linear mapping with linear elements, the error in the volume you integrate over is already at the same level as the integration error using the usual Gauss quadrature. Of course, for higher order elements one would have to choose matching mapping objects.</p>
<p>Another point of view on why it is probably not worth worrying too much about the issue is that there is certainly no narrative in the community of numerical analysts that these issues are a major concern one needs to watch out for when using complex geometries. If it does not seem to be discussed often among practitioners, if ever at all, then it is at least not something people have identified as a common problem.</p>
<p>This issue is not dissimilar to having hanging nodes at curved boundaries where the geometry description of the boundary typically pulls a hanging node onto the boundary whereas the large edge remains straight, making the adjacent small and large cells not match each other. Although this behavior existed in deal.II since its beginning, 15 years before manifold descriptions became available, it did not ever come up in mailing list discussions or conversations with colleagues.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Could it be fixed? In principle, yes, but it's a complicated issue. Let's assume for the moment that we would only ever use the <a class="el" href="classMappingQ1.html">MappingQ1</a> class, i.e., linear mappings. In that case, whenever the triangulation class requires a new vertex along an edge that would become a hanging node, it would just take the mean value of the adjacent vertices <em>in real space</em>, i.e., without asking the manifold description. This way, the point lies on the long straight edge and the two short straight edges would match the one long edge. Only when all adjacent cells have been refined and the point is no longer a hanging node would we replace its coordinates by coordinates we get by a manifold. This may be awkward to implement, but it would certainly be possible.</p>
<p>The more complicated issue arises because people may want to use a higher order <a class="el" href="classMappingQ.html">MappingQ</a> object. In that case, the <a class="el" href="classTriangulation.html">Triangulation</a> class may freely choose the location of the hanging node (because the quadratic curve for the long edge can be chosen in such a way that it goes through the hanging node) but the <a class="el" href="classMappingQ.html">MappingQ</a> class, when determining the location of mid-edge points must make sure that if the edge is one half of a long edge of a neighboring coarser cell, then the midpoint cannot be obtained from the manifold but must be chosen along the long quadratic edge. For cubic (and all other odd) mappings, the matter is again a bit complicated because one typically arranges the cubic edge to go through points 1/3 and 2/3 along the edge, and thus necessarily through the hanging node, but this could probably be worked out. In any case, even then, there are two problems with this:</p>
<ul>
<li>When refining the triangulation, the <a class="el" href="classTriangulation.html">Triangulation</a> class can not know what mapping will be used. In fact it is not uncommon for a triangulation to be used differently in different contexts within the same program. If the mapping used determines whether we can freely choose a point or not, how, then, should the triangulation locate new vertices?</li>
<li>Mappings are purely local constructs: they only work on a cell in isolation, and this is one of the important features of the finite element method. Having to ask whether one of the vertices of an edge is a hanging node requires querying the neighborhood of a cell; furthermore, such a query does not just involve the 6 face neighbors of a cell in 3d, but may require traversing a possibly very large number of other cells that connect to an edge. Even if it can be done, one still needs to do different things depending on how the neighborhood looks like, producing code that is likely very complex, hard to maintain, and possibly slow.</li>
</ul>
<p>Consequently, at least for the moment, none of these ideas are implemented. This leads to the undesirable consequence of discontinuous geometries, but, as discussed above, the effects of this do not appear to pose problem in actual practice.</p>
<p class="endli"></p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2014 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, Texas A&amp;M University, 2014</span></div><div class="line"><span class="comment"> *          Luca Heltai, SISSA, 2014</span></div><div class="line"><span class="comment"> *          D. Sarah Stamps, MIT, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2grid_2manifold_8h.html">deal.II/grid/manifold.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__lib_8h.html">deal.II/base/function_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filtering_stream.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filter/gzip.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/device/file.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step53</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>AfricaTopography</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AfricaTopography();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;double&gt; get_data();</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  AfricaTopography::AfricaTopography()</div><div class="line">    : topography_data({{std::make_pair(-6.983333, 11.966667),</div><div class="line">                        std::make_pair(25, 35.95)}},</div><div class="line">                      {{379, 219}},</div><div class="line">                      <a class="code" href="classTable.html">Table&lt;2, double&gt;</a>(380, 220, get_data().begin()))</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> AfricaTopography::value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> topography_data.value(</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat * 180 / numbers::PI, lon * 180 / numbers::PI));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt; AfricaTopography::get_data()</div><div class="line">  {</div><div class="line">    std::vector&lt;double&gt; data;</div><div class="line"></div><div class="line">    boost::iostreams::filtering_istream in;</div><div class="line">    in.push(boost::iostreams::basic_gzip_decompressor&lt;&gt;());</div><div class="line">    in.push(boost::iostreams::file_source(<span class="stringliteral">&quot;topography.txt.gz&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line = 0; line &lt; 83600; ++line)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">try</span></div><div class="line">          {</div><div class="line">            <span class="keywordtype">double</span> lat, lon, elevation;</div><div class="line">            in &gt;&gt; lat &gt;&gt; lon &gt;&gt; elevation;</div><div class="line"></div><div class="line">            data.push_back(elevation);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">catch</span> (...)</div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                        <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Could not read all 83,600 data points &quot;</span></div><div class="line">                                   <span class="stringliteral">&quot;from the file &lt;topography.txt.gz&gt;!&quot;</span>));</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> data;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3, 3&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; clone() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> R;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> AfricaTopography topography;</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat) <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::R           = 6378137;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::ellipticity = 8.1819190842622e-2;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">AfricaGeometry::pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> pull_back_topo(pull_back_wgs84(space_point));</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">AfricaGeometry::push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> push_forward_wgs84(push_forward_topo(chart_point));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; AfricaGeometry::clone()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;AfricaGeometry&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = phi_theta_d[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta = phi_theta_d[1];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - (ellipticity * ellipticity *</div><div class="line">                                            std::sin(theta) * std::sin(theta)));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {(R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::cos(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">            (R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::sin(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">            ((1 - ellipticity * ellipticity) * R_bar + d) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta)};</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R * R * (1 - ellipticity * ellipticity));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> ep  = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R * R - b * b) / (b * b));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> p   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) * x(0) + x(1) * x(1));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> th  = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R * x(2), b * p);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(1), x(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta =</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(2) + ep * ep * b * std::pow(std::sin(th), 3),</div><div class="line">                 (p -</div><div class="line">                  (ellipticity * ellipticity * R * std::pow(std::cos(th), 3))));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar =</div><div class="line">      R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - ellipticity * ellipticity * std::sin(theta) *</div><div class="line">                           std::sin(theta)));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> phi_theta_d;</div><div class="line">    <span class="keywordflow">if</span> (phi &lt; 0)</div><div class="line">      phi_theta_d[0] = phi + 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phi &gt; 2 * numbers::PI)</div><div class="line">      phi_theta_d[0] = phi - 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      phi_theta_d[0] = phi;</div><div class="line">    phi_theta_d[1] = theta;</div><div class="line">    phi_theta_d[2] = R_plus_d - R_bar;</div><div class="line">    <span class="keywordflow">return</span> phi_theta_d;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  AfricaGeometry::push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = phi_theta_d_hat[2];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d = d_hat + (d_hat + 500000) / 500000 * h;</div><div class="line">    <span class="keywordflow">return</span> {phi_theta_d_hat[0], phi_theta_d_hat[1], d};</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h     = topography.value(phi_theta_d[0], phi_theta_d[1]);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = 500000 * (d - h) / (500000 + h);</div><div class="line">    <span class="keywordflow">return</span> {phi_theta_d[0], phi_theta_d[1], d_hat};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">  {</div><div class="line">    AfricaGeometry   geometry;</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> corner_points[2] = {</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(26 * numbers::PI / 180, -10 * numbers::PI / 180, -500000),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(35 * numbers::PI / 180, 5 * numbers::PI / 180, 0)};</div><div class="line">      std::vector&lt;unsigned int&gt; subdivisions(3);</div><div class="line">      subdivisions[0] = 1;</div><div class="line">      subdivisions[1] = 2;</div><div class="line">      subdivisions[2] = 1;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(</div><div class="line">        triangulation, subdivisions, corner_points[0], corner_points[1], <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">        [&amp;geometry](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) {</div><div class="line">          <span class="keywordflow">return</span> geometry.push_forward(chart_point);</div><div class="line">        },</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, geometry);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      cell-&gt;set_all_manifold_ids(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;boundary_id() == 5)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement step &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; cells, &quot;</span></div><div class="line">                  &lt;&lt; <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / 1000</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;km minimal cell diameter&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;mesh.vtu&quot;</span>;</div><div class="line">    std::ofstream     out(filename);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>           grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step53</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step53::run</a>();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_49.html">step-49</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Wheregeometryandmeshesintersect">Where geometry and meshes
 intersect</a><a href="#Wheregeometryandmeshesintersect">Where geometry and
 meshes intersect</a>
 <li><a href="#Theexamplecase">The example case</a><a
 href="#Theexamplecase">The example case</a>
 <li><a href="#Implementation">Implementation</a><a
 href="#Implementation">Implementation</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#DescribingtopographyAfricaTopography">Describing topography:
 AfricaTopography</a><a
 href="#DescribingtopographyAfricaTopography">Describing topography:
 AfricaTopography</a>
 <li><a href="#DescribingthegeometryAfricaGeometry">Describing the geometry:
 AfricaGeometry</a><a href="#DescribingthegeometryAfricaGeometry">Describing
 the geometry: AfricaGeometry</a>
 <li><a href="#Creatingthemesh">Creating the mesh</a><a
 href="#Creatingthemesh">Creating the mesh</a>
 <li><a href="#Themainfunction">The main function</a><a
 href="#Themainfunction">The main function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Issueswithadaptivelyrefinedmeshesgeneratedthisway">Issues
 with adaptively refined meshes generated this way</a><a
 href="#Issueswithadaptivelyrefinedmeshesgeneratedthisway">Issues with
 adaptively refined meshes generated this way</a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Wolfgang Bangerth and Luca Heltai, using data provided by D. Sarah Stamps.</em> </p><dl class="section note"><dt>Note</dt><dd>This program elaborates on concepts of geometry and the classes thatimplement it. These classes are grouped into the documentation module on <a class="el" href="group__manifold.html">Manifold description for triangulations</a>. See there for additionalinformation. </dd>
<dd>
This tutorial is also available as a Jupyter Python notebook that uses the deal.II python interface. The notebook is available in the same directory as the original C++ program. Rendered notebook can also be viewed on the <a href="https://github.com/dealii/dealii/blob/master/examples/step-53/step-53.ipynb">github</a>.</dd></dl>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>Partial differential equations for realistic problems are often posed ondomains with complicated geometries. To provide just a few examples, considerthese cases:</p>
<ul>
<li>Among the two arguably most important industrial applications for the finite element method, aerodynamics and more generally fluid dynamics is one. Computer simulations today are used in the design of every airplane, car, train and ship. The domain in which the partial differential equation is posed is, in these cases, the air surrounding the plane with its wings, flaps and engines; the air surrounding the car with its wheel, wheel wells, mirrors and, in the case of race cars, all sorts of aerodynamic equipment; the air surrounding the train with its wheels and gaps between cars. In the case of ships, the domain is the water surrounding the ship with its rudders and propellers.</li>
<li>The other of the two big applications of the finite element method is structural engineering in which the domains are bridges, airplane nacelles and wings, and other solid bodies of often complicated shapes.</li>
<li>Finite element modeling is also often used to describe the generation and propagation of earthquake waves. In these cases, one needs to accurately represent the geometry of faults in the Earth crust. Since faults intersect, dip at angles, and are often not completely straight, domains are frequently very complex.One could cite many more examples of complicated geometries in which one wantsto pose and solve a partial differential equation. What this shows is that the"real" world is much more complicated than what we have shown in almost all ofthe tutorial programs preceding this one. This program is therefore devoted to showing how one deals with complexgeometries using a concrete application. In particular, what it shows is howwe make a mesh fit the domain we want to solve on. On the other hand, what theprogram does not show is how to create a coarse for a domain. The process toarrive at a coarse mesh is called "mesh generation" and there are a number ofhigh-quality programs that do this much better than we could everimplement. However, deal.II does have the ability to read in meshes in manyformats generated by mesh generators and then make them fit a given shape,either by deforming a mesh or refining it a number of times until it fits. Thedeal.II Frequently Asked Questions page referenced from <a href="http://www.dealii.org/provides">http://www.dealii.org/provides</a> resources to mesh generators.</li>
</ul>
<p><a class="anchor" id="Wheregeometryandmeshesintersect"></a></p><h3>Where geometry and meshes intersect</h3>
<p>Let us assume that you have a complex domain and that you already have acoarse mesh that somehow represents the general features of the domain. Thenthere are two situations in which it is necessary to describe to a deal.IIprogram the details of your geometry:</p>
<ul>
<li>Mesh refinement: Whenever a cell is refined, it is necessary to introduce new vertices in the <a class="el" href="classTriangulation.html">Triangulation</a>. In the simplest case, one assumes that the objects that make up the <a class="el" href="classTriangulation.html">Triangulation</a> are straight line segments, a bi-linear surface or a tri-linear volume. The next vertex is then simply put into the middle of the old ones. However, for curved boundaries or if we want to solve a PDE on a curved, lower-dimensional manifold embedded in a higher-dimensional space, this is insufficient since it will not respect the actual geometry. We will therefore have to tell <a class="el" href="classTriangulation.html">Triangulation</a> where to put new points.</li>
<li>Integration: When using higher order finite element methods, it is often necessary to compute integrals using curved approximations of the boundary, i.e., describe each edge or face of cells as curves, instead of straight line segments or bilinear patches. The same is, of course, true when integrating boundary terms (e.g., inhomogeneous Neumann boundary conditions). For the purpose of integration, the various <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> classes then provide the transformation from the reference cell to the actual cell. In both cases, we need a way to provide information about the geometry of thedomain at the level of an individual cell, its faces and edges. This is wherethe <a class="el" href="classManifold.html">Manifold</a> class comes into play. <a class="el" href="classManifold.html">Manifold</a> is an abstract base class thatonly defines an interface by which the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a> classes canquery geometric information about the domain. Conceptually, <a class="el" href="classManifold.html">Manifold</a> sees theworld in a way not dissimilar to how the mathematical subdiscipline geometrysees it: a domain is essentially just a collection of points that is somehowequipped with the notion of a distance between points so that we can obtain apoint "in the middle" of some other points. deal.II provides a number of classes that implement the interface provided byManifold for a variety of common geometries. On the other hand, in thisprogram we will consider only a very common and much simpler case, namely thesituation where (a part of) the domain we want to solve on can be described bytransforming a much simpler domain (we will call this the "reference domain").In the language of mathematics, this meansthat the (part of the) domain is a <a href="http://en.wikipedia.org/wiki/Chart_%28topology%29">chart</a>. Charts aredescribed by a smooth function that maps from the simpler domain to the chart(the "push-forward" function) and its inverse (the "pull-back" function). Ifthe domain as a whole is not a chart (e.g., the surface of a sphere), then itcan often be described as a collection of charts (e.g., the northernhemisphere and the southern hemisphere are each charts) and the domain can thenbe describe by an <a href="http://en.wikipedia.org/wiki/Atlas_%28topology%29">atlas</a>. If a domain can be decomposed into an atlas, all we need to do is provide thepull-back and push-forward functions for each of the charts. In deal.II, thismeans providing a class derived from <a class="el" href="classChartManifold.html">ChartManifold</a>, and this is precisely whatwe will do in this program.</li>
</ul>
<p><a class="anchor" id="Theexamplecase"></a></p><h3>The example case</h3>
<p>To illustrate how one describes geometries using charts in deal.II, we willconsider a case that originates in an application of the <a href="https://aspect.geodynamics.org">ASPECT mantle convection code</a>, using adata set provided by D. Sarah Stamps. In the concrete application, we wereinterested in describing flow in the Earth mantle under the <a href="http://en.wikipedia.org/wiki/East_African_rift">East African Rift</a>, azone where two continental plates drift apart. Not to beat around the bush,the geometry we want to describe looks like this: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topo.png"/>
</div>
<p> In particular, though you cannot see this here, the top surface is notjust colored by the elevation but is, in fact, deformed to follow thecorrect topography.While the actual application is not relevant here, the geometry is. The domainwe are interested in is a part of the Earth that ranges from the surface to adepth of 500km, from 26 to 35 degrees East of the Greenwich meridian, and from5 degrees North of the equator to 10 degrees South. This description of the geometry suggests to start with a box \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\) (measured in degrees,degrees, and meters) and to provide a map \(\varphi\) sothat \(\varphi^{-1}(\hat U)=\Omega\) where \(\Omega\) is the domain weseek. \((\Omega,\varphi)\) is then a chart, \(\varphi\) the pull-back operator, and \(\varphi^{-1}\) the push-forward operator. If we need a point \(q\) that is the"average" of other points \(q_i\in\Omega\) , the <a class="el" href="classChartManifold.html">ChartManifold</a> class then firstapplies the pull-back to obtain \(\hat q_i=\varphi(q_i)\) , averages these to apoint \(\hat p\) and then computes \(p=\varphi^{-1}(\hat p)\) . Our goal here is therefore to implement a class that describes \(\varphi\) and \(\varphi^{-1}\) . If Earth was a sphere, then this would not be difficult: if wedenote by \((\hat \phi,\hat \theta,\hat d)\) the points of \(\hat U\) (i.e.,longitude counted eastward, latitude counted northward, and elevation relativeto zero depth), then </p><p class="formulaDsp">
\[ \mathbf x = \varphi^{-1}(\hat \phi,\hat \theta,\hat d) = (R+\hat d) (\cos\hat \phi\cos\hat \theta, \sin\hat \phi\cos\hat \theta, \sin\hat \theta)^T \]
</p>
<p> coordinates in a Cartesian coordinate system, where \(R\) is the radiusof the sphere. However, the Earth is not a sphere: </p><ol>
<li>
It is flattened at the poles and larger at the equator: the semi-major axis is approximately 22km longer than the semi-minor axis. We will account for this using the <a href="http://en.wikipedia.org/wiki/WGS84">WGS 84</a> reference standard for the Earth shape. The formula used in WGS 84 to obtain a position in Cartesian coordinates from longitude, latitude, and elevation is <p class="formulaDsp">
\[ \mathbf x = \varphi_\text{WGS84}^{-1}(\phi,\theta,d) = \left( \begin{array}{c} (\bar R(\theta)+d) \cos\phi\cos\theta, \\ (\bar R(\theta)+d) \sin\phi\cos\theta, \\ ((1-e^2)\bar R(\theta)+d) \sin\theta \end{array} \right), \]
</p>
 where \(\bar R(\theta)=\frac{R}{\sqrt{1-(e \sin\theta)^2}}\) , and radius and ellipticity are given by \(R=6378137\text{m}, e=0.081819190842622\) . In this formula, we assume that the arguments to sines and cosines are evaluated in degree, not radians (though we will have to change this assumption in the code). </li>
<li>
It has topography in the form of mountains and valleys. We will account for this using real topography data (see below for a description of where this data comes from). Using this data set, we can look up elevations on a latitude-longitude mesh laid over the surface of the Earth. Starting with the box \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\) , we will therefore first stretch it in vertical direction before handing it off to the WGS 84 function: if \(h(\hat\phi,\hat\theta)\) is the height at longitude \(\hat\phi\) and latitude \(\hat\theta\) , then we define <p class="formulaDsp">
\[ (\phi,\theta,d) = \varphi_\text{topo}^{-1}(\hat\phi,\hat\theta,\hat d) = \left( \hat\phi, \hat\theta, \hat d + \frac{\hat d+500000}{500000}h(\hat\phi,\hat\theta) \right). \]
</p>
 Using this function, the top surface of the box \(\hat U\) is displaced to the correct topography, the bottom surface remains where it was, and points in between are linearly interpolated. </li>
</ol>
<p>Using these two functions, we can then define the entire push-forward function \(\varphi^{-1}: \hat U \rightarrow \Omega\) as </p><p class="formulaDsp">
\[ \mathbf x = \varphi^{-1}(\hat\phi,\hat\theta,\hat d) = \varphi_\text{WGS84}^{-1}(\varphi_\text{topo}^{-1}(\hat\phi,\hat\theta,\hat d)). \]
</p>
<p> addition, we will have to define the inverse of this function, thepull-back operation, which we can write as </p><p class="formulaDsp">
\[ (\hat\phi,\hat\theta,\hat d) = \varphi(\mathbf x) = \varphi_\text{topo}(\varphi_\text{WGS84}(\mathbf x)). \]
</p>
<p> can obtain one of the components of this function by inverting the formula above: </p><p class="formulaDsp">
\[ (\hat\phi,\hat\theta,\hat d) = \varphi_\text{topo}(\phi,\theta,d) = \left( \phi, \theta, 500000\frac{d-h(\phi,\theta)}{500000+h(\phi,\theta)} \right). \]
</p>
<p> \(\varphi_\text{WGS84}(\mathbf x)\) is also possible though a lot moreawkward. We won't show the formula here but instead only provide the implementationin the program.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>There are a number of issues we need to address in the program. At the largest scale,we need to write a class that implements the interface of <a class="el" href="classChartManifold.html">ChartManifold</a>. This involvesa function <code><a class="el" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">push_forward()</a></code> that takes a pointin the reference domain \(\hat U\) and transform it into real space using the function \(\varphi^{-1}\) outlined above, and its inverse function <code><a class="el" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">pull_back()</a></code> implementing \(\varphi\) . We will do so in the <code>AfricaGeometry</code> class belowthat looks, in essence, like this: </p><div class="fragment"><div class="line"><span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3,3&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> <span class="keyword">virtual</span></div><div class="line"> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line"> <a class="code" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"> <span class="keyword">virtual</span></div><div class="line"> <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line"> <a class="code" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"> ... some member variables and other member <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a>...;</div><div class="line">};</div></div><!-- fragment --><p>The transformations above have two parts: the WGS 84 transformations and the topographytransformation. Consequently, the <code>AfricaGeometry</code> class will haveadditional (non-virtual) member functions <code>AfricaGeometry::push_forward_wgs84()</code> and <code>AfricaGeometry::push_forward_topo()</code> that implement these two pieces, andcorresponding pull back functions. The WGS 84 transformation functions are not particularly interesting (even though theformulas they implement are impressive). The more interesting part is the topographytransformation. Recall that for this, we needed to evaluate the elevation function \(h(\hat\phi,\hat\theta)\) . There is of course no formula for this: Earth is what it is,the best one can do is look up the altitude from some table. This is, in fact what wewill do. The data we use was originally created by the <a href="http://en.wikipedia.org/wiki/Shuttle_Radar_Topography_Mission">Shuttle Radar Topography Mission</a>, was downloaded from the US Geologic Survey(USGS) and processed by D. Sarah Stamps who also wrote the initial version ofthe WGS 84 transformation functions. The topography data so processed isstored in a file <code>topography.txt.gz</code> that, when unpackedlooks like this: </p><div class="fragment"><div class="line">6.983333 25.000000 700</div><div class="line">6.983333 25.016667 692</div><div class="line">6.983333 25.033333 701</div><div class="line">6.983333 25.050000 695</div><div class="line">6.983333 25.066667 710</div><div class="line">6.983333 25.083333 702</div><div class="line">...</div><div class="line"></div><div class="line">-11.983333 35.950000 707</div><div class="line"></div><div class="line">-11.983333 35.966667 687</div><div class="line"></div><div class="line">-11.983333 35.983333 659</div></div><!-- fragment --><p> The data is formatted as <code>latitude longitude elevation</code> where the first twocolumns are provided in degrees North of the equator and degrees East of the Greenwichmeridian. The final column is given in meters above the WGS 84 zero elevation. In the transformation functions, we need to evaluate \(h(\hat\phi,\hat\theta)\) for a givenlongitude \(\hat\phi\) and latitude \(\hat\theta\) . In general, this data point will not beavailable and we will have to interpolate between adjacent data points. Writing such aninterpolation routine is not particularly difficult, but it is a bit tedious and errorprone. Fortunately, we can somehow shoehorn this data set into an existing class: <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> . Unfortunately, the class does not fit the billquite exactly and so we need to work around it a bit. The problem comes from the waywe initialize this class: in its simplest form, it takes a stream of values that itassumes form an equispaced mesh in the \(x-y\) plane (or, here, the \(\phi-\theta\) plane).Which is what they do here, sort of: they are ordered latitude first, longitude second;and more awkwardly, the first column starts at the largest values and counts down,rather than the usual other way around. Now, while tutorial programs are meant to illustrate how to code with deal.II, they donot necessarily have to satisfy the same quality standards as one would have to dowith production codes. In a production code, we would write a function that reads thedata and (i) automatically determines the extents of the first and second column,(ii) automatically determines the number of data points in each direction, (iii) doesthe interpolation regardless of the order in which data is arranged, if necessaryby switching the order between reading and presenting it to the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> class. On the other hand, tutorial programs are best if they are short and demonstrate keypoints rather than dwell on unimportant aspects and, thereby, obscure what we reallywant to show. Consequently, we will allow ourselves a bit of leeway:</p>
<ul>
<li>since this program is intended solely for a particular geometry around the area of the East-African rift and since this is precisely the area described by the data file, we will hardcode in the program that there are \(1139\times 660\) pieces of data;</li>
<li>we will hardcode the boundaries of the data \([-11.98333^\circ,6.983333^\circ]\times[25^\circ,35.98333^\circ]\) ;</li>
<li>we will lie to the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> class: the class will only see the data in the last column of this data file, and we will pretend that the data is arranged in a way that there are 1139 data points in the first coordinate direction that are arranged in <em>ascending</em> order but in an interval \([-6.983333^\circ,11.98333^\circ]\) (not the negated bounds). Then, when we need to look something up for a latitude \(\hat\theta\) , we can ask the interpolating table class for a value at \(-\hat\theta\) . With this little trick, we can avoid having to switch around the order of data as read from file. All of this then calls for a class that essentially looks like this: <div class="fragment"><div class="line"><span class="keyword">class </span>AfricaTopography</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> AfricaTopography ()</div><div class="line">   :</div><div class="line">   topography_data (...initialize somehow...)</div><div class="line"> {}</div><div class="line"></div><div class="line"> <span class="keywordtype">double</span> value (<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"> </span>{</div><div class="line">   <span class="keywordflow">return</span> topography_data.value (<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat 180/numbers::PI,</div><div class="line">                                          lon 180/numbers::PI));</div><div class="line"> }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line">};</div></div><!-- fragment --></li>
</ul>
<p>Note how the <code>value()</code> function negates the latitude. It also switchesfrom the format \(\phi,\theta\) that we use everywhere else to the latitude-longitudeformat used in the table. Finally, it takes its arguments in radians as that is whatwe do everywhere else in the program, but then converts them to the degree-basedsystem used for table lookup. As you will see in the implementation below, the functionhas a few more (static) member functions that we will call in the initializationof the <code>topography_data</code> member variable: the class type of this variablehas a constructor that allows us to set everything right at construction time,rather than having to fill data later on, but this constructor takes a number ofobjects that can't be constructed in-place (at least not in C++98). Consequently,the construction of each of the objects we want to pass in the initialization happensin a number of static member functions. Having discussed the general outline of how we want to implement things, let us goto the program and show how it is done in practice.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>Let us start with the include files we need here. Obviously, we need the ones that describe the triangulation ( <code>tria.h</code> ), and that allow us to create and output triangulations ( <code><a class="el" href="grid__generator_8h.html">grid_generator.h</a></code> and <code><a class="el" href="grid__out_8h.html">grid_out.h</a></code> ). Furthermore, we need the header file that declares the <a class="el" href="classManifold.html">Manifold</a> and <a class="el" href="classChartManifold.html">ChartManifold</a> classes that we will need to describe the geometry ( <code>manifold.h</code> ). We will then also need the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function from the last of the following header files; the purpose for this function will become discussed at the point where we use it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2grid_2manifold_8h.html">deal.II/grid/manifold.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The remainder of the include files relate to reading the topography data. As explained in the introduction, we will read it from a file and then use the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> class that is declared in the first of the following header files. Because the data is large, the file we read from is stored as gzip compressed data and we make use of some BOOST-provided functionality to read directly from gzipped data.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__lib_8h.html">deal.II/base/function_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filtering_stream.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filter/gzip.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/device/file.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>The final part of the top matter is to open a namespace into which to put everything, and then to import the dealii namespace into it.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step53</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="DescribingtopographyAfricaTopography"></a> </p><h3>Describing topography: AfricaTopography</h3>
<p>The first significant part of this program is the class that describes the topography \(h(\hat phi,\hat \theta)\) as a function of longitude and latitude. As discussed in the introduction, we will make our life a bit easier here by not writing the class in the most general way possible but by only writing it for the particular purpose we are interested in here: interpolating data obtained from one very specific data file that contains information about a particular area of the world for which we know the extents. The general layout of the class has been discussed already above. Following is its declaration, including three static member functions that we will need in initializing the <code>topography_data</code> member variable.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AfricaTopography</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AfricaTopography();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;double&gt; get_data();</div><div class="line">};</div></div><!-- fragment --><p>Let us move to the implementation of the class. The interesting parts of the class are the constructor and the <code>value()</code> function. The former initializes the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> member variable and we will use the constructor that requires us to pass in the end points of the 2-dimensional data set we want to interpolate (which are here given by the intervals \([-6.983333, 11.98333]\) , using the trick of switching end points discussed in the introduction, and \([25, 35.983333]\) , both given in degrees), the number of intervals into which the data is split (379 in latitude direction and 219 in longitude direction, for a total of \(380\times 220\) data points), and a <a class="el" href="classTable.html">Table</a> object that contains the data. The data then of course has size \(380\times 220\) and we initialize it by providing an iterator to the first of the 83,600 elements of a std::vector object returned by the <code>get_data()</code> function below. Note that all of the member functions we call here are static because (i) they do not access any member variables of the class, and (ii) because they are called at a time when the object is not initialized fully anyway.</p>
<div class="fragment"><div class="line">AfricaTopography::AfricaTopography()</div><div class="line">  : topography_data({{std::make_pair(-6.983333, 11.966667),</div><div class="line">                      std::make_pair(25, 35.95)}},</div><div class="line">                    {{379, 219}},</div><div class="line">                    <a class="code" href="classTable.html">Table&lt;2, double&gt;</a>(380, 220, get_data().begin()))</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> AfricaTopography::value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> topography_data.value(</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat 180 / numbers::PI, lon 180 / numbers::PI));</div><div class="line">}</div></div><!-- fragment --><p>The only other function of greater interest is the <code>get_data()</code> function. It returns a temporary vector that contains all 83,600 data points describing the altitude and is read from the file <code>topography.txt.gz</code> . Because the file is compressed by gzip, we cannot just read it through an object of type std::ifstream, but there are convenient methods in the BOOST library (see <a href="http://www.boost.org">http://www.boost.org</a>) that allows us to read from compressed files without first having to uncompress it on disk. The result is, basically, just another input stream that, for all practical purposes, looks just like the ones we always use. When reading the data, we read the three columns but throw ignore the first two. The datum in the last column is appended to an array that we the return and that will be copied into the table from which <code>topography_data</code> is initialized. Since the BOOST.iostreams library does not provide a very useful exception when the input file does not exist, is not readable, or does not contain the correct number of data lines, we catch all exceptions it may produce and create our own one. To this end, in the <code>catch</code> clause, we let the program run into an <code>AssertThrow(false, ...)</code> statement. Since the condition is always false, this always triggers an exception. In other words, this is equivalent to writing <code>throw ExcMessage("...")</code> but it also fills certain fields in the exception object that will later be printed on the screen identifying the function, file and line where the exception happened.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; AfricaTopography::get_data()</div><div class="line">{</div><div class="line">  std::vector&lt;double&gt; data;</div></div><!-- fragment --><p>create a stream where we read from gzipped data</p>
<div class="fragment"><div class="line">  boost::iostreams::filtering_istream in;</div><div class="line">  in.push(boost::iostreams::basic_gzip_decompressor&lt;&gt;());</div><div class="line">  in.push(boost::iostreams::file_source(<span class="stringliteral">&quot;topography.txt.gz&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line = 0; line &lt; 83600; ++line)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          <span class="keywordtype">double</span> lat, lon, elevation;</div><div class="line">          in &gt;&gt; lat &gt;&gt; lon &gt;&gt; elevation;</div><div class="line"></div><div class="line">          data.push_back(elevation);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (...)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Could not read all 83,600 data points &quot;</span></div><div class="line">                                 <span class="stringliteral">&quot;from the file &lt;topography.txt.gz&gt;!&quot;</span>));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> data;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DescribingthegeometryAfricaGeometry"></a> </p><h3>Describing the geometry: AfricaGeometry</h3>
<p>The following class is then the main one of this program. Its structure has been described in much detail in the introduction and does not need much introduction any more.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3, 3&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; <a class="code" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">clone</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> R;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> AfricaTopography topography;</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat) <span class="keyword">const</span>;</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::R           = 6378137;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::ellipticity = 8.1819190842622e-2;</div></div><!-- fragment --><p>The implementation, as well, is pretty straightforward if you have read the introduction. In particular, both of the pull back and push forward functions are just concatenations of the respective functions of the WGS 84 and topography mappings:</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">AfricaGeometry::pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> pull_back_topo(pull_back_wgs84(space_point));</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">AfricaGeometry::push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> push_forward_wgs84(push_forward_topo(chart_point));</div><div class="line">}</div></div><!-- fragment --><p>The next function is required by the interface of the <a class="el" href="classManifold.html">Manifold</a> base class, and allows cloning the AfricaGeometry class. Notice that, while the function returns a <code>std::unique_ptr&lt;<a class="el" href="classManifold.html">Manifold</a>&lt;3,3&gt;&gt;</code>, we internally create a <code>unique_ptr&lt;AfricaGeometry&gt;</code>. In other words, the library requires a pointer-to-base-class, which we provide by creating a pointer-to-derived-class.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; AfricaGeometry::clone()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> std::make_unique&lt;AfricaGeometry&gt;();</div><div class="line">}</div></div><!-- fragment --><p>The following two functions then define the forward and inverse transformations that correspond to the WGS 84 reference shape of Earth. The forward transform follows the formula shown in the introduction. The inverse transform is significantly more complicated and is, at the very least, not intuitive. It also suffers from the fact that it returns an angle that at the end of the function we need to clip back into the interval \([0,2\pi]\) if it should have escaped from there.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = phi_theta_d[0];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta = phi_theta_d[1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1</div><div class="line"></div><div class="line">- (ellipticity ellipticity</div><div class="line">                                          std::sin(theta) std::sin(theta)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {(R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) std::cos(phi) <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">          (R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) std::sin(phi) <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">          ((1</div><div class="line"></div><div class="line">- ellipticity ellipticity) R_bar + d) <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta)};</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> b   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R R (1</div><div class="line"></div><div class="line">- ellipticity ellipticity));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> ep  = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R R</div><div class="line"></div><div class="line">- b b) / (b b));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> p   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) x(0) + x(1) x(1));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> th  = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R x(2), b p);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(1), x(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta =</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(2) + ep ep b std::pow(std::sin(th), 3),</div><div class="line">               (p</div><div class="line"></div><div class="line">-</div><div class="line">                (ellipticity ellipticity R std::pow(std::cos(th), 3))));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar =</div><div class="line">    R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1</div><div class="line"></div><div class="line">- ellipticity ellipticity std::sin(theta)</div><div class="line">                         std::sin(theta)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> phi_theta_d;</div><div class="line">  <span class="keywordflow">if</span> (phi &lt; 0)</div><div class="line">    phi_theta_d[0] = phi + 2 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phi &gt; 2 numbers::PI)</div><div class="line">    phi_theta_d[0] = phi</div><div class="line"></div><div class="line">- 2 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    phi_theta_d[0] = phi;</div><div class="line">  phi_theta_d[1] = theta;</div><div class="line">  phi_theta_d[2] = R_plus_d</div><div class="line"></div><div class="line">- R_bar;</div><div class="line">  <span class="keywordflow">return</span> phi_theta_d;</div><div class="line">}</div></div><!-- fragment --><p>In contrast, the topography transformations follow exactly the description in the introduction. There is not consequently not much to add:</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">AfricaGeometry::push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = phi_theta_d_hat[2];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d = d_hat + (d_hat + 500000) / 500000 h;</div><div class="line">  <span class="keywordflow">return</span> {phi_theta_d_hat[0], phi_theta_d_hat[1], d};</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h     = topography.value(phi_theta_d[0], phi_theta_d[1]);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = 500000 (d</div><div class="line"></div><div class="line">- h) / (500000 + h);</div><div class="line">  <span class="keywordflow">return</span> {phi_theta_d[0], phi_theta_d[1], d_hat};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthemesh"></a> </p><h3>Creating the mesh</h3>
<p>Having so described the properties of the geometry, not it is time to deal with the mesh used to discretize it. To this end, we create objects for the geometry and triangulation, and then proceed to create a \(1\times 2\times 1\) rectangular mesh that corresponds to the reference domain \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\) . We choose this number of subdivisions because it leads to cells that are roughly like cubes instead of stretched in one direction or another. Of course, we are not actually interested in meshing the reference domain. We are interested in meshing the real domain. Consequently, we will use the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function that simply moves every point of a triangulation according to a given transformation. The transformation function it wants is a function that takes as its single argument a point in the reference domain and returns the corresponding location in the domain that we want to map to. This is, of course, exactly the push forward function of the geometry we use. We wrap it by a lambda function to obtain the kind of function object required for the transformation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">{</div><div class="line">  AfricaGeometry   geometry;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> corner_points[2] = {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(26 numbers::PI / 180,</div><div class="line"></div><div class="line">-10 numbers::PI / 180,</div><div class="line"></div><div class="line">-500000),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(35 numbers::PI / 180, 5 numbers::PI / 180, 0)};</div><div class="line">    std::vector&lt;unsigned int&gt; subdivisions(3);</div><div class="line">    subdivisions[0] = 1;</div><div class="line">    subdivisions[1] = 2;</div><div class="line">    subdivisions[2] = 1;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(</div><div class="line">      triangulation, subdivisions, corner_points[0], corner_points[1], <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">      [&amp;geometry](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) {</div><div class="line">        <span class="keywordflow">return</span> geometry.push_forward(chart_point);</div><div class="line">      },</div><div class="line">      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">  }</div></div><!-- fragment --><p>The next step is to explain to the triangulation to use our geometry object whenever a new point is needed upon refining the mesh. We do this by telling the triangulation to use our geometry for everything that has manifold indicator zero, and then proceed to mark all cells and their bounding faces and edges with manifold indicator zero. This ensures that the triangulation consults our geometry object every time a new vertex is needed. Since manifold indicators are inherited from mother to children, this also happens after several recursive refinement steps.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, geometry);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  cell-&gt;set_all_manifold_ids(0);</div></div><!-- fragment --><p>The last step is to refine the mesh beyond its initial \(1\times 2\times 1\) coarse mesh. We could just refine globally a number of times, but since for the purpose of this tutorial program we're really only interested in what is happening close to the surface, we just refine 6 times all of the cells that have a face at a boundary with indicator 5. Looking this up in the documentation of the <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> function we have used above reveals that boundary indicator 5 corresponds to the top surface of the domain (and this is what the last <code>true</code> argument in the call to <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> above meant: to "color" the boundaries by assigning each boundary a unique boundary indicator).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;boundary_id() == 5)</div><div class="line">          {</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement step &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; cells, &quot;</span></div><div class="line">              &lt;&lt; <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / 1000</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;km minimal cell diameter&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>Having done this all, we can now output the mesh into a file of its own:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;mesh.vtu&quot;</span>;</div><div class="line">  std::ofstream     out(filename);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>           grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step53</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function, which follows the same scheme used in all tutorial programs starting with <a class="el" href="step_6.html">step-6</a> . There isn't much to do here, only to call the single <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step53::run</a>();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the program produces a mesh file <code>mesh.vtu</code> that we canvisualize with any of the usual visualization programs that can read the VTUfile format. If one just looks at the mesh itself, it is actually very difficultto see anything that doesn't just look like a perfectly round piece of asphere (though if one modified the program so that it does produce a sphere andlooked at them at the same time, the difference between the overall sphere andWGS 84 shape is quite apparent). Apparently, Earth is actually quite a flat place.Of course we already know this from satellite pictures.However, we can tease out something more bycoloring cells by their volume. This both produces slight variations in huealong the top surface and something for the visualization programs to applytheir shading algorithms to (because the top surfaces of the cells are now nolonger just tangential to a sphere but tilted): </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.mesh.png"/>
</div>
<p> Yet, at least as far as visualizations are concerned, this is still not tooimpressive. Rather, let us visualize things in a way so that we show theactual elevation along the top surface. In other words, we want a picture likethis, with an incredible amount of detail: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topo.png"/>
</div>
<p> A zoom-in of this picture shows the vertical displacement quite clearly (here,looking from the West-Northwest over the rift valley, the triple peaksof<a href="http://en.wikipedia.org/wiki/Mount_Stanley">Mount Stanley</a>,<a href="http://en.wikipedia.org/wiki/Mount_Speke">Mount Speke</a>, and<a href="http://en.wikipedia.org/wiki/Mount_Baker_%28Uganda%29">Mount Baker</a>in the<a href="http://en.wikipedia.org/wiki/Rwenzori_Mountains">Rwenzori Range</a>,<a href="http://en.wikipedia.org/wiki/Lake_George_%28Uganda%29">Lake George</a>and toward the great flatness of<a href="http://en.wikipedia.org/wiki/Lake_Victoria">Lake Victoria</a>): </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topozoom.png"/>
</div>
<p>These image were produced with three small modifications: </p><ol>
<li>
An additional seventh mesh refinement towards the top surface for the first of these two pictures, and a total of nine for the second. In the second image, the horizontal mesh size is approximately 1.5km, and just under 1km in vertical direction. (The picture was also created using a more resolved data set; however, it is too big to distribute as part of the tutorial.) </li>
<li>
<p class="startli">The addition of the following function that, given a point <code>x</code> computes the elevation by converting the point to reference WGS 84 coordinates and only keeping the depth variable (the function is, consequently, a simplified version of the <code>AfricaGeometry::pull_back_wgs84()</code> function): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_elevation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)</div><div class="line">{</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> R           = 6378137;</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity = 8.1819190842622e-2;</div><div class="line"></div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> b     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R R (1</div><div class="line"></div><div class="line">- ellipticity ellipticity));</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> ep    = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R R</div><div class="line"></div><div class="line">- b b) / (b b));</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> p     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) x(0) + x(1) x(1));</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> th    = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R x(2), b p);</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> theta = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>((x(2) + ep ep b std::sin(th) std::sin(th) std::sin(th)),</div><div class="line">                                   (p</div><div class="line"></div><div class="line">- (ellipticity ellipticity R  (std::cos(th) std::cos(th) std::cos(th)))));</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1</div><div class="line"></div><div class="line">- ellipticity ellipticity std::sin(theta) std::sin(theta)));</div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line"> <span class="keywordflow">return</span> R_plus_d</div><div class="line"></div><div class="line">- R_bar;</div><div class="line">}</div></div><!-- fragment --><p class="endli"></p>
</li>
<li>
Adding the following piece to the bottom of the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function: <div class="fragment"><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>       fe(1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;3&gt;</a> dof_handler (triangulation);</div><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> elevation (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">{</div><div class="line">  std::map&lt;unsigned int,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           5,</div><div class="line">                                           <a class="code" href="classScalarFunctionFromFunctionObject.html">ScalarFunctionFromFunctionObject&lt;3&gt;</a>(get_elevation),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (std::map&lt;unsigned int,double&gt;::const_iterator p = boundary_values.begin();</div><div class="line">       p!=boundary_values.end(); ++p)</div><div class="line">    elevation[p-&gt;first] = p-&gt;second;</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;3&gt;</a>    data_out;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (elevation, <span class="stringliteral">&quot;elevation&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">std::ofstream out (<span class="stringliteral">&quot;data.vtu&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (out);</div></div><!-- fragment --> </li>
</ol>
<p>This last piece of code first creates a \(Q_1\) finite element space on the mesh.It then (ab)uses <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> to evaluate theelevation function for every node at the top boundary (the one with boundaryindicator 5). We here wrap the call to <code>get_elevation()</code> with theScalarFunctionFromFunctionObject class to make a regular C++ function looklike an object of a class derived from the <a class="el" href="classFunction.html">Function</a> class that we wantto use in <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>. Having so gotten a listof degrees of freedom located at the top boundary and corresponding elevationvalues, we just go down this list and set these elevations in the <code>elevation</code> vector (leaving all interior degrees of freedom attheir original zero value). This vector is then output using <a class="el" href="classDataOut.html">DataOut</a> asusual and can be visualized as shown above.</p>
<p><a class="anchor" id="Issueswithadaptivelyrefinedmeshesgeneratedthisway"></a></p><h3>Issues with adaptively refined meshes generated this way</h3>
<p>If you zoomed in on the mesh shown above and looked closely enough, you wouldfind that at hanging nodes, the two small edges connecting to the hangingnodes are not in exactly the same location as the large edge of theneighboring cell. This can be shown more clearly by using a different surfacedescription in which we enlarge the vertical topography to enhance the effect(courtesy of Alexander Grayver): </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.smooth-geometry.png"/>
</div>
<p> So what is happening here? Partly, this is only a result of visualization, butthere is an underlying real cause as well: </p><ul>
<li>
When you visualize a mesh using any of the common visualization programs, what they really show you is just a set of edges that are plotted as straight lines in three-dimensional space. This is so because almost all data file formats for visualizing data only describe hexahedral cells as a collection of eight vertices in 3d space, and do not allow to any more complicated descriptions. (This is the main reason why <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> takes an argument that can be set to something larger than one.) These linear edges may be the edges of the cell you do actual computations on, or they may not, depending on what kind of mapping you use when you do your integrations using <a class="el" href="classFEValues.html">FEValues</a>. By default, of course, <a class="el" href="classFEValues.html">FEValues</a> uses a linear mapping (i.e., an object of class <a class="el" href="classMappingQ1.html">MappingQ1</a>) and in that case a 3d cell is indeed described exclusively by its 8 vertices and the volume it fills is a trilinear interpolation between these points, resulting in linear edges. But, you could also have used tri-quadratic, tri-cubic, or even higher order mappings and in these cases the volume of each cell will be bounded by quadratic, cubic or higher order polynomial curves. Yet, you only get to see these with linear edges in the visualization program because, as mentioned, file formats do not allow to describe the real geometry of cells. </li>
<li>
That said, let us for simplicity assume that you are indeed using a trilinear mapping, then the image shown above is a faithful representation of the cells on which you form your integrals. In this case, indeed the small cells at a hanging nodes do not, in general, snugly fit against the large cell but leave a gap or may intersect the larger cell. Why is this? Because when the triangulation needs a new vertex on an edge it wants to refine, it asks the manifold description where this new vertex is supposed to be, and the manifold description duly returns such a point by (in the case of a geometry derived from <a class="el" href="classChartManifold.html">ChartManifold</a>) pulling the adjacent points of the line back to the reference domain, averaging their locations, and pushing forward this new location to the real domain. But this new location is not usually along a straight line (in real space) between the adjacent vertices and consequently the two small straight lines forming the refined edge do not lie exactly on the one large straight line forming the unrefined side of the hanging node. </li>
</ul>
<p>The situation is slightly more complicated if you use a higher order mappingusing the <a class="el" href="classMappingQ.html">MappingQ</a> class, but not fundamentally different. Let's take aquadratic mapping for the moment (nothing fundamental changes with even higherorder mappings). Then you need to imagine each edge of the cells you integrateon as a quadratic curve despite the fact that you will never actually see itplotted that way by a visualization program. But imagine it that way for asecond. So which quadratic curve does <a class="el" href="classMappingQ.html">MappingQ</a> take? It is the quadratic curvethat goes through the two vertices at the end of the edge as well as a pointin the middle that it queries from the manifold. In the case of the long edgeon the unrefined side, that's of course exactly the location of the hangingnode, so the quadratic curve describing the long edge does go through thehanging node, unlike in the case of the linear mapping. But the two smalledges are also quadratic curves; for example, the left small edge will gothrough the left vertex of the long edge and the hanging node, plus a point itqueries halfway in between from the manifold. Because, as before, the pointthe manifold returns halfway along the left small edge is rarely exactly onthe quadratic curve describing the long edge, the quadratic short edge willtypically not coincide with the left half of the quadratic long edge, and thesame is true for the right short edge. In other words, again, the geometriesof the large cell and its smaller neighbors at hanging nodes do not touchsnuggly. This all begs two questions: first, does it matter, and second, could this befixed. Let us discuss these in the following: </p><ul>
<li>
Does it matter? It is almost certainly true that this depends on the equation you are solving. For example, it is known that solving the Euler equations of gas dynamics on complex geometries requires highly accurate boundary descriptions to ensure convergence of quantities that are measure the flow close to the boundary. On the other hand, equations with elliptic components (e.g., the Laplace or Stokes equations) are typically rather forgiving of these issues: one does quadrature anyway to approximate integrals, and further approximating the geometry may not do as much harm as one could fear given that the volume of the overlaps or gaps at every hanging node is only \({\cal O}(h^d)\) even with a linear mapping and \({\cal O}(h^{d+p-1})\) for a mapping of degree \(p\) . (You can see this by considering that in 2d the gap/overlap is a triangle with base \(h\) and height \({\cal O}(h)\) ; in 3d, it is a pyramid-like structure with base area \(h^2\) and height \({\cal O}(h)\) . Similar considerations apply for higher order mappings where the height of the gaps/overlaps is \({\cal O}(h^p)\) .) In other words, if you use a linear mapping with linear elements, the error in the volume you integrate over is already at the same level as the integration error using the usual Gauss quadrature. Of course, for higher order elements one would have to choose matching mapping objects. Another point of view on why it is probably not worth worrying too much about the issue is that there is certainly no narrative in the community of numerical analysts that these issues are a major concern one needs to watch out for when using complex geometries. If it does not seem to be discussed often among practitioners, if ever at all, then it is at least not something people have identified as a common problem. This issue is not dissimilar to having hanging nodes at curved boundaries where the geometry description of the boundary typically pulls a hanging node onto the boundary whereas the large edge remains straight, making the adjacent small and large cells not match each other. Although this behavior existed in deal.II since its beginning, 15 years before manifold descriptions became available, it did not ever come up in mailing list discussions or conversations with colleagues. </li>
<li>
<p class="startli">Could it be fixed? In principle, yes, but it's a complicated issue. Let's assume for the moment that we would only ever use the <a class="el" href="classMappingQ1.html">MappingQ1</a> class, i.e., linear mappings. In that case, whenever the triangulation class requires a new vertex along an edge that would become a hanging node, it would just take the mean value of the adjacent vertices <em>in real space</em>, i.e., without asking the manifold description. This way, the point lies on the long straight edge and the two short straight edges would match the one long edge. Only when all adjacent cells have been refined and the point is no longer a hanging node would we replace its coordinates by coordinates we get by a manifold. This may be awkward to implement, but it would certainly be possible. The more complicated issue arises because people may want to use a higher order <a class="el" href="classMappingQ.html">MappingQ</a> object. In that case, the <a class="el" href="classTriangulation.html">Triangulation</a> class may freely choose the location of the hanging node (because the quadratic curve for the long edge can be chosen in such a way that it goes through the hanging node) but the <a class="el" href="classMappingQ.html">MappingQ</a> class, when determining the location of mid-edge points must make sure that if the edge is one half of a long edge of a neighboring coarser cell, then the midpoint cannot be obtained from the manifold but must be chosen along the long quadratic edge. For cubic (and all other odd) mappings, the matter is again a bit complicated because one typically arranges the cubic edge to go through points 1/3 and 2/3 along the edge, and thus necessarily through the hanging node, but this could probably be worked out. In any case, even then, there are two problems with this:</p>
<ul>
<li>When refining the triangulation, the <a class="el" href="classTriangulation.html">Triangulation</a> class can not know what mapping will be used. In fact it is not uncommon for a triangulation to be used differently in different contexts within the same program. If the mapping used determines whether we can freely choose a point or not, how, then, should the triangulation locate new vertices?</li>
<li>Mappings are purely local constructs: they only work on a cell in isolation, and this is one of the important features of the finite element method. Having to ask whether one of the vertices of an edge is a hanging node requires querying the neighborhood of a cell; furthermore, such a query does not just involve the 6 face neighbors of a cell in 3d, but may require traversing a possibly very large number of other cells that connect to an edge. Even if it can be done, one still needs to do different things depending on how the neighborhood looks like, producing code that is likely very complex, hard to maintain, and possibly slow. Consequently, at least for the moment, none of these ideas are implemented. This leads to the undesirable consequence of discontinuous geometries, but, as discussed above, the effects of this do not appear to pose problem in actual practice. </li>
</ul>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2014 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, Texas A&amp;M University, 2014</span></div><div class="line"><span class="comment"> *          Luca Heltai, SISSA, 2014</span></div><div class="line"><span class="comment"> *          D. Sarah Stamps, MIT, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2grid_2manifold_8h.html">deal.II/grid/manifold.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__lib_8h.html">deal.II/base/function_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filtering_stream.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filter/gzip.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/device/file.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step53</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>AfricaTopography</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AfricaTopography();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;double&gt; get_data();</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  AfricaTopography::AfricaTopography()</div><div class="line">    : topography_data({{std::make_pair(-6.983333, 11.966667),</div><div class="line">                        std::make_pair(25, 35.95)}},</div><div class="line">                      {{379, 219}},</div><div class="line">                      <a class="code" href="classTable.html">Table&lt;2, double&gt;</a>(380, 220, get_data().begin()))</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> AfricaTopography::value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> topography_data.value(</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat * 180 / numbers::PI, lon * 180 / numbers::PI));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt; AfricaTopography::get_data()</div><div class="line">  {</div><div class="line">    std::vector&lt;double&gt; data;</div><div class="line"></div><div class="line">    boost::iostreams::filtering_istream in;</div><div class="line">    in.push(boost::iostreams::basic_gzip_decompressor&lt;&gt;());</div><div class="line">    in.push(boost::iostreams::file_source(<span class="stringliteral">&quot;topography.txt.gz&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line = 0; line &lt; 83600; ++line)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">try</span></div><div class="line">          {</div><div class="line">            <span class="keywordtype">double</span> lat, lon, elevation;</div><div class="line">            in &gt;&gt; lat &gt;&gt; lon &gt;&gt; elevation;</div><div class="line"></div><div class="line">            data.push_back(elevation);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">catch</span> (...)</div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                        <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Could not read all 83,600 data points &quot;</span></div><div class="line">                                   <span class="stringliteral">&quot;from the file &lt;topography.txt.gz&gt;!&quot;</span>));</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> data;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3, 3&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; clone() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> R;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> AfricaTopography topography;</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat) <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::R           = 6378137;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::ellipticity = 8.1819190842622e-2;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">AfricaGeometry::pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> pull_back_topo(pull_back_wgs84(space_point));</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">AfricaGeometry::push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> push_forward_wgs84(push_forward_topo(chart_point));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; AfricaGeometry::clone()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;AfricaGeometry&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = phi_theta_d[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta = phi_theta_d[1];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - (ellipticity * ellipticity *</div><div class="line">                                            std::sin(theta) * std::sin(theta)));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {(R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::cos(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">            (R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::sin(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">            ((1 - ellipticity * ellipticity) * R_bar + d) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta)};</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R * R * (1 - ellipticity * ellipticity));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> ep  = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R * R - b * b) / (b * b));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> p   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) * x(0) + x(1) * x(1));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> th  = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R * x(2), b * p);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(1), x(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta =</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(2) + ep * ep * b * std::pow(std::sin(th), 3),</div><div class="line">                 (p -</div><div class="line">                  (ellipticity * ellipticity * R * std::pow(std::cos(th), 3))));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar =</div><div class="line">      R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - ellipticity * ellipticity * std::sin(theta) *</div><div class="line">                           std::sin(theta)));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> phi_theta_d;</div><div class="line">    <span class="keywordflow">if</span> (phi &lt; 0)</div><div class="line">      phi_theta_d[0] = phi + 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phi &gt; 2 * numbers::PI)</div><div class="line">      phi_theta_d[0] = phi - 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      phi_theta_d[0] = phi;</div><div class="line">    phi_theta_d[1] = theta;</div><div class="line">    phi_theta_d[2] = R_plus_d - R_bar;</div><div class="line">    <span class="keywordflow">return</span> phi_theta_d;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  AfricaGeometry::push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = phi_theta_d_hat[2];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d = d_hat + (d_hat + 500000) / 500000 * h;</div><div class="line">    <span class="keywordflow">return</span> {phi_theta_d_hat[0], phi_theta_d_hat[1], d};</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h     = topography.value(phi_theta_d[0], phi_theta_d[1]);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = 500000 * (d - h) / (500000 + h);</div><div class="line">    <span class="keywordflow">return</span> {phi_theta_d[0], phi_theta_d[1], d_hat};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">  {</div><div class="line">    AfricaGeometry   geometry;</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> corner_points[2] = {</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(26 * numbers::PI / 180, -10 * numbers::PI / 180, -500000),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(35 * numbers::PI / 180, 5 * numbers::PI / 180, 0)};</div><div class="line">      std::vector&lt;unsigned int&gt; subdivisions(3);</div><div class="line">      subdivisions[0] = 1;</div><div class="line">      subdivisions[1] = 2;</div><div class="line">      subdivisions[2] = 1;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(</div><div class="line">        triangulation, subdivisions, corner_points[0], corner_points[1], <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">        [&amp;geometry](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) {</div><div class="line">          <span class="keywordflow">return</span> geometry.push_forward(chart_point);</div><div class="line">        },</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, geometry);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      cell-&gt;set_all_manifold_ids(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;boundary_id() == 5)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement step &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; cells, &quot;</span></div><div class="line">                  &lt;&lt; <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / 1000</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;km minimal cell diameter&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;mesh.vtu&quot;</span>;</div><div class="line">    std::ofstream     out(filename);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>           grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step53</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step53::run</a>();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_49.html">step-49</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Wheregeometryandmeshesintersect">Where geometry and meshes intersect</a>
        <li><a href="#Theexamplecase">The example case</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#DescribingtopographyAfricaTopography">Describing topography: AfricaTopography</a>
        <li><a href="#DescribingthegeometryAfricaGeometry">Describing the geometry: AfricaGeometry</a>
        <li><a href="#Creatingthemesh">Creating the mesh</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Issueswithadaptivelyrefinedmeshesgeneratedthisway">Issues with adaptively refined meshes generated this way</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-53/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Wolfgang Bangerth and Luca Heltai, using data provided by D. Sarah Stamps.</em></p>
<dl class="section note"><dt>Note</dt><dd>这个程序阐述了几何学的概念和实现它的类。这些类被归入 <a class="el" href="group__manifold.html">三角形的流形描述 </a>的文档模块。其他信息见那里。</dd>
<dd>
本教程也可作为Jupyter Python笔记本，使用deal.II python接口。该笔记本与原始的C++程序在同一目录下可用。渲染的笔记本也可以在<a href="https://github.com/dealii/dealii/blob/master/example/step-53/step-53.ipynb">github</a>上查看。</dd></dl>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>现实问题的偏微分方程往往是在具有复杂几何形状的域上提出的。为了提供几个例子，请考虑这些情况。</p>
<ul>
<li>在有限元方法的两个可以说是最重要的工业应用中，空气动力学和更普遍的流体动力学是其中之一。今天，计算机模拟被用于每架飞机、汽车、火车和船舶的设计。在这些情况下，提出偏微分方程的领域是飞机周围的空气，包括机翼、襟翼和发动机；汽车周围的空气，包括车轮、轮井、后视镜，在赛车的情况下，还有各种空气动力设备；火车周围的空气，包括车轮和车厢之间的空隙。在船舶的情况下，该领域是指有船舵和螺旋桨的船舶周围的水。</li>
<li>有限元方法的两大应用中的另一个是结构工程，其领域是桥梁、飞机机舱和机翼，以及其他通常形状复杂的固体物体。</li>
<li>有限元建模也经常被用来描述地震波的产生和传播。在这些情况下，人们需要准确地表示地壳中断层的几何形状。由于断层相交，有一定的倾角，而且往往不完全是直线，所以域经常是非常复杂的。我们可以举出更多复杂几何形状的例子，在这些例子中，我们要提出和解决一个偏微分方程。这表明，"真实 "世界比我们在这之前的几乎所有教程中所展示的要复杂得多。</li>
</ul>
<p>因此，这个程序致力于展示如何用具体的应用来处理复杂的几何图形。特别是，它所展示的是我们如何使网格符合我们想要解决的领域。另一方面，该程序没有展示的是如何为一个领域创建一个粗的。获得粗网格的过程被称为 "网格生成"，有许多高质量的程序在这方面做得比我们做得更好。然而，deal.II确实有能力读取由网格生成器生成的多种格式的网格，然后使其适合给定的形状，可以通过变形网格或多次细化网格直至适合。从http://www.dealii.org/ 引用的deal.II常见问题页面提供了网格生成器的资源。</p>
<p><a class="anchor" id="Wheregeometryandmeshesintersect"></a></p><h3>Where geometry and meshes intersect</h3>
<p>让我们假设你有一个复杂的领域，并且你已经有一个粗略的网格，在某种程度上代表了这个领域的一般特征。那么在两种情况下，有必要向deal.II程序描述你的几何形状的细节。</p>
<ul>
<li>网格细化。每当一个单元被细化时，有必要在三角网中引入新的顶点。在最简单的情况下，我们假设构成三角网的对象是直线段、双线性表面或三线性体。然后，下一个顶点被简单地放在旧顶点的中间。然而，对于弯曲的边界，或者如果我们想解决一个嵌入高维空间的弯曲的低维流形上的PDE，这是不充分的，因为它将不尊重实际的几何。因此，我们将不得不告诉Triangulation在哪里放置新的点。</li>
<li>积分。当使用高阶有限元方法时，经常需要使用边界的曲线近似来计算积分，即把单元的每个边缘或面描述为曲线，而不是直线段或双线性补丁。当然，在积分边界条款时也是如此（例如，不均匀的诺伊曼边界条件）。为了整合的目的，各种Mapping类提供了从参考单元到实际单元的转换。</li>
</ul>
<p>在这两种情况下，我们需要一种方法来提供关于单个单元、其面和边的域的几何信息。这就是Manifold类开始发挥作用的地方。Manifold是一个抽象的基类，它只定义了一个接口，Triangulation和Mapping类可以通过这个接口查询领域的几何信息。从概念上讲，Manifold看待世界的方式与数学分支学科几何学看待世界的方式并无二致：域本质上只是一个点的集合，以某种方式配备了点之间的距离概念，这样我们就可以在其他一些点的 "中间 "获得一个点。</p>
<p>deal.II提供了一些实现Manifold所提供的接口的类，用于各种常见的几何形状。另一方面，在这个程序中，我们将只考虑一种非常常见的、简单得多的情况，即我们要解决的域的（一部分）可以通过转换一个简单得多的域（我们将称之为 "参考域"）来描述的情况。在数学语言中，这意味着该（部分）域是一个<a href="http://en.wikipedia.org/wiki/Chart_%28topology%29">chart</a>。图表由一个平滑函数描述，该函数从较简单的域映射到图表（"向前推 "函数）及其逆向（"向后拉 "函数）。如果域作为一个整体不是一个图表（例如，球体的表面），那么它通常可以被描述为一个图表的集合（例如，北半球和南半球各自是一个图表），然后域可以被描述为一个<a href="http://en.wikipedia.org/wiki/Atlas_%28topology%29">atlas</a>。</p>
<p>如果一个域可以被分解成一个图集，那么我们需要做的就是为每个图集提供回拉和推送函数。在deal.II中，这意味着提供一个从ChartManifold派生的类，而这正是我们在这个程序中要做的。</p>
<p><a class="anchor" id="Theexamplecase"></a></p><h3>The example case</h3>
<p>为了说明如何在deal.II中使用图表描述几何形状，我们将考虑一个源于<a href="https://aspect.geodynamics.org">ASPECT mantle convection code</a>的应用的案例，使用D. Sarah Stamps提供的数据集。在具体应用中，我们对描述<a href="http://en.wikipedia.org/wiki/East_African_rift">East African Rift</a>下的地幔流动感兴趣，这是一个两个大陆板块漂移的区域。不拐弯抹角，我们想要描述的几何形状看起来是这样的。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topo.png"/>
</div>
<p>特别是，虽然你在这里看不到，但顶部的表面不仅仅是由高程着色，实际上，它是按照正确的地形变形的。虽然实际的应用在这里并不重要，但几何学是相关的。我们感兴趣的领域是地球的一部分，范围从表面到500公里的深度，从格林威治子午线以东26度到35度，从赤道以北5度到南10度。</p>
<p>这种对几何学的描述建议从一个盒子 \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\) 开始（以度、度数和米为单位），并提供一个地图 \(\varphi\) ，以便 \(\varphi^{-1}(\hat U)=\Omega\) 其中 \(\Omega\) 是我们寻求的领域。 然后， \((\Omega,\varphi)\) 是一个图表， \(\varphi\) 是回拉运算符， \(\varphi^{-1}\) 是前推运算符。如果我们需要一个点 \(q\) 是其他点 \(q_i\in\Omega\) 的 "平均值"，那么ChartManifold类首先应用回拉得到 \(\hat q_i=\varphi(q_i)\) ，将其平均到一个点 \(\hat p\) ，然后计算出 \(p=\varphi^{-1}(\hat p)\) 。</p>
<p>因此，我们这里的目标是实现一个描述 \(\varphi\) 和 \(\varphi^{-1}\) 的类。如果地球是一个球体，那么这并不困难：如果我们用 \((\hat \phi,\hat \theta,\hat d)\) 表示 \(\hat U\) 的点（即经度向东计算，纬度向北计算，海拔相对于零深度），那么</p>
<p class="formulaDsp">
\[ \mathbf x = \varphi^{-1}(\hat \phi,\hat \theta,\hat d) = (R+\hat d) (\cos\hat \phi\cos\hat \theta, \sin\hat \phi\cos\hat \theta, \sin\hat \theta)^T \]
</p>
<p>提供直角坐标系中的坐标，其中 \(R\) 是球体的半径。然而，地球不是一个球体。</p>
<ol>
<li>
<p class="startli">它在两极是扁平的，在赤道是较大的：半主轴比半副轴长约22公里。我们将使用<a href="http://en.wikipedia.org/wiki/WGS84">WGS 84</a>的地球形状参考标准来说明这一点。在WGS 84中，用于从经度、纬度和海拔获得直角坐标位置的公式是</p>
<p class="formulaDsp">
\[ \mathbf x = \varphi_\text{WGS84}^{-1}(\phi,\theta,d) = \left( \begin{array}{c} (\bar R(\theta)+d) \cos\phi\cos\theta, \\ (\bar R(\theta)+d) \sin\phi\cos\theta, \\ ((1-e^2)\bar R(\theta)+d) \sin\theta \end{array} \right), \]
</p>
<p>其中 \(\bar R(\theta)=\frac{R}{\sqrt{1-(e \sin\theta)^2}}\) ，而半径和椭圆度由 \(R=6378137\text{m}, e=0.081819190842622\) 给出。在这个公式中，我们假设正弦和余弦的参数是以度数而不是弧度来计算的（尽管我们将不得不在代码中改变这个假设）。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">它的地形是山脉和山谷的形式。我们将使用真实的地形数据来说明这一点（见下文对这些数据来源的描述）。使用这个数据集，我们可以在地球表面的经纬度网格上查找高程。从方框 \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\) 开始，我们将首先在垂直方向上拉伸它，然后再把它交给WGS 84函数：如果 \(h(\hat\phi,\hat\theta)\) 是经度 \(\hat\phi\) 和纬度 \(\hat\theta\) 的高度，那么我们定义</p>
<p class="formulaDsp">
\[ (\phi,\theta,d) = \varphi_\text{topo}^{-1}(\hat\phi,\hat\theta,\hat d) = \left( \hat\phi, \hat\theta, \hat d + \frac{\hat d+500000}{500000}h(\hat\phi,\hat\theta) \right). \]
</p>
<p class="endli">使用这个函数，盒子 \(\hat U\) 的顶面被移到正确的地形上，底面保持原来的位置，中间的点被线性内插。 </p>
</li>
</ol>
<p>利用这两个函数，我们就可以将整个推送函数 \(\varphi^{-1}: \hat U \rightarrow \Omega\) 定义为</p>
<p class="formulaDsp">
\[ \mathbf x = \varphi^{-1}(\hat\phi,\hat\theta,\hat d) = \varphi_\text{WGS84}^{-1}(\varphi_\text{topo}^{-1}(\hat\phi,\hat\theta,\hat d)). \]
</p>
<p>此外，我们将不得不定义这个函数的逆运算，即回拉运算，我们可以将其写为</p>
<p class="formulaDsp">
\[ (\hat\phi,\hat\theta,\hat d) = \varphi(\mathbf x) = \varphi_\text{topo}(\varphi_\text{WGS84}(\mathbf x)). \]
</p>
<p>我们可以通过倒置上面的公式得到这个函数的一个分量。</p>
<p class="formulaDsp">
\[ (\hat\phi,\hat\theta,\hat d) = \varphi_\text{topo}(\phi,\theta,d) = \left( \phi, \theta, 500000\frac{d-h(\phi,\theta)}{500000+h(\phi,\theta)} \right). \]
</p>
<p>计算 \(\varphi_\text{WGS84}(\mathbf x)\) 也是可能的，不过要笨拙得多。我们不会在这里展示这个公式，而是只提供程序中的实现。</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>在这个程序中，我们需要解决一些问题。在最大范围内，我们需要编写一个实现ChartManifold接口的类。这涉及到一个函数 <code><a class="el" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">push_forward()</a></code> ，该函数在参考域 \(\hat U\) 中取一个点，并使用上面概述的函数 \(\varphi^{-1}\) 将其转换为实空间，以及实现 <code><a class="el" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">pull_back()</a></code> 的反函数 \(\varphi\) 。我们将在下面的 <code>AfricaGeometry</code> 类中这样做，该类本质上看起来像这样。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3,3&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  <a class="code" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">virtual</span></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  <a class="code" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  ... some member variables and other member <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a>...;</div><div class="line">};</div></div><!-- fragment --><p>上述转换有两个部分：WGS 84转换和地形转换。因此， <code>AfricaGeometry</code> 类将有额外的（非虚拟）成员函数 <code>AfricaGeometry::push_forward_wgs84()</code> 和 <code>AfricaGeometry::push_forward_topo()</code> 来实现这两部分，以及相应的回拉函数。</p>
<p>WGS 84的转换函数并不特别有趣（尽管它们实现的公式令人印象深刻）。更有趣的部分是地形变换。回顾一下，为此我们需要评估高程函数 \(h(\hat\phi,\hat\theta)\) 。当然，这没有公式。地球就是这样，人们能做的最好的事情就是从一些表格中查找海拔高度。事实上，这就是我们要做的。</p>
<p>我们使用的数据最初是由<a href="http://en.wikipedia.org/wiki/Shuttle_Radar_Topography_Mission">Shuttle Radar Topography Mission</a>创建的，是从美国地质调查局（USGS）下载的，并由D. Sarah Stamps处理，他还编写了WGS 84转换函数的初始版本。这样处理过的地形数据被储存在一个文件 <code>topography.txt.gz</code> 中，解压后看起来是这样的。</p>
<div class="fragment"><div class="line">6.983333 25.000000 700</div><div class="line">6.983333 25.016667 692</div><div class="line">6.983333 25.033333 701</div><div class="line">6.983333 25.050000 695</div><div class="line">6.983333 25.066667 710</div><div class="line">6.983333 25.083333 702</div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">-11.983333 35.950000 707</div><div class="line"></div><div class="line"></div><div class="line">-11.983333 35.966667 687</div><div class="line"></div><div class="line"></div><div class="line">-11.983333 35.983333 659</div></div><!-- fragment --><p>数据格式为 <code>latitude longitude elevation</code> ，其中前两栏以赤道以北的度数和格林威治子午线以东的度数提供。最后一列是以WGS84零点以上的米数为单位。</p>
<p>在转换函数中，我们需要对给定的经度 \(\hat\phi\) 和纬度 \(\hat\theta\) 评估 \(h(\hat\phi,\hat\theta)\) 。一般来说，这个数据点是不可用的，我们将不得不在相邻的数据点之间进行内插。编写这样一个插值程序并不特别困难，但它有点乏味，而且容易出错。幸运的是，我们可以以某种方式将这个数据集塞进一个现有的类中。 <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> .不幸的是，这个类并不完全适合，所以我们需要绕过它。问题来自于我们初始化这个类的方式：在其最简单的形式下，它需要一个数值流，它假设在 \(x-y\) 平面（或者，这里是 \(\phi-\theta\) 平面）形成一个等距的网格。这就是它们在这里所做的，某种程度上：它们的顺序是纬度第一，经度第二；更尴尬的是，第一列从最大的数值开始往下数，而不是通常的其他方式。</p>
<p>现在，虽然教程程序是为了说明如何用deal.II编码，但它们不一定要满足与生产代码相同的质量标准。在生产代码中，我们会写一个函数来读取数据，并（i）自动确定第一列和第二列的外延，（ii）自动确定每个方向的数据点的数量，（iii）无论数据的排列顺序如何，都要进行插值，如果有必要的话，在读取和呈现给 <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> 类之间切换顺序。</p>
<p>另一方面，辅导课程最好是短小精悍，展示关键点，而不是纠缠于不重要的方面，从而掩盖了我们真正想要展示的东西。因此，我们将允许自己有一点回旋余地。</p>
<ul>
<li>由于这个程序只针对东非裂谷地区周围的特定几何形状，并且由于这正是数据文件所描述的区域，我们将在程序中硬编码有 \(1139\times 660\) 个数据。</li>
<li>我们将硬编码数据的边界 \([-11.98333^\circ,6.983333^\circ]\times[25^\circ,35.98333^\circ]\) 。</li>
<li>我们将对 <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> 类撒谎：该类将只看到这个数据文件最后一列的数据，我们将假装数据的排列方式是：在第一个坐标方向上有1139个数据点，这些数据点按<em>ascending</em>的顺序排列，但在一个区间 \([-6.983333^\circ,11.98333^\circ]\) （不是否定的边界）。然后，当我们需要查询某个纬度 \(\hat\theta\) 的东西时，我们可以向内插表类索取 \(-\hat\theta\) 的数值。有了这个小技巧，我们就可以避免在从文件中读取数据的时候切换顺序。</li>
</ul>
<p>所有这些都需要一个本质上看起来像这样的类。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AfricaTopography</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AfricaTopography ()</div><div class="line">    :</div><div class="line">    topography_data (...initialize somehow...)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> value (<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> topography_data.value (<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat * 180/numbers::PI,</div><div class="line">                                           lon * 180/numbers::PI));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line">};</div></div><!-- fragment --><p>注意 <code>value()</code> 函数如何否定了纬度。它还将我们在其他地方使用的格式 \(\phi,\theta\) 转换为表格中使用的纬度-经度格式。最后，它的参数以弧度为单位，因为我们在程序中的其他地方也是这样做的，但随后将它们转换为用于表格查询的基于度的系统。正如你在下面的实现中所看到的，该函数还有几个（静态）成员函数，我们将在初始化 <code>topography_data</code> 成员变量时调用：该变量的类类型有一个构造函数，允许我们在构造时正确设置一切，而不是在以后填充数据，但这个构造函数需要一些不能就地构造的对象（至少在C++98中不能）。因此，我们要在初始化中传递的每个对象的构造都发生在一些静态成员函数中。</p>
<p>在讨论了我们要实施的事情的大体轮廓之后，让我们去看程序，并展示它在实践中是如何做的。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>Let us start with the include files we need here. Obviously, we need the ones that describe the triangulation (<code>tria.h</code>), and that allow us to create and output triangulations (<code><a class="el" href="grid__generator_8h.html">grid_generator.h</a></code> and <code><a class="el" href="grid__out_8h.html">grid_out.h</a></code>). Furthermore, we need the header file that declares the <a class="el" href="classManifold.html">Manifold</a> and <a class="el" href="classChartManifold.html">ChartManifold</a> classes that we will need to describe the geometry (<code>manifold.h</code>). We will then also need the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function from the last of the following header files; the purpose for this function will become discussed at the point where we use it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2grid_2manifold_8h.html">deal.II/grid/manifold.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The remainder of the include files relate to reading the topography data. As explained in the introduction, we will read it from a file and then use the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> class that is declared in the first of the following header files. Because the data is large, the file we read from is stored as gzip compressed data and we make use of some BOOST-provided functionality to read directly from gzipped data.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__lib_8h.html">deal.II/base/function_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filtering_stream.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filter/gzip.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/device/file.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>The final part of the top matter is to open a namespace into which to put everything, and then to import the dealii namespace into it.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step53</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="DescribingtopographyAfricaTopography"></a> </p><h3>Describing topography: AfricaTopography</h3>
<p>The first significant part of this program is the class that describes the topography \(h(\hat phi,\hat \theta)\) as a function of longitude and latitude. As discussed in the introduction, we will make our life a bit easier here by not writing the class in the most general way possible but by only writing it for the particular purpose we are interested in here: interpolating data obtained from one very specific data file that contains information about a particular area of the world for which we know the extents.</p>
<p>The general layout of the class has been discussed already above. Following is its declaration, including three static member functions that we will need in initializing the <code>topography_data</code> member variable.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AfricaTopography</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AfricaTopography();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;double&gt; get_data();</div><div class="line">};</div></div><!-- fragment --><p>Let us move to the implementation of the class. The interesting parts of the class are the constructor and the <code>value()</code> function. The former initializes the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a> member variable and we will use the constructor that requires us to pass in the end points of the 2-dimensional data set we want to interpolate (which are here given by the intervals \([-6.983333, 11.98333]\), using the trick of switching end points discussed in the introduction, and \([25, 35.983333]\), both given in degrees), the number of intervals into which the data is split (379 in latitude direction and 219 in longitude direction, for a total of \(380\times 220\) data points), and a <a class="el" href="classTable.html">Table</a> object that contains the data. The data then of course has size \(380\times 220\) and we initialize it by providing an iterator to the first of the 83,600 elements of a std::vector object returned by the <code>get_data()</code> function below. Note that all of the member functions we call here are static because (i) they do not access any member variables of the class, and (ii) because they are called at a time when the object is not initialized fully anyway.</p>
<div class="fragment"><div class="line">AfricaTopography::AfricaTopography()</div><div class="line">  : topography_data({{std::make_pair(-6.983333, 11.966667),</div><div class="line">                      std::make_pair(25, 35.95)}},</div><div class="line">                    {{379, 219}},</div><div class="line">                    <a class="code" href="classTable.html">Table&lt;2, double&gt;</a>(380, 220, get_data().begin()))</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> AfricaTopography::value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> topography_data.value(</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat * 180 / numbers::PI, lon * 180 / numbers::PI));</div><div class="line">}</div></div><!-- fragment --><p>The only other function of greater interest is the <code>get_data()</code> function. It returns a temporary vector that contains all 83,600 data points describing the altitude and is read from the file <code>topography.txt.gz</code>. Because the file is compressed by gzip, we cannot just read it through an object of type std::ifstream, but there are convenient methods in the BOOST library (see <a href="http://www.boost.org">http://www.boost.org</a>) that allows us to read from compressed files without first having to uncompress it on disk. The result is, basically, just another input stream that, for all practical purposes, looks just like the ones we always use.</p>
<p>When reading the data, we read the three columns but throw ignore the first two. The datum in the last column is appended to an array that we the return and that will be copied into the table from which <code>topography_data</code> is initialized. Since the BOOST.iostreams library does not provide a very useful exception when the input file does not exist, is not readable, or does not contain the correct number of data lines, we catch all exceptions it may produce and create our own one. To this end, in the <code>catch</code> clause, we let the program run into an <code>AssertThrow(false, ...)</code> statement. Since the condition is always false, this always triggers an exception. In other words, this is equivalent to writing <code>throw ExcMessage("...")</code> but it also fills certain fields in the exception object that will later be printed on the screen identifying the function, file and line where the exception happened.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; AfricaTopography::get_data()</div><div class="line">{</div><div class="line">  std::vector&lt;double&gt; data;</div></div><!-- fragment --><p>create a stream where we read from gzipped data</p>
<div class="fragment"><div class="line">  boost::iostreams::filtering_istream in;</div><div class="line">  in.push(boost::iostreams::basic_gzip_decompressor&lt;&gt;());</div><div class="line">  in.push(boost::iostreams::file_source(<span class="stringliteral">&quot;topography.txt.gz&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line = 0; line &lt; 83600; ++line)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          <span class="keywordtype">double</span> lat, lon, elevation;</div><div class="line">          in &gt;&gt; lat &gt;&gt; lon &gt;&gt; elevation;</div><div class="line"></div><div class="line">          data.push_back(elevation);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (...)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Could not read all 83,600 data points &quot;</span></div><div class="line">                                 <span class="stringliteral">&quot;from the file &lt;topography.txt.gz&gt;!&quot;</span>));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> data;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DescribingthegeometryAfricaGeometry"></a> </p><h3>Describing the geometry: AfricaGeometry</h3>
<p>The following class is then the main one of this program. Its structure has been described in much detail in the introduction and does not need much introduction any more.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3, 3&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="classChartManifold.html#a5113d1d256ef1777f91eafe5f7d5fa35">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="classChartManifold.html#a713fbbf4271f9539bb2406f7029ab239">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; <a class="code" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">clone</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> R;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> AfricaTopography topography;</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat) <span class="keyword">const</span>;</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::R           = 6378137;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::ellipticity = 8.1819190842622e-2;</div></div><!-- fragment --><p>The implementation, as well, is pretty straightforward if you have read the introduction. In particular, both of the pull back and push forward functions are just concatenations of the respective functions of the WGS 84 and topography mappings:</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">AfricaGeometry::pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> pull_back_topo(pull_back_wgs84(space_point));</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">AfricaGeometry::push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> push_forward_wgs84(push_forward_topo(chart_point));</div><div class="line">}</div></div><!-- fragment --><p>The next function is required by the interface of the <a class="el" href="classManifold.html">Manifold</a> base class, and allows cloning the AfricaGeometry class. Notice that, while the function returns a <code>std::unique_ptr&lt;<a class="el" href="classManifold.html">Manifold</a>&lt;3,3&gt;&gt;</code>, we internally create a <code>unique_ptr&lt;AfricaGeometry&gt;</code>. In other words, the library requires a pointer-to-base-class, which we provide by creating a pointer-to-derived-class.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; AfricaGeometry::clone()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> std::make_unique&lt;AfricaGeometry&gt;();</div><div class="line">}</div></div><!-- fragment --><p>The following two functions then define the forward and inverse transformations that correspond to the WGS 84 reference shape of Earth. The forward transform follows the formula shown in the introduction. The inverse transform is significantly more complicated and is, at the very least, not intuitive. It also suffers from the fact that it returns an angle that at the end of the function we need to clip back into the interval \([0,2\pi]\) if it should have escaped from there.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = phi_theta_d[0];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta = phi_theta_d[1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - (ellipticity * ellipticity *</div><div class="line">                                          std::sin(theta) * std::sin(theta)));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {(R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::cos(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">          (R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::sin(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">          ((1 - ellipticity * ellipticity) * R_bar + d) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta)};</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> b   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R * R * (1 - ellipticity * ellipticity));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> ep  = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R * R - b * b) / (b * b));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> p   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) * x(0) + x(1) * x(1));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> th  = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R * x(2), b * p);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(1), x(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> theta =</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(2) + ep * ep * b * std::pow(std::sin(th), 3),</div><div class="line">               (p -</div><div class="line">                (ellipticity * ellipticity * R * std::pow(std::cos(th), 3))));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar =</div><div class="line">    R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - ellipticity * ellipticity * std::sin(theta) *</div><div class="line">                         std::sin(theta)));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> phi_theta_d;</div><div class="line">  <span class="keywordflow">if</span> (phi &lt; 0)</div><div class="line">    phi_theta_d[0] = phi + 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phi &gt; 2 * numbers::PI)</div><div class="line">    phi_theta_d[0] = phi - 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    phi_theta_d[0] = phi;</div><div class="line">  phi_theta_d[1] = theta;</div><div class="line">  phi_theta_d[2] = R_plus_d - R_bar;</div><div class="line">  <span class="keywordflow">return</span> phi_theta_d;</div><div class="line">}</div></div><!-- fragment --><p>In contrast, the topography transformations follow exactly the description in the introduction. There is not consequently not much to add:</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">AfricaGeometry::push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = phi_theta_d_hat[2];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d = d_hat + (d_hat + 500000) / 500000 * h;</div><div class="line">  <span class="keywordflow">return</span> {phi_theta_d_hat[0], phi_theta_d_hat[1], d};</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h     = topography.value(phi_theta_d[0], phi_theta_d[1]);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = 500000 * (d - h) / (500000 + h);</div><div class="line">  <span class="keywordflow">return</span> {phi_theta_d[0], phi_theta_d[1], d_hat};</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthemesh"></a> </p><h3>Creating the mesh</h3>
<p>Having so described the properties of the geometry, not it is time to deal with the mesh used to discretize it. To this end, we create objects for the geometry and triangulation, and then proceed to create a \(1\times 2\times 1\) rectangular mesh that corresponds to the reference domain \(\hat U=[26,35]\times[-10,5]\times[-500000,0]\). We choose this number of subdivisions because it leads to cells that are roughly like cubes instead of stretched in one direction or another.</p>
<p>Of course, we are not actually interested in meshing the reference domain. We are interested in meshing the real domain. Consequently, we will use the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> function that simply moves every point of a triangulation according to a given transformation. The transformation function it wants is a function that takes as its single argument a point in the reference domain and returns the corresponding location in the domain that we want to map to. This is, of course, exactly the push forward function of the geometry we use. We wrap it by a lambda function to obtain the kind of function object required for the transformation.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">{</div><div class="line">  AfricaGeometry   geometry;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> corner_points[2] = {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(26 * numbers::PI / 180, -10 * numbers::PI / 180, -500000),</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(35 * numbers::PI / 180, 5 * numbers::PI / 180, 0)};</div><div class="line">    std::vector&lt;unsigned int&gt; subdivisions(3);</div><div class="line">    subdivisions[0] = 1;</div><div class="line">    subdivisions[1] = 2;</div><div class="line">    subdivisions[2] = 1;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(</div><div class="line">      triangulation, subdivisions, corner_points[0], corner_points[1], <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">      [&amp;geometry](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) {</div><div class="line">        <span class="keywordflow">return</span> geometry.push_forward(chart_point);</div><div class="line">      },</div><div class="line">      <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">  }</div></div><!-- fragment --><p>The next step is to explain to the triangulation to use our geometry object whenever a new point is needed upon refining the mesh. We do this by telling the triangulation to use our geometry for everything that has manifold indicator zero, and then proceed to mark all cells and their bounding faces and edges with manifold indicator zero. This ensures that the triangulation consults our geometry object every time a new vertex is needed. Since manifold indicators are inherited from mother to children, this also happens after several recursive refinement steps.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, geometry);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  cell-&gt;set_all_manifold_ids(0);</div></div><!-- fragment --><p>The last step is to refine the mesh beyond its initial \(1\times 2\times 1\) coarse mesh. We could just refine globally a number of times, but since for the purpose of this tutorial program we're really only interested in what is happening close to the surface, we just refine 6 times all of the cells that have a face at a boundary with indicator 5. Looking this up in the documentation of the <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> function we have used above reveals that boundary indicator 5 corresponds to the top surface of the domain (and this is what the last <code>true</code> argument in the call to <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> above meant: to "color" the boundaries by assigning each boundary a unique boundary indicator).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;boundary_id() == 5)</div><div class="line">          {</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement step &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; cells, &quot;</span></div><div class="line">              &lt;&lt; <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / 1000</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;km minimal cell diameter&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>Having done this all, we can now output the mesh into a file of its own:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;mesh.vtu&quot;</span>;</div><div class="line">    std::ofstream     out(filename);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>           grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step53</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function, which follows the same scheme used in all tutorial programs starting with <a class="el" href="step_6.html">step-6</a>. There isn't much to do here, only to call the single <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step53::run</a>();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> examples/step-53/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>运行程序会产生一个网格文件 <code>mesh.vtu</code> ，我们可以用任何可以读取VTU文件格式的常规可视化程序来进行可视化。如果只看网格本身，实际上很难看到任何不只是看起来像一块完全圆形的球体的东西（尽管如果修改程序，使其确实产生一个球体，并同时看它们，整体球体和WGS 84形状之间的差异是相当明显的）。很明显，地球实际上是一个相当平坦的地方。当然，我们已经从卫星图片中知道了这一点。然而，我们可以通过对细胞的体积进行着色来找出更多的东西。这既产生了沿顶面的轻微色调变化，也为可视化程序提供了应用其着色算法的东西（因为单元的顶面现在不再只是与球体的切线，而是倾斜的）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.mesh.png"/>
</div>
<p>然而，至少就视觉化而言，这仍然不是太令人印象深刻。相反，让我们以一种可视化的方式，使我们显示出沿顶面的实际海拔。换句话说，我们想要一张这样的图片，有难以置信的细节。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topo.png"/>
</div>
<p>这张照片的放大显示了相当清楚的垂直位移（这里，从西-西北方向看裂谷上空，<a href="http://en.wikipedia.org/wiki/Mount_Stanley">Mount Stanley</a>、<a href="http://en.wikipedia.org/wiki/Mount_Speke">Mount Speke</a>和<a href="http://en.wikipedia.org/wiki/Mount_Baker_%28Uganda%29">Mount Baker</a>的三座山峰在<a href="http://en.wikipedia.org/wiki/Rwenzori_Mountains">Rwenzori Range</a>、<a href="http://en.wikipedia.org/wiki/Lake_George_%28Uganda%29">Lake George</a>和向<a href="http://en.wikipedia.org/wiki/Lake_Victoria">Lake Victoria</a>的巨大平坦处）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.topozoom.png"/>
</div>
<p>这些图片是经过三个小的修改后产生的。</p><ol>
<li>
<p class="startli">在这两张图片中，第一张图片的顶面增加了第七个网格细化，第二张图片总共增加了九个。在第二张图片中，水平方向的网格大小约为1.5km，垂直方向的网格大小略低于1km。(这张图也是用一个更有分辨率的数据集制作的；但是，它太大了，不能作为教程的一部分分发)。 </p><pre class="fragment">&lt;li&gt;  增加以下函数，在给定一个点 &lt;code&gt;x&lt;/code&gt; 时，通过将该点转换为参考WGS 84坐标并只保留深度变量来计算海拔高度（因此，该函数是 &lt;code&gt;AfricaGeometry::pull_back_wgs84()&lt;/code&gt; 函数的简化版本）。
</pre><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_elevation (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R           = 6378137;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity = 8.1819190842622e-2;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R * R * (1 - ellipticity * ellipticity));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> ep    = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R * R - b * b) / (b * b));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> p     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) * x(0) + x(1) * x(1));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> th    = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R * x(2), b * p);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>((x(2) + ep * ep * b * std::sin(th) * std::sin(th) * std::sin(th)),</div><div class="line">                                      (p - (ellipticity * ellipticity * R  * (std::cos(th) * std::cos(th) * std::cos(th)))));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - ellipticity * ellipticity * std::sin(theta) * std::sin(theta)));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> R_plus_d - R_bar;</div><div class="line">  }</div></div><!-- fragment --><pre class="fragment">&lt;li&gt;  在 &lt;code&gt;run()&lt;/code&gt; 函数的底部添加以下一块。
</pre><div class="fragment"><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>       fe(1);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;3&gt;</a> dof_handler (triangulation);</div><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> elevation (dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">{</div><div class="line">  std::map&lt;unsigned int,double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           5,</div><div class="line">                                           <a class="code" href="classScalarFunctionFromFunctionObject.html">ScalarFunctionFromFunctionObject&lt;3&gt;</a>(get_elevation),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (std::map&lt;unsigned int,double&gt;::const_iterator p = boundary_values.begin();</div><div class="line">       p!=boundary_values.end(); ++p)</div><div class="line">    elevation[p-&gt;first] = p-&gt;second;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;3&gt;</a>    data_out;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (elevation, <span class="stringliteral">&quot;elevation&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line"></div><div class="line">std::ofstream out (<span class="stringliteral">&quot;data.vtu&quot;</span>);</div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (out);</div></div><!-- fragment --><p class="endli"></p>
</li>
</ol>
<p>这最后一段代码首先在网格上创建一个 \(Q_1\) 有限元空间。然后使用 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> 对顶部边界的每个节点（边界指标为5的节点）进行高程函数的评估。我们在这里用ScalarFunctionFromFunctionObject类来包装对 <code>get_elevation()</code> 的调用，使一个普通的C++函数看起来像一个派生自Function类的对象，我们想在 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>. 中使用。然后像往常一样用DataOut输出这个向量，并可以如上图所示进行可视化。</p>
<p><a class="anchor" id="Issueswithadaptivelyrefinedmeshesgeneratedthisway"></a></p><h3>Issues with adaptively refined meshes generated this way</h3>
<p>如果你放大上图所示的网格并仔细观察，你会发现在悬空节点处，连接到悬空节点的两条小边与相邻单元的大边的位置不完全相同。这可以通过使用不同的表面描述来更清楚地显示出来，在这种描述中，我们放大了垂直地形以增强效果（由Alexander Grayver提供）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-53.smooth-geometry.png"/>
</div>
<p>那么这里发生了什么？部分原因是，这只是视觉化的结果，但也有一个潜在的真正原因。</p>
<ul>
<li>
<p class="startli">当你使用任何一个常见的可视化程序对网格进行可视化时，它们真正显示的只是一组在三维空间中被绘制成直线的边缘。这是因为几乎所有用于可视化的数据文件格式都只将六面体单元描述为三维空间中八个顶点的集合，而不允许任何更复杂的描述。这就是为什么 <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> 需要一个可以设置为大于1的参数的主要原因）。这些线性边缘可能是你进行实际计算的单元格的边缘，也可能不是，这取决于你在使用FEValues进行积分时使用何种映射。当然，在默认情况下，FEValues使用的是线性映射（即MappingQ1类的对象），在这种情况下，一个3D单元确实完全由其8个顶点描述，它所填充的体积是这些点之间的三线插值，从而产生了线性边缘。但是，你也可以使用三次方、三次立方、甚至更高阶的映射，在这些情况下，每个单元的体积将由二次方、三次方或高阶多项式曲线来限定。然而，你只能在可视化程序中看到这些带有线性边缘的曲线，因为如前所述，文件格式不允许描述细胞的真实几何形状。</p>
<p class="endli"></p>
</li>
<li>
也就是说，为了简单起见，让我们假设你确实在使用三线性映射，那么上面显示的图像就是你形成积分的单元的忠实代表。在这种情况下，一般来说，悬空节点上的小单元并不与大单元紧密贴合，而是留有间隙，或者可能与大单元相交。这是为什么呢？ 因为当三角测量需要在它想要细化的边缘上增加一个新的顶点时，它会询问流形描述这个新的顶点应该在哪里，流形描述通过（在从ChartManifold派生的几何体的情况下）将线的相邻点拉回到参考域，平均它们的位置，并将这个新的位置推到真实域，从而适当地返回这样一个点。但是这个新的位置通常不是沿着相邻顶点之间的直线（在实空间），因此，形成精炼边缘的两条小直线并不完全位于形成悬挂节点的未精炼边的一条大直线上。 </li>
</ul>
<p>如果你使用MappingQ类的高阶映射，情况会稍微复杂一些，但没有根本的不同。我们暂且采用二次映射（高阶映射也没有什么根本性的变化）。那么你需要把你所整合的单元格的每条边想象成一条二次曲线，尽管你实际上不会看到可视化程序以这种方式绘制。但请先想象一下。那么，MappingQ采用哪条二次曲线呢？它是经过边缘末端的两个顶点以及中间的一个点的二次曲线，它从流形中查询。在未精炼一侧的长边的情况下，这当然正是悬空节点的位置，所以描述长边的二次曲线确实经过了悬空节点，这与线性映射的情况不同。但是两条小边也是二次曲线；例如，左边的小边会经过长边的左顶点和悬挂节点，再加上它从流形中查询到的一个点。因为如前所述，流形沿左小边中途返回的点很少完全在描述长边的二次曲线上，二次短边通常不会与二次长边的左半边重合，右短边也是如此。换句话说，同样的，大单元格和它在悬挂节点上的小邻居的几何形状并不相依相偎。</p>
<p>这一切引出了两个问题：第一，这是否重要，第二，这是否可以解决。让我们在下文中讨论这些问题。</p>
<ul>
<li>
<p class="startli">这重要吗？几乎可以肯定的是，这取决于你所求解的方程。例如，众所周知，在复杂几何体上求解气体动力学的欧拉方程需要高度精确的边界描述，以确保衡量靠近边界的流动的量的收敛。另一方面，具有椭圆成分的方程（如拉普拉斯方程或斯托克斯方程）通常对这些问题比较宽容：无论如何都要做正交来近似积分，鉴于每个悬空节点的重叠或间隙的体积只有 \({\cal O}(h^d)\) ，进一步近似几何可能不会像人们担心的那样造成伤害。]，即使是线性映射，对于度数为 \(p\) 的映射，也只有 \({\cal O}(h^{d+p-1})\) 。 (你可以通过考虑到在2D中，间隙/重叠是一个三角形，底 \(h\) ，高 \({\cal O}(h)\) ；在3D中，它是一个类似金字塔的结构，底面积 \(h^2\) ，高 \({\cal O}(h)\) 。类似的考虑也适用于高阶映射，其中空隙/重叠的高度为 \({\cal O}(h^p)\) .)换句话说，如果你使用线性元素的线性映射，你所积分的体积的误差已经与使用通常的高斯正交的积分误差处于同一水平。当然，对于更高阶的元素，人们将不得不选择匹配的映射对象。</p>
<p>关于为什么不值得过分担心这个问题的另一个观点是，在数值分析界肯定没有人说这些问题是使用复杂几何体时需要注意的一个主要问题。如果从业者之间似乎并不经常讨论这个问题，如果有的话，那么它至少不是人们认定的一个普遍问题。</p>
<p>这个问题与在弯曲的边界上有悬挂的节点没有什么不同，在这种情况下，边界的几何描述通常会将悬挂的节点拉到边界上，而大的边缘仍然是直的，使得相邻的小单元和大单元不能相互匹配。虽然这种行为从一开始就存在于deal.II中，在流形描述出现之前的15年，但在邮件列表的讨论或与同事的交谈中，它从未出现过。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">能否修复？原则上是的，但这是一个复杂的问题。我们暂且假设我们只会使用MappingQ1类，也就是线性映射。在这种情况下，每当三角化类需要沿着一条将成为悬空节点的边建立一个新的顶点时，它就会直接取相邻顶点的平均值<em>in real space</em>，也就是说，不问流形的描述。这样一来，该点就位于长直边上，两条短直边将与一条长直边匹配。只有当所有相邻的单元都被细化，并且该点不再是一个悬挂的节点时，我们才会用通过流形得到的坐标来替换它的坐标。这在实现上可能比较麻烦，但肯定是可行的。</p>
<p>更复杂的问题出现了，因为人们可能想使用高阶的MappingQ对象。在这种情况下，Triangulation类可以自由选择悬挂节点的位置（因为长边的二次曲线可以选择通过悬挂节点的方式），但是MappingQ类在确定中边点的位置时，必须确保如果该边是相邻的较粗单元的长边的一半，那么中点不能从流形中获得，而必须沿着长二次边选择。对于立方体（和所有其他奇数）映射，这个问题又有点复杂了，因为人们通常安排立方体边沿着边的1/3和2/3点走，因此必然要通过悬挂的节点，但这可能是可以解决的。在任何情况下，即使如此，这也有两个问题。</p>
<ul>
<li>在细化三角函数时，三角函数类不可能知道将使用什么映射。事实上，在同一个程序中，一个三角函数在不同的情况下被使用的情况并不罕见。如果使用的映射决定了我们是否可以自由选择一个点，那么，三角剖分应该如何定位新的顶点？</li>
<li>映射是纯粹的局部构造：它们只对孤立的单元起作用，而这正是有限元方法的重要特征之一。要问一条边的一个顶点是否是悬空节点，需要查询一个单元的邻域；此外，这样的查询不只是涉及到三维中一个单元的6个面的邻域，而是可能需要遍历与一条边相连的大量的其他单元。即使可以做到这一点，人们仍然需要根据邻域的样子做不同的事情，产生的代码可能非常复杂，难以维护，而且可能很慢。</li>
</ul>
<p>因此，至少在目前，这些想法都没有被实施。这导致了不连续的几何形状的不良后果，但是，正如上面所讨论的，这种影响在实际操作中似乎并不构成问题。</p>
<p class="endli"></p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2014 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Wolfgang Bangerth, Texas A&amp;M University, 2014</span></div><div class="line"><span class="comment"> *          Luca Heltai, SISSA, 2014</span></div><div class="line"><span class="comment"> *          D. Sarah Stamps, MIT, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2grid_2manifold_8h.html">deal.II/grid/manifold.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__lib_8h.html">deal.II/base/function_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filtering_stream.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/filter/gzip.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/iostreams/device/file.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step53</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>AfricaTopography</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AfricaTopography();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData&lt;2&gt;</a> topography_data;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;double&gt; get_data();</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  AfricaTopography::AfricaTopography()</div><div class="line">    : topography_data({{std::make_pair(-6.983333, 11.966667),</div><div class="line">                        std::make_pair(25, 35.95)}},</div><div class="line">                      {{379, 219}},</div><div class="line">                      <a class="code" href="classTable.html">Table&lt;2, double&gt;</a>(380, 220, get_data().begin()))</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> AfricaTopography::value(<span class="keyword">const</span> <span class="keywordtype">double</span> lon, <span class="keyword">const</span> <span class="keywordtype">double</span> lat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> topography_data.value(</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-lat * 180 / numbers::PI, lon * 180 / numbers::PI));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;double&gt; AfricaTopography::get_data()</div><div class="line">  {</div><div class="line">    std::vector&lt;double&gt; data;</div><div class="line"></div><div class="line">    boost::iostreams::filtering_istream in;</div><div class="line">    in.push(boost::iostreams::basic_gzip_decompressor&lt;&gt;());</div><div class="line">    in.push(boost::iostreams::file_source(<span class="stringliteral">&quot;topography.txt.gz&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> line = 0; line &lt; 83600; ++line)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">try</span></div><div class="line">          {</div><div class="line">            <span class="keywordtype">double</span> lat, lon, elevation;</div><div class="line">            in &gt;&gt; lat &gt;&gt; lon &gt;&gt; elevation;</div><div class="line"></div><div class="line">            data.push_back(elevation);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">catch</span> (...)</div><div class="line">          {</div><div class="line">            <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                        <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Could not read all 83,600 data points &quot;</span></div><div class="line">                                   <span class="stringliteral">&quot;from the file &lt;topography.txt.gz&gt;!&quot;</span>));</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> data;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>AfricaGeometry : <span class="keyword">public</span> <a class="code" href="classChartManifold.html">ChartManifold</a>&lt;3, 3&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; clone() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> R;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> ellipticity;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> AfricaTopography topography;</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat) <span class="keyword">const</span>;</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d) <span class="keyword">const</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::R           = 6378137;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> AfricaGeometry::ellipticity = 8.1819190842622e-2;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespacePhysics_1_1Transformations_1_1Contravariant.html#ab392343cf71c5cc20a6e5a7059d1c4f2">AfricaGeometry::pull_back</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;space_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> pull_back_topo(pull_back_wgs84(space_point));</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">AfricaGeometry::push_forward</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> push_forward_wgs84(push_forward_topo(chart_point));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  std::unique_ptr&lt;Manifold&lt;3, 3&gt;&gt; AfricaGeometry::clone()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;AfricaGeometry&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::push_forward_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> phi   = phi_theta_d[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta = phi_theta_d[1];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar = R / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - (ellipticity * ellipticity *</div><div class="line">                                            std::sin(theta) * std::sin(theta)));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {(R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::cos(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">            (R_bar + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) * std::sin(phi) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta),</div><div class="line">            ((1 - ellipticity * ellipticity) * R_bar + d) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(theta)};</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_wgs84(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;x)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(R * R * (1 - ellipticity * ellipticity));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> ep  = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>((R * R - b * b) / (b * b));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> p   = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(x(0) * x(0) + x(1) * x(1));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> th  = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(R * x(2), b * p);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(1), x(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> theta =</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(x(2) + ep * ep * b * std::pow(std::sin(th), 3),</div><div class="line">                 (p -</div><div class="line">                  (ellipticity * ellipticity * R * std::pow(std::cos(th), 3))));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_bar =</div><div class="line">      R / (<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 - ellipticity * ellipticity * std::sin(theta) *</div><div class="line">                           std::sin(theta)));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R_plus_d = p / <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(theta);</div><div class="line"></div><div class="line">    <a class="code" href="classPoint.html">Point&lt;3&gt;</a> phi_theta_d;</div><div class="line">    <span class="keywordflow">if</span> (phi &lt; 0)</div><div class="line">      phi_theta_d[0] = phi + 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (phi &gt; 2 * numbers::PI)</div><div class="line">      phi_theta_d[0] = phi - 2 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      phi_theta_d[0] = phi;</div><div class="line">    phi_theta_d[1] = theta;</div><div class="line">    phi_theta_d[2] = R_plus_d - R_bar;</div><div class="line">    <span class="keywordflow">return</span> phi_theta_d;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a></div><div class="line">  AfricaGeometry::push_forward_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d_hat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = phi_theta_d_hat[2];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h = topography.value(phi_theta_d_hat[0], phi_theta_d_hat[1]);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d = d_hat + (d_hat + 500000) / 500000 * h;</div><div class="line">    <span class="keywordflow">return</span> {phi_theta_d_hat[0], phi_theta_d_hat[1], d};</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> AfricaGeometry::pull_back_topo(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;phi_theta_d)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d     = phi_theta_d[2];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h     = topography.value(phi_theta_d[0], phi_theta_d[1]);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d_hat = 500000 * (d - h) / (500000 + h);</div><div class="line">    <span class="keywordflow">return</span> {phi_theta_d[0], phi_theta_d[1], d_hat};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">  {</div><div class="line">    AfricaGeometry   geometry;</div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> corner_points[2] = {</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(26 * numbers::PI / 180, -10 * numbers::PI / 180, -500000),</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;3&gt;</a>(35 * numbers::PI / 180, 5 * numbers::PI / 180, 0)};</div><div class="line">      std::vector&lt;unsigned int&gt; subdivisions(3);</div><div class="line">      subdivisions[0] = 1;</div><div class="line">      subdivisions[1] = 2;</div><div class="line">      subdivisions[2] = 1;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(</div><div class="line">        triangulation, subdivisions, corner_points[0], corner_points[1], <span class="keyword">true</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">        [&amp;geometry](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;chart_point) {</div><div class="line">          <span class="keywordflow">return</span> geometry.push_forward(chart_point);</div><div class="line">        },</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, geometry);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      cell-&gt;set_all_manifold_ids(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;boundary_id() == 5)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement step &quot;</span> &lt;&lt; i + 1 &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; cells, &quot;</span></div><div class="line">                  &lt;&lt; <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / 1000</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;km minimal cell diameter&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;mesh.vtu&quot;</span>;</div><div class="line">    std::ofstream     out(filename);</div><div class="line">    <a class="code" href="classGridOut.html">GridOut</a>           grid_out;</div><div class="line">    grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step53</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step53::run</a>();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
