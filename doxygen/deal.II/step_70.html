<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_70.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-70 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-70 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_19.html">step-19</a>, <a class="el" href="step_32.html">step-32</a>, <a class="el" href="step_60.html">step-60</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems">Massively parallel non-matching grid simulations of fluid structure interaction problems</a>
      <ul>
        <li><a href="#Codimensiononecase">Co-dimension one case</a>
        <li><a href="#Codimensionzerocase">Co-dimension zero case</a>
        <li><a href="#Representationofand">Representation of Ω and Γ</a>
        <li><a href="#Usingparticlestotrack">Using particles to track Γ</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#Morereferences"> More references</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Runtimeparameterhandling">Run-time parameter handling</a>
        <li><a href="#TheStokesImmersedProblemclassdeclaration">The StokesImmersedProblem class declaration</a>
        <li><a href="#TheStokesImmersedProblemclassimplementation">The StokesImmersedProblem class implementation</a>
      <ul>
        <li><a href="#Objectconstructionandmeshinitializationfunctions">Object construction and mesh initialization functions</a>
        <li><a href="#Particleinitializationfunctions">Particle initialization functions</a>
        <li><a href="#DoFinitializationfunctions">DoF initialization functions</a>
        <li><a href="#Assemblyfunctions">Assembly functions</a>
        <li><a href="#Solvingthelinearsystem">Solving the linear system</a>
        <li><a href="#Meshrefinement">Mesh refinement</a>
        <li><a href="#Creatingoutputforvisualization">Creating output for visualization</a>
        <li><a href="#Therunfunction">The "run" function</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Twodimensionaltestcase"> Two dimensional test case </a>
        <li><a href="#Threedimensionaltestcase"> Three dimensional test case </a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Luca Heltai (International School for Advanced Studies, Trieste), Bruno Blais (Polytechnique Montréal), and Rene Gassmöller (University of California Davis) </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3829064"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3829064.svg" alt="10.5281/zenodo.3829064"/></a> </dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems"></a></p><h3>Massively parallel non-matching grid simulations of fluid structure interaction problems</h3>
<p>In this tutorial we consider a mixing problem in the laminar flow regime. Such problems occur in a wide range of applications ranging from chemical engineering to power generation (e.g. turbomachinery). Mixing problems are particularly hard to solve numerically, because they often involve a container (with fixed boundaries, and possibly complex geometries such as baffles), represented by the domain \(\Omega\), and one (or more) immersed and rotating impellers (represented by the domain \(\Omega^{\text{imp}}\)). The domain in which we would like to solve the flow equations is the (time dependent) difference between the two domains, namely: \(\Omega\setminus\Omega^{\text{imp}}\).</p>
<p>For rotating impellers, the use of Arbitrary Lagrangian Eulerian formulations (in which the fluid domain &ndash; along with the mesh! &ndash; is smoothly deformed to follow the deformations of the immersed solid) is not possible, unless only small times (i.e., small fluid domain deformations) are considered. If one wants to track the evolution of the flow across multiple rotations of the impellers, the resulting deformed grid would simply be too distorted to be useful.</p>
<p>In this case, a viable alternative strategy would be to use non-matching methods (similarly to what we have done in <a class="el" href="step_60.html">step-60</a>), where a background fixed grid (that may or may not be locally refined in time to better capture the solid motion) is coupled with a rotating, independent, grid.</p>
<p>In order to maintain the same notations used in <a class="el" href="step_60.html">step-60</a>, we use \(\Omega\) to denote the domain in \({\mathbb R}^{\text{spacedim}}\) representing the container of both the fluid and the impeller, and we use \(\Gamma\) in \({\mathbb R}^{\text{dim}}\) to denote either the full impeller (when its <code>spacedim</code> measure is non-negligible, i.e., when we can represent it as a grid of dimension <code>dim</code> equal to <code>spacedim</code>), a co-dimension one representation of a thin impeller, or just the boundary of the full impeller.</p>
<p>The domain \(\Gamma\) is embedded in \(\Omega\) ( \(\Gamma \subseteq \Omega\)) and it is non-matching: It does not, in general, align with any of the features of the volume mesh. We solve a partial differential equation on \(\Omega\), enforcing some conditions on the solution of the problem on the embedded domain \(\Gamma\) by some penalization techniques. In the current case, the condition is that the velocity of the fluid at points on \(\Gamma\) equal the velocity of the solid impeller at that point.</p>
<p>The technique we describe here is presented in the literature using one of many names: the <b>immersed finite element method</b> and the <b>fictitious boundary method</b> among others. The main principle is that the discretization of the two grids are kept completely independent. In the present tutorial, this approach is used to solve for the motion of a viscous fluid, described by the Stokes equation, that is agitated by a rigid non-deformable impeller.</p>
<p>Thus, the equations solved in \(\Omega\) are the Stokes equations for a creeping flow (i.e. a flow where \(\text{Re}\rightarrow 0\)) and a no-slip boundary condition is applied on the moving <em>embedded domain</em> \(\Gamma\) associated with the impeller. However, this tutorial could be readily extended to other equations (e.g. the Navier-Stokes equations, linear elasticity equation, etc.). It can be seen as a natural extension of <a class="el" href="step_60.html">step-60</a> that enables the solution of large problems using a distributed parallel computing architecture via MPI.</p>
<p>However, contrary to <a class="el" href="step_60.html">step-60</a>, the Dirichlet boundary conditions on \(\Gamma\) are imposed weakly instead of through the use of Lagrange multipliers, and we concentrate on dealing with the coupling of two fully distributed triangulations (a combination that was not possible in the implementation of <a class="el" href="step_60.html">step-60</a>).</p>
<p>There are two interesting scenarios that occur when one wants to enforce conditions on the embedded domain \(\Gamma\):</p>
<ul>
<li>The geometrical dimension <code>dim</code> of the embedded domain \(\Gamma\) is the same of the domain \(\Omega\) (<code>spacedim</code>), that is, the spacedim-dimensional measure of \(\Gamma\) is not zero. In this case, the imposition of the Dirichlet boundary boundary condition on \(\Gamma\) is done through a volumetric penalization. If the applied penalization only depends on the velocity, this is often referred to as \(\mathcal{L}^2\) penalization whereas if the penalization depends on both the velocity and its gradient, it is an \(\mathcal{H}^1\) penalization. The case of the \(\mathcal{L}^2\) penalization is very similar to a Darcy-type approach. Both \(\mathcal{L}^2\) and \(\mathcal{H}^1\) penalizations have been analyzed extensively (see, for example, <b>[Angot1999]</b>).</li>
<li>The embedded domain \(\Gamma\) has an intrinsic dimension <code>dim</code> which is smaller than that of \(\Omega\) (<code>spacedim</code>), thus its spacedim-dimensional measure is zero; for example it is a curve embedded in a two dimensional domain, or a surface embedded in a three-dimensional domain. This is of course physically impossible, but one may consider very thin sheets of metal moving in a fluid as essentially lower-dimensional if the thickness of the sheet is negligible. In this case, the boundary condition is imposed weakly on \(\Gamma\) by applying the <a href="https://en.wikipedia.org/wiki/Joachim_Nitsche">Nitsche</a> method (see <b>[Freund1995]</b>).</li>
</ul>
<p>Both approaches have very similar requirements and result in highly similar formulations. Thus, we treat them almost in the same way.</p>
<p>In this tutorial program we are not interested in further details on \(\Gamma\): we assume that the dimension of the embedded domain (<code>dim</code>) is always smaller by one or equal with respect to the dimension of the embedding domain \(\Omega\) (<code>spacedim</code>).</p>
<p>We are going to solve the following differential problem: given a sufficiently regular function \(g\) on \(\Gamma\), find the solution \((\textbf{u},p)\) to</p>
<p class="formulaDsp">
\begin{eqnarray*} -\Delta \mathbf{u} + \nabla p &amp;=&amp; 0,\\ -\nabla \cdot \textbf{u} &amp;=&amp; 0,\\ \textbf{u} &amp;=&amp; \textbf{g} \text{ in } \Gamma,\\ \textbf{u} &amp;=&amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
<p>This equation, which we have normalized by scaling the time units in such a way that the viscosity has a numerical value of 1, describes slow, viscous flow such as honey or lava. The main goal of this tutorial is to show how to impose the velocity field condition \(\mathbf{u} = \mathbf{g}\) on a non-matching \(\Gamma\) in a weak way, using a penalization method. A more extensive discussion of the Stokes problem including body forces, different boundary conditions, and solution strategies can be found in <a class="el" href="step_22.html">step-22</a>.</p>
<p>Let us start by considering the Stokes problem alone, in the entire domain \(\Omega\). We look for a velocity field \(\mathbf{u}\) and a pressure field \(p\) that satisfy the Stokes equations with homogeneous boundary conditions on \(\partial\Omega\).</p>
<p>The weak form of the Stokes equations is obtained by first writing it in vector form as </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-\Delta \textbf{u} + \nabla p} \\ {-\textrm{div}\;\textbf{u}} \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p> forming the dot product from the left with a vector-valued test function \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\), and integrating over the domain \(\Omega\), yielding the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -\Delta \textbf{u} + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = 0 \end{eqnarray*}
</p>
<p> which has to hold for all test functions \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\).</p>
<p>Integrating by parts and exploiting the boundary conditions on \(\partial\Omega\), we obtain the following variational problem: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega}&amp;=&amp; 0 \end{eqnarray*}
</p>
<p>where \((\cdot, \cdot)_{\Omega}\) represents the \(L^2\) scalar product. This is the same variational form used in <a class="el" href="step_22.html">step-22</a>.</p>
<p>This variational formulation does not take into account the embedded domain. Contrary to <a class="el" href="step_60.html">step-60</a>, we do not enforce strongly the constraints of \(\textbf{u}\) on \(\Gamma\), but enforce them weakly via a penalization term.</p>
<p>The analysis of this weak imposition of the boundary condition depends on the spacedim-dimensional measure of \(\Gamma\) as either positive (if <code>dim</code> is equal to <code>spacedim</code>) or zero (if <code>dim</code> is smaller than <code>spacedim</code>). We discuss both scenarios.</p>
<p><a class="anchor" id="Codimensiononecase"></a></p><h4>Co-dimension one case</h4>
<p>In this case, we assume that \(\Gamma\) is the boundary of the actual impeller, that is, a closed curve embedded in a two-dimensional domain or a closed surface in a three-dimensional domain. The idea of this method starts by considering a weak imposition of the Dirichlet boundary condition on \(\Gamma\), following the Nitsche method. This is achieved by using the following modified formulation on the fluid domain, where no strong conditions on the test functions on \(\Gamma\) are imposed:</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ - (\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ - (\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} + (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} + (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>The integrals over \(\Gamma\) are lower-dimensional integrals. It can be shown (see <b>[Freund1995]</b>) that there exists a positive constant \(C_1\) so that if \(\beta &gt; C_1\), the weak imposition of the boundary will be consistent and stable. The first two additional integrals on \(\Gamma\) (the second line in the equation above) appear naturally after integrating by parts, when one does not assume that \(\mathbf{v}\) is zero on \(\Gamma\).</p>
<p>The third line in the equation above contains two terms that are added to ensure consistency of the weak form, and a stabilization term, that is there to enforce the boundary condition with an error which is consistent with the approximation error. The consistency terms and the stabilization term are added to the right hand side with the actual boundary data \(\mathbf{g}\).</p>
<p>When \(\mathbf{u}\) satisfies the condition \(\mathbf{u}=\mathbf{g}\) on \(\Gamma\), all the consistency and stability integrals on \(\Gamma\) cancel out, and one is left with the usual weak form of Stokes flow, that is, the above formulation is consistent.</p>
<p>We note that an alternative (non-symmetric) formulation can be used :</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ -(\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ +(\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} - (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} - (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p> Note the different sign of the first terms on the third and fourth lines. In this case, the stability and consistency conditions become \(\beta &gt; 0\). In the symmetric case, the value of \(\beta\) is dependent on \(h\), and it is in general chosen such that \(\beta = C h^{-1} \) with \(h\) a measure of size of the face being integrated and \(C\) a constant such that \(1 \leq C \leq 10\). This is as one usually does with the Nitsche penalty method to enforcing Dirichlet boundary conditions.</p>
<p>The non-symmetric approach, on the other hand, is related to how one enforced continuity for the non-symmetric interior penalty method for discontinuous Galerkin methods (the "NIPG" method <b>[Riviere1999]</b>). Even if the non-symmetric case seems advantageous w.r.t. possible choices of stabilization parameters, we opt for the symmetric discretization, since in this case it can be shown that the dual problem is also consistent, leading to a solution where not only the energy norm of the solution converges with the correct order, but also its \(L^2\) norm. Furthermore, the resulting matrix remains symmetric.</p>
<p>The above formulation works under the assumption that the domain is discretized exactly. However, if the deformation of the impeller is a rigid body motion, it is possible to artificially extend the solution of the Stokes problem inside the propeller itself, since a rigid body motion is also a solution to the Stokes problem. The idea is then to solve the same problem, inside \(\Omega^{\text{imp}}\), imposing the same boundary conditions on \(\Gamma\), using the same penalization technique, and testing with test functions \(\mathbf{v}\) which are globally continuous over \(\Omega\).</p>
<p>This results in the following (intermediate) formulation: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} \\ - (\textbf{v}, \lbrack \nabla \textbf{u} \rbrack \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},\lbrack p \rbrack )_{\Gamma} \\ - (\lbrack \nabla\textbf{v} \rbrack \cdot \textbf{n},\textbf{u})_{\Gamma} + (\lbrack q \rbrack, \textbf{u} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\lbrack \nabla\textbf{v}\rbrack\cdot \textbf{n},\textbf{g})_{\Gamma} + (\lbrack q\rbrack, \textbf{g} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{g})_{\Gamma}, \end{multline*}
</p>
<p> where the jump terms, denoted with \(\lbrack \cdot \rbrack\), are computed with respect to a fixed orientation of the normal vector \(\textbf{n}\). The factor of 2 appears in front of \(\beta\) since we see every part of \(\Gamma\) twice, once from within the fluid and once from within the obstacle moving around in it. (For all of the other integrals over \(\Gamma\), we visit each part of \(\Gamma\) twice, but with opposite signs, and consequently get the jump terms.)</p>
<p>Here we notice that, unlike in discontinuous Galerkin methods, the test and trial functions are continuous across \(\Gamma\). Moreover, if \(\Gamma\) is not aligned with cell boundaries, all the jump terms are also zero, since, in general, finite element function spaces are smooth inside each cell, and if \(\Gamma\) cuts through an element intersecting its boundary only at a finite number of points, all the contributions on \(\Gamma\), with the exception of the stabilization ones, can be neglected from the formulation, resulting in the following final form of the variational formulation:</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = 2\beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>In <a class="el" href="step_60.html">step-60</a>, the imposition of the constraint required the addition of new variables in the form of Lagrange multipliers. This is not the case for this tutorial program. The imposition of the boundary condition using Nitsche's method only modifies the system matrix and the right-hand side without adding additional unknowns. However, the velocity vector \(\textbf{u}\) on the embedded domain will not match exactly the prescribed velocity \(\textbf{g}\), but only up to a numerical error which is in the same order as the interpolation error of the finite element method. Furthermore, as in <a class="el" href="step_60.html">step-60</a>, we still need to integrate over the non-matching embedded grid in order to construct the boundary term necessary to impose the boundary condition over \(\Gamma\).</p>
<p><a class="anchor" id="Codimensionzerocase"></a></p><h4>Co-dimension zero case</h4>
<p>In this case, \(\Gamma\) has the same dimension, but is embedded into \(\Omega\). We can think of this as a thick object moving around in the fluid. In the case of \(\mathcal{L}^2\) penalization, the additional penalization term can be interpreted as a Darcy term within \(\Gamma\), resulting in:</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta (\textbf{v},\textbf{u})_{\Gamma} = \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Here, integrals over \(\Gamma\) are simply integrals over a part of the volume. The \(\mathcal{L}^2\) penalization thus consists in adding a volumetric term that constrains the velocity of the fluid to adhere to the velocity of the rigid body within \(\Gamma\). Also in this case, \(\beta\) must be chosen sufficiently large in order to ensure that the Dirichlet boundary condition in \(\Gamma\) is sufficiently respected, but not too high in order to maintain the proper conditioning of the system matrix.</p>
<p>A \(\mathcal{H}^1\) penalization may be constructed in a similar manner, with the addition of a viscous component to the penalization that dampens the velocity gradient within \(\Gamma\):</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta_1 (\textbf{v},\textbf{u})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{u})_{\Gamma} = \beta_1 (\textbf{v},\textbf{g})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Notice that the \(L^2\) penalization (<code>dim</code> equal to <code>spacedim</code>) and the Nitsche penalization (<code>dim</code> equal to <code>spacedim-1</code>) result in the exact same numerical implementation, thanks to the dimension independent capabilities of deal.II.</p>
<p><a class="anchor" id="Representationofand"></a></p><h4>Representation of Ω and Γ</h4>
<p>In this tutorial, both the embedded grid \(\Gamma\) and the embedding grid are described using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. These two triangulations can be built from functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace or by reading a mesh file produced with another application (e.g. GMSH, see the discussion in <a class="el" href="step_49.html">step-49</a>). This is slightly more general than what was previously done in <a class="el" href="step_60.html">step-60</a>.</p>
<p>The addition of the immersed boundary method, whether it is in the <code>dim=spacedim</code> or <code>dim&lt;spacedim</code> case, only introduces additional terms in the system matrix and the right-hand side of the system which result from the integration over \(\Gamma\). This does not modify the number of variables for which the problem must be solved. The challenge is thus related to the integrals that must be carried over \(\Gamma\).</p>
<p>As usual in finite elements we split this integral into contributions from all cells of the triangulation used to discretize \(\Gamma\), we transform the integral on \(K\) to an integral on the reference element \(\hat K\), where \(F_{K}\) is the mapping from \(\hat K\) to \(K\), and compute the integral on \(\hat K\) using a quadrature formula. For example:</p>
<p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \int_{\hat K} \hat{\textbf{u}}(\hat x) (\textbf{v} \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p>Computing this sum is non-trivial because we have to evaluate \((v_j \circ F_{K}) (\hat x_i)\). In general, if \(\Gamma\) and \(\Omega\) are not aligned, the point \(y_i = F_{K}(\hat x_i)\) is completely arbitrary with respect to \(\Omega\), and unless we figure out a way to interpolate all basis functions of \(V_h(\Omega)\) on an arbitrary point on \(\Omega\), we cannot compute the integral needed.</p>
<p>To evaluate \((v_j \circ F_{K}) (\hat x_i)\) the following steps needs to be taken (as shown in the picture below):</p>
<ul>
<li>For a given cell \(K\) in \(\Gamma\) compute the real point \(y_i \dealcoloneq F_{K} (\hat x_i)\), where \(x_i\) is one of the quadrature points used for the integral on \(K \subseteq \Gamma\). This is the easy part: <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">FEValues::quadrature_point()</a> gives us the real-space locations of all quadrature points.</li>
<li>Find the cell of \(\Omega\) in which \(y_i\) lies. We shall call this element \(T\).</li>
<li>Find the reference coordinates within \(T\) of \(y_i\). For this, we need the inverse of the mapping \(G_T\) that transforms the reference element \(\hat T\) into the element \(T\): \(\hat y_i = G^{-1}_{T} (y_i)\).</li>
<li>Evaluate the basis function \(v_j\) of the \(\Omega\) mesh at this point \(\hat y_i\). This is, again, relatively simple using <a class="el" href="classFEValues.html">FEValues</a>.</li>
</ul>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png"/>
</div>
 <p>In <a class="el" href="step_60.html">step-60</a>, the second through fourth steps above were computed by calling, in turn,</p>
<ul>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, followed by</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. We then</li>
<li>construct a custom <a class="el" href="classQuadrature.html">Quadrature</a> formula, containing the point in the reference cell and then</li>
<li>construct an <a class="el" href="classFEValues.html">FEValues</a> object, with the given quadrature formula, and initialized with the cell obtained in the first step.</li>
</ul>
<p>Although this approach could work for the present case, it does not lends itself readily to parallel simulations using distributed triangulations. Indeed, since the position of the quadrature points on the cells of the embedded domain \(\Gamma\) do not match that of the embedding triangulation and since \(\Gamma\) is constantly moving, this would require that the triangulation representing \(\Gamma\) be stored in it's entirety for all of the processors. As the number of processor and the number of cells in \(\Gamma\) increases, this leads to a severe bottleneck in terms of memory. Consequently, an alternative strategy is sought in this step.</p>
<p><a class="anchor" id="Usingparticlestotrack"></a></p><h4>Using particles to track Γ</h4>
<p>Remember that for both the penalization approach ( \(\mathcal{L}^2\) or \(\mathcal{H}^1\)) and the Nitsche method, we want to compute integrals that are approximated by the quadrature. That is, we need to compute </p><p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p> If you followed the discussion above, then you will recall that \(\textbf{u}\) and \(\textbf{v}\) are shape functions defined on the fluid mesh. The only things defined on the solid mesh are: \(F_K(\hat x_i)\), which is the location of a quadrature point on a solid cell that is part of \(\Gamma\), \(J_K\) is the determinant of its Jacobian, and \(w_i\) the corresponding quadrature weight.</p>
<p>The important part to realize is now this: \(w_i\) is a property of the quadrature formula and does not change with time. Furthermore, the Jacobian matrix of \(F_K\) itself changes as the solid obstacle moves around in the fluid, but because the solid is considered non-deforming (it only translates and rotates, but doesn't dilate), the determinant of the Jacobian remains constant. As a consequence, the product \(J_K(\hat x_i) w_i\) (which we typically denote by <code>JxW</code>) remains constant for each quadrature point. So the only thing we need keep track of are the positions \(x_i=F_K(\hat x_i)\) &ndash; but these move with the velocity of the solid domain.</p>
<p>In other words, we don't actually need to keep the solid mesh at all. All we need is the positions \(x_i(t)\) and corresponding <code>JxW</code> values. Since both of these properties are point-properties (or point-vectors) that are attached to the solid material, they can be idealized as a set of disconnected infinitesimally small "particles", which carry the required <code>JxW</code> information with the movement of the solid. deal.II has the ability to distribute and store such a set of particles in large-scale parallel computations in the form of the ParticleHandler class (for details on the implementation see <b>[GLHPW2018]</b>), and we will make use of this functionality in this tutorial.</p>
<p>Thus, the approach taken in this step is as follows:</p><ul>
<li>Create a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> for the domain \(\Gamma\);</li>
<li>Create <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> at the positions of the quadrature points on \(\Gamma\);</li>
<li>Call the <a class="el" href="classParticles_1_1ParticleHandler.html#ac4bae8e82e7a021bd4c269f0df3f8bea">Particles::ParticleHandler::insert_global_particles()</a> function, to distribute the particles across processors, <em>following the solid triangulation</em>;</li>
<li>Attach the <code>JxW</code> values as a "property" to each <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> object.</li>
</ul>
<p>This structure is relatively expensive to generate, but must only be generated once per simulation. Once the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> is generated and the required information is attached to the particle, the integrals over \(\Gamma\) can be carried out by exploiting the fact that particles are grouped cellwise inside ParticleHandler, allowing us to:</p><ul>
<li>Looping over all cells of \(\Omega\) that contain at least one particle</li>
<li>Looping over all particles in the given cell</li>
<li>Compute the integrals and fill the global matrix.</li>
</ul>
<p>Since the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can manage the exchange of particles from one processor to the other, the embedded triangulation can be moved or deformed by displacing the particles. The only constraint associated with this displacement is that particles should be displaced by a distance that is no larger than the size of one cell. That's because that is the limit to which <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can track which cell a particle that leaves its current cell now resides in.</p>
<p>Once the entire problem (the Stokes problem and the immersed boundary imposition) is assembled, the final saddle point problem is solved by an iterative solver, applied to the Schur complement \(S\) (whose construction is described, for example, in <a class="el" href="step_22.html">step-22</a>), and we construct \(S\) using <a class="el" href="classLinearOperator.html">LinearOperator</a> classes.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is a demonstration of the time-reversibility of Stokes flow. This is often illustrated in science education experiments with a Taylor-Couette flow and dye droplets that revert back to their original shape after the fluid has been displaced in a periodic manner.</p>
<p> 

<iframe width="560" height="315" src="https://www.youtube.com/embed/p08_KlTKP50" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</p>
<p>In the present problem, a very viscous fluid is agitated by the rotation of an impeller, which, in 2D, is modeled by a rectangular grid. The impeller rotates for a given number of revolutions, after which the flow is reversed such that the same number of revolutions is carried out in the opposite direction. We recall that since the Stokes equations are self-adjoint, creeping flows are reversible. Consequently, if the impeller motion is reversed in the opposite direction, the fluid should return to its original position. In the present case, this is illustrated by inserting a circle of passive tracer particles that are advected by the fluid and which return to their original position, thus demonstrating the time-reversibility of the flow.</p>
<p><a class="anchor" id="Morereferences"></a></p><h3>More references</h3>
<p>This tutorial program uses a number of techniques on imposing velocity conditions on non-matching interfaces in the interior of the fluid. For more background material, you may want to look up the following references: <b>[Freund1995]</b>, <b>[Angot1999]</b>, <b>[Glowinski1999]</b>, <b>[Boffi2008]</b>, <b>[Heltai2012]</b>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones. The switches close to the top that allow selecting between PETSc and Trilinos linear algebra capabilities are similar to the ones in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_50.html">step-50</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>LA</div><div class="line">{</div><div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div><div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div><div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div><div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">} <span class="comment">// namespace LA</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>These are the only new include files with regard to <a class="el" href="step_60.html">step-60</a>. In this tutorial, the non-matching coupling between the solid and the fluid is computed using an intermediate data structure that keeps track of how the locations of quadrature points of the solid evolve within the fluid mesh. This data structure needs to keep track of the position of the quadrature points on each cell describing the solid domain, of the quadrature weights, and possibly of the normal vector to each point, if the solid domain is of co-dimension one.</p>
<p>Deal.II offers these facilities in the <a class="el" href="namespaceParticles.html">Particles</a> namespace, through the ParticleHandler class. ParticleHandler is a class that allows you to manage a collection of particles (objects of type <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>), representing a collection of points with some attached properties (e.g., an id) floating on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. The methods and classes in the namespace <a class="el" href="namespaceParticles.html">Particles</a> allows one to easily implement Particle-In-Cell methods and particle tracing on distributed triangulations.</p>
<p>We "abuse" this data structure to store information about the location of solid quadrature points embedded in the surrounding fluid grid, including integration weights, and possibly surface normals. The reason why we use this additional data structure is related to the fact that the solid and the fluid grids might be non-overlapping, and if we were using two separate triangulation objects, would be distributed independently among parallel processes.</p>
<p>In order to couple the two problems, we rely on the ParticleHandler class, storing in each particle the position of a solid quadrature point (which is in general not aligned to any of the fluid quadrature points), its weight, and any other information that may be required to couple the two problems. These locations are then propagated along with the (prescribed) velocity of the solid impeller.</p>
<p>Ownership of the solid quadrature points is initially inherited from the MPI partitioning on the solid mesh itself. The <a class="el" href="namespaceParticles.html">Particles</a> so generated are later distributed to the fluid mesh using the methods of the ParticleHandler class. This allows transparent exchange of information between MPI processes about the overlapping pattern between fluid cells and solid quadrature points.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>When generating the grids, we allow reading it from a file, and if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support, we also allow reading CAD files and use them as manifold descriptors for the grid (see <a class="el" href="step_54.html">step-54</a> for a detailed description of the various <a class="el" href="classManifold.html">Manifold</a> descriptors that are available in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step70</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Runtimeparameterhandling"></a> </p><h3>Run-time parameter handling</h3>
<p>Similarly to what we have done in <a class="el" href="step_60.html">step-60</a>, we set up a class that holds all the parameters of our problem and derive it from the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class to simplify the management and creation of parameter files.</p>
<p>The <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> paradigm requires all parameters to be writable by the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> methods. In order to avoid bugs that would be very difficult to track down (such as writing things like <code>time = 0</code> instead of <code>time == 0</code>), we declare all the parameters in an external class, which is initialized before the actual <code>StokesImmersedProblem</code> class, and pass it to the main class as a <code>const</code> reference.</p>
<p>The constructor of the class is responsible for the connection between the members of this class and the corresponding entries in the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. Thanks to the use of the <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter()</a> method, this connection is trivial, but requires all members of this class to be writeable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesImmersedProblemParameters();</div></div><!-- fragment --><p>however, since this class will be passed as a <code>const</code> reference to the StokesImmersedProblem class, we have to make sure we can still set the time correctly in the objects derived by the <a class="el" href="classFunction.html">Function</a> class defined herein. In order to do so, we declare both the <code>StokesImmersedProblemParameters::rhs</code> and <code>StokesImmersedProblemParameters::angular_velocity</code> members to be <code>mutable</code>, and define the following little helper method that sets their time to the correct value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  rhs.set_time(time);</div><div class="line">  angular_velocity.set_time(time);</div><div class="line">}</div></div><!-- fragment --><p>The remainder of the class consists largely of member variables that describe the details of the simulation and its discretization. The following parameters are about where output should land, the spatial and temporal discretization (the default is the \(Q_2\times Q_1\) Taylor-Hood discretization which uses a polynomial degree of 2 for the velocity), and how many time steps should elapse before we generate graphical output again:</p>
<div class="fragment"><div class="line">std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div><div class="line"><span class="keywordtype">double</span>       final_time           = 1.0;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div></div><!-- fragment --><p>We allow every grid to be refined independently. In this tutorial, no physics is resolved on the solid grid, and its velocity is given as a datum. However it is relatively straightforward to incorporate some elasticity model in this tutorial, and transform it into a fully fledged FSI solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div></div><!-- fragment --><p>To provide a rough description of the fluid domain, we use the method <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> applied to the tree of bounding boxes of each locally owned cell of the fluid triangulation. The higher the level of the tree, the larger the number of extracted bounding boxes, and the more accurate is the description of the fluid domain. However, a large number of bounding boxes also implies a large communication cost, since the collection of bounding boxes is gathered by all processes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div></div><!-- fragment --><p>The only two numerical parameters used in the equations are the viscosity of the fluid, and the penalty term \(\beta\) used in the Nitsche formulation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> viscosity    = 1.0;</div><div class="line"><span class="keywordtype">double</span> penalty_term = 100;</div></div><!-- fragment --><p>By default, we create a hyper_cube without colorization, and we use homogeneous Dirichlet boundary conditions. In this set we store the boundary ids to use when setting the boundary conditions:</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div></div><!-- fragment --><p>We illustrate here another way to create a <a class="el" href="classTriangulation.html">Triangulation</a> from a parameter file, using the method <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments()</a>, that takes the name of a function in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, and its arguments as a single string representing the arguments as a tuple.</p>
<p>The mechanism with which the arguments are parsed from and to a string is explained in detail in the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class, which is used to translate from strings to most of the basic STL types (vectors, maps, tuples) and basic deal.II types (<a class="el" href="classPoint.html">Point</a>, <a class="el" href="classTensor.html">Tensor</a>, <a class="el" href="classBoundingBox.html">BoundingBox</a>, etc.).</p>
<p>In general objects that can be represented by rank 1 uniform elements (i.e., std::vector&lt;double&gt;, <a class="el" href="classPoint.html">Point&lt;dim&gt;</a>, std::set&lt;int&gt;, etc.) are comma separated. Additional ranks take a semicolon, allowing you to parse strings into objects of type <code>std::vector&lt;std::vector&lt;double&gt;&gt;</code>, or, for example, <code>std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt;&gt;</code>, as <code>0.0, 0.1; 0.1, 0.2</code>. This string could be interpreted as a vector of two <a class="el" href="classPoint.html">Point</a> objects, or a vector of vector of doubles.</p>
<p>When the entries are not uniform, as in the tuple case, we use a colon to separate the various entries. For example, a string like <code>5: 0.1, 0.2</code> could be used to parse an object of type <code>std::pair&lt;int, <a class="el" href="classPoint.html">Point</a>&lt;2&gt;&gt;</code> or a <code>std::tuple&lt;int, std::vector&lt;double&gt;&gt;</code>.</p>
<p>In our case most of the arguments are <a class="el" href="classPoint.html">Point</a> objects (representing centers, corners, subdivision elements, etc.), integer values (number of subdivisions), double values (radius, lengths, etc.), or boolean options (such as the <code>colorize</code> option that many <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions take).</p>
<p>In the example below, we set reasonable default values, but these can be changed at run time by selecting any other supported function of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. If the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function fails, this program will interpret the name of the grid as a vtk grid filename, and the arguments as a map from manifold_id to the CAD files describing the geometry of the domain. Every CAD file will be analyzed and a <a class="el" href="classManifold.html">Manifold</a> of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace will be generated according to the content of the CAD file itself.</p>
<p>To be as generic as possible, we do this for each of the generated grids: the fluid grid, the solid grid, but also the tracer particles which are also generated using a triangulation.</p>
<div class="fragment"><div class="line">std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div><div class="line">std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div><div class="line">std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div><div class="line">std::string arguments_for_solid_grid = spacedim == 2 ?</div><div class="line">                                         <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div><div class="line">                                         <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div><div class="line">std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div><div class="line">std::string arguments_for_particle_grid =</div><div class="line">  spacedim == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div></div><!-- fragment --><p>Similarly, we allow for different local refinement strategies. In particular, we limit the maximum number of refinement levels, in order to control the minimum size of the fluid grid, and guarantee that it is compatible with the solid grid. The minimum number of refinement levels is also controlled to ensured sufficient accuracy in the bulk of the flow. Additionally, we perform local refinement based on standard error estimators on the fluid velocity field.</p>
<p>We permit the user to choose between the two most common refinement strategies, namely <code>fixed_number</code> or <code>fixed_fraction</code>, that refer to the methods <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction()</a> and <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number()</a>.</p>
<p>Refinement may be done every few time steps, instead of continuously, and we control this value by the <code>refinement_frequency</code> parameter:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>          max_level_refinement = 8;</div><div class="line"><span class="keywordtype">int</span>          min_level_refinement = 5;</div><div class="line">std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div><div class="line"><span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div><div class="line"><span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div><div class="line"><span class="keywordtype">int</span>          refinement_frequency = 5;</div></div><!-- fragment --><p>Finally, the following two function objects are used to control the source term of Stokes flow and the angular velocity at which we move the solid body. In a more realistic simulation, the solid velocity or its deformation would come from the solution of an auxiliary problem on the solid domain. In this example step we leave this part aside, and simply impose a fixed rotational velocity field along the z-axis on the immersed solid, governed by a function that can be specified in the parameter file :</p>
<div class="fragment"><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; rhs;</div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">    angular_velocity;</div><div class="line">};</div></div><!-- fragment --><p>There remains the task of declaring what run-time parameters we can accept in input files. We split the parameters in various categories, by putting them in different sections of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class. We begin by declaring all the global parameters used by StokesImmersedProblem in the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">StokesImmersedProblemParameters&lt;dim,</div><div class="line">                                spacedim&gt;::StokesImmersedProblemParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div><div class="line">  , rhs(<span class="stringliteral">&quot;Right hand side&quot;</span>, spacedim + 1)</div><div class="line">  , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, final_time);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div><div class="line">                initial_fluid_refinement,</div><div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div><div class="line">                initial_solid_refinement,</div><div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div><div class="line">                fluid_rtree_extraction_level,</div><div class="line">                <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div><div class="line">                <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div><div class="line">    particle_insertion_refinement,</div><div class="line">    <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">    homogeneous_dirichlet_ids,</div><div class="line">    <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div></div><!-- fragment --><p>Next section is dedicated to the parameters used to create the various grids. We will need three different triangulations: <code>Fluid grid</code> is used to define the fluid domain, <code>Solid grid</code> defines the solid domain, and <code>Particle grid</code> is used to distribute some tracer particles, that are advected with the velocity and only used as passive tracers.</p>
<div class="fragment"><div class="line">enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div><div class="line">                arguments_for_particle_grid);</div><div class="line">}</div><div class="line">leave_subsection();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div><div class="line">                refinement_strategy,</div><div class="line">                <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">                this-&gt;prm,</div><div class="line">                <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div><div class="line">}</div><div class="line">leave_subsection();</div></div><!-- fragment --><p>The final task is to correct the default dimension for the right hand side function and define a meaningful default angular velocity instead of zero.</p>
<div class="fragment"><div class="line">  rhs.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">    <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div><div class="line">                                                            spacedim + 1);</div><div class="line">  });</div><div class="line">  angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">    this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                  <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p>Once the angular velocity is provided as a <a class="el" href="classFunction.html">Function</a> object, we reconstruct the pointwise solid velocity through the following class which derives from the <a class="el" href="classFunction.html">Function</a> class. It provides the value of the velocity of the solid body at a given position by assuming that the body rotates around the origin (or the \(z\) axis in 3d) with a given angular velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  static_assert(spacedim &gt; 1,</div><div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">  SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div><div class="line">    : angular_velocity(angular_velocity)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> velocity;</div></div><!-- fragment --><p>We assume that the angular velocity is directed along the z-axis, i.e., we model the actual angular velocity as if it was a two-dimensional rotation, irrespective of the actual value of <code>spacedim</code>.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(p);</div><div class="line">    velocity[0]        = -omega * p[1];</div><div class="line">    velocity[1]        = omega * p[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> velocity[component];</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">};</div></div><!-- fragment --><p>Similarly, we assume that the solid position can be computed explicitly at each time step, exploiting the knowledge of the angular velocity. We compute the exact position of the solid particle assuming that the solid is rotated by an amount equal to the time step multiplied by the angular velocity computed at the point <code>p</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  static_assert(spacedim &gt; 1,</div><div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">  SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;(spacedim)</div><div class="line">    , angular_velocity(angular_velocity)</div><div class="line">    , time_step(time_step)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = p;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> dtheta = angular_velocity.value(p) * time_step;</div><div class="line"></div><div class="line">    new_position[0] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[0] - <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[1];</div><div class="line">    new_position[1] = <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[0] + <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[1];</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> new_position[component];</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div><div class="line">  {</div><div class="line">    time_step = new_time_step;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">  <span class="keywordtype">double</span>                                     time_step;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassdeclaration"></a> </p><h3>The StokesImmersedProblem class declaration</h3>
<p>We are now ready to introduce the main class of our tutorial program. As usual, other than the constructor, we leave a single public entry point: the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> method. Everything else is left <code>private</code>, and accessed through the run method itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>StokesImmersedProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesImmersedProblem(</div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div></div><!-- fragment --><p>The next section contains the <code>private</code> members of the class. The first method is similar to what is present in previous example. However it not only takes care of generating the grid for the fluid, but also the grid for the solid. The second computes the largest time step that guarantees that each particle moves of at most one cell. This is important to ensure that the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can find which cell a particle ends up in, as it can only look from one cell to its immediate neighbors (because, in a parallel setting, every MPI process only knows about the cells it owns as well as their immediate neighbors).</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The next two functions initialize the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used in this class. We have two such objects: One represents passive tracers, used to plot the trajectories of fluid particles, while the the other represents material particles of the solid, which are placed at quadrature points of the solid grid.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_tracer_particles();</div><div class="line"><span class="keywordtype">void</span> setup_solid_particles();</div></div><!-- fragment --><p>The remainder of the set up is split in two parts: The first of the following two functions creates all objects that are needed once per simulation, whereas the other sets up all objects that need to be reinitialized at every refinement step.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initial_setup();</div><div class="line"><span class="keywordtype">void</span> setup_dofs();</div></div><!-- fragment --><p>The assembly routine is very similar to other Stokes assembly routines, with the exception of the Nitsche restriction part, which exploits one of the particle handlers to integrate on a non-matching part of the fluid domain, corresponding to the position of the solid. We split these two parts into two separate functions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_stokes_system();</div><div class="line"><span class="keywordtype">void</span> assemble_nitsche_restriction();</div></div><!-- fragment --><p>The remaining functions solve the linear system (which looks almost identical to the one in <a class="el" href="step_60.html">step-60</a>) and then postprocess the solution: The refine_and_transfer() method is called only every <code>refinement_frequency</code> steps to adapt the mesh and also make sure that all the fields that were computed on the time step before refinement are transferred correctly to the new grid. This includes vector fields, as well as particle information. Similarly, we call the two output methods only every <code>output_frequency</code> steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> refine_and_transfer();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle, <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">                      std::string                                 fprefix,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Let us then move on to the member functions of the class. The first deals with run-time parameters that are read from a parameter file. As noted before, we make sure we cannot modify this object from within this class, by making it a <code>const</code> reference.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div></div><!-- fragment --><p>Then there is also the MPI communicator object that we will use to let processes send information across the network if the program runs in parallel, along with the <code>pcout</code> object and timer information that has also been employed by <a class="el" href="step_40.html">step-40</a>, for example:</p>
<div class="fragment"><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line"><span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div></div><!-- fragment --><p>Next is one of the main novelties with regard to <a class="el" href="step_60.html">step-60</a>. Here we assume that both the solid and the fluid are fully distributed triangulations. This allows the problem to scale to a very large number of degrees of freedom, at the cost of communicating all the overlapping regions between non matching triangulations. This is especially tricky, since we make no assumptions on the relative position or distribution of the various subdomains of the two triangulations. In particular, we assume that every process owns only a part of the <code>solid_tria</code>, and only a part of the <code>fluid_tria</code>, not necessarily in the same physical region, and not necessarily overlapping.</p>
<p>We could in principle try to create the initial subdivisions in such a way that each process's subdomains overlap between the solid and the fluid regions. However, this overlap would be destroyed during the simulation, and we would have to redistribute the DoFs again and again. The approach we follow in this tutorial is more flexible, and not much more expensive. We make two all-to-all communications at the beginning of the simulation to exchange information about an (approximate) information of the geometrical occupancy of each processor (done through a collection of bounding boxes).</p>
<p>This information is used by the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class to exchange (using a some-to-some communication pattern) all particles, so that every process knows about the particles that live on the region occupied by the fluid subdomain that it owns.</p>
<p>In order to couple the overlapping regions, we exploit the facilities implemented in the ParticleHandler class.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div></div><!-- fragment --><p>Next come descriptions of the finite elements in use, along with appropriate quadrature formulas and the corresponding <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the current implementation, only <code>fluid_fe</code> is really necessary. For completeness, and to allow easy extension, we also keep the <code>solid_fe</code> around, which is however initialized to a <a class="el" href="classFE__Nothing.html">FE_Nothing</a> finite element space, i.e., one that has no degrees of freedom.</p>
<p>We declare both finite element spaces as <code>std::unique_ptr</code> objects rather than regular member variables, to allow their generation after <code>StokesImmersedProblemParameters</code> has been initialized. In particular, they will be initialized in the <code>initial_setup()</code> method.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div><div class="line"></div><div class="line">std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div><div class="line">std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div><div class="line"></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div><div class="line"></div><div class="line">std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div></div><!-- fragment --><p>Similarly to how things are done in <a class="el" href="step_22.html">step-22</a>, we use a block system to treat the Stokes part of the problem, and follow very closely what was done there.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div><div class="line">std::vector&lt;IndexSet&gt; solid_owned_dofs;</div><div class="line"></div><div class="line">std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div><div class="line">std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div></div><!-- fragment --><p>Using this partitioning of degrees of freedom, we can then define all of the objects necessary to describe the linear systems in question:</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> system_matrix;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> solution;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> locally_relevant_solution;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> system_rhs;</div></div><!-- fragment --><p>Let us move to the particles side of this program. There are two <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used to couple the solid with the fluid, and to describe the passive tracers. These, in many ways, play a role similar to the <a class="el" href="classDoFHandler.html">DoFHandler</a> class used in the discretization, i.e., they provide for an enumeration of particles and allow querying information about each particle.</p>
<div class="fragment"><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div></div><!-- fragment --><p>For every tracer particle, we need to compute the velocity field in its current position, and update its position using a discrete time stepping scheme. We do this using distributed linear algebra objects that store the coordinates of each particle's location or velocity. That is, these vectors have <code>tracer_particle_handler.n_global_particles() * spacedim</code> entries that we will store in a way so that parts of the vector are partitioned across all processes. (Implicitly, we here make the assumption that the <code>spacedim</code> coordinates of each particle are stored in consecutive entries of the vector.) Thus, we need to determine who the owner of each vector entry is. We set this owner to be equal to the process that generated that particle at time \(t=0\). This information is stored for every process in the <code>locally_owned_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>Once the particles have been distributed around to match the process that owns the region where the particle lives, we will need read access from that process to the corresponding velocity field. We achieve this by filling a read only velocity vector field that contains the relevant information in ghost entries. This is achieved using the <code>locally_relevant_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>, that keeps track of how things change during the simulation, i.e., it keeps track of where particles that the current process owns have ended up being, and who owns the particles that ended up in my subdomain.</p>
<p>While this is not the most efficient strategy, we keep it this way to illustrate how things would work in a real fluid-structure interaction (FSI) problem. If a particle is linked to a specific solid degree of freedom, we are not free to choose who owns it, and we have to communicate this information around. We illustrate this here, and show that the communication pattern is point-to-point, and negligible in terms of total cost of the algorithm.</p>
<p>The vectors defined based on these subdivisions are then used to store the particles velocities (read-only, with ghost entries) and their displacement (read/write, no ghost entries).</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> tracer_particle_velocities;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div></div><!-- fragment --><p>One of the key points of this tutorial program is the coupling between two independent <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, one of which may be moving and deforming (with possibly large deformations) with respect to the other. When both the fluid and the solid triangulations are of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, every process has access only to its fraction of locally owned cells of each of the two triangulations. As mentioned above, in general, the locally owned domains are not overlapping.</p>
<p>In order to allow for the efficient exchange of information between non-overlapping <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, some algorithms of the library require the user to provide a rough description of the area occupied by the locally owned part of the triangulation, in the form of a collection of axis-aligned bounding boxes for each process, that provide a full covering of the locally owned part of the domain. This kind of information can then be used in situations where one needs to send information to the owner of the cell surrounding a known location, without knowing who that owner may in fact be. But, if one knows a collection of bounding boxes for the geometric area or volume each process owns, then we can determine a subset of all processes that might possibly own the cell in which that location lies: namely, all of those processes whose bounding boxes contain that point. Instead of sending the information associated to that location to all processes, one can then get away with only sending it to a small subset of the processes with point-to-point communication primitives. (You will notice that this also allows for the typical time-vs-memory trade-off: The more data we are willing to store about each process's owned area &ndash; in the form of more refined bounding box information &ndash; the less communication we have to perform.)</p>
<p>We construct this information by gathering a vector (of length <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>) of vectors of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects. We fill this vector using the <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function, and allow the user to select what level of the tree to extract. The "level" corresponds to how coarse/fine the overlap of the area with bounding boxes should be.</p>
<p>As an example, this is what would be extracted by the <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function applied to a two dimensional hyper ball, distributed over three processes. Each image shows in green the bounding boxes associated to the locally owned cells of the triangulation on each process, and in violet the bounding boxes extracted from the rtree:</p>
<div class="image">
<img src="rtree-process-0.png" alt="rtree-process-0.png"/>
</div>
 <div class="image">
<img src="rtree-process-1.png" alt="rtree-process-1.png"/>
</div>
 <div class="image">
<img src="rtree-process-2.png" alt="rtree-process-2.png"/>
</div>
<p>We store these boxes in a global member variable, which is updated at every refinement step:</p>
<div class="fragment"><div class="line">  std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassimplementation"></a> </p><h3>The StokesImmersedProblem class implementation</h3>
<p><a class="anchor" id="Objectconstructionandmeshinitializationfunctions"></a> </p><h4>Object construction and mesh initialization functions</h4>
<p>In the constructor, we create the mpi_communicator as well as the triangulations and dof_handler for both the fluid and the solid. Using the mpi_communicator, both the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and <a class="el" href="classTimerOutput.html">TimerOutput</a> object are constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div><div class="line">  <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div><div class="line">  : par(par)</div><div class="line">  , mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">          (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">  , computing_timer(mpi_communicator,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  , fluid_tria(mpi_communicator,</div><div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::MeshSmoothing(</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_refinement |</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_coarsening))</div><div class="line">  , solid_tria(mpi_communicator,</div><div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::MeshSmoothing(</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_refinement |</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_coarsening))</div><div class="line">  , fluid_dh(fluid_tria)</div><div class="line">  , solid_dh(solid_tria)</div><div class="line">{}</div></div><!-- fragment --><p>In order to generate the grid, we first try to use the functions in the deal.II <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, by leveraging the GridGenerator::generate_from_name_and_argument(). If this function fails, then we use the following method, where the name is interpreted as a filename, and the arguments are interpreted as a map from manifold ids to CAD files, and are converted to <a class="el" href="classManifold.html">Manifold</a> descriptors using the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace facilities. At the top, we read the file into a triangulation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> read_grid_and_cad_files(<span class="keyword">const</span> std::string &amp;grid_file_name,</div><div class="line">                             <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div><div class="line">                             <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div><div class="line">{</div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div><div class="line">  grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">  grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div></div><!-- fragment --><p>If we got to this point, then the <a class="el" href="classTriangulation.html">Triangulation</a> has been read, and we are ready to attach to it the correct manifold descriptions. We perform the next lines of code only if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support. For each entry in the map, we try to open the corresponding CAD file, we analyze it, and according to its content, opt for either a OpenCASCADE::ArcLengthProjectionLineManifold (if the CAD file contains a single <code>TopoDS_Edge</code> or a single <code>TopoDS_Wire</code>) or a <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>, if the file contains a single face. Notice that if the CAD files do not contain single wires, edges, or faces, an assertion will be throw in the generation of the <a class="el" href="classManifold.html">Manifold</a>.</p>
<p>We use the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class to do the conversion from the string to a map between manifold ids and file names for us:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div><div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="namespacePatterns_1_1Tools.html#a59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>   = pair.first;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> extension = boost::algorithm::to_lower_copy(</div><div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div><div class="line"></div><div class="line">        TopoDS_Shape shape;</div><div class="line">        <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;iges&quot;</span> || extension == <span class="stringliteral">&quot;igs&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;step&quot;</span> || extension == <span class="stringliteral">&quot;stp&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div></div><!-- fragment --><p>Now we check how many faces are contained in the <code>Shape</code>. <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> is intrinsically 3D, so if this number is zero, we interpret this as a line manifold, otherwise as a <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> in <code>spacedim</code> = 3, or <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a> in <code>spacedim</code> = 2.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n_elements = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div><div class="line"><span class="keywordflow">if</span> ((std::get&lt;0&gt;(n_elements) == 0))</div><div class="line">  tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div><div class="line">    <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (spacedim == 3)</div><div class="line">  {</div></div><!-- fragment --><p>We use this trick, because <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> is only implemented for spacedim = 3. The check above makes sure that things actually work correctly.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div><div class="line">    t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                    <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div><div class="line">                      shape));</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div></div><!-- fragment --><p>We also allow surface descriptions in two dimensional spaces based on single NURBS patches. For this to work, the CAD file must contain a single <code>TopoDS_Face</code>.</p>
<div class="fragment"><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div><div class="line">                              TopoDS::Face(shape)));</div><div class="line">      }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    (void)ids_and_cad_file_names;</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">  }</span></div></div><!-- fragment --><p>Now let's put things together, and make all the necessary grids. As mentioned above, we first try to generate the grid internally, and if we fail (i.e., if we end up in the <code>catch</code> clause), then we proceed with the above function.</p>
<p>We repeat this pattern for both the fluid and the solid mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">        fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div><div class="line">      read_grid_and_cad_files(par.name_of_fluid_grid,</div><div class="line">                              par.arguments_for_fluid_grid,</div><div class="line">                              fluid_tria);</div><div class="line">    }</div><div class="line">  fluid_tria.refine_global(par.initial_fluid_refinement);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">        solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      read_grid_and_cad_files(par.name_of_solid_grid,</div><div class="line">                              par.arguments_for_solid_grid,</div><div class="line">                              solid_tria);</div><div class="line">    }</div><div class="line"></div><div class="line">  solid_tria.refine_global(par.initial_solid_refinement);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Particleinitializationfunctions"></a> </p><h4>Particle initialization functions</h4>
<p>Once the solid and fluid grids have been created, we start filling the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects. The first one we take care of is the one we use to keep track of passive tracers in the fluid. These are simply transported along, and in some sense their locations are unimportant: We just want to use them to see where flow is being transported. We could use any way we choose to determine where they are initially located. A convenient one is to create the initial locations as the vertices of a mesh in a shape of our choice &ndash; a choice determined by one of the run-time parameters in the parameter file.</p>
<p>In this implementation, we create tracers using the support points of a <a class="el" href="classFE__Q.html">FE_Q</a> finite element space defined on a temporary grid, which is then discarded. Of this grid, we only keep around the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects (stored in a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class) associated to the support points.</p>
<p>The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class offers the possibility to insert a set of particles that live physically in the part of the domain owned by the active process. However, in this case this function would not suffice. The particles generated as the locally owned support points of an <a class="el" href="classFE__Q.html">FE_Q</a> object on an arbitrary grid (non-matching with regard to the fluid grid) have no reasons to lie in the same physical region of the locally owned subdomain of the fluid grid. In fact this will almost never be the case, especially since we want to keep track of what is happening to the particles themselves.</p>
<p>In particle-in-cell methods (PIC), it is often customary to assign ownership of the particles to the process where the particles lie. In this tutorial we illustrate a different approach, which is useful if one wants to keep track of information related to the particles (for example, if a particle is associated to a given degree of freedom, which is owned by a specific process and not necessarily the same process that owns the fluid cell where the particle happens to be at any given time). In the approach used here, ownership of the particles is assigned once at the beginning, and one-to-one communication happens whenever the original owner needs information from the process that owns the cell where the particle lives. We make sure that we set ownership of the particles using the initial particle distribution, and keep the same ownership throughout the execution of the program.</p>
<p>With this overview out of the way, let us see what the function does. At the top, we create a temporary triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object from which we will take the node locations for initial particle locations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div><div class="line">{</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div><div class="line">    mpi_communicator);</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">    particle_insert_tria,</div><div class="line">    par.name_of_particle_grid,</div><div class="line">    par.arguments_for_particle_grid);</div><div class="line">  particle_insert_tria.refine_global(par.particle_insertion_refinement);</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div><div class="line">  particles_dof_handler.distribute_dofs(particles_fe);</div></div><!-- fragment --><p>This is where things start to get complicated. Since we may run this program in a parallel environment, every parallel process will now have created these temporary triangulations and DoFHandlers. But, in fully distributed triangulations, the active process only knows about the locally owned cells, and has no idea of how other processes have distributed their own cells. This is true for both the temporary triangulation created above as well as the fluid triangulation into which we want to embed the particles below. On the other hand, these locally known portions of the two triangulations will, in general, not overlap. That is, the locations of the particles we will create from the node locations of the temporary mesh are arbitrary, and may fall within a region of the fluid triangulation that the current process doesn't have access to (i.e., a region of the fluid domain where cells are artificial). In order to understand who to send those particles to, we need to have a (rough) idea of how the fluid grid is distributed among processors.</p>
<p>We construct this information by first building an index tree of boxes bounding the locally owned cells, and then extracting one of the first levels of the tree:</p>
<div class="fragment"><div class="line">std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div><div class="line">all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    all_boxes.emplace_back(cell-&gt;bounding_box());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div><div class="line">  <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, par.fluid_rtree_extraction_level);</div></div><!-- fragment --><p>Each process now has a collection of bounding boxes that completely enclose all locally owned processes (but that may overlap the bounding boxes of other processes). We then exchange this information between all participating processes so that every process knows the bounding boxes of all other processes.</p>
<p>Equipped with this knowledge, we can then initialize the <code>tracer_particle_handler</code> to the fluid mesh and generate the particles from the support points of the (temporary) tracer particles triangulation. This function call uses the <code>global_bounding_boxes</code> object we just constructed to figure out where to send the particles whose locations were derived from the locally owned part of the <code>particles_dof_handler</code>. At the end of this call, every particle will have been distributed to the correct process (i.e., the process that owns the fluid cell where the particle lives). We also output their number to the screen at this point.</p>
<div class="fragment"><div class="line">global_fluid_bounding_boxes =</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div><div class="line"></div><div class="line">tracer_particle_handler.initialize(fluid_tria,</div><div class="line">                                   <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div><div class="line"></div><div class="line"><a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div><div class="line">                                          global_fluid_bounding_boxes,</div><div class="line">                                          tracer_particle_handler);</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div><div class="line">      &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Each particle so created has a unique ID. At some point in the algorithm below, we will need vectors containing position and velocity information for each particle. This vector will have size <code>n_particles * spacedim</code>, and we will have to store the elements of this vector in a way so that each parallel process "owns" those elements that correspond to coordinates of the particles it owns. In other words, we have to partition the index space between zero and <code>n_particles * spacedim</code> among all processes. We can do this by querying the <code>tracer_particle_handler</code> for the IDs of its locally relevant particles, and construct the indices that would be needed to store in a (parallel distributed) vector of the position and velocity of all particles where we implicitly assume that we store the coordinates of each location or velocity in <code>spacedim</code> successive vector elements (this is what the IndexSet::tensor_priduct() function does).</p>
<div class="fragment"><div class="line">locally_owned_tracer_particle_coordinates =</div><div class="line">  tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">    <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div></div><!-- fragment --><p>At the beginning of the simulation, all particles are in their original position. When particles move, they may traverse to a part of the domain which is owned by another process. If this happens, the current process keeps formally "ownership" of the particles, but may need read access from the process where the particle has landed. We keep this information in another index set, which stores the indices of all particles that are currently on the current process's subdomain, independently if they have always been here or not.</p>
<p>Keeping this index set around allows us to leverage linear algebra classes for all communications regarding positions and velocities of the particles. This mimics what would happen in the case where another problem was solved in the solid domain (as in fluid-structure interaction. In this latter case, additional DOFs on the solid domain would be coupled to what is occurring in the fluid domain.</p>
<div class="fragment"><div class="line">locally_relevant_tracer_particle_coordinates =</div><div class="line">  locally_owned_tracer_particle_coordinates;</div></div><!-- fragment --><p>Finally, we make sure that upon refinement, particles are correctly transferred. When performing local refinement or coarsening, particles will land in another cell. We could in principle redistribute all particles after refining, however this would be overly expensive.</p>
<p>The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class has a way to transfer information from a cell to its children or to its parent upon refinement, without the need to reconstruct the entire data structure. This is done by registering two callback functions to the triangulation. These functions will receive a signal when refinement is about to happen, and when it has just happened, and will take care of transferring all information to the newly refined grid with minimal computational cost.</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">    [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">  fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div><div class="line">    tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p>Similarly to what we have done for passive tracers, we next set up the particles that track the quadrature points of the solid mesh. The main difference here is that we also want to attach a weight value (the "JxW" value of the quadrature point) to each of particle, so that we can compute integrals even without direct access to the original solid grid.</p>
<p>This is achieved by leveraging the "properties" concept of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> class. It is possible to store (in a memory efficient way) an arbitrary number of <code>double</code> numbers for each of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects inside a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> object. We use this possibility to store the JxW values of the quadrature points of the solid grid.</p>
<p>In our case, we only need to store one property per particle: the JxW value of the integration on the solid grid. This is passed at construction time to the solid_particle_handler object as the last argument</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(fluid_fe-&gt;degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div><div class="line">  solid_particle_handler.initialize(fluid_tria,</div><div class="line">                                    <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div><div class="line">                                    n_properties);</div></div><!-- fragment --><p>The number of particles that we generate locally is equal to the total number of locally owned cells times the number of quadrature points used in each cell. We store all these points in a vector, and their corresponding properties in a vector of vectors:</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div><div class="line">quadrature_points_vec.reserve(quadrature.size() *</div><div class="line">                              solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; properties;</div><div class="line">properties.reserve(quadrature.size() *</div><div class="line">                   solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div><div class="line">                             quadrature,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : solid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      fe_v.reinit(cell);</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; points.size(); ++q)</div><div class="line">        {</div><div class="line">          quadrature_points_vec.emplace_back(points[q]);</div><div class="line">          properties.emplace_back(</div><div class="line">            std::vector&lt;double&gt;(n_properties, JxW[q]));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>We proceed in the same way we did with the tracer particles, reusing the computed bounding boxes. However, we first check that the <code>global_fluid_bounding_boxes</code> object has been actually filled. This should certainly be the case here, since this method is called after the one that initializes the tracer particles. However, we want to make sure that if in the future someone decides (for whatever reason) to initialize first the solid particle handler, or to copy just this part of the tutorial, a meaningful exception is thrown when things don't work as expected</p>
<p>Since we have already stored the position of the quadrature points, we can use these positions to insert the particles directly using the <code>solid_particle_handler</code> instead of having to go through a <a class="el" href="namespaceParticles_1_1Generators.html">Particles::Generators</a> function:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div><div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div><div class="line">         <span class="stringliteral">&quot;I was expecting the &quot;</span></div><div class="line">         <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div><div class="line">         <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div><div class="line">         <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">solid_particle_handler.insert_global_particles(quadrature_points_vec,</div><div class="line">                                               global_fluid_bounding_boxes,</div><div class="line">                                               properties);</div></div><!-- fragment --><p>As in the previous function, we end by making sure that upon refinement, particles are correctly transferred:</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">    [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">  fluid_tria.signals.post_distributed_refinement.connect(</div><div class="line">    [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DoFinitializationfunctions"></a> </p><h4>DoF initialization functions</h4>
<p>We set up the finite element space and the quadrature formula to be used throughout the step. For the fluid, we use Taylor-Hood elements (e.g. \(Q_k \times Q_{k-1}\)). Since we do not solve any equation on the solid domain, an empty finite element space is generated. A natural extension of this program would be to solve a fluid structure interaction problem, which would require that the <code>solid_fe</code> use more useful <a class="el" href="classFiniteElement.html">FiniteElement</a> class.</p>
<p>Like for many other functions, we store the time necessary to carry out the operations we perform here. The current function puts its timing information into a section with label "Initial setup". Numerous other calls to this timer are made in various functions. They allow to monitor the absolute and relative cost of each individual function to identify bottlenecks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div><div class="line"></div><div class="line">  fluid_fe =</div><div class="line">    std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div><div class="line">                                         spacedim,</div><div class="line">                                         <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div><div class="line">                                                        1),</div><div class="line">                                         1);</div><div class="line"></div><div class="line"></div><div class="line">  solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div><div class="line">  solid_dh.distribute_dofs(*solid_fe);</div><div class="line"></div><div class="line">  fluid_quadrature_formula =</div><div class="line">    std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">  solid_quadrature_formula =</div><div class="line">    std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">}</div></div><!-- fragment --><p>We next construct the distributed block matrices and vectors which are used to solve the linear equations that arise from the problem. This function is adapted from <a class="el" href="step_55.html">step-55</a> and we refer to this step for a thorough explanation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div><div class="line"></div><div class="line">  fluid_dh.distribute_dofs(*fluid_fe);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0);</div><div class="line">  stokes_sub_blocks[spacedim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">        &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div><div class="line">        &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div><div class="line">        &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  fluid_owned_dofs.resize(2);</div><div class="line">  fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div><div class="line">  fluid_owned_dofs[1] =</div><div class="line">    fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div><div class="line">  fluid_relevant_dofs.resize(2);</div><div class="line">  fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div><div class="line">  fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.reinit(locally_relevant_dofs);</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      fluid_dh,</div><div class="line">      0,</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(spacedim + 1),</div><div class="line">      constraints,</div><div class="line">      fluid_fe-&gt;component_mask(velocities));</div><div class="line">    constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator,</div><div class="line">                               fluid_dh.locally_owned_dofs());</div><div class="line">  {</div><div class="line">    system_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == spacedim || d == spacedim || c == d)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">      dsp,</div><div class="line">      locally_owned_dofs_per_processor,</div><div class="line">      mpi_communicator,</div><div class="line">      locally_relevant_dofs);</div><div class="line"></div><div class="line">    system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">      dsp,</div><div class="line">      locally_owned_dofs_per_processor,</div><div class="line">      mpi_communicator,</div><div class="line">      locally_relevant_dofs);</div><div class="line">    preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line">  locally_relevant_solution.reinit(fluid_owned_dofs,</div><div class="line">                                   fluid_relevant_dofs,</div><div class="line">                                   mpi_communicator);</div><div class="line">  system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">  solution.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyfunctions"></a> </p><h4>Assembly functions</h4>
<p>We assemble the system matrix, the preconditioner matrix, and the right hand side. The code is adapted from <a class="el" href="step_55.html">step-55</a>, which is essentially what <a class="el" href="step_27.html">step-27</a> also has, and is pretty standard if you know what the Stokes equations look like.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  system_matrix         = 0;</div><div class="line">  preconditioner_matrix = 0;</div><div class="line">  system_rhs            = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div><div class="line">                               *fluid_quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fluid_quadrature_formula-&gt;size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points,</div><div class="line">                                         Vector&lt;double&gt;(spacedim + 1));</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;              div_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;              phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure(spacedim);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_matrix  = 0;</div><div class="line">        cell_matrix2 = 0;</div><div class="line">        cell_rhs     = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        par.rhs.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                  rhs_values);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_u[k] = fe_values[velocities].gradient(k, q);</div><div class="line">                div_phi_u[k]  = fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]      = fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (par.viscosity *</div><div class="line">                         <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) -</div><div class="line">                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">                    cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *</div><div class="line">                                          phi_p[j] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                  fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">                               rhs_values[q](component_i) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix2,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               preconditioner_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">  system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>The following method is then the one that deals with the penalty terms that result from imposing the velocity on the impeller. It is, in a sense, the heart of the tutorial, but it is relatively straightforward. Here we exploit the <code>solid_particle_handler</code> to compute the Nitsche restriction or the penalization in the embedded domain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);</div><div class="line"></div><div class="line">  SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div><div class="line">    fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div><div class="line">                                  fluid_fe-&gt;n_dofs_per_cell());</div><div class="line">  <a class="code" href="classVector.html">::Vector&lt;double&gt;</a> local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div><div class="line">    1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div></div><!-- fragment --><p>We loop over all the local particles. Although this could be achieved directly by looping over all the cells, this would force us to loop over numerous cells which do not contain particles. Consequently, we loop over all the particles, but, we get the reference of the cell in which the particle lies and then loop over all particles within that cell. This enables us to skip the cells which do not contain particles, yet to assemble the local matrix and rhs of each cell to apply the Nitsche restriction. Once we are done with all particles on one cell, we advance the <code>particle</code> iterator to the particle past the end of the ones on the current cell (this is the last line of the <code>while</code> loop's body).</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> particle = solid_particle_handler.begin();</div><div class="line"><span class="keywordflow">while</span> (particle != solid_particle_handler.end())</div><div class="line">  {</div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs    = 0;</div></div><!-- fragment --><p>We get an iterator to the cell within which the particle lies from the particle itself. We can then assemble the additional terms in the system matrix and the right hand side as we would normally.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*cell, &amp;fluid_dh);</div><div class="line">dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div></div><!-- fragment --><p>So then let us get the collection of cells that are located on this cell and iterate over them. From each particle we gather the location and the reference location of the particle as well as the additional information that is attached to the particle. In the present case, this information is the "JxW" of the quadrature points which were used to generate the particles.</p>
<p>Using this information, we can add the contribution of the quadrature point to the local_matrix and local_rhs. We can evaluate the value of the shape function at the position of each particle easily by using its reference location.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(cell);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == particle, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pic)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = p.get_reference_location();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = p.get_location();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = p.get_properties()[0];</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fluid_fe-&gt;n_dofs_per_cell(); ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div><div class="line">                fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">              <span class="keywordflow">if</span> (comp_i &lt; spacedim)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div><div class="line">                        fluid_fe-&gt;system_to_component_index(j).first;</div><div class="line">                      <span class="keywordflow">if</span> (comp_i == comp_j)</div><div class="line">                        local_matrix(i, j) +=</div><div class="line">                          penalty_parameter * par.penalty_term *</div><div class="line">                          fluid_fe-&gt;shape_value(i, ref_q) *</div><div class="line">                          fluid_fe-&gt;shape_value(j, ref_q) * JxW;</div><div class="line">                    }</div><div class="line">                  local_rhs(i) += penalty_parameter * par.penalty_term *</div><div class="line">                                  solid_velocity.value(real_q, comp_i) *</div><div class="line">                                  fluid_fe-&gt;shape_value(i, ref_q) * JxW;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                             local_rhs,</div><div class="line">                                             fluid_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">      particle = pic.end();</div><div class="line">    }</div><div class="line"></div><div class="line">  system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solvingthelinearsystem"></a> </p><h4>Solving the linear system</h4>
<p>This function solves the linear system with FGMRES with a block diagonal preconditioner and an algebraic multigrid (AMG) method for the diagonal blocks. The preconditioner applies a V cycle to the \((0,0)\) (i.e., the velocity-velocity) block and a CG with the mass matrix for the \((1,1)\) block (which is our approximation to the Schur complement: the pressure mass matrix assembled above).</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_A;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_A.initialize(system_matrix.block(0, 0), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_S;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_S.initialize(preconditioner_matrix.block(1, 1), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, prec_A);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div><div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(S, prec_S);</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div><div class="line">                                          1e-8 * system_rhs.l2_norm(),</div><div class="line">                                          1.e-2);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div><div class="line">      std::array&lt;</div><div class="line">        <a class="code" href="classLinearOperator.html">::LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;</a>,</div><div class="line">        2&gt;{{amgA, amgS}});</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div><div class="line">                                 1e-10 * system_rhs.l2_norm());</div><div class="line"></div><div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">    constraints.set_zero(solution);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, P);</div><div class="line"></div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    locally_relevant_solution = solution;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div><div class="line">      VectorTools::compute_mean_value(fluid_dh,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div><div class="line">                                      locally_relevant_solution,</div><div class="line">                                      spacedim);</div><div class="line">    solution.block(1).add(-mean_pressure);</div><div class="line">    locally_relevant_solution.block(1) = solution.block(1);</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="Meshrefinement"></a> </p><h4>Mesh refinement</h4>
<p>We deal with mesh refinement in a completely standard way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell(fluid_tria.n_active_cells());</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div><div class="line">                                            par.velocity_degree + 1),</div><div class="line">                                          {},</div><div class="line">                                          locally_relevant_solution,</div><div class="line">                                          error_per_cell,</div><div class="line">                                          fluid_fe-&gt;component_mask(velocity));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">        refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div><div class="line">                                          error_per_cell,</div><div class="line">                                          par.refinement_fraction,</div><div class="line">                                          par.coarsening_fraction);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">        fluid_tria,</div><div class="line">        error_per_cell,</div><div class="line">        par.refinement_fraction,</div><div class="line">        par.coarsening_fraction,</div><div class="line">        par.max_cells);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;refine_flag_set() &amp;&amp;</div><div class="line">          cell-&gt;level() == par.max_level_refinement)</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;coarsen_flag_set() &amp;&amp;</div><div class="line">          cell-&gt;level() == par.min_level_refinement)</div><div class="line">        cell-&gt;clear_coarsen_flag();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div><div class="line">    transfer(fluid_dh);</div><div class="line">  fluid_tria.prepare_coarsening_and_refinement();</div><div class="line">  transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div><div class="line">  fluid_tria.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  transfer.interpolate(solution);</div><div class="line">  constraints.distribute(solution);</div><div class="line">  locally_relevant_solution = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingoutputforvisualization"></a> </p><h4>Creating output for visualization</h4>
<p>We output the results (velocity and pressure) on the fluid domain using the standard parallel capabilities of deal.II. A single compressed vtu file is written that agglomerates the information of all processors. An additional <code>.pvd</code> record is written to associate the physical time to the vtu files.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle,</div><div class="line">                                                     <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_names(spacedim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      spacedim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(fluid_dh);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(locally_relevant_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(fluid_tria.n_active_cells());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">    subdomain(i) = fluid_tria.locally_owned_subdomain();</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                 mpi_communicator);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line">  times_and_names.push_back(std::make_pair(time, filename));</div><div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div><div class="line">}</div></div><!-- fragment --><p>Similarly, we write the particles (either from the solid or the tracers) as a single compressed vtu file through the <a class="el" href="classParticles_1_1DataOut.html">Particles::DataOut</a> object. This simple object does not write the additional information attached as "properties" to the particles, but only writes their id &ndash; but then, we don't care about the "JxW" values of these particle locations anyway, so no information that we may have wanted to visualize is lost.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">  std::string                                 fprefix,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div><div class="line">  particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(particles);</div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  particles_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                      mpi_communicator);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div><div class="line">    times_and_names;</div><div class="line">  <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div><div class="line">    times_and_names[fprefix].push_back(std::make_pair(time, filename));</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    times_and_names[fprefix] = {std::make_pair(time, filename)};</div><div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunction"></a> </p><h4>The "run" function</h4>
<p>This function now orchestrates the entire simulation. It is very similar to the other time dependent tutorial programs &ndash; take <a class="el" href="step_21.html">step-21</a> or <a class="el" href="step_26.html">step-26</a> as an example. At the beginning, we output some status information and also save all current parameters to a file in the output directory, for reproducibility.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div><div class="line">                               <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) +</div><div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div><div class="line">                             <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a>);</div></div><!-- fragment --><p>We then start the time loop. We initialize all the elements of the simulation in the first cycle</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div><div class="line"><span class="keywordtype">double</span>       time         = 0;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; par.number_of_time_steps;</div><div class="line">     ++cycle, time += time_step)</div><div class="line">  {</div><div class="line">    par.set_time(time);</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">      {</div><div class="line">        make_grid();</div><div class="line">        initial_setup();</div><div class="line">        setup_dofs();</div><div class="line">        setup_tracer_particles();</div><div class="line">        setup_solid_particles();</div><div class="line">        tracer_particle_velocities.reinit(</div><div class="line">          locally_owned_tracer_particle_coordinates, mpi_communicator);</div><div class="line">        output_results(output_cycle, time);</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">          output_particles(tracer_particle_handler,</div><div class="line">                           <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                           output_cycle,</div><div class="line">                           time);</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">          output_particles(solid_particle_handler,</div><div class="line">                           <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                           output_cycle,</div><div class="line">                           time);</div><div class="line">        }</div><div class="line">      }</div></div><!-- fragment --><p>After the first time step, we displace the solid body at the beginning of each time step to take into account the fact that is has moved.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div><div class="line">                         <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div><div class="line"></div><div class="line">    SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div><div class="line">                                           time_step);</div><div class="line">    solid_particle_handler.set_particle_positions(solid_position,</div><div class="line">                                                  <span class="keyword">false</span>);</div><div class="line">  }</div></div><!-- fragment --><p>In order to update the state of the system, we first interpolate the fluid velocity at the position of the tracer particles and, with a naive explicit Euler scheme, advect the massless tracer particles.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div><div class="line">  <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div><div class="line">    fluid_dh,</div><div class="line">    tracer_particle_handler,</div><div class="line">    locally_relevant_solution,</div><div class="line">    tracer_particle_velocities,</div><div class="line">    fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div><div class="line"></div><div class="line">  tracer_particle_velocities *= time_step;</div><div class="line"></div><div class="line">  locally_relevant_tracer_particle_coordinates =</div><div class="line">    tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">      <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">  relevant_tracer_particle_displacements.reinit(</div><div class="line">    locally_owned_tracer_particle_coordinates,</div><div class="line">    locally_relevant_tracer_particle_coordinates,</div><div class="line">    mpi_communicator);</div><div class="line"></div><div class="line">  relevant_tracer_particle_displacements = tracer_particle_velocities;</div><div class="line"></div><div class="line">  tracer_particle_handler.set_particle_positions(</div><div class="line">    relevant_tracer_particle_displacements);</div><div class="line">}</div></div><!-- fragment --><p>Using these new locations, we can then assemble the Stokes system and solve it.</p>
<div class="fragment"><div class="line">assemble_stokes_system();</div><div class="line">assemble_nitsche_restriction();</div><div class="line">solve();</div></div><!-- fragment --><p>With the appropriate frequencies, we then write the information of the solid particles, the tracer particles, and the fluid domain into files for visualization, and end the time step by adapting the mesh.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (cycle % par.output_frequency == 0)</div><div class="line">          {</div><div class="line">            output_results(output_cycle, time);</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">              output_particles(tracer_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">              output_particles(solid_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            ++output_cycle;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cycle % par.refinement_frequency == 0 &amp;&amp;</div><div class="line">            cycle != par.number_of_time_steps - 1)</div><div class="line">          refine_and_transfer();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step70</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The remainder of the code, the <code>main()</code> function, is standard, with the exception of the handling of input parameter files. We allow the user to specify an optional parameter file as an argument to the program. If nothing is specified, we use the default file "parameters.prm", which is created if non existent. The file name is scanned for the the string "23" first, and "3" afterwards. If the filename contains the string "23", the problem classes are instantiated with template arguments 2 and 3 respectively. If only the string "3" is found, then both template arguments are set to 3, otherwise both are set to 2.</p>
<p>If the program is called without any command line arguments (i.e., <code>argc==1</code>), then we just use "parameters.prm" by default.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step70;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2, 3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2, 3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The directory in which this program is run contains a number of sample parameter files that you can use to reproduce the results presented in this section. If you do not specify a parameter file as an argument on the command line, the program will try to read the file "`parameters.prm`" by default, and will execute the two dimensional version of the code. As explained in the discussion of the source code, if your file name contains the string "23", then the program will run a three dimensional problem, with immersed solid of co-dimension one. If it contains the string "3", it will run a three dimensional problem, with immersed solid of co-dimension zero, otherwise it will run a two dimensional problem with immersed solid of co-dimension zero.</p>
<p>Regardless of the specific parameter file name, if the specified file does not exist, when you execute the program you will get an exception that no such file can be found:</p>
<div class="fragment"><div class="line">----------------------------------------------------</div><div class="line">Exception on processing:</div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;74&gt; of file &lt;../source/base/parameter_acceptor.cc&gt; in <span class="keyword">function</span></div><div class="line">    <span class="keyword">static</span> void ::ParameterAcceptor::initialize(<span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>, ::<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;)</div><div class="line">The violated condition was:</div><div class="line">    <span class="keyword">false</span></div><div class="line">Additional information:</div><div class="line">    You specified &lt;parameters.prm&gt; as input parameter file, but it does not exist. We created it <span class="keywordflow">for</span> you.</div><div class="line">--------------------------------------------------------</div><div class="line"></div><div class="line">Aborting!</div><div class="line">----------------------------------------------------</div></div><!-- fragment --><p>However, as the error message already states, the code that triggers the exception will also generate the specified file ("`parameters.prm`" in this case) that simply contains the default values for all parameters this program cares about (for the correct dimension and co-dimension, according to the whether a string "23" or "3" is contained in the file name). By inspection of the default parameter file, we see the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line">subsection Stokes Immersed Problem</div><div class="line">  <span class="keyword">set</span> Final time                            = 1</div><div class="line"><span class="preprocessor">  # Extraction level of the rtree used to construct global bounding boxes</span></div><div class="line">  <span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line"></div><div class="line"><span class="preprocessor">  # Boundary Ids over which homogeneous Dirichlet boundary conditions are</span></div><div class="line"><span class="preprocessor">  # applied</span></div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line"></div><div class="line"><span class="preprocessor">  # Initial mesh refinement used for the fluid domain Omega</span></div><div class="line">  <span class="keyword">set</span> Initial fluid refinement              = 5</div><div class="line"></div><div class="line"><span class="preprocessor">  # Initial mesh refinement used for the solid domain Gamma</span></div><div class="line">  <span class="keyword">set</span> Initial solid refinement              = 5</div><div class="line">  <span class="keyword">set</span> Nitsche penalty term                  = 100</div><div class="line">  <span class="keyword">set</span> Number of time steps                  = 501</div><div class="line">  <span class="keyword">set</span> Output directory                      = .</div><div class="line">  <span class="keyword">set</span> Output frequency                      = 1</div><div class="line"></div><div class="line"><span class="preprocessor">  # Refinement of the volumetric mesh used to insert the particles</span></div><div class="line">  <span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line">  <span class="keyword">set</span> Velocity degree                       = 2</div><div class="line">  <span class="keyword">set</span> Viscosity                             = 1</div><div class="line"></div><div class="line"></div><div class="line">  subsection Angular velocity</div><div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div><div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="preprocessor">    # components by a semicolon.</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 : -6.283185 # <span class="keywordflow">default</span>: 0</div><div class="line"></div><div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div><div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor">    # your function expression.</span></div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line"></div><div class="line">  subsection Grid generation</div><div class="line">    <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div><div class="line">    <span class="keyword">set</span> Fluid grid generator arguments    = -1: 1: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line">    <span class="keyword">set</span> Particle grid generator arguments = 0.3, 0.3: 0.1: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Solid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line">    <span class="keyword">set</span> Solid grid generator arguments    = -.5, -.1: .5, .1: <span class="keyword">false</span></div><div class="line">  end</div><div class="line"></div><div class="line">  subsection Refinement and remeshing</div><div class="line">    <span class="keyword">set</span> Maximum number of cells        = 20000</div><div class="line">    <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement maximal level       = 8</div><div class="line">    <span class="keyword">set</span> Refinement minimal level       = 5</div><div class="line">    <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line">    <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">  end</div><div class="line"></div><div class="line">  subsection Right hand side</div><div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div><div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="preprocessor">    # components by a semicolon.</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0</div><div class="line"></div><div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div><div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor">    # your function expression.</span></div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line"></div><div class="line">end</div></div><!-- fragment --><p>If you now run the program, you will get a file called <code>parameters_22.prm</code> in the directory specified by the parameter <code>Output directory</code> (which defaults to the current directory) containing a shorter version of the above parameters (without comments and documentation), documenting all parameters that were used to run your program:</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line">  <span class="keyword">set</span> Final time                            = 1</div><div class="line">  <span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line">  <span class="keyword">set</span> Initial fluid refinement              = 5</div><div class="line">  <span class="keyword">set</span> Initial solid refinement              = 5</div><div class="line">  <span class="keyword">set</span> Nitsche penalty term                  = 100</div><div class="line">  <span class="keyword">set</span> Number of time steps                  = 501</div><div class="line">  <span class="keyword">set</span> Output directory                      = .</div><div class="line">  <span class="keyword">set</span> Output frequency                      = 1</div><div class="line">  <span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line">  <span class="keyword">set</span> Velocity degree                       = 2</div><div class="line">  <span class="keyword">set</span> Viscosity                             = 1</div><div class="line">  subsection Angular velocity</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 : -6.283185</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Grid generation</div><div class="line">    <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div><div class="line">    <span class="keyword">set</span> Fluid grid generator arguments    = -1: 1: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line">    <span class="keyword">set</span> Particle grid generator arguments = 0.3, 0.3: 0.1: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Solid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line">    <span class="keyword">set</span> Solid grid generator arguments    = -.5, -.1: .5, .1: <span class="keyword">false</span></div><div class="line">  end</div><div class="line">  subsection Refinement and remeshing</div><div class="line">    <span class="keyword">set</span> Maximum number of cells        = 20000</div><div class="line">    <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement maximal level       = 8</div><div class="line">    <span class="keyword">set</span> Refinement minimal level       = 5</div><div class="line">    <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line">    <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">  end</div><div class="line">  subsection Right hand side</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>The rationale behind creating first <code>parameters.prm</code> file (the first time the program is run) and then a <code>output/parameters_22.prm</code> (every time you run the program with an existing input file), is because you may want to leave most parameters to their default values, and only modify a handful of them, while still beeing able to reproduce the results and inspect what parameters were used for a specific simulation. It is generally good scientific practice to store the parameter file you used for a simulation along with the simulation output so that you can repeat the exact same run at a later time if necessary.</p>
<p>Another reason is because the input file may only contain those parameters that differ from their defaults. For example, you could use the following (perfectly valid) parameter file with this tutorial program: </p><div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line">  <span class="keyword">set</span> Final time                         = 1</div><div class="line">  <span class="keyword">set</span> Nitsche penalty term               = 10</div><div class="line">  <span class="keyword">set</span> Number of time steps               = 101</div><div class="line">  <span class="keyword">set</span> Velocity degree                    = 3</div><div class="line">end</div></div><!-- fragment --><p> and you would run the program with Q3/Q2 Taylor-Hood finite elements, for 101 steps, using a Nitsche penalty of <code>10</code>, and leaving all the other parameters to their default value. The output directory then contains a record of not just these parameters, but indeed all parameters used in the simulation. You can inspect all the other parameters in the produced file <code>parameters_22.prm</code>.</p>
<p><a class="anchor" id="Twodimensionaltestcase"></a></p><h3>Two dimensional test case </h3>
<p>The default problem generates a co-dimension zero impeller, consisting of a rotating rectangular grid, where the rotation is for half a time unit in one direction, and half a time unit in the opposite direction, with constant angular velocity equal to \(\approx 2\pi \frac{\text{rad}}{\text{time unit}}\). Consequently, the impeller does half a rotation and returns to its original position. The following animation displays the velocity magnitude, the motion of the solid impeller and of the tracer particles.</p>
<div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-70.2d_tracing.gif" width="500"/>
</div>
 </div> <p>On one core, the output of the program will look like the following:</p>
<div class="fragment"><div class="line">bash@f$ mpirun -np 1 ./step-70 test.prm</div><div class="line">Running StokesImmersedProblem&lt;2&gt; <span class="keyword">using</span> Trilinos.</div><div class="line">Cycle 0:</div><div class="line">Time : 0, time step: 0.002</div><div class="line">   Number of degrees of freedom: 9539 (8450+1089 -- 0+0)</div><div class="line">Tracer particles: 337</div><div class="line">Solid particles: 9216</div><div class="line">   Solved in 158 iterations.</div><div class="line">   Number of degrees of freedom: 9845 (8722+1123 -- 9216+337)</div><div class="line">Cycle 1:</div><div class="line">Time : 0.002, time step: 0.002</div><div class="line">   Solved in 142 iterations.</div><div class="line">Cycle 2:</div><div class="line">Time : 0.004, time step: 0.002</div><div class="line">   Solved in 121 iterations.</div><div class="line">Cycle 3:</div><div class="line">Time : 0.006, time step: 0.002</div><div class="line">   Solved in 121 iterations.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Cycle 499:</div><div class="line">Time : 0.998, time step: 0.002</div><div class="line">   Solved in 199 iterations.</div><div class="line">Cycle 500:</div><div class="line">Time : 1, time step: 0.002</div><div class="line">   Solved in 196 iterations.</div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |       302s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble Nitsche terms          |       501 |      43.3s |        14% |</div><div class="line">| Assemble Stokes terms           |       501 |      21.5s |       7.1% |</div><div class="line">| Initial setup                   |         1 |  0.000792s |         0% |</div><div class="line">| Output fluid                    |       502 |      31.8s |        11% |</div><div class="line">| Output solid particles          |       502 |      32.2s |        11% |</div><div class="line">| Output tracer particles         |       502 |      0.61s |       0.2% |</div><div class="line">| Refine                          |       100 |      4.68s |       1.5% |</div><div class="line">| Set solid particle position     |       500 |      3.34s |       1.1% |</div><div class="line">| Set tracer particle motion      |       501 |     0.729s |      0.24% |</div><div class="line">| Setup dofs                      |       101 |       2.2s |      0.73% |</div><div class="line">| Solve                           |       501 |       164s |        54% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>You may notice that assembling the coupling system is more expensive than assembling the Stokes part. This depends highly on the number of Gauss points (solid particles) that are used to apply the Nitsche restriction. In the present case, a relatively low number of tracer particles are used. Consequently, tracking their motion is relatively cheap.</p>
<p>The following movie shows the evolution of the solution over time:</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/y4Gypj2jpXw"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p>The movie shows the rotating obstacle in gray (actually a superposition of the solid particles plotted with large enough dots that they overlap), <a href="https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines">streamlines of the fluid flow</a> in light colors (including the corner vertices that form at specific times during the simulation), and the tracer particles in bluish tones.</p>
<p>The simulation shows that at the end time, the tracer particles have somewhat returned to their original position, although they have been distorted by the flow field. The following image compares the initial and the final position of the particles after one time unit of flow.</p>
<div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-70.tracer_comparison.png" width="500"/>
</div>
 </div> <p>In this case, we see that the tracer particles that were outside of the swept volume of the impeller have returned very close to their initial position, whereas those in the swept volume were slightly more deformed. This deformation is non-physical. It is caused by the numerical error induced by the explicit Euler scheme used to advect the particles, by the loss of accuracy due to the fictitious domain and, finally, by the discretization error on the Stokes equations. The first two errors are the leading cause of this deformation and they could be alleviated by the use of a finer mesh and a lower time step.</p>
<p><a class="anchor" id="Threedimensionaltestcase"></a></p><h3>Three dimensional test case </h3>
<p>To play around a little bit, we complicate the fictitious domain (taken from <a href="https://grabcad.com/library/lungstors-blower-1">https://grabcad.com/library/lungstors-blower-1</a>), and run a co-dimension one simulation in three space dimensions, using the following "`parameters_23.prm`" file :</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line">  <span class="keyword">set</span> Final time                            = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line">  <span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line">  <span class="keyword">set</span> Initial fluid refinement              = 3</div><div class="line">  <span class="keyword">set</span> Initial solid refinement              = 0</div><div class="line">  <span class="keyword">set</span> Nitsche penalty term                  = 10</div><div class="line">  <span class="keyword">set</span> Number of time steps                  = 101</div><div class="line">  <span class="keyword">set</span> Output frequency                      = 1</div><div class="line">  <span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line">  <span class="keyword">set</span> Velocity degree                       = 2</div><div class="line">  <span class="keyword">set</span> Viscosity                             = 1</div><div class="line">  subsection Angular velocity</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 5 : -5</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,z,t</div><div class="line">  end</div><div class="line">  subsection Grid generation</div><div class="line">    <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line">    <span class="keyword">set</span> Fluid grid generator arguments    = -50,-50, -10: 50, 50, 40: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Solid grid generator              = impeller.vtk</div><div class="line">    <span class="keyword">set</span> Solid grid generator arguments    = 1:impeller.step</div><div class="line">    <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line">    <span class="keyword">set</span> Particle grid generator arguments = 30, 30, 20: 10: <span class="keyword">false</span></div><div class="line">  end</div><div class="line">  subsection Refinement and remeshing</div><div class="line">    <span class="keyword">set</span> Maximum number of cells        = 100000</div><div class="line">    <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement maximal level       = 6</div><div class="line">    <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line">    <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">  end</div><div class="line">  subsection Right hand side</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0; 0</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,z,t</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>In this case, the timing outputs are a bit different:</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |  5.54e+03s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble Nitsche terms          |       101 |       111s |         2% |</div><div class="line">| Assemble Stokes terms           |       101 |       208s |       3.8% |</div><div class="line">| Initial setup                   |         1 |   0.00187s |         0% |</div><div class="line">| Output fluid                    |       102 |      15.5s |      0.28% |</div><div class="line">| Output solid particles          |       102 |      2.63s |         0% |</div><div class="line">| Output tracer particles         |       102 |      2.49s |         0% |</div><div class="line">| Refine                          |        20 |      18.4s |      0.33% |</div><div class="line">| Set solid particle position     |       100 |       6.1s |      0.11% |</div><div class="line">| Set tracer particle motion      |       101 |      10.8s |       0.2% |</div><div class="line">| Setup dofs                      |        21 |      13.9s |      0.25% |</div><div class="line">| Solve                           |       101 |  5.16e+03s |        93% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>Now, the solver is taking most of the solution time in three dimensions, and the particle motion and Nitsche assembly remain relatively unimportant as far as run time is concerned.</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Srwq7zyR9mg"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>The current tutorial program shows a one-way coupling between the fluid and the solid, where the solid motion is imposed (and not solved for), and read in the solid domain by exploiting the location and the weights of the solid quadrature points.</p>
<p>The structure of the code already allows one to implement a two-way coupling, by exploiting the possibility to read values of the fluid velocity on the quadrature points of the solid grid. For this to be more efficient in terms of MPI communication patterns, one should maintain ownership of the quadrature points on the solid processor that owns the cells where they have been created. In the current code, it is sufficient to define the <a class="el" href="classIndexSet.html">IndexSet</a> of the vectors used to exchange information of the quadrature points by using the solid partition instead of the initial fluid partition.</p>
<p>This allows the combination of the technique used in this tutorial program with those presented in the tutorial <a class="el" href="step_60.html">step-60</a> to solve a fluid structure interaction problem with distributed Lagrange multipliers, on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects.</p>
<p>The timings above show that the current preconditioning strategy does not work well for Nitsche penalization, and we should come up with a better preconditioner if we want to aim at larger problems. Moreover, a checkpoint restart strategy should be implemented to allow for longer simulations to be interrupted and restored, as it is done for example in the <a class="el" href="step_69.html">step-69</a> tutorial.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2020 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Luca Heltai, Bruno Blais, Rene Gassmoeller, 2020</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>LA</div><div class="line">{</div><div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div><div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div><div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div><div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">} <span class="comment">// namespace LA</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step70</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesImmersedProblemParameters();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      rhs.set_time(time);</div><div class="line">      angular_velocity.set_time(time);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div><div class="line">    <span class="keywordtype">double</span>       final_time           = 1.0;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> viscosity    = 1.0;</div><div class="line">    <span class="keywordtype">double</span> penalty_term = 100;</div><div class="line"></div><div class="line">    std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div><div class="line"></div><div class="line">    std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div><div class="line">    std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div><div class="line">    std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div><div class="line">    std::string arguments_for_solid_grid = spacedim == 2 ?</div><div class="line">                                             <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div><div class="line">                                             <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div><div class="line">    std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div><div class="line">    std::string arguments_for_particle_grid =</div><div class="line">      spacedim == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span>          max_level_refinement = 8;</div><div class="line">    <span class="keywordtype">int</span>          min_level_refinement = 5;</div><div class="line">    std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div><div class="line">    <span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div><div class="line">    <span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div><div class="line">    <span class="keywordtype">int</span>          refinement_frequency = 5;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; rhs;</div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      angular_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  StokesImmersedProblemParameters&lt;dim,</div><div class="line">                                  spacedim&gt;::StokesImmersedProblemParameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div><div class="line">    , rhs(<span class="stringliteral">&quot;Right hand side&quot;</span>, spacedim + 1)</div><div class="line">    , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, final_time);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div><div class="line">                  initial_fluid_refinement,</div><div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div><div class="line">                  initial_solid_refinement,</div><div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div><div class="line">                  fluid_rtree_extraction_level,</div><div class="line">                  <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div><div class="line">      particle_insertion_refinement,</div><div class="line">      <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">      homogeneous_dirichlet_ids,</div><div class="line">      <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div><div class="line"></div><div class="line">    enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div><div class="line">                    arguments_for_particle_grid);</div><div class="line">    }</div><div class="line">    leave_subsection();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div><div class="line">                    refinement_strategy,</div><div class="line">                    <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">                    this-&gt;prm,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div><div class="line">    }</div><div class="line">    leave_subsection();</div><div class="line"></div><div class="line">    rhs.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div><div class="line">                                                              spacedim + 1);</div><div class="line">    });</div><div class="line">    angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">      this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    static_assert(spacedim &gt; 1,</div><div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">    SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div><div class="line">      : angular_velocity(angular_velocity)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> velocity;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(p);</div><div class="line">      velocity[0]        = -omega * p[1];</div><div class="line">      velocity[1]        = omega * p[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> velocity[component];</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    static_assert(spacedim &gt; 1,</div><div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">    SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;(spacedim)</div><div class="line">      , angular_velocity(angular_velocity)</div><div class="line">      , time_step(time_step)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = p;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> dtheta = angular_velocity.value(p) * time_step;</div><div class="line"></div><div class="line">      new_position[0] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[0] - <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[1];</div><div class="line">      new_position[1] = <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[0] + <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[1];</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> new_position[component];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div><div class="line">    {</div><div class="line">      time_step = new_time_step;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">    <span class="keywordtype">double</span>                                     time_step;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesImmersedProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesImmersedProblem(</div><div class="line">      <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_tracer_particles();</div><div class="line">    <span class="keywordtype">void</span> setup_solid_particles();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> initial_setup();</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_stokes_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_nitsche_restriction();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_and_transfer();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle, <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">                          std::string                                 fprefix,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div><div class="line"></div><div class="line">    <a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div><div class="line">    std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div><div class="line">    std::vector&lt;IndexSet&gt; solid_owned_dofs;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div><div class="line">    std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> system_matrix;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> solution;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> locally_relevant_solution;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div><div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> tracer_particle_velocities;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div><div class="line">    : par(par)</div><div class="line">    , mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">            (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">    , computing_timer(mpi_communicator,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">    , fluid_tria(mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::MeshSmoothing(</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_refinement |</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_coarsening))</div><div class="line">    , solid_tria(mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::MeshSmoothing(</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_refinement |</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_coarsening))</div><div class="line">    , fluid_dh(fluid_tria)</div><div class="line">    , solid_dh(solid_tria)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> read_grid_and_cad_files(<span class="keyword">const</span> std::string &amp;grid_file_name,</div><div class="line">                               <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div><div class="line">                               <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div><div class="line">  {</div><div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div><div class="line">    grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">    grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div><div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="namespacePatterns_1_1Tools.html#a59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>   = pair.first;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> extension = boost::algorithm::to_lower_copy(</div><div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div><div class="line"></div><div class="line">        TopoDS_Shape shape;</div><div class="line">        <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;iges&quot;</span> || extension == <span class="stringliteral">&quot;igs&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;step&quot;</span> || extension == <span class="stringliteral">&quot;stp&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> n_elements = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div><div class="line">        <span class="keywordflow">if</span> ((std::get&lt;0&gt;(n_elements) == 0))</div><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div><div class="line">            <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (spacedim == 3)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div><div class="line">            t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                            <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div><div class="line">                              shape));</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div><div class="line">                              TopoDS::Face(shape)));</div><div class="line">      }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    (void)ids_and_cad_file_names;</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        read_grid_and_cad_files(par.name_of_fluid_grid,</div><div class="line">                                par.arguments_for_fluid_grid,</div><div class="line">                                fluid_tria);</div><div class="line">      }</div><div class="line">    fluid_tria.refine_global(par.initial_fluid_refinement);</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">      {</div><div class="line">        read_grid_and_cad_files(par.name_of_solid_grid,</div><div class="line">                                par.arguments_for_solid_grid,</div><div class="line">                                solid_tria);</div><div class="line">      }</div><div class="line"></div><div class="line">    solid_tria.refine_global(par.initial_solid_refinement);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div><div class="line">  {</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div><div class="line">      mpi_communicator);</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">      particle_insert_tria,</div><div class="line">      par.name_of_particle_grid,</div><div class="line">      par.arguments_for_particle_grid);</div><div class="line">    particle_insert_tria.refine_global(par.particle_insertion_refinement);</div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div><div class="line">    particles_dof_handler.distribute_dofs(particles_fe);</div><div class="line"></div><div class="line">    std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div><div class="line">    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        all_boxes.emplace_back(cell-&gt;bounding_box());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div><div class="line">      <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, par.fluid_rtree_extraction_level);</div><div class="line"></div><div class="line">    global_fluid_bounding_boxes =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div><div class="line"></div><div class="line">    tracer_particle_handler.initialize(fluid_tria,</div><div class="line">                                       <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div><div class="line">                                              global_fluid_bounding_boxes,</div><div class="line">                                              tracer_particle_handler);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div><div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    locally_owned_tracer_particle_coordinates =</div><div class="line">      tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">        <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">    locally_relevant_tracer_particle_coordinates =</div><div class="line">      locally_owned_tracer_particle_coordinates;</div><div class="line"></div><div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">      [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">    fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div><div class="line">      tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(fluid_fe-&gt;degree + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div><div class="line">    solid_particle_handler.initialize(fluid_tria,</div><div class="line">                                      <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div><div class="line">                                      n_properties);</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div><div class="line">    quadrature_points_vec.reserve(quadrature.size() *</div><div class="line">                                  solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;double&gt;&gt; properties;</div><div class="line">    properties.reserve(quadrature.size() *</div><div class="line">                       solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div><div class="line">                                 quadrature,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : solid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_v.reinit(cell);</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; points.size(); ++q)</div><div class="line">            {</div><div class="line">              quadrature_points_vec.emplace_back(points[q]);</div><div class="line">              properties.emplace_back(</div><div class="line">                std::vector&lt;double&gt;(n_properties, JxW[q]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div><div class="line">             <span class="stringliteral">&quot;I was expecting the &quot;</span></div><div class="line">             <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div><div class="line">             <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div><div class="line">             <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">    solid_particle_handler.insert_global_particles(quadrature_points_vec,</div><div class="line">                                                   global_fluid_bounding_boxes,</div><div class="line">                                                   properties);</div><div class="line"></div><div class="line"></div><div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">      [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">    fluid_tria.signals.post_distributed_refinement.connect(</div><div class="line">      [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div><div class="line"></div><div class="line">    fluid_fe =</div><div class="line">      std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div><div class="line">                                           spacedim,</div><div class="line">                                           <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div><div class="line">                                                          1),</div><div class="line">                                           1);</div><div class="line"></div><div class="line"></div><div class="line">    solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div><div class="line">    solid_dh.distribute_dofs(*solid_fe);</div><div class="line"></div><div class="line">    fluid_quadrature_formula =</div><div class="line">      std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">    solid_quadrature_formula =</div><div class="line">      std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div><div class="line"></div><div class="line">    fluid_dh.distribute_dofs(*fluid_fe);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0);</div><div class="line">    stokes_sub_blocks[spacedim] = 1;</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">          &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div><div class="line">          &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div><div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    fluid_owned_dofs.resize(2);</div><div class="line">    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div><div class="line">    fluid_owned_dofs[1] =</div><div class="line">      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div><div class="line">    fluid_relevant_dofs.resize(2);</div><div class="line">    fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div><div class="line">    fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.reinit(locally_relevant_dofs);</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        fluid_dh,</div><div class="line">        0,</div><div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(spacedim + 1),</div><div class="line">        constraints,</div><div class="line">        fluid_fe-&gt;component_mask(velocities));</div><div class="line">      constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator,</div><div class="line">                                 fluid_dh.locally_owned_dofs());</div><div class="line">    {</div><div class="line">      system_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == spacedim || d == spacedim || c == d)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">        dsp,</div><div class="line">        locally_owned_dofs_per_processor,</div><div class="line">        mpi_communicator,</div><div class="line">        locally_relevant_dofs);</div><div class="line"></div><div class="line">      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">        dsp,</div><div class="line">        locally_owned_dofs_per_processor,</div><div class="line">        mpi_communicator,</div><div class="line">        locally_relevant_dofs);</div><div class="line">      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">    }</div><div class="line"></div><div class="line">    locally_relevant_solution.reinit(fluid_owned_dofs,</div><div class="line">                                     fluid_relevant_dofs,</div><div class="line">                                     mpi_communicator);</div><div class="line">    system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">    solution.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div><div class="line">  {</div><div class="line">    system_matrix         = 0;</div><div class="line">    preconditioner_matrix = 0;</div><div class="line">    system_rhs            = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div><div class="line">                                 *fluid_quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fluid_quadrature_formula-&gt;size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points,</div><div class="line">                                           Vector&lt;double&gt;(spacedim + 1));</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;              div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;              phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure(spacedim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell_matrix  = 0;</div><div class="line">          cell_matrix2 = 0;</div><div class="line">          cell_rhs     = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          par.rhs.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    rhs_values);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                {</div><div class="line">                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);</div><div class="line">                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);</div><div class="line">                  phi_p[k]      = fe_values[pressure].value(k, q);</div><div class="line">                }</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        (par.viscosity *</div><div class="line">                           <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) -</div><div class="line">                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">                      cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *</div><div class="line">                                            phi_p[j] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                    }</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                    fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                  cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">                                 rhs_values[q](component_i) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 system_matrix,</div><div class="line">                                                 system_rhs);</div><div class="line"></div><div class="line">          constraints.distribute_local_to_global(cell_matrix2,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 preconditioner_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);</div><div class="line"></div><div class="line">    SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div><div class="line">      fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div><div class="line">                                    fluid_fe-&gt;n_dofs_per_cell());</div><div class="line">    ::Vector&lt;double&gt; local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div><div class="line">      1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> particle = solid_particle_handler.begin();</div><div class="line">    <span class="keywordflow">while</span> (particle != solid_particle_handler.end())</div><div class="line">      {</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*cell, &amp;fluid_dh);</div><div class="line">        dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(cell);</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == particle, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pic)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = p.get_reference_location();</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = p.get_location();</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = p.get_properties()[0];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fluid_fe-&gt;n_dofs_per_cell(); ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div><div class="line">                  fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                <span class="keywordflow">if</span> (comp_i &lt; spacedim)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">                         ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div><div class="line">                          fluid_fe-&gt;system_to_component_index(j).first;</div><div class="line">                        <span class="keywordflow">if</span> (comp_i == comp_j)</div><div class="line">                          local_matrix(i, j) +=</div><div class="line">                            penalty_parameter * par.penalty_term *</div><div class="line">                            fluid_fe-&gt;shape_value(i, ref_q) *</div><div class="line">                            fluid_fe-&gt;shape_value(j, ref_q) * JxW;</div><div class="line">                      }</div><div class="line">                    local_rhs(i) += penalty_parameter * par.penalty_term *</div><div class="line">                                    solid_velocity.value(real_q, comp_i) *</div><div class="line">                                    fluid_fe-&gt;shape_value(i, ref_q) * JxW;</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               fluid_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line">        particle = pic.end();</div><div class="line">      }</div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_A;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_A.initialize(system_matrix.block(0, 0), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_S;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_S.initialize(preconditioner_matrix.block(1, 1), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, prec_A);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div><div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(S, prec_S);</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div><div class="line">                                          1e-8 * system_rhs.l2_norm(),</div><div class="line">                                          1.e-2);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div><div class="line">      std::array&lt;</div><div class="line">        ::LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;,</div><div class="line">        2&gt;{{amgA, amgS}});</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div><div class="line">                                 1e-10 * system_rhs.l2_norm());</div><div class="line"></div><div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">    constraints.set_zero(solution);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, P);</div><div class="line"></div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    locally_relevant_solution = solution;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div><div class="line">      VectorTools::compute_mean_value(fluid_dh,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div><div class="line">                                      locally_relevant_solution,</div><div class="line">                                      spacedim);</div><div class="line">    solution.block(1).add(-mean_pressure);</div><div class="line">    locally_relevant_solution.block(1) = solution.block(1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; error_per_cell(fluid_tria.n_active_cells());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div><div class="line">                                              par.velocity_degree + 1),</div><div class="line">                                            {},</div><div class="line">                                            locally_relevant_solution,</div><div class="line">                                            error_per_cell,</div><div class="line">                                            fluid_fe-&gt;component_mask(velocity));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">          refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div><div class="line">                                            error_per_cell,</div><div class="line">                                            par.refinement_fraction,</div><div class="line">                                            par.coarsening_fraction);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">          fluid_tria,</div><div class="line">          error_per_cell,</div><div class="line">          par.refinement_fraction,</div><div class="line">          par.coarsening_fraction,</div><div class="line">          par.max_cells);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;refine_flag_set() &amp;&amp;</div><div class="line">            cell-&gt;level() == par.max_level_refinement)</div><div class="line">          cell-&gt;clear_refine_flag();</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;coarsen_flag_set() &amp;&amp;</div><div class="line">            cell-&gt;level() == par.min_level_refinement)</div><div class="line">          cell-&gt;clear_coarsen_flag();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div><div class="line">      transfer(fluid_dh);</div><div class="line">    fluid_tria.prepare_coarsening_and_refinement();</div><div class="line">    transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div><div class="line">    fluid_tria.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    transfer.interpolate(solution);</div><div class="line">    constraints.distribute(solution);</div><div class="line">    locally_relevant_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle,</div><div class="line">                                                       <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names(spacedim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        spacedim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(fluid_dh);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(locally_relevant_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(fluid_tria.n_active_cells());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      subdomain(i) = fluid_tria.locally_owned_subdomain();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                   mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line">    times_and_names.push_back(std::make_pair(time, filename));</div><div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">    std::string                                 fprefix,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div><div class="line">    particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(particles);</div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    particles_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                        mpi_communicator);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div><div class="line">      times_and_names;</div><div class="line">    <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div><div class="line">      times_and_names[fprefix].push_back(std::make_pair(time, filename));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      times_and_names[fprefix] = {std::make_pair(time, filename)};</div><div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div><div class="line">                               <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) +</div><div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div><div class="line">                             <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div><div class="line">    <span class="keywordtype">double</span>       time         = 0;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; par.number_of_time_steps;</div><div class="line">         ++cycle, time += time_step)</div><div class="line">      {</div><div class="line">        par.set_time(time);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            make_grid();</div><div class="line">            initial_setup();</div><div class="line">            setup_dofs();</div><div class="line">            setup_tracer_particles();</div><div class="line">            setup_solid_particles();</div><div class="line">            tracer_particle_velocities.reinit(</div><div class="line">              locally_owned_tracer_particle_coordinates, mpi_communicator);</div><div class="line">            output_results(output_cycle, time);</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">              output_particles(tracer_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">              output_particles(solid_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div><div class="line">                                 <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div><div class="line"></div><div class="line">            SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div><div class="line">                                                   time_step);</div><div class="line">            solid_particle_handler.set_particle_positions(solid_position,</div><div class="line">                                                          <span class="keyword">false</span>);</div><div class="line">          }</div><div class="line"></div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div><div class="line">          <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div><div class="line">            fluid_dh,</div><div class="line">            tracer_particle_handler,</div><div class="line">            locally_relevant_solution,</div><div class="line">            tracer_particle_velocities,</div><div class="line">            fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div><div class="line"></div><div class="line">          tracer_particle_velocities *= time_step;</div><div class="line"></div><div class="line">          locally_relevant_tracer_particle_coordinates =</div><div class="line">            tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">              <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">          relevant_tracer_particle_displacements.reinit(</div><div class="line">            locally_owned_tracer_particle_coordinates,</div><div class="line">            locally_relevant_tracer_particle_coordinates,</div><div class="line">            mpi_communicator);</div><div class="line"></div><div class="line">          relevant_tracer_particle_displacements = tracer_particle_velocities;</div><div class="line"></div><div class="line">          tracer_particle_handler.set_particle_positions(</div><div class="line">            relevant_tracer_particle_displacements);</div><div class="line">        }</div><div class="line"></div><div class="line">        assemble_stokes_system();</div><div class="line">        assemble_nitsche_restriction();</div><div class="line">        solve();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle % par.output_frequency == 0)</div><div class="line">          {</div><div class="line">            output_results(output_cycle, time);</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">              output_particles(tracer_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">              output_particles(solid_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            ++output_cycle;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cycle % par.refinement_frequency == 0 &amp;&amp;</div><div class="line">            cycle != par.number_of_time_steps - 1)</div><div class="line">          refine_and_transfer();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step70</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step70;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2, 3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2, 3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_19.html">step-19</a> , <a class="el" href="step_32.html">step-32</a> , <a class="el" href="step_60.html">step-60</a> . 
 <table class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a
 href="#Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems">Massively
 parallel non-matching grid simulations of fluid structure interaction
 problems</a><a
 href="#Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems">Massively
 parallel non-matching grid simulations of fluid structure interaction
 problems</a>
 <ul>
 <li><a href="#Codimensiononecase">Co-dimension one case</a><a
 href="#Codimensiononecase">Co-dimension one case</a>
 <li><a href="#Codimensionzerocase">Co-dimension zero case</a><a
 href="#Codimensionzerocase">Co-dimension zero case</a>
 <li><a href="#Representationofand">Representation of Ω and Γ</a><a
 href="#Representationofand">Representation of Ω and Γ</a>
 <li><a href="#Usingparticlestotrack">Using particles to track Γ</a><a
 href="#Usingparticlestotrack">Using particles to track Γ</a>
 </ul>
 <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The
 testcase</a>
 <li><a href="#Morereferences"> More references</a><a
 href="#Morereferences"> More references</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#Runtimeparameterhandling">Run-time parameter handling</a><a
 href="#Runtimeparameterhandling">Run-time parameter handling</a>
 <li><a href="#TheStokesImmersedProblemclassdeclaration">The
 StokesImmersedProblem class declaration</a><a
 href="#TheStokesImmersedProblemclassdeclaration">The StokesImmersedProblem
 class declaration</a>
 <li><a href="#TheStokesImmersedProblemclassimplementation">The
 StokesImmersedProblem class implementation</a><a
 href="#TheStokesImmersedProblemclassimplementation">The
 StokesImmersedProblem class implementation</a>
 <ul>
 <li><a href="#Objectconstructionandmeshinitializationfunctions">Object
 construction and mesh initialization functions</a><a
 href="#Objectconstructionandmeshinitializationfunctions">Object
 construction and mesh initialization functions</a>
 <li><a href="#Particleinitializationfunctions">Particle initialization
 functions</a><a href="#Particleinitializationfunctions">Particle
 initialization functions</a>
 <li><a href="#DoFinitializationfunctions">DoF initialization
 functions</a><a href="#DoFinitializationfunctions">DoF initialization
 functions</a>
 <li><a href="#Assemblyfunctions">Assembly functions</a><a
 href="#Assemblyfunctions">Assembly functions</a>
 <li><a href="#Solvingthelinearsystem">Solving the linear system</a><a
 href="#Solvingthelinearsystem">Solving the linear system</a>
 <li><a href="#Meshrefinement">Mesh refinement</a><a
 href="#Meshrefinement">Mesh refinement</a>
 <li><a href="#Creatingoutputforvisualization">Creating output for
 visualization</a><a href="#Creatingoutputforvisualization">Creating output
 for visualization</a>
 <li><a href="#Therunfunction">The "run" function</a><a
 href="#Therunfunction">The "run" function</a>
 </ul>
 <li><a href="#Themainfunction">The main() function</a><a
 href="#Themainfunction">The main() function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Twodimensionaltestcase"> Two dimensional test case </a><a
 href="#Twodimensionaltestcase"> Two dimensional test case </a>
 <li><a href="#Threedimensionaltestcase"> Three dimensional test case </a><a
 href="#Threedimensionaltestcase"> Three dimensional test case </a>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Luca Heltai (International School for Advanced Studies, Trieste), Bruno Blais (Polytechnique Montréal), and Rene Gassmöller (University of California Davis) </em> </p><dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3829064"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3829064.svg" alt="10.5281/zenodo.3829064"/></a> </dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems"></a></p><h3>Massively parallel non-matching grid simulations of fluid structure interaction problems</h3>
<p>In this tutorial we consider a mixing problem in the laminar flow regime.Such problems occur in a wide range of applications ranging from chemical engineering to powergeneration (e.g. turbomachinery). Mixing problems are particularly hard to solve numerically,because they often involve a container (with fixed boundaries, and possiblycomplex geometries such as baffles), represented by the domain \(\Omega\) ,and one (or more) immersed and rotating impellers (represented by the domain \(\Omega^{\text{imp}}\) ).The domain in which we would like to solve the flow equations is the (timedependent) difference between the two domains, namely: \(\Omega\setminus\Omega^{\text{imp}}\) . For rotating impellers, the use of Arbitrary Lagrangian Eulerian formulations(in which the fluid domain</p>
<ul>
<li>along with the mesh!</li>
<li>is smoothly deformed to follow the deformationsof the immersed solid) is not possible, unless only small times (i.e.,small fluid domain deformations) are considered. If one wants to track theevolution of the flow across multiple rotations of the impellers, the resultingdeformed grid would simply be too distorted to be useful. In this case, a viable alternative strategy would be to use non-matchingmethods (similarly to what we have done in <a class="el" href="step_60.html">step-60</a> ), where a background fixedgrid (that may or may not be locally refined in time to better capture the solidmotion) is coupled with a rotating, independent, grid. In order to maintain the same notations used in <a class="el" href="step_60.html">step-60</a> , we use \(\Omega\) todenote the domain in \({\mathbb R}^{\text{spacedim}}\) representing the container of boththe fluid and the impeller, and we use \(\Gamma\) in \({\mathbb R}^{\text{dim}}\) to denoteeither the full impeller (when its <code>spacedim</code> measure is non-negligible, i.e.,when we can represent it as a grid of dimension <code>dim</code> equal to <code>spacedim</code>),a co-dimension one representation of a thin impeller, or just the boundary ofthe full impeller. The domain \(\Gamma\) is embedded in \(\Omega\) ( \(\Gamma \subseteq \Omega\) ) and itis non-matching: It does not, in general, align with any of thefeatures of the volume mesh. We solve a partial differential equation on \(\Omega\) ,enforcing some conditions on the solution of the problem on the embeddeddomain \(\Gamma\) by some penalization techniques. In the current case,the condition is that the velocity of the fluid at points on \(\Gamma\) equal the velocity of the solid impeller at that point. The technique we describe here is presented in the literature using one of manynames: the <b>immersed finite element method</b> and the <b>fictitious boundary method</b> among others. The main principle is that the discretization of thetwo grids are kept completely independent. In the present tutorial, thisapproach is used to solve for the motion of a viscous fluid, described by theStokes equation, that is agitated by a rigid non-deformable impeller. Thus, the equations solved in \(\Omega\) are the Stokes equations for a creepingflow (i.e. a flow where \(\text{Re}\rightarrow 0\) ) and a no-slip boundarycondition is applied on the movingembedded domain* \(\Gamma\) associated withthe impeller. However, this tutorial could be readily extendedto other equations (e.g. the Navier-Stokes equations, linear elasticityequation, etc.). It can be seen as a natural extension of <a class="el" href="step_60.html">step-60</a> thatenables the solution of large problems using a distributed parallel computingarchitecture via MPI. However, contrary to <a class="el" href="step_60.html">step-60</a> , the Dirichlet boundary conditions on \(\Gamma\) are imposed weakly instead of through the use of Lagrange multipliers, and weconcentrate on dealing with the coupling of two fully distributedtriangulations (a combination that was not possible in the implementation of <a class="el" href="step_60.html">step-60</a> ). There are two interesting scenarios that occur when one wants to enforceconditions on the embedded domain \(\Gamma\) :</li>
<li>The geometrical dimension <code>dim</code> of the embedded domain \(\Gamma\) is the same ofthe domain \(\Omega\) (<code>spacedim</code>), that is, the spacedim-dimensional measure of \(\Gamma\) is not zero. In this case, the imposition of the Dirichlet boundaryboundary condition on \(\Gamma\) is done through a volumetric penalization. If theapplied penalization only depends on the velocity, this is often referredto as \(\mathcal{L}^2\) penalization whereas if the penalization dependson both the velocity and its gradient, it is an \(\mathcal{H}^1\) penalization.The case of the \(\mathcal{L}^2\) penalization is very similar to a Darcy-typeapproach. Both \(\mathcal{L}^2\) and \(\mathcal{H}^1\) penalizations have beenanalyzed extensively (see, for example, <b>[Angot1999]</b> ).</li>
<li>The embedded domain \(\Gamma\) has an intrinsic dimension <code>dim</code> which is smallerthan that of \(\Omega\) (<code>spacedim</code>), thus its spacedim-dimensional measure iszero; for example it is a curve embedded in a two dimensional domain, or asurface embedded in a three-dimensional domain. This is of coursephysically impossible, but one may consider very thin sheets of metalmoving in a fluid as essentially lower-dimensional if the thickness ofthe sheet is negligible. In this case, the boundarycondition is imposed weakly on \(\Gamma\) by applying the<a href="https://en.wikipedia.org/wiki/Joachim_Nitsche">Nitsche</a> method (see <b>[Freund1995]</b> ). Both approaches have very similar requirements and result in highlysimilar formulations. Thus, we treat them almost in the same way. In this tutorial program we are not interested in further details on \(\Gamma\) :we assume that the dimension of the embedded domain (<code>dim</code>) is always smaller byone or equal with respect to the dimension of the embedding domain \(\Omega\) (<code>spacedim</code>). We are going to solve the following differential problem: given a sufficientlyregular function \(g\) on \(\Gamma\) , find the solution \((\textbf{u},p)\) to <p class="formulaDsp">
\begin{eqnarray*} -\Delta \mathbf{u} + \nabla p &amp;=&amp; 0,\\ -\nabla \cdot \textbf{u} &amp;=&amp; 0,\\ \textbf{u} &amp;=&amp; \textbf{g} \text{ in } \Gamma,\\ \textbf{u} &amp;=&amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
</li>
</ul>
<p>This equation, which we have normalized by scaling the time units insuch a way that the viscosity has a numerical value of 1, describesslow, viscous flow such as honey or lava.The main goal of this tutorial is to show how to impose the velocity fieldcondition \(\mathbf{u} = \mathbf{g}\) on a non-matching \(\Gamma\) in a weak way,using a penalization method. A more extensive discussion of the Stokesproblem including body forces, different boundary conditions, and solutionstrategies can be found in <a class="el" href="step_22.html">step-22</a> . Let us start by considering the Stokes problem alone, in the entire domain \(\Omega\) . We look for a velocity field \(\mathbf{u}\) and a pressure field \(p\) that satisfy the Stokes equations with homogeneous boundary conditionson \(\partial\Omega\) . The weak form of the Stokes equations is obtained by first writing it in vectorform as </p><p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-\Delta \textbf{u} + \nabla p} \\ {-\textrm{div}\;\textbf{u}} \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p> forming the dot product from the left with a vector-valued testfunction \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) , and integratingover the domain \(\Omega\) , yielding the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -\Delta \textbf{u} + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = 0 \end{eqnarray*}
</p>
<p> which has to hold for all test functions \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) .</p>
<p>Integrating by parts and exploiting the boundary conditions on \(\partial\Omega\) ,we obtain the following variational problem: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega}&amp;=&amp; 0 \end{eqnarray*}
</p>
<p>where \((\cdot, \cdot)_{\Omega}\) represents the \(L^2\) scalarproduct. This is the same variational form used in <a class="el" href="step_22.html">step-22</a> . This variational formulation does not take into account the embedded domain.Contrary to <a class="el" href="step_60.html">step-60</a> , we do not enforce strongly the constraints of \(\textbf{u}\) on \(\Gamma\) , but enforce them weakly via a penalization term. The analysis of this weak imposition of the boundary condition depends on thespacedim-dimensional measure of \(\Gamma\) as either positive (if <code>dim</code> is equalto <code>spacedim</code>) or zero (if <code>dim</code> is smaller than <code>spacedim</code>). We discuss bothscenarios.</p>
<p><a class="anchor" id="Codimensiononecase"></a></p><h4>Co-dimension one case</h4>
<p>In this case, we assume that \(\Gamma\) is the boundary of the actual impeller,that is, a closed curve embedded in a two-dimensional domain or a closedsurface in a three-dimensional domain. The idea of this method starts byconsidering a weak imposition of the Dirichlet boundary condition on \(\Gamma\) ,following the Nitsche method. This is achieved by using the following modified formulationon the fluid domain, where no strong conditions on the test functions on \(\Gamma\) are imposed: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ - (\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ - (\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} + (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} + (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>The integrals over \(\Gamma\) are lower-dimensional integrals. It can be shown (see <b>[Freund1995]</b> ) that there exists a positive constant \(C_1\) so that if \(\beta &gt; C_1\) , the weak imposition of the boundary willbe consistent and stable. The first two additional integrals on \(\Gamma\) (thesecond line in the equation above) appear naturally after integrating by parts,when one does not assume that \(\mathbf{v}\) is zero on \(\Gamma\) . The third line in the equation above contains two terms that are added to ensureconsistency of the weak form, and a stabilization term, that is there to enforcethe boundary condition with an error which is consistent with the approximationerror. The consistency terms and the stabilization term are added to theright hand side with the actual boundary data \(\mathbf{g}\) . When \(\mathbf{u}\) satisfies the condition \(\mathbf{u}=\mathbf{g}\) on \(\Gamma\) ,all the consistency and stability integrals on \(\Gamma\) cancel out, and one isleft with the usual weak form of Stokes flow, that is, the above formulation isconsistent. We note that an alternative (non-symmetric) formulation can be used : </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ -(\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ +(\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} - (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} - (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p> Note the different sign of the first terms on the third and fourth lines.In this case, the stability and consistency conditions become \(\beta &gt; 0\) . Inthe symmetric case, the value of \(\beta\) is dependent on \(h\) , and it is ingeneral chosen such that \(\beta = C h^{-1} \) with \(h\) a measure of size of the face being integrated and \(C\) a constant such that \(1 \leq C \leq 10\) . This is as one usually does with the Nitschepenalty method to enforcing Dirichlet boundary conditions. The non-symmetric approach, on the other hand, is related to how oneenforced continuity for the non-symmetric interior penalty method fordiscontinuous Galerkin methods (the "NIPG" method <b>[Riviere1999]</b> ).Even if the non-symmetric case seems advantageous w.r.t.possible choices of stabilization parameters, we opt for the symmetricdiscretization, since in this case it can be shown that the dual problem isalso consistent, leading to a solution where not only the energy norm of thesolution converges with the correct order, but also its \(L^2\) norm. Furthermore, the resulting matrix remains symmetric. The above formulation works under the assumption that the domain is discretizedexactly. However, if the deformation of the impeller is a rigid bodymotion, it is possible to artificially extend the solution of the Stokesproblem inside the propeller itself, since a rigid body motion is also asolution to the Stokes problem. The idea is then to solve the same problem,inside \(\Omega^{\text{imp}}\) , imposing the same boundary conditions on \(\Gamma\) , using the same penalization technique, and testing with testfunctions \(\mathbf{v}\) which are globally continuous over \(\Omega\) . This results in the following (intermediate) formulation: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} \\ - (\textbf{v}, \lbrack \nabla \textbf{u} \rbrack \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},\lbrack p \rbrack )_{\Gamma} \\ - (\lbrack \nabla\textbf{v} \rbrack \cdot \textbf{n},\textbf{u})_{\Gamma} + (\lbrack q \rbrack, \textbf{u} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\lbrack \nabla\textbf{v}\rbrack\cdot \textbf{n},\textbf{g})_{\Gamma} + (\lbrack q\rbrack, \textbf{g} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{g})_{\Gamma}, \end{multline*}
</p>
<p> where the jump terms, denoted with \(\lbrack \cdot \rbrack\) , are computed withrespect to a fixed orientation of the normal vector \(\textbf{n}\) . Thefactor of 2 appears in front of \(\beta\) since we see every part of \(\Gamma\) twice, once from within the fluid and once from within theobstacle moving around in it. (For all of the other integrals over \(\Gamma\) , we visit each part of \(\Gamma\) twice, but with oppositesigns, and consequently get the jump terms.) Here we notice that, unlike in discontinuous Galerkin methods, the testand trial functions are continuous across \(\Gamma\) . Moreover, if \(\Gamma\) isnot aligned with cell boundaries, all the jump terms are also zero, since, ingeneral, finite element function spaces are smooth inside each cell, and if \(\Gamma\) cuts through an element intersecting its boundary only at a finitenumber of points, all the contributions on \(\Gamma\) , with the exception ofthe stabilization ones, can be neglected from the formulation, resulting inthe following final form of the variational formulation: </p><p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = 2\beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>In <a class="el" href="step_60.html">step-60</a> , the imposition of the constraintrequired the addition of new variables in the form of Lagrange multipliers.This is not the case for this tutorial program. The imposition of theboundary condition using Nitsche's method only modifies the system matrixand the right-hand side without adding additional unknowns.However, the velocity vector \(\textbf{u}\) on the embedded domain will not matchexactly the prescribed velocity \(\textbf{g}\) , but only up to a numerical errorwhich is in the same order as the interpolation error of the finite elementmethod. Furthermore, as in <a class="el" href="step_60.html">step-60</a> , we still need to integrate over thenon-matching embedded grid in order to construct the boundary term necessaryto impose the boundary condition over \(\Gamma\) .</p>
<p><a class="anchor" id="Codimensionzerocase"></a></p><h4>Co-dimension zero case</h4>
<p>In this case, \(\Gamma\) has the same dimension, but is embedded into \(\Omega\) . We can think of this as a thick object moving around in the fluid.In the case of \(\mathcal{L}^2\) penalization, the additional penalizationterm can be interpreted as a Darcy term within \(\Gamma\) , resulting in: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta (\textbf{v},\textbf{u})_{\Gamma} = \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Here, integrals over \(\Gamma\) are simply integrals over a part of the volume.The \(\mathcal{L}^2\) penalization thus consists in adding a volumetric term thatconstrains the velocity of the fluid to adhere to the velocity of the rigid bodywithin \(\Gamma\) . Also in this case, \(\beta\) must be chosen sufficiently largein order to ensure that the Dirichlet boundary condition in \(\Gamma\) issufficiently respected, but not too high in order to maintain the properconditioning of the system matrix. A \(\mathcal{H}^1\) penalization may be constructed in a similar manner, with theaddition of a viscous component to the penalization that dampens the velocitygradient within \(\Gamma\) : </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta_1 (\textbf{v},\textbf{u})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{u})_{\Gamma} = \beta_1 (\textbf{v},\textbf{g})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>Notice that the \(L^2\) penalization (<code>dim</code> equal to <code>spacedim</code>) and the Nitschepenalization (<code>dim</code> equal to <code>spacedim-1</code>) result in the exact same numericalimplementation, thanks to the dimension independent capabilities of deal.II.</p>
<p><a class="anchor" id="Representationofand"></a></p><h4>Representation of Ω and Γ</h4>
<p>In this tutorial, both the embedded grid \(\Gamma\) and the embeddinggrid are described using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. These twotriangulations can be built from functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace or by readinga mesh file produced with another application (e.g. GMSH, see thediscussion in <a class="el" href="step_49.html">step-49</a> ). This is slightlymore general than what was previously done in <a class="el" href="step_60.html">step-60</a> . The addition of the immersed boundary method, whetherit is in the <code>dim=spacedim</code> or <code>dim&lt;spacedim</code> case, only introducesadditional terms in the system matrix and the right-hand side of thesystem which result from the integration over \(\Gamma\) . This does notmodify the number of variables for which the problemmust be solved. The challenge is thus related to the integralsthat must be carried over \(\Gamma\) . As usual in finite elements we split this integral into contributions from allcells of the triangulation used todiscretize \(\Gamma\) , we transform the integral on \(K\) to an integral on thereference element \(\hat K\) , where \(F_{K}\) is the mapping from \(\hat K\) to \(K\) ,and compute the integral on \(\hat K\) using a quadrature formula. For example: </p><p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \int_{\hat K} \hat{\textbf{u}}(\hat x) (\textbf{v} \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p> Computing this sum is non-trivial because we have to evaluate \((v_j \circ F_{K}) (\hat x_i)\) . In general, if \(\Gamma\) and \(\Omega\) are not aligned, the point \(y_i = F_{K}(\hat x_i)\) is completely arbitrary with respect to \(\Omega\) , and unlesswe figure out a way to interpolate all basis functions of \(V_h(\Omega)\) on anarbitrary point on \(\Omega\) , we cannot compute the integral needed.</p>
<p>To evaluate \((v_j \circ F_{K}) (\hat x_i)\) the following steps needs to betaken (as shown in the picture below):</p>
<ul>
<li>For a given cell \(K\) in \(\Gamma\) compute the real point \(y_i \dealcoloneq F_{K} (\hat x_i)\) , where \(x_i\) is one of the quadrature points used for the integral on \(K \subseteq \Gamma\) . This is the easy part: <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">FEValues::quadrature_point()</a> gives us the real-space locations of allquadrature points.</li>
<li>Find the cell of \(\Omega\) in which \(y_i\) lies. We shall call this element \(T\) .</li>
<li>Find the reference coordinates within \(T\) of \(y_i\) . For this, weneed the inverse of the mapping \(G_T\) thattransforms the reference element \(\hat T\) into the element \(T\) : \(\hat y_i = G^{-1}_{T} (y_i)\) .</li>
<li>Evaluate the basis function \(v_j\) of the \(\Omega\) mesh at this point \(\hat y_i\) . This is, again, relatively simple using <a class="el" href="classFEValues.html">FEValues</a>.</li>
</ul>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png"/>
</div>
 <p>In <a class="el" href="step_60.html">step-60</a> , the second through fourth steps above were computed by calling, in turn,</p>
<ul>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, followed by</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. We then</li>
<li>construct a custom <a class="el" href="classQuadrature.html">Quadrature</a> formula, containing the point in the reference cell and then</li>
<li>construct an <a class="el" href="classFEValues.html">FEValues</a> object, with the given quadrature formula, and initialized with the cell obtained in the first step. Although this approach could work for the present case, it does not lends itselfreadily to parallel simulations using distributed triangulations. Indeed,since the position of the quadrature points on the cells of theembedded domain \(\Gamma\) do not match that of the embedding triangulationand since \(\Gamma\) is constantly moving, this would require that the triangulation representing \(\Gamma\) be stored in it's entirety for all of the processors. As the numberof processor and the number of cells in \(\Gamma\) increases, this leadsto a severe bottleneck in terms of memory. Consequently, an alternative strategy is soughtin this step.</li>
</ul>
<p><a class="anchor" id="Usingparticlestotrack"></a></p><h4>Using particles to track Γ</h4>
<p>Remember that for both the penalization approach ( \(\mathcal{L}^2\) or \(\mathcal{H}^1\) )and the Nitsche method, we want to compute integrals that are approximated bythe quadrature. That is, we need to compute </p><p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p> you followed the discussion above, then you will recall that \(\textbf{u}\) and \(\textbf{v}\) are shape functions defined on the fluid mesh.The only things defined on the solid mesh are: \(F_K(\hat x_i)\) , which is the location of a quadrature point on a solid cell thatis part of \(\Gamma\) , \(J_K\) is the determinant of its Jacobian, and \(w_i\) the correspondingquadrature weight. The important part to realize is now this: \(w_i\) is a property ofthe quadrature formula and does not change with time. Furthermore,the Jacobian matrix of \(F_K\) itself changes as the solid obstaclemoves around in the fluid, but because the solid is considerednon-deforming (it only translates and rotates, but doesn't dilate),the determinant of the Jacobian remains constant. As a consequence,the product \(J_K(\hat x_i) w_i\) (which we typically denote by <code>JxW</code>)remains constant for each quadrature point. So the only thing we needkeep track of are the positions \(x_i=F_K(\hat x_i)\)</p>
<ul>
<li>but thesemove with the velocity of the solid domain. In other words, we don't actually need to keep the solid mesh at all.All we need is the positions \(x_i(t)\) and corresponding <code>JxW</code> values.Since both of these properties are point-properties (or point-vectors) that areattached to the solid material, they can be idealized as a set of disconnectedinfinitesimally small "particles", which carry the required <code>JxW</code> information with themovement of the solid. deal.II has the ability to distribute andstore such a set of particles in large-scale parallel computations in the form ofthe ParticleHandler class (for details on the implementation see <b>[GLHPW2018]</b> ),and we will make use of this functionality in this tutorial. Thus, the approach taken in this step is as follows:</li>
<li>Create a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> for the domain \(\Gamma\) ;</li>
<li>Create <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> at the positions of the quadrature points on \(\Gamma\) ;</li>
<li>Call the <a class="el" href="classParticles_1_1ParticleHandler.html#ac4bae8e82e7a021bd4c269f0df3f8bea">Particles::ParticleHandler::insert_global_particles()</a> function, to distribute the particles across processors,following the solid triangulation*;</li>
<li>Attach the <code>JxW</code> values as a "property" to each <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> object. This structure is relatively expensive to generate, but must only be generatedonce per simulation. Once the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> is generated and therequired information is attached to the particle, the integrals over \(\Gamma\) can be carried out by exploiting the fact that particles are grouped cellwiseinside ParticleHandler, allowing us to:</li>
<li>Looping over all cells of \(\Omega\) that contain at least one particle</li>
<li>Looping over all particles in the given cell</li>
<li>Compute the integrals and fill the global matrix. Since the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can manage the exchange of particles fromone processor to the other, the embeddedtriangulation can be moved or deformed by displacing the particles.The only constraint associated with this displacement is that particles shouldbe displaced by a distance that is no larger than the size of onecell. That's because that is the limit to which <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can track which cell a particle that leavesits current cell now resides in. Once the entire problem (the Stokes problem and the immersed boundaryimposition) is assembled,the final saddle point problem is solved by an iterative solver, applied to theSchur complement \(S\) (whose construction is described, for example, in <a class="el" href="step_22.html">step-22</a> ),and we construct \(S\) using <a class="el" href="classLinearOperator.html">LinearOperator</a> classes.</li>
</ul>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is a demonstration of the time-reversibility of Stokesflow. This is often illustrated in science education experiments with aTaylor-Couette flow and dye droplets that revert back to their original shapeafter the fluid has been displaced in a periodic manner. 

 <iframe width="560" height="315"
 src="https://www.youtube.com/embed/p08_KlTKP50" frameborder="0"
 allow="accelerometer; autoplay; encrypted-media; gyroscope;
 picture-in-picture" allowfullscreen></iframe>

 </p>
<p>In the present problem, a very viscous fluid is agitated by the rotation ofan impeller, which, in 2D, is modeled by a rectangular grid. The impellerrotates for a given number of revolutions, after which the flow is reversed suchthat the same number of revolutions is carried out in the opposite direction. Werecall that since the Stokes equations are self-adjoint, creeping flows arereversible. Consequently, if the impeller motion is reversed in the oppositedirection, the fluid should return to its original position. In the presentcase, this is illustrated by inserting a circle of passive tracer particles thatare advected by the fluid and which return to their original position, thusdemonstrating the time-reversibility of the flow.</p>
<p><a class="anchor" id="Morereferences"></a></p><h3>More references</h3>
<p>This tutorial program uses a number of techniques on imposing velocityconditions on non-matching interfaces in the interior of the fluid.For more background material, you may want to look up the following references: <b>[Freund1995]</b> , <b>[Angot1999]</b> , <b>[Glowinski1999]</b> , <b>[Boffi2008]</b> , <b>[Heltai2012]</b> .</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones. The switches close to the top that allow selecting between PETSc and Trilinos linear algebra capabilities are similar to the ones in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_50.html">step-50</a></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>LA</div><div class="line">{</div><div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div><div class="line"><span class="preprocessor">!(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div><div class="line"><span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div><div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div><div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div><div class="line"><span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">} <span class="comment">// namespace LA</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>These are the only new include files with regard to <a class="el" href="step_60.html">step-60</a> . In this tutorial, the non-matching coupling between the solid and the fluid is computed using an intermediate data structure that keeps track of how the locations of quadrature points of the solid evolve within the fluid mesh. This data structure needs to keep track of the position of the quadrature points on each cell describing the solid domain, of the quadrature weights, and possibly of the normal vector to each point, if the solid domain is of co-dimension one.</p>
<p>Deal.II offers these facilities in the <a class="el" href="namespaceParticles.html">Particles</a> namespace, through the ParticleHandler class. ParticleHandler is a class that allows you to manage a collection of particles (objects of type <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>), representing a collection of points with some attached properties (e.g., an id) floating on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. The methods and classes in the namespace <a class="el" href="namespaceParticles.html">Particles</a> allows one to easily implement Particle-In-Cell methods and particle tracing on distributed triangulations.</p>
<p>We "abuse" this data structure to store information about the location of solid quadrature points embedded in the surrounding fluid grid, including integration weights, and possibly surface normals. The reason why we use this additional data structure is related to the fact that the solid and the fluid grids might be non-overlapping, and if we were using two separate triangulation objects, would be distributed independently among parallel processes.</p>
<p>In order to couple the two problems, we rely on the ParticleHandler class, storing in each particle the position of a solid quadrature point (which is in general not aligned to any of the fluid quadrature points), its weight, and any other information that may be required to couple the two problems. These locations are then propagated along with the (prescribed) velocity of the solid impeller.</p>
<p>Ownership of the solid quadrature points is initially inherited from the MPI partitioning on the solid mesh itself. The <a class="el" href="namespaceParticles.html">Particles</a> so generated are later distributed to the fluid mesh using the methods of the ParticleHandler class. This allows transparent exchange of information between MPI processes about the overlapping pattern between fluid cells and solid quadrature points.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>When generating the grids, we allow reading it from a file, and if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support, we also allow reading CAD files and use them as manifold descriptors for the grid (see <a class="el" href="step_54.html">step-54</a> for a detailed description of the various <a class="el" href="classManifold.html">Manifold</a> descriptors that are available in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step70</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Runtimeparameterhandling"></a> </p><h3>Run-time parameter handling</h3>
<p>Similarly to what we have done in <a class="el" href="step_60.html">step-60</a> , we set up a class that holds all the parameters of our problem and derive it from the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class to simplify the management and creation of parameter files. The <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> paradigm requires all parameters to be writable by the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> methods. In order to avoid bugs that would be very difficult to track down (such as writing things like <code>time = 0</code> instead of <code>time == 0</code>), we declare all the parameters in an external class, which is initialized before the actual <code>StokesImmersedProblem</code> class, and pass it to the main class as a <code>const</code> reference. The constructor of the class is responsible for the connection between the members of this class and the corresponding entries in the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. Thanks to the use of the <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter()</a> method, this connection is trivial, but requires all members of this class to be writeable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesImmersedProblemParameters();</div></div><!-- fragment --><p>however, since this class will be passed as a <code>const</code> reference to the StokesImmersedProblem class, we have to make sure we can still set the time correctly in the objects derived by the <a class="el" href="classFunction.html">Function</a> class defined herein. In order to do so, we declare both the <code>StokesImmersedProblemParameters::rhs</code> and <code>StokesImmersedProblemParameters::angular_velocity</code> members to be <code>mutable</code>, and define the following little helper method that sets their time to the correct value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  rhs.set_time(time);</div><div class="line">  angular_velocity.set_time(time);</div><div class="line">}</div></div><!-- fragment --><p>The remainder of the class consists largely of member variables that describe the details of the simulation and its discretization. The following parameters are about where output should land, the spatial and temporal discretization (the default is the \(Q_2\times Q_1\) Taylor-Hood discretization which uses a polynomial degree of 2 for the velocity), and how many time steps should elapse before we generate graphical output again:</p>
<div class="fragment"><div class="line">std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div><div class="line"><span class="keywordtype">double</span>       final_time           = 1.0;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div></div><!-- fragment --><p>We allow every grid to be refined independently. In this tutorial, no physics is resolved on the solid grid, and its velocity is given as a datum. However it is relatively straightforward to incorporate some elasticity model in this tutorial, and transform it into a fully fledged FSI solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div></div><!-- fragment --><p>To provide a rough description of the fluid domain, we use the method <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> applied to the tree of bounding boxes of each locally owned cell of the fluid triangulation. The higher the level of the tree, the larger the number of extracted bounding boxes, and the more accurate is the description of the fluid domain. However, a large number of bounding boxes also implies a large communication cost, since the collection of bounding boxes is gathered by all processes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div></div><!-- fragment --><p>The only two numerical parameters used in the equations are the viscosity of the fluid, and the penalty term \(\beta\) used in the Nitsche formulation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> viscosity    = 1.0;</div><div class="line"><span class="keywordtype">double</span> penalty_term = 100;</div></div><!-- fragment --><p>By default, we create a hyper_cube without colorization, and we use homogeneous Dirichlet boundary conditions. In this set we store the boundary ids to use when setting the boundary conditions:</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div></div><!-- fragment --><p>We illustrate here another way to create a <a class="el" href="classTriangulation.html">Triangulation</a> from a parameter file, using the method <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments()</a>, that takes the name of a function in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, and its arguments as a single string representing the arguments as a tuple. The mechanism with which the arguments are parsed from and to a string is explained in detail in the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class, which is used to translate from strings to most of the basic STL types (vectors, maps, tuples) and basic deal.II types (<a class="el" href="classPoint.html">Point</a>, <a class="el" href="classTensor.html">Tensor</a>, <a class="el" href="classBoundingBox.html">BoundingBox</a>, etc.). In general objects that can be represented by rank 1 uniform elements (i.e., std::vector&lt;double&gt;, <a class="el" href="classPoint.html">Point&lt;dim&gt;</a>, std::set&lt;int&gt;, etc.) are comma separated. Additional ranks take a semicolon, allowing you to parse strings into objects of type <code>std::vector&lt;std::vector&lt;double&gt;&gt;</code>, or, for example, <code>std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt;&gt;</code>, as <code>0.0, 0.1; 0.1, 0.2</code>. This string could be interpreted as a vector of two <a class="el" href="classPoint.html">Point</a> objects, or a vector of vector of doubles. When the entries are not uniform, as in the tuple case, we use a colon to separate the various entries. For example, a string like <code>5: 0.1, 0.2</code> could be used to parse an object of type <code>std::pair&lt;int, <a class="el" href="classPoint.html">Point</a>&lt;2&gt;&gt;</code> or a <code>std::tuple&lt;int, std::vector&lt;double&gt;&gt;</code>. In our case most of the arguments are <a class="el" href="classPoint.html">Point</a> objects (representing centers, corners, subdivision elements, etc.), integer values (number of subdivisions), double values (radius, lengths, etc.), or boolean options (such as the <code>colorize</code> option that many <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions take). In the example below, we set reasonable default values, but these can be changed at run time by selecting any other supported function of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. If the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function fails, this program will interpret the name of the grid as a vtk grid filename, and the arguments as a map from manifold_id to the CAD files describing the geometry of the domain. Every CAD file will be analyzed and a <a class="el" href="classManifold.html">Manifold</a> of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace will be generated according to the content of the CAD file itself. To be as generic as possible, we do this for each of the generated grids: the fluid grid, the solid grid, but also the tracer particles which are also generated using a triangulation.</p>
<div class="fragment"><div class="line">  std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div><div class="line">  std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div><div class="line">  std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div><div class="line">  std::string arguments_for_solid_grid = spacedim == 2 ?</div><div class="line">                                           <span class="stringliteral">&quot;-.5,</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">-.1: .5, .1: false&quot;</span> :</div><div class="line">                                           <span class="stringliteral">&quot;-.5,</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">-.1,</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">-.1: .5, .1, .1: false&quot;</span>;</div><div class="line">  std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div><div class="line">  std::string arguments_for_particle_grid =</div><div class="line">    spacedim == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div></div><!-- fragment --><p>Similarly, we allow for different local refinement strategies. In particular, we limit the maximum number of refinement levels, in order to control the minimum size of the fluid grid, and guarantee that it is compatible with the solid grid. The minimum number of refinement levels is also controlled to ensured sufficient accuracy in the bulk of the flow. Additionally, we perform local refinement based on standard error estimators on the fluid velocity field. We permit the user to choose between the two most common refinement strategies, namely <code>fixed_number</code> or <code>fixed_fraction</code>, that refer to the methods <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction()</a> and <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number()</a>. Refinement may be done every few time steps, instead of continuously, and we control this value by the <code>refinement_frequency</code> parameter:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>          max_level_refinement = 8;</div><div class="line"><span class="keywordtype">int</span>          min_level_refinement = 5;</div><div class="line">std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div><div class="line"><span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div><div class="line"><span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div><div class="line"><span class="keywordtype">int</span>          refinement_frequency = 5;</div></div><!-- fragment --><p>Finally, the following two function objects are used to control the source term of Stokes flow and the angular velocity at which we move the solid body. In a more realistic simulation, the solid velocity or its deformation would come from the solution of an auxiliary problem on the solid domain. In this example step we leave this part aside, and simply impose a fixed rotational velocity field along the z-axis on the immersed solid, governed by a function that can be specified in the parameter file :</p>
<div class="fragment"><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; rhs;</div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">    angular_velocity;</div><div class="line">};</div></div><!-- fragment --><p>There remains the task of declaring what run-time parameters we can accept in input files. We split the parameters in various categories, by putting them in different sections of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class. We begin by declaring all the global parameters used by StokesImmersedProblem in the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">StokesImmersedProblemParameters&lt;dim,</div><div class="line">                                spacedim&gt;::StokesImmersedProblemParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div><div class="line">  , rhs(<span class="stringliteral">&quot;Right hand side&quot;</span>, spacedim + 1)</div><div class="line">  , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, final_time);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div><div class="line">                initial_fluid_refinement,</div><div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div><div class="line">                initial_solid_refinement,</div><div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div><div class="line">                fluid_rtree_extraction_level,</div><div class="line">                <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div><div class="line">                <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div><div class="line">    particle_insertion_refinement,</div><div class="line">    <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">    homogeneous_dirichlet_ids,</div><div class="line">    <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div></div><!-- fragment --><p>Next section is dedicated to the parameters used to create the various grids. We will need three different triangulations: <code>Fluid grid</code> is used to define the fluid domain, <code>Solid grid</code> defines the solid domain, and <code>Particle grid</code> is used to distribute some tracer particles, that are advected with the velocity and only used as passive tracers.</p>
<div class="fragment"><div class="line">enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div><div class="line">                arguments_for_particle_grid);</div><div class="line">}</div><div class="line">leave_subsection();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div><div class="line">                refinement_strategy,</div><div class="line">                <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">                this-&gt;prm,</div><div class="line">                <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div><div class="line">}</div><div class="line">leave_subsection();</div></div><!-- fragment --><p>The final task is to correct the default dimension for the right hand side function and define a meaningful default angular velocity instead of zero.</p>
<div class="fragment"><div class="line">  rhs.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">    <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div><div class="line">                                                            spacedim + 1);</div><div class="line">  });</div><div class="line">  angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">    this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                  <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 :</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">-6.283185&quot;</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p>Once the angular velocity is provided as a <a class="el" href="classFunction.html">Function</a> object, we reconstruct the pointwise solid velocity through the following class which derives from the <a class="el" href="classFunction.html">Function</a> class. It provides the value of the velocity of the solid body at a given position by assuming that the body rotates around the origin (or the \(z\) axis in 3d) with a given angular velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  static_assert(spacedim &gt; 1,</div><div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">  SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div><div class="line">    : angular_velocity(angular_velocity)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> velocity;</div></div><!-- fragment --><p>We assume that the angular velocity is directed along the z-axis, i.e., we model the actual angular velocity as if it was a two-dimensional rotation, irrespective of the actual value of <code>spacedim</code>.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(p);</div><div class="line">    velocity[0]        =</div><div class="line"></div><div class="line">-omega p[1];</div><div class="line">    velocity[1]        = omega p[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> velocity[component];</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">};</div></div><!-- fragment --><p>Similarly, we assume that the solid position can be computed explicitly at each time step, exploiting the knowledge of the angular velocity. We compute the exact position of the solid particle assuming that the solid is rotated by an amount equal to the time step multiplied by the angular velocity computed at the point <code>p</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  static_assert(spacedim &gt; 1,</div><div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">  SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;(spacedim)</div><div class="line">    , angular_velocity(angular_velocity)</div><div class="line">    , time_step(time_step)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = p;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> dtheta = angular_velocity.value(p) time_step;</div><div class="line"></div><div class="line">    new_position[0] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) p[0]</div><div class="line"></div><div class="line">- <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) p[1];</div><div class="line">    new_position[1] = <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) p[0] + <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) p[1];</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> new_position[component];</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div><div class="line">  {</div><div class="line">    time_step = new_time_step;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">  <span class="keywordtype">double</span>                                     time_step;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassdeclaration"></a> </p><h3>The StokesImmersedProblem class declaration</h3>
<p>We are now ready to introduce the main class of our tutorial program. As usual, other than the constructor, we leave a single public entry point: the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> method. Everything else is left <code>private</code>, and accessed through the run method itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>StokesImmersedProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesImmersedProblem(</div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div></div><!-- fragment --><p>The next section contains the <code>private</code> members of the class. The first method is similar to what is present in previous example. However it not only takes care of generating the grid for the fluid, but also the grid for the solid. The second computes the largest time step that guarantees that each particle moves of at most one cell. This is important to ensure that the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can find which cell a particle ends up in, as it can only look from one cell to its immediate neighbors (because, in a parallel setting, every MPI process only knows about the cells it owns as well as their immediate neighbors).</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The next two functions initialize the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used in this class. We have two such objects: One represents passive tracers, used to plot the trajectories of fluid particles, while the the other represents material particles of the solid, which are placed at quadrature points of the solid grid.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_tracer_particles();</div><div class="line"><span class="keywordtype">void</span> setup_solid_particles();</div></div><!-- fragment --><p>The remainder of the set up is split in two parts: The first of the following two functions creates all objects that are needed once per simulation, whereas the other sets up all objects that need to be reinitialized at every refinement step.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initial_setup();</div><div class="line"><span class="keywordtype">void</span> setup_dofs();</div></div><!-- fragment --><p>The assembly routine is very similar to other Stokes assembly routines, with the exception of the Nitsche restriction part, which exploits one of the particle handlers to integrate on a non-matching part of the fluid domain, corresponding to the position of the solid. We split these two parts into two separate functions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_stokes_system();</div><div class="line"><span class="keywordtype">void</span> assemble_nitsche_restriction();</div></div><!-- fragment --><p>The remaining functions solve the linear system (which looks almost identical to the one in <a class="el" href="step_60.html">step-60</a> ) and then postprocess the solution: The refine_and_transfer() method is called only every <code>refinement_frequency</code> steps to adapt the mesh and also make sure that all the fields that were computed on the time step before refinement are transferred correctly to the new grid. This includes vector fields, as well as particle information. Similarly, we call the two output methods only every <code>output_frequency</code> steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> refine_and_transfer();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle, <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">                      std::string                                 fprefix,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Let us then move on to the member functions of the class. The first deals with run-time parameters that are read from a parameter file. As noted before, we make sure we cannot modify this object from within this class, by making it a <code>const</code> reference.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div></div><!-- fragment --><p>Then there is also the MPI communicator object that we will use to let processes send information across the network if the program runs in parallel, along with the <code>pcout</code> object and timer information that has also been employed by <a class="el" href="step_40.html">step-40</a> , for example:</p>
<div class="fragment"><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line"><span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div></div><!-- fragment --><p>Next is one of the main novelties with regard to <a class="el" href="step_60.html">step-60</a> . Here we assume that both the solid and the fluid are fully distributed triangulations. This allows the problem to scale to a very large number of degrees of freedom, at the cost of communicating all the overlapping regions between non matching triangulations. This is especially tricky, since we make no assumptions on the relative position or distribution of the various subdomains of the two triangulations. In particular, we assume that every process owns only a part of the <code>solid_tria</code>, and only a part of the <code>fluid_tria</code>, not necessarily in the same physical region, and not necessarily overlapping. We could in principle try to create the initial subdivisions in such a way that each process's subdomains overlap between the solid and the fluid regions. However, this overlap would be destroyed during the simulation, and we would have to redistribute the DoFs again and again. The approach we follow in this tutorial is more flexible, and not much more expensive. We make two all-to-all communications at the beginning of the simulation to exchange information about an (approximate) information of the geometrical occupancy of each processor (done through a collection of bounding boxes). This information is used by the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class to exchange (using a some-to-some communication pattern) all particles, so that every process knows about the particles that live on the region occupied by the fluid subdomain that it owns. In order to couple the overlapping regions, we exploit the facilities implemented in the ParticleHandler class.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div></div><!-- fragment --><p>Next come descriptions of the finite elements in use, along with appropriate quadrature formulas and the corresponding <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the current implementation, only <code>fluid_fe</code> is really necessary. For completeness, and to allow easy extension, we also keep the <code>solid_fe</code> around, which is however initialized to a <a class="el" href="classFE__Nothing.html">FE_Nothing</a> finite element space, i.e., one that has no degrees of freedom. We declare both finite element spaces as <code>std::unique_ptr</code> objects rather than regular member variables, to allow their generation after <code>StokesImmersedProblemParameters</code> has been initialized. In particular, they will be initialized in the <code>initial_setup()</code> method.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div><div class="line"></div><div class="line">std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div><div class="line">std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div><div class="line"></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div><div class="line"></div><div class="line">std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div></div><!-- fragment --><p>Similarly to how things are done in <a class="el" href="step_22.html">step-22</a> , we use a block system to treat the Stokes part of the problem, and follow very closely what was done there.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div><div class="line">std::vector&lt;IndexSet&gt; solid_owned_dofs;</div><div class="line"></div><div class="line">std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div><div class="line">std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div></div><!-- fragment --><p>Using this partitioning of degrees of freedom, we can then define all of the objects necessary to describe the linear systems in question:</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> system_matrix;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> solution;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> locally_relevant_solution;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> system_rhs;</div></div><!-- fragment --><p>Let us move to the particles side of this program. There are two <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used to couple the solid with the fluid, and to describe the passive tracers. These, in many ways, play a role similar to the <a class="el" href="classDoFHandler.html">DoFHandler</a> class used in the discretization, i.e., they provide for an enumeration of particles and allow querying information about each particle.</p>
<div class="fragment"><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div></div><!-- fragment --><p>For every tracer particle, we need to compute the velocity field in its current position, and update its position using a discrete time stepping scheme. We do this using distributed linear algebra objects that store the coordinates of each particle's location or velocity. That is, these vectors have <code>tracer_particle_handler.n_global_particles() spacedim</code> entries that we will store in a way so that parts of the vector are partitioned across all processes. (Implicitly, we here make the assumption that the <code>spacedim</code> coordinates of each particle are stored in consecutive entries of the vector.) Thus, we need to determine who the owner of each vector entry is. We set this owner to be equal to the process that generated that particle at time \(t=0\) . This information is stored for every process in the <code>locally_owned_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>. Once the particles have been distributed around to match the process that owns the region where the particle lives, we will need read access from that process to the corresponding velocity field. We achieve this by filling a read only velocity vector field that contains the relevant information in ghost entries. This is achieved using the <code>locally_relevant_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>, that keeps track of how things change during the simulation, i.e., it keeps track of where particles that the current process owns have ended up being, and who owns the particles that ended up in my subdomain. While this is not the most efficient strategy, we keep it this way to illustrate how things would work in a real fluid-structure interaction (FSI) problem. If a particle is linked to a specific solid degree of freedom, we are not free to choose who owns it, and we have to communicate this information around. We illustrate this here, and show that the communication pattern is point-to-point, and negligible in terms of total cost of the algorithm. The vectors defined based on these subdivisions are then used to store the particles velocities (read-only, with ghost entries) and their displacement (read/write, no ghost entries).</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> tracer_particle_velocities;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div></div><!-- fragment --><p>One of the key points of this tutorial program is the coupling between two independent <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, one of which may be moving and deforming (with possibly large deformations) with respect to the other. When both the fluid and the solid triangulations are of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, every process has access only to its fraction of locally owned cells of each of the two triangulations. As mentioned above, in general, the locally owned domains are not overlapping. In order to allow for the efficient exchange of information between non-overlapping <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, some algorithms of the library require the user to provide a rough description of the area occupied by the locally owned part of the triangulation, in the form of a collection of axis-aligned bounding boxes for each process, that provide a full covering of the locally owned part of the domain. This kind of information can then be used in situations where one needs to send information to the owner of the cell surrounding a known location, without knowing who that owner may in fact be. But, if one knows a collection of bounding boxes for the geometric area or volume each process owns, then we can determine a subset of all processes that might possibly own the cell in which that location lies: namely, all of those processes whose bounding boxes contain that point. Instead of sending the information associated to that location to all processes, one can then get away with only sending it to a small subset of the processes with point-to-point communication primitives. (You will notice that this also allows for the typical time-vs-memory trade-off: The more data we are willing to store about each process's owned area</p>
<ul>
<li>in the form of more refined bounding box information</li>
<li>the less communication we have to perform.) We construct this information by gathering a vector (of length <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>) of vectors of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects. We fill this vector using the <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function, and allow the user to select what level of the tree to extract. The "level" corresponds to how coarse/fine the overlap of the area with bounding boxes should be. As an example, this is what would be extracted by the <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function applied to a two dimensional hyper ball, distributed over three processes. Each image shows in green the bounding boxes associated to the locally owned cells of the triangulation on each process, and in violet the bounding boxes extracted from the rtree: <div class="image">
<img src="rtree-process-0.png" alt="rtree-process-0.png"/>
<div class="caption">
html rtree-process-1.png  html rtree-process-2.png</div></div>
 We store these boxes in a global member variable, which is updated at every refinement step:</li>
</ul>
<div class="fragment"><div class="line">  std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassimplementation"></a> </p><h3>The StokesImmersedProblem class implementation</h3>
<p><a class="anchor" id="Objectconstructionandmeshinitializationfunctions"></a> </p><h4>Object construction and mesh initialization functions</h4>
<p>In the constructor, we create the mpi_communicator as well as the triangulations and dof_handler for both the fluid and the solid. Using the mpi_communicator, both the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and <a class="el" href="classTimerOutput.html">TimerOutput</a> object are constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div><div class="line">  <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div><div class="line">  : par(par)</div><div class="line">  , mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">          (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">  , computing_timer(mpi_communicator,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  , fluid_tria(mpi_communicator,</div><div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::MeshSmoothing(</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_refinement |</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_coarsening))</div><div class="line">  , solid_tria(mpi_communicator,</div><div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::MeshSmoothing(</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_refinement |</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_coarsening))</div><div class="line">  , fluid_dh(fluid_tria)</div><div class="line">  , solid_dh(solid_tria)</div><div class="line">{}</div></div><!-- fragment --><p>In order to generate the grid, we first try to use the functions in the deal.II <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, by leveraging the GridGenerator::generate_from_name_and_argument(). If this function fails, then we use the following method, where the name is interpreted as a filename, and the arguments are interpreted as a map from manifold ids to CAD files, and are converted to <a class="el" href="classManifold.html">Manifold</a> descriptors using the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace facilities. At the top, we read the file into a triangulation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> read_grid_and_cad_files(<span class="keyword">const</span> std::string &amp;grid_file_name,</div><div class="line">                             <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div><div class="line">                             <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div><div class="line">{</div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div><div class="line">  grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">  grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div></div><!-- fragment --><p>If we got to this point, then the <a class="el" href="classTriangulation.html">Triangulation</a> has been read, and we are ready to attach to it the correct manifold descriptions. We perform the next lines of code only if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support. For each entry in the map, we try to open the corresponding CAD file, we analyze it, and according to its content, opt for either a OpenCASCADE::ArcLengthProjectionLineManifold (if the CAD file contains a single <code>TopoDS_Edge</code> or a single <code>TopoDS_Wire</code>) or a <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>, if the file contains a single face. Notice that if the CAD files do not contain single wires, edges, or faces, an assertion will be throw in the generation of the <a class="el" href="classManifold.html">Manifold</a>. We use the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class to do the conversion from the string to a map between manifold ids and file names for us:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line">  <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div><div class="line">  <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="namespacePatterns_1_1Tools.html#a59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>   = pair.first;</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> extension = boost::algorithm::to_lower_copy(</div><div class="line">        cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div><div class="line"></div><div class="line">      TopoDS_Shape shape;</div><div class="line">      <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;iges&quot;</span> || extension == <span class="stringliteral">&quot;igs&quot;</span>)</div><div class="line">        shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;step&quot;</span> || extension == <span class="stringliteral">&quot;stp&quot;</span>)</div><div class="line">        shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                    <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div><div class="line">                                      <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div><div class="line">                                      <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div></div><!-- fragment --><p>Now we check how many faces are contained in the <code>Shape</code>. <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> is intrinsically 3D, so if this number is zero, we interpret this as a line manifold, otherwise as a <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> in <code>spacedim</code> = 3, or <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a> in <code>spacedim</code> = 2.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n_elements = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div><div class="line"><span class="keywordflow">if</span> ((std::get&lt;0&gt;(n_elements) == 0))</div><div class="line">  tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div><div class="line">    <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (spacedim == 3)</div><div class="line">  {</div></div><!-- fragment --><p>We use this trick, because <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> is only implemented for spacedim = 3. The check above makes sure that things actually work correctly.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a><span class="keyword">&gt;</span>(&amp;tria);</div><div class="line">    t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                    <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div><div class="line">                      shape));</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div></div><!-- fragment --><p>We also allow surface descriptions in two dimensional spaces based on single NURBS patches. For this to work, the CAD file must contain a single <code>TopoDS_Face</code>.</p>
<div class="fragment"><div class="line">        tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                          <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div><div class="line">                            TopoDS::Face(shape)));</div><div class="line">    }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  (void)ids_and_cad_file_names;</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><p>Now let's put things together, and make all the necessary grids. As mentioned above, we first try to generate the grid internally, and if we fail (i.e., if we end up in the <code>catch</code> clause), then we proceed with the above function. We repeat this pattern for both the fluid and the solid mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">        fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div><div class="line">      read_grid_and_cad_files(par.name_of_fluid_grid,</div><div class="line">                              par.arguments_for_fluid_grid,</div><div class="line">                              fluid_tria);</div><div class="line">    }</div><div class="line">  fluid_tria.refine_global(par.initial_fluid_refinement);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">        solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      read_grid_and_cad_files(par.name_of_solid_grid,</div><div class="line">                              par.arguments_for_solid_grid,</div><div class="line">                              solid_tria);</div><div class="line">    }</div><div class="line"></div><div class="line">  solid_tria.refine_global(par.initial_solid_refinement);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Particleinitializationfunctions"></a> </p><h4>Particle initialization functions</h4>
<p>Once the solid and fluid grids have been created, we start filling the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects. The first one we take care of is the one we use to keep track of passive tracers in the fluid. These are simply transported along, and in some sense their locations are unimportant: We just want to use them to see where flow is being transported. We could use any way we choose to determine where they are initially located. A convenient one is to create the initial locations as the vertices of a mesh in a shape of our choice</p>
<ul>
<li>a choice determined by one of the run-time parameters in the parameter file. In this implementation, we create tracers using the support points of a <a class="el" href="classFE__Q.html">FE_Q</a> finite element space defined on a temporary grid, which is then discarded. Of this grid, we only keep around the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects (stored in a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class) associated to the support points. The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class offers the possibility to insert a set of particles that live physically in the part of the domain owned by the active process. However, in this case this function would not suffice. The particles generated as the locally owned support points of an <a class="el" href="classFE__Q.html">FE_Q</a> object on an arbitrary grid (non-matching with regard to the fluid grid) have no reasons to lie in the same physical region of the locally owned subdomain of the fluid grid. In fact this will almost never be the case, especially since we want to keep track of what is happening to the particles themselves. In particle-in-cell methods (PIC), it is often customary to assign ownership of the particles to the process where the particles lie. In this tutorial we illustrate a different approach, which is useful if one wants to keep track of information related to the particles (for example, if a particle is associated to a given degree of freedom, which is owned by a specific process and not necessarily the same process that owns the fluid cell where the particle happens to be at any given time). In the approach used here, ownership of the particles is assigned once at the beginning, and one-to-one communication happens whenever the original owner needs information from the process that owns the cell where the particle lives. We make sure that we set ownership of the particles using the initial particle distribution, and keep the same ownership throughout the execution of the program. With this overview out of the way, let us see what the function does. At the top, we create a temporary triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object from which we will take the node locations for initial particle locations:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div><div class="line">{</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div><div class="line">    mpi_communicator);</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">    particle_insert_tria,</div><div class="line">    par.name_of_particle_grid,</div><div class="line">    par.arguments_for_particle_grid);</div><div class="line">  particle_insert_tria.refine_global(par.particle_insertion_refinement);</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div><div class="line">  particles_dof_handler.distribute_dofs(particles_fe);</div></div><!-- fragment --><p>This is where things start to get complicated. Since we may run this program in a parallel environment, every parallel process will now have created these temporary triangulations and DoFHandlers. But, in fully distributed triangulations, the active process only knows about the locally owned cells, and has no idea of how other processes have distributed their own cells. This is true for both the temporary triangulation created above as well as the fluid triangulation into which we want to embed the particles below. On the other hand, these locally known portions of the two triangulations will, in general, not overlap. That is, the locations of the particles we will create from the node locations of the temporary mesh are arbitrary, and may fall within a region of the fluid triangulation that the current process doesn't have access to (i.e., a region of the fluid domain where cells are artificial). In order to understand who to send those particles to, we need to have a (rough) idea of how the fluid grid is distributed among processors. We construct this information by first building an index tree of boxes bounding the locally owned cells, and then extracting one of the first levels of the tree:</p>
<div class="fragment"><div class="line">std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div><div class="line">all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    all_boxes.emplace_back(cell-&gt;bounding_box());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div><div class="line">  <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, par.fluid_rtree_extraction_level);</div></div><!-- fragment --><p>Each process now has a collection of bounding boxes that completely enclose all locally owned processes (but that may overlap the bounding boxes of other processes). We then exchange this information between all participating processes so that every process knows the bounding boxes of all other processes. Equipped with this knowledge, we can then initialize the <code>tracer_particle_handler</code> to the fluid mesh and generate the particles from the support points of the (temporary) tracer particles triangulation. This function call uses the <code>global_bounding_boxes</code> object we just constructed to figure out where to send the particles whose locations were derived from the locally owned part of the <code>particles_dof_handler</code>. At the end of this call, every particle will have been distributed to the correct process (i.e., the process that owns the fluid cell where the particle lives). We also output their number to the screen at this point.</p>
<div class="fragment"><div class="line">global_fluid_bounding_boxes =</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div><div class="line"></div><div class="line">tracer_particle_handler.initialize(fluid_tria,</div><div class="line">                                   <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div><div class="line"></div><div class="line"><a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div><div class="line">                                          global_fluid_bounding_boxes,</div><div class="line">                                          tracer_particle_handler);</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div><div class="line">      &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Each particle so created has a unique ID. At some point in the algorithm below, we will need vectors containing position and velocity information for each particle. This vector will have size <code>n_particles spacedim</code>, and we will have to store the elements of this vector in a way so that each parallel process "owns" those elements that correspond to coordinates of the particles it owns. In other words, we have to partition the index space between zero and <code>n_particles spacedim</code> among all processes. We can do this by querying the <code>tracer_particle_handler</code> for the IDs of its locally relevant particles, and construct the indices that would be needed to store in a (parallel distributed) vector of the position and velocity of all particles where we implicitly assume that we store the coordinates of each location or velocity in <code>spacedim</code> successive vector elements (this is what the IndexSet::tensor_priduct() function does).</p>
<div class="fragment"><div class="line">locally_owned_tracer_particle_coordinates =</div><div class="line">  tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">    <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div></div><!-- fragment --><p>At the beginning of the simulation, all particles are in their original position. When particles move, they may traverse to a part of the domain which is owned by another process. If this happens, the current process keeps formally "ownership" of the particles, but may need read access from the process where the particle has landed. We keep this information in another index set, which stores the indices of all particles that are currently on the current process's subdomain, independently if they have always been here or not. Keeping this index set around allows us to leverage linear algebra classes for all communications regarding positions and velocities of the particles. This mimics what would happen in the case where another problem was solved in the solid domain (as in fluid-structure interaction. In this latter case, additional DOFs on the solid domain would be coupled to what is occurring in the fluid domain.</p>
<div class="fragment"><div class="line">locally_relevant_tracer_particle_coordinates =</div><div class="line">  locally_owned_tracer_particle_coordinates;</div></div><!-- fragment --><p>Finally, we make sure that upon refinement, particles are correctly transferred. When performing local refinement or coarsening, particles will land in another cell. We could in principle redistribute all particles after refining, however this would be overly expensive. The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class has a way to transfer information from a cell to its children or to its parent upon refinement, without the need to reconstruct the entire data structure. This is done by registering two callback functions to the triangulation. These functions will receive a signal when refinement is about to happen, and when it has just happened, and will take care of transferring all information to the newly refined grid with minimal computational cost.</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">    [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">  fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div><div class="line">    tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p>Similarly to what we have done for passive tracers, we next set up the particles that track the quadrature points of the solid mesh. The main difference here is that we also want to attach a weight value (the "JxW" value of the quadrature point) to each of particle, so that we can compute integrals even without direct access to the original solid grid. This is achieved by leveraging the "properties" concept of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> class. It is possible to store (in a memory efficient way) an arbitrary number of <code>double</code> numbers for each of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects inside a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> object. We use this possibility to store the JxW values of the quadrature points of the solid grid. In our case, we only need to store one property per particle: the JxW value of the integration on the solid grid. This is passed at construction time to the solid_particle_handler object as the last argument</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(fluid_fe-&gt;degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div><div class="line">  solid_particle_handler.initialize(fluid_tria,</div><div class="line">                                    <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div><div class="line">                                    n_properties);</div></div><!-- fragment --><p>The number of particles that we generate locally is equal to the total number of locally owned cells times the number of quadrature points used in each cell. We store all these points in a vector, and their corresponding properties in a vector of vectors:</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div><div class="line">quadrature_points_vec.reserve(quadrature.size()</div><div class="line">                              solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; properties;</div><div class="line">properties.reserve(quadrature.size()</div><div class="line">                   solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div><div class="line">                             quadrature,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : solid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      fe_v.reinit(cell);</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; points.size(); ++q)</div><div class="line">        {</div><div class="line">          quadrature_points_vec.emplace_back(points[q]);</div><div class="line">          properties.emplace_back(</div><div class="line">            std::vector&lt;double&gt;(n_properties, JxW[q]));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>We proceed in the same way we did with the tracer particles, reusing the computed bounding boxes. However, we first check that the <code>global_fluid_bounding_boxes</code> object has been actually filled. This should certainly be the case here, since this method is called after the one that initializes the tracer particles. However, we want to make sure that if in the future someone decides (for whatever reason) to initialize first the solid particle handler, or to copy just this part of the tutorial, a meaningful exception is thrown when things don't work as expected Since we have already stored the position of the quadrature points, we can use these positions to insert the particles directly using the <code>solid_particle_handler</code> instead of having to go through a <a class="el" href="namespaceParticles_1_1Generators.html">Particles::Generators</a> function:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div><div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div><div class="line">         <span class="stringliteral">&quot;I was expecting the &quot;</span></div><div class="line">         <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div><div class="line">         <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div><div class="line">         <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">solid_particle_handler.insert_global_particles(quadrature_points_vec,</div><div class="line">                                               global_fluid_bounding_boxes,</div><div class="line">                                               properties);</div></div><!-- fragment --><p>As in the previous function, we end by making sure that upon refinement, particles are correctly transferred:</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">    [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">  fluid_tria.signals.post_distributed_refinement.connect(</div><div class="line">    [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DoFinitializationfunctions"></a> </p><h4>DoF initialization functions</h4>
<p>We set up the finite element space and the quadrature formula to be used throughout the step. For the fluid, we use Taylor-Hood elements (e.g. \(Q_k \times Q_{k-1}\) ). Since we do not solve any equation on the solid domain, an empty finite element space is generated. A natural extension of this program would be to solve a fluid structure interaction problem, which would require that the <code>solid_fe</code> use more useful <a class="el" href="classFiniteElement.html">FiniteElement</a> class. Like for many other functions, we store the time necessary to carry out the operations we perform here. The current function puts its timing information into a section with label "Initial setup". Numerous other calls to this timer are made in various functions. They allow to monitor the absolute and relative cost of each individual function to identify bottlenecks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div><div class="line"></div><div class="line">  fluid_fe =</div><div class="line">    std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div><div class="line">                                         spacedim,</div><div class="line">                                         <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree</div><div class="line"></div><div class="line">-</div><div class="line">                                                        1),</div><div class="line">                                         1);</div><div class="line"></div><div class="line"></div><div class="line">  solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div><div class="line">  solid_dh.distribute_dofs(*solid_fe);</div><div class="line"></div><div class="line">  fluid_quadrature_formula =</div><div class="line">    std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">  solid_quadrature_formula =</div><div class="line">    std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">}</div></div><!-- fragment --><p>We next construct the distributed block matrices and vectors which are used to solve the linear equations that arise from the problem. This function is adapted from <a class="el" href="step_55.html">step-55</a> and we refer to this step for a thorough explanation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div><div class="line"></div><div class="line">  fluid_dh.distribute_dofs(*fluid_fe);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0);</div><div class="line">  stokes_sub_blocks[spacedim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">        &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">-- &quot;</span></div><div class="line">        &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div><div class="line">        &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  fluid_owned_dofs.resize(2);</div><div class="line">  fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div><div class="line">  fluid_owned_dofs[1] =</div><div class="line">    fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div><div class="line">  fluid_relevant_dofs.resize(2);</div><div class="line">  fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div><div class="line">  fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.reinit(locally_relevant_dofs);</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      fluid_dh,</div><div class="line">      0,</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(spacedim + 1),</div><div class="line">      constraints,</div><div class="line">      fluid_fe-&gt;component_mask(velocities));</div><div class="line">    constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator,</div><div class="line">                               fluid_dh.locally_owned_dofs());</div><div class="line">  {</div><div class="line">    system_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == spacedim || d == spacedim || c == d)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">      dsp,</div><div class="line">      locally_owned_dofs_per_processor,</div><div class="line">      mpi_communicator,</div><div class="line">      locally_relevant_dofs);</div><div class="line"></div><div class="line">    system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">      dsp,</div><div class="line">      locally_owned_dofs_per_processor,</div><div class="line">      mpi_communicator,</div><div class="line">      locally_relevant_dofs);</div><div class="line">    preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line">  locally_relevant_solution.reinit(fluid_owned_dofs,</div><div class="line">                                   fluid_relevant_dofs,</div><div class="line">                                   mpi_communicator);</div><div class="line">  system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">  solution.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyfunctions"></a> </p><h4>Assembly functions</h4>
<p>We assemble the system matrix, the preconditioner matrix, and the right hand side. The code is adapted from <a class="el" href="step_55.html">step-55</a> , which is essentially what <a class="el" href="step_27.html">step-27</a> also has, and is pretty standard if you know what the Stokes equations look like.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  system_matrix         = 0;</div><div class="line">  preconditioner_matrix = 0;</div><div class="line">  system_rhs            = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div><div class="line">                              fluid_quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fluid_quadrature_formula-&gt;size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points,</div><div class="line">                                         Vector&lt;double&gt;(spacedim + 1));</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;              div_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;              phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure(spacedim);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_matrix  = 0;</div><div class="line">        cell_matrix2 = 0;</div><div class="line">        cell_rhs     = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        par.rhs.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                  rhs_values);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_u[k] = fe_values[velocities].gradient(k, q);</div><div class="line">                div_phi_u[k]  = fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]      = fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (par.viscosity</div><div class="line">                         <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j])</div><div class="line"></div><div class="line">-</div><div class="line">                       div_phi_u[i] phi_p[j]</div><div class="line"></div><div class="line">- phi_p[i] div_phi_u[j])</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">                    cell_matrix2(i, j) += 1.0 / par.viscosity phi_p[i]</div><div class="line">                                          phi_p[j] fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                  fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)</div><div class="line">                               rhs_values[q](component_i) fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix2,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               preconditioner_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">  system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>The following method is then the one that deals with the penalty terms that result from imposing the velocity on the impeller. It is, in a sense, the heart of the tutorial, but it is relatively straightforward. Here we exploit the <code>solid_particle_handler</code> to compute the Nitsche restriction or the penalization in the embedded domain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);</div><div class="line"></div><div class="line">  SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div><div class="line">    fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div><div class="line">                                  fluid_fe-&gt;n_dofs_per_cell());</div><div class="line">  <a class="code" href="classVector.html">::Vector&lt;double&gt;</a> local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div><div class="line">    1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div></div><!-- fragment --><p>We loop over all the local particles. Although this could be achieved directly by looping over all the cells, this would force us to loop over numerous cells which do not contain particles. Consequently, we loop over all the particles, but, we get the reference of the cell in which the particle lies and then loop over all particles within that cell. This enables us to skip the cells which do not contain particles, yet to assemble the local matrix and rhs of each cell to apply the Nitsche restriction. Once we are done with all particles on one cell, we advance the <code>particle</code> iterator to the particle past the end of the ones on the current cell (this is the last line of the <code>while</code> loop's body).</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> particle = solid_particle_handler.begin();</div><div class="line"><span class="keywordflow">while</span> (particle != solid_particle_handler.end())</div><div class="line">  {</div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs    = 0;</div></div><!-- fragment --><p>We get an iterator to the cell within which the particle lies from the particle itself. We can then assemble the additional terms in the system matrix and the right hand side as we would normally.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*cell, &amp;fluid_dh);</div><div class="line">dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div></div><!-- fragment --><p>So then let us get the collection of cells that are located on this cell and iterate over them. From each particle we gather the location and the reference location of the particle as well as the additional information that is attached to the particle. In the present case, this information is the "JxW" of the quadrature points which were used to generate the particles. Using this information, we can add the contribution of the quadrature point to the local_matrix and local_rhs. We can evaluate the value of the shape function at the position of each particle easily by using its reference location.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(cell);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == particle, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pic)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = p.get_reference_location();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = p.get_location();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = p.get_properties()[0];</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fluid_fe-&gt;n_dofs_per_cell(); ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div><div class="line">                fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">              <span class="keywordflow">if</span> (comp_i &lt; spacedim)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div><div class="line">                        fluid_fe-&gt;system_to_component_index(j).first;</div><div class="line">                      <span class="keywordflow">if</span> (comp_i == comp_j)</div><div class="line">                        local_matrix(i, j) +=</div><div class="line">                          penalty_parameter par.penalty_term</div><div class="line">                          fluid_fe-&gt;shape_value(i, ref_q)</div><div class="line">                          fluid_fe-&gt;shape_value(j, ref_q) JxW;</div><div class="line">                    }</div><div class="line">                  local_rhs(i) += penalty_parameter par.penalty_term</div><div class="line">                                  solid_velocity.value(real_q, comp_i)</div><div class="line">                                  fluid_fe-&gt;shape_value(i, ref_q) JxW;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                             local_rhs,</div><div class="line">                                             fluid_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">      particle = pic.end();</div><div class="line">    }</div><div class="line"></div><div class="line">  system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solvingthelinearsystem"></a> </p><h4>Solving the linear system</h4>
<p>This function solves the linear system with FGMRES with a block diagonal preconditioner and an algebraic multigrid (AMG) method for the diagonal blocks. The preconditioner applies a V cycle to the \((0,0)\) (i.e., the velocity-velocity) block and a CG with the mass matrix for the \((1,1)\) block (which is our approximation to the Schur complement: the pressure mass matrix assembled above).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">  LA::MPI::PreconditionAMG prec_A;</div><div class="line">  {</div><div class="line">    LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">    data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    prec_A.initialize(system_matrix.block(0, 0), data);</div><div class="line">  }</div><div class="line"></div><div class="line">  LA::MPI::PreconditionAMG prec_S;</div><div class="line">  {</div><div class="line">    LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">    data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    prec_S.initialize(preconditioner_matrix.block(1, 1), data);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, prec_A);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> S =</div><div class="line">    linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(S, prec_S);</div><div class="line"></div><div class="line">  <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div><div class="line">                                        1e-8 system_rhs.l2_norm(),</div><div class="line">                                        1.e-2);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div><div class="line">    std::array&lt;</div><div class="line">      ::LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;,</div><div class="line">      2&gt;{{amgA, amgS}});</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div><div class="line">                               1e-10 system_rhs.l2_norm());</div><div class="line"></div><div class="line">  <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">  constraints.set_zero(solution);</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, P);</div><div class="line"></div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line"></div><div class="line">  locally_relevant_solution = solution;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div><div class="line">    VectorTools::compute_mean_value(fluid_dh,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div><div class="line">                                    locally_relevant_solution,</div><div class="line">                                    spacedim);</div><div class="line">  solution.block(1).add(-mean_pressure);</div><div class="line">  locally_relevant_solution.block(1) = solution.block(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Meshrefinement"></a> </p><h4>Mesh refinement</h4>
<p>We deal with mesh refinement in a completely standard way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell(fluid_tria.n_active_cells());</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss</a>&lt;spacedim</div><div class="line"></div><div class="line">- 1&gt;(</div><div class="line">                                            par.velocity_degree + 1),</div><div class="line">                                          {},</div><div class="line">                                          locally_relevant_solution,</div><div class="line">                                          error_per_cell,</div><div class="line">                                          fluid_fe-&gt;component_mask(velocity));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">        refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div><div class="line">                                          error_per_cell,</div><div class="line">                                          par.refinement_fraction,</div><div class="line">                                          par.coarsening_fraction);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">        fluid_tria,</div><div class="line">        error_per_cell,</div><div class="line">        par.refinement_fraction,</div><div class="line">        par.coarsening_fraction,</div><div class="line">        par.max_cells);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;refine_flag_set() &amp;&amp;</div><div class="line">          cell-&gt;level() == par.max_level_refinement)</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;coarsen_flag_set() &amp;&amp;</div><div class="line">          cell-&gt;level() == par.min_level_refinement)</div><div class="line">        cell-&gt;clear_coarsen_flag();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div><div class="line">    transfer(fluid_dh);</div><div class="line">  fluid_tria.prepare_coarsening_and_refinement();</div><div class="line">  transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div><div class="line">  fluid_tria.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  transfer.interpolate(solution);</div><div class="line">  constraints.distribute(solution);</div><div class="line">  locally_relevant_solution = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingoutputforvisualization"></a> </p><h4>Creating output for visualization</h4>
<p>We output the results (velocity and pressure) on the fluid domain using the standard parallel capabilities of deal.II. A single compressed vtu file is written that agglomerates the information of all processors. An additional <code>.pvd</code> record is written to associate the physical time to the vtu files.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle,</div><div class="line">                                                     <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_names(spacedim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      spacedim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(fluid_dh);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(locally_relevant_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(fluid_tria.n_active_cells());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">    subdomain(i) = fluid_tria.locally_owned_subdomain();</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                 mpi_communicator);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line">  times_and_names.push_back(std::make_pair(time, filename));</div><div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div><div class="line">}</div></div><!-- fragment --><p>Similarly, we write the particles (either from the solid or the tracers) as a single compressed vtu file through the <a class="el" href="classParticles_1_1DataOut.html">Particles::DataOut</a> object. This simple object does not write the additional information attached as "properties" to the particles, but only writes their id</p>
<ul>
<li>but then, we don't care about the "JxW" values of these particle locations anyway, so no information that we may have wanted to visualize is lost.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">  std::string                                 fprefix,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div><div class="line">  particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(particles);</div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  particles_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                      mpi_communicator);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div><div class="line">    times_and_names;</div><div class="line">  <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div><div class="line">    times_and_names[fprefix].push_back(std::make_pair(time, filename));</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    times_and_names[fprefix] = {std::make_pair(time, filename)};</div><div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunction"></a> </p><h4>The "run" function</h4>
<p>This function now orchestrates the entire simulation. It is very similar to the other time dependent tutorial programs</p>
<ul>
<li>take <a class="el" href="step_21.html">step-21</a> or <a class="el" href="step_26.html">step-26</a> as an example. At the beginning, we output some status information and also save all current parameters to a file in the output directory, for reproducibility.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">        &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">        &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div><div class="line">                             <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) +</div><div class="line">                             <span class="stringliteral">&quot;.prm&quot;</span>,</div><div class="line">                           <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a>);</div></div><!-- fragment --><p>We then start the time loop. We initialize all the elements of the simulation in the first cycle</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps</div><div class="line"></div><div class="line">- 1);</div><div class="line">  <span class="keywordtype">double</span>       time         = 0;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; par.number_of_time_steps;</div><div class="line">       ++cycle, time += time_step)</div><div class="line">    {</div><div class="line">      par.set_time(time);</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        {</div><div class="line">          make_grid();</div><div class="line">          initial_setup();</div><div class="line">          setup_dofs();</div><div class="line">          setup_tracer_particles();</div><div class="line">          setup_solid_particles();</div><div class="line">          tracer_particle_velocities.reinit(</div><div class="line">            locally_owned_tracer_particle_coordinates, mpi_communicator);</div><div class="line">          output_results(output_cycle, time);</div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">            output_particles(tracer_particle_handler,</div><div class="line">                             <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                             output_cycle,</div><div class="line">                             time);</div><div class="line">          }</div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">            output_particles(solid_particle_handler,</div><div class="line">                             <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                             output_cycle,</div><div class="line">                             time);</div><div class="line">          }</div><div class="line">        }</div></div><!-- fragment --><p>After the first time step, we displace the solid body at the beginning of each time step to take into account the fact that is has moved.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div><div class="line">                         <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div><div class="line"></div><div class="line">    SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div><div class="line">                                           time_step);</div><div class="line">    solid_particle_handler.set_particle_positions(solid_position,</div><div class="line">                                                  <span class="keyword">false</span>);</div><div class="line">  }</div></div><!-- fragment --><p>In order to update the state of the system, we first interpolate the fluid velocity at the position of the tracer particles and, with a naive explicit Euler scheme, advect the massless tracer particles.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div><div class="line">  <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div><div class="line">    fluid_dh,</div><div class="line">    tracer_particle_handler,</div><div class="line">    locally_relevant_solution,</div><div class="line">    tracer_particle_velocities,</div><div class="line">    fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div><div class="line"></div><div class="line">  tracer_particle_velocities= time_step;</div><div class="line"></div><div class="line">  locally_relevant_tracer_particle_coordinates =</div><div class="line">    tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">      <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">  relevant_tracer_particle_displacements.reinit(</div><div class="line">    locally_owned_tracer_particle_coordinates,</div><div class="line">    locally_relevant_tracer_particle_coordinates,</div><div class="line">    mpi_communicator);</div><div class="line"></div><div class="line">  relevant_tracer_particle_displacements = tracer_particle_velocities;</div><div class="line"></div><div class="line">  tracer_particle_handler.set_particle_positions(</div><div class="line">    relevant_tracer_particle_displacements);</div><div class="line">}</div></div><!-- fragment --><p>Using these new locations, we can then assemble the Stokes system and solve it.</p>
<div class="fragment"><div class="line">assemble_stokes_system();</div><div class="line">assemble_nitsche_restriction();</div><div class="line">solve();</div></div><!-- fragment --><p>With the appropriate frequencies, we then write the information of the solid particles, the tracer particles, and the fluid domain into files for visualization, and end the time step by adapting the mesh.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (cycle % par.output_frequency == 0)</div><div class="line">        {</div><div class="line">          output_results(output_cycle, time);</div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">            output_particles(tracer_particle_handler,</div><div class="line">                             <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                             output_cycle,</div><div class="line">                             time);</div><div class="line">          }</div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">            output_particles(solid_particle_handler,</div><div class="line">                             <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                             output_cycle,</div><div class="line">                             time);</div><div class="line">          }</div><div class="line">          ++output_cycle;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">if</span> (cycle % par.refinement_frequency == 0 &amp;&amp;</div><div class="line">          cycle != par.number_of_time_steps</div><div class="line"></div><div class="line">- 1)</div><div class="line">        refine_and_transfer();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step70</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The remainder of the code, the <code>main()</code> function, is standard, with the exception of the handling of input parameter files. We allow the user to specify an optional parameter file as an argument to the program. If nothing is specified, we use the default file "parameters.prm", which is created if non existent. The file name is scanned for the the string "23" first, and "3" afterwards. If the filename contains the string "23", the problem classes are instantiated with template arguments 2 and 3 respectively. If only the string "3" is found, then both template arguments are set to 3, otherwise both are set to 2.</p>
<p>If the program is called without any command line arguments (i.e., <code>argc==1</code>), then we just use "parameters.prm" by default.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span>Step70;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"><a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">    std::string prm_file;</div><div class="line">    <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">      prm_file = argv[1];</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div><div class="line">      {</div><div class="line">        StokesImmersedProblemParameters&lt;2, 3&gt; par;</div><div class="line">        <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">        StokesImmersedProblem&lt;2, 3&gt; problem(par);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div><div class="line">      {</div><div class="line">        StokesImmersedProblemParameters&lt;3&gt; par;</div><div class="line">        <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">        StokesImmersedProblem&lt;3&gt; problem(par);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        StokesImmersedProblemParameters&lt;2&gt; par;</div><div class="line">        <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">        StokesImmersedProblem&lt;2&gt; problem(par);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The directory in which this program is run contains a number of sampleparameter files that you can use to reproduce the results presented in thissection. If you do not specify a parameter file as an argument on the commandline, the program will try to read the file "`parameters.prm`" by default, andwill execute the two dimensional version of the code. As explained inthe discussion of the source code, ifyour file name contains the string "23", then the program will run a threedimensional problem, with immersed solid of co-dimension one. If it containsthe string "3", it will run a three dimensional problem, with immersed solid ofco-dimension zero, otherwise it will run a two dimensional problem withimmersed solid of co-dimension zero. Regardless of the specific parameter file name, if the specified file does notexist, when you execute the program you will get an exception that no such filecan be found: </p><div class="fragment"><div class="line">----------------------------------------------------</div><div class="line">Exception on processing:</div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;74&gt; of file &lt;../source/base/parameter_acceptor.cc&gt; in <span class="keyword">function</span></div><div class="line"> <span class="keyword">static</span> void ::ParameterAcceptor::initialize(<span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>, ::<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;)</div><div class="line">The violated condition was:</div><div class="line"> <span class="keyword">false</span></div><div class="line">Additional information:</div><div class="line"> You specified &lt;parameters.prm&gt; as input parameter file, but it does not exist. We created it <span class="keywordflow">for</span> you.</div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line"></div><div class="line">Aborting!</div><div class="line"></div><div class="line">----------------------------------------------------</div></div><!-- fragment --><p>However, as the error message already states, the code that triggers theexception will also generate the specified file ("`parameters.prm`" in this case)that simply contains the default values for all parameters this program caresabout (for the correct dimension and co-dimension, according to the whether astring "23" or "3" is contained in the file name). By inspection of the defaultparameter file, we see the following: </p><div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line"></div><div class="line">---------------------</div><div class="line">subsection Stokes Immersed Problem</div><div class="line"><span class="keyword">set</span> Final time                            = 1</div><div class="line"><span class="preprocessor"># Extraction level of the rtree used to construct global bounding boxes</span></div><div class="line"><span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line"></div><div class="line"><span class="preprocessor"># Boundary Ids over which homogeneous Dirichlet boundary conditions are</span></div><div class="line"><span class="preprocessor"># applied</span></div><div class="line"><span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line"></div><div class="line"><span class="preprocessor"># Initial mesh refinement used for the fluid domain Omega</span></div><div class="line"><span class="keyword">set</span> Initial fluid refinement              = 5</div><div class="line"></div><div class="line"><span class="preprocessor"># Initial mesh refinement used for the solid domain Gamma</span></div><div class="line"><span class="keyword">set</span> Initial solid refinement              = 5</div><div class="line"><span class="keyword">set</span> Nitsche penalty term                  = 100</div><div class="line"><span class="keyword">set</span> Number of time steps                  = 501</div><div class="line"><span class="keyword">set</span> Output directory                      = .</div><div class="line">set Output frequency                      = 1</div><div class="line"></div><div class="line"><span class="preprocessor"># Refinement of the volumetric mesh used to insert the particles</span></div><div class="line"><span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line"><span class="keyword">set</span> Velocity degree                       = 2</div><div class="line"><span class="keyword">set</span> Viscosity                             = 1</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Angular velocity</div><div class="line"><span class="preprocessor"> # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor"> # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor"> # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor"> # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor"> #</span></div><div class="line"><span class="preprocessor"> # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor"> # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor"> # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor"> # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"><span class="preprocessor"> # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor"> # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor"> # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor"> # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor"> # addition, it may contain expressions like `if(x&gt;0, 1,</span></div><div class="line"></div><div class="line">-1)<span class="stringliteral">&#39; where the</span></div><div class="line"><span class="stringliteral"> # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="stringliteral"> # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="stringliteral"> # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="stringliteral"> # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="stringliteral"> #</span></div><div class="line"><span class="stringliteral"> # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="stringliteral"> # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="stringliteral"> # components by a semicolon.</span></div><div class="line"><span class="stringliteral"> set Function expression = t &lt; .500001 ? 6.283185 :</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">-6.283185 # default: 0</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"> # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="stringliteral"> # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="stringliteral"> # function will be evaluated are `x&#39;</span> (in 1d), `x,y<span class="stringliteral">&#39; (in 2d) or `x,y,z&#39;</span> (in</div><div class="line"><span class="preprocessor"> # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor"> # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor"> # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor"> # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor"> # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor"> # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor"> # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor"> # your function expression.</span></div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line"></div><div class="line">subsection Grid generation</div><div class="line"> <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div><div class="line"> <span class="keyword">set</span> Fluid grid generator arguments    =</div><div class="line"></div><div class="line">-1: 1: <span class="keyword">false</span></div><div class="line"> <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line"> <span class="keyword">set</span> Particle grid generator arguments = 0.3, 0.3: 0.1: <span class="keyword">false</span></div><div class="line"> <span class="keyword">set</span> Solid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line"> <span class="keyword">set</span> Solid grid generator arguments    =</div><div class="line"></div><div class="line">-.5,</div><div class="line"></div><div class="line">-.1: .5, .1: <span class="keyword">false</span></div><div class="line">end</div><div class="line"></div><div class="line">subsection Refinement and remeshing</div><div class="line"> <span class="keyword">set</span> Maximum number of cells        = 20000</div><div class="line"> <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line"> <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line"> <span class="keyword">set</span> Refinement maximal level       = 8</div><div class="line"> <span class="keyword">set</span> Refinement minimal level       = 5</div><div class="line"> <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line"> <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">end</div><div class="line"></div><div class="line">subsection Right hand side</div><div class="line"><span class="preprocessor"> # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor"> # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor"> # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor"> # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor"> #</span></div><div class="line"><span class="preprocessor"> # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor"> # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor"> # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor"> # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"><span class="preprocessor"> # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor"> # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor"> # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor"> # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor"> # addition, it may contain expressions like `if(x&gt;0, 1,</span></div><div class="line"></div><div class="line">-1)<span class="stringliteral">&#39; where the</span></div><div class="line"><span class="stringliteral"> # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="stringliteral"> # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="stringliteral"> # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="stringliteral"> # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="stringliteral"> #</span></div><div class="line"><span class="stringliteral"> # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="stringliteral"> # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="stringliteral"> # components by a semicolon.</span></div><div class="line"><span class="stringliteral"> set Function expression = 0; 0; 0</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"> # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="stringliteral"> # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="stringliteral"> # function will be evaluated are `x&#39;</span> (in 1d), `x,y<span class="stringliteral">&#39; (in 2d) or `x,y,z&#39;</span> (in</div><div class="line"><span class="preprocessor"> # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor"> # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor"> # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor"> # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor"> # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor"> # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor"> # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor"> # your function expression.</span></div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line"></div><div class="line">end</div></div><!-- fragment --><p>If you now run the program, you will get a file called <code>parameters_22.prm</code> inthe directory specified by the parameter <code>Output directory</code> (which defaults tothe current directory) containing a shorter version of the above parameters(without comments and documentation), documenting all parameters that were usedto run your program: </p><div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line"><span class="keyword">set</span> Final time                            = 1</div><div class="line"><span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line"><span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line"><span class="keyword">set</span> Initial fluid refinement              = 5</div><div class="line"><span class="keyword">set</span> Initial solid refinement              = 5</div><div class="line"><span class="keyword">set</span> Nitsche penalty term                  = 100</div><div class="line"><span class="keyword">set</span> Number of time steps                  = 501</div><div class="line"><span class="keyword">set</span> Output directory                      = .</div><div class="line">set Output frequency                      = 1</div><div class="line"><span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line"><span class="keyword">set</span> Velocity degree                       = 2</div><div class="line"><span class="keyword">set</span> Viscosity                             = 1</div><div class="line">subsection Angular velocity</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 :</div><div class="line"></div><div class="line">-6.283185</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line">subsection Grid generation</div><div class="line"> <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div><div class="line"> <span class="keyword">set</span> Fluid grid generator arguments    =</div><div class="line"></div><div class="line">-1: 1: <span class="keyword">false</span></div><div class="line"> <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line"> <span class="keyword">set</span> Particle grid generator arguments = 0.3, 0.3: 0.1: <span class="keyword">false</span></div><div class="line"> <span class="keyword">set</span> Solid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line"> <span class="keyword">set</span> Solid grid generator arguments    =</div><div class="line"></div><div class="line">-.5,</div><div class="line"></div><div class="line">-.1: .5, .1: <span class="keyword">false</span></div><div class="line">end</div><div class="line">subsection Refinement and remeshing</div><div class="line"> <span class="keyword">set</span> Maximum number of cells        = 20000</div><div class="line"> <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line"> <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line"> <span class="keyword">set</span> Refinement maximal level       = 8</div><div class="line"> <span class="keyword">set</span> Refinement minimal level       = 5</div><div class="line"> <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line"> <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">end</div><div class="line">subsection Right hand side</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line">end</div></div><!-- fragment --><p>The rationale behind creating first <code>parameters.prm</code> file (the first time theprogram is run) and then a <code>output/parameters_22.prm</code> (every time yourun the program with an existing input file), is because you may wantto leave most parameters to theirdefault values, and only modify a handful of them, while still beeing able toreproduce the results and inspect what parameters were used for a specificsimulation. It is generally good scientific practice to store theparameter file you used for a simulation along with the simulationoutput so that you can repeat the exact same run at a later time if necessary. Another reason is because the input file may only contain thoseparameters that differ from their defaults.For example, you could use the following (perfectly valid) parameter file withthis tutorial program: </p><div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line"><span class="keyword">set</span> Final time                         = 1</div><div class="line"><span class="keyword">set</span> Nitsche penalty term               = 10</div><div class="line"><span class="keyword">set</span> Number of time steps               = 101</div><div class="line"><span class="keyword">set</span> Velocity degree                    = 3</div><div class="line">end</div></div><!-- fragment --><p> and you would run the program with Q3/Q2 Taylor-Hood finite elements, for 101steps, using a Nitsche penalty of <code>10</code>, and leaving all the other parameters totheir default value. The output directory then contains a record ofnot just these parameters, but indeed all parameters used in thesimulation. You can inspect all the other parameters in theproduced file <code>parameters_22.prm</code>.</p>
<p><a class="anchor" id="Twodimensionaltestcase"></a></p><h3>Two dimensional test case </h3>
<p>The default problem generates a co-dimension zero impeller, consisting of arotating rectangular grid, where the rotation is for half a time unit in onedirection, and half a time unit in the opposite direction, with constant angularvelocity equal to \(\approx 2\pi \frac{\text{rad}}{\text{time unit}}\) . Consequently, the impeller does half arotation and returns to its original position. The following animationdisplays the velocity magnitude, the motion of the solid impeller and of thetracer particles.</p>
<div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-70.2d_tracing.gif" width="500"/>
</div>
 </div> <p>On one core, the output of the program will look like the following: </p><div class="fragment"><div class="line">bash@f$ mpirun</div><div class="line"></div><div class="line">-np 1 ./step-70 test.prm</div><div class="line">Running StokesImmersedProblem&lt;2&gt; <span class="keyword">using</span> Trilinos.</div><div class="line">Cycle 0:</div><div class="line">Time : 0, time step: 0.002</div><div class="line">Number of degrees of freedom: 9539 (8450+1089</div><div class="line"></div><div class="line">-- 0+0)</div><div class="line">Tracer particles: 337</div><div class="line">Solid particles: 9216</div><div class="line">Solved in 158 iterations.</div><div class="line">Number of degrees of freedom: 9845 (8722+1123</div><div class="line"></div><div class="line">-- 9216+337)</div><div class="line">Cycle 1:</div><div class="line">Time : 0.002, time step: 0.002</div><div class="line">Solved in 142 iterations.</div><div class="line">Cycle 2:</div><div class="line">Time : 0.004, time step: 0.002</div><div class="line">Solved in 121 iterations.</div><div class="line">Cycle 3:</div><div class="line">Time : 0.006, time step: 0.002</div><div class="line">Solved in 121 iterations.</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Cycle 499:</div><div class="line">Time : 0.998, time step: 0.002</div><div class="line">Solved in 199 iterations.</div><div class="line">Cycle 500:</div><div class="line">Time : 1, time step: 0.002</div><div class="line">Solved in 196 iterations.</div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |       302s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble Nitsche terms          |       501 |      43.3s |        14% |</div><div class="line">| Assemble Stokes terms           |       501 |      21.5s |       7.1% |</div><div class="line">| Initial setup                   |         1 |  0.000792s |         0% |</div><div class="line">| Output fluid                    |       502 |      31.8s |        11% |</div><div class="line">| Output solid particles          |       502 |      32.2s |        11% |</div><div class="line">| Output tracer particles         |       502 |      0.61s |       0.2% |</div><div class="line">| Refine                          |       100 |      4.68s |       1.5% |</div><div class="line">| Set solid particle position     |       500 |      3.34s |       1.1% |</div><div class="line">| Set tracer particle motion      |       501 |     0.729s |      0.24% |</div><div class="line">| Setup dofs                      |       101 |       2.2s |      0.73% |</div><div class="line">| Solve                           |       501 |       164s |        54% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>You may notice that assembling the coupling system is more expensive thanassembling the Stokes part. This depends highly on the number of Gauss points(solid particles) that are used to apply the Nitsche restriction.In the present case, a relatively low number of tracer particles are used.Consequently, tracking their motion is relatively cheap. The following movie shows the evolution of the solution over time: <p
 align="center"> <iframe width="560" height="315"
 src="https://www.youtube.com/embed/y4Gypj2jpXw" frameborder="0"
 allow="accelerometer; autoplay; encrypted-media; gyroscope;
 picture-in-picture" allowfullscreen></iframe> </p> </p>
<p>The movie shows the rotating obstacle in gray (actually asuperposition of the solid particles plotted with large enough dotsthat they overlap), <a href="https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines">streamlines of the fluid flow</a> in light colors (including the corner verticesthat form at specific times during the simulation), and the tracer particles inbluish tones. The simulation shows that at the end time,the tracer particles have somewhat returned to theiroriginal position, although they have been distorted by the flow field. Thefollowing image compares the initial and the final position of the particlesafter one time unit of flow. </p>
<div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-70.tracer_comparison.png" width="500"/>
</div>
 </div> <p>In this case, we see that the tracer particles that were outside of the sweptvolume of the impeller have returned very close to their initial position,whereas those in the swept volume were slightly more deformed. This deformationis non-physical. It is caused by the numerical error induced by the explicitEuler scheme used to advect the particles, by the loss of accuracy due to thefictitious domain and, finally, by the discretization error on the Stokesequations. The first two errors are the leading cause of this deformation andthey could be alleviated by the use of a finer mesh and a lower time step.</p>
<p><a class="anchor" id="Threedimensionaltestcase"></a></p><h3>Three dimensional test case </h3>
<p>To play around a little bit, we complicate the fictitious domain (taken fromhttps://grabcad.com/library/lungstors-blower-1), and run a co-dimension onesimulation in three space dimensions, using the following"`parameters_23.prm`" file : </p><div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line"><span class="keyword">set</span> Final time                            = 1</div><div class="line"><span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line"><span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line"><span class="keyword">set</span> Initial fluid refinement              = 3</div><div class="line"><span class="keyword">set</span> Initial solid refinement              = 0</div><div class="line"><span class="keyword">set</span> Nitsche penalty term                  = 10</div><div class="line"><span class="keyword">set</span> Number of time steps                  = 101</div><div class="line"><span class="keyword">set</span> Output frequency                      = 1</div><div class="line"><span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line"><span class="keyword">set</span> Velocity degree                       = 2</div><div class="line"><span class="keyword">set</span> Viscosity                             = 1</div><div class="line">subsection Angular velocity</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 5 :</div><div class="line"></div><div class="line">-5</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,z,t</div><div class="line">end</div><div class="line">subsection Grid generation</div><div class="line"> <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line"> <span class="keyword">set</span> Fluid grid generator arguments    =</div><div class="line"></div><div class="line">-50,-50,</div><div class="line"></div><div class="line">-10: 50, 50, 40: <span class="keyword">false</span></div><div class="line"> <span class="keyword">set</span> Solid grid generator              = impeller.vtk</div><div class="line"> <span class="keyword">set</span> Solid grid generator arguments    = 1:impeller.step</div><div class="line"> <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line"> <span class="keyword">set</span> Particle grid generator arguments = 30, 30, 20: 10: <span class="keyword">false</span></div><div class="line">end</div><div class="line">subsection Refinement and remeshing</div><div class="line"> <span class="keyword">set</span> Maximum number of cells        = 100000</div><div class="line"> <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line"> <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line"> <span class="keyword">set</span> Refinement maximal level       = 6</div><div class="line"> <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line"> <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">end</div><div class="line">subsection Right hand side</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0; 0</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,z,t</div><div class="line">end</div><div class="line">end</div></div><!-- fragment --><p>In this case, the timing outputs are a bit different: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |  5.54e+03s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble Nitsche terms          |       101 |       111s |         2% |</div><div class="line">| Assemble Stokes terms           |       101 |       208s |       3.8% |</div><div class="line">| Initial setup                   |         1 |   0.00187s |         0% |</div><div class="line">| Output fluid                    |       102 |      15.5s |      0.28% |</div><div class="line">| Output solid particles          |       102 |      2.63s |         0% |</div><div class="line">| Output tracer particles         |       102 |      2.49s |         0% |</div><div class="line">| Refine                          |        20 |      18.4s |      0.33% |</div><div class="line">| Set solid particle position     |       100 |       6.1s |      0.11% |</div><div class="line">| Set tracer particle motion      |       101 |      10.8s |       0.2% |</div><div class="line">| Setup dofs                      |        21 |      13.9s |      0.25% |</div><div class="line">| Solve                           |       101 |  5.16e+03s |        93% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>Now, the solver is taking most of the solution time in three dimensions,and the particle motion and Nitsche assembly remain relativelyunimportant as far as run time is concerned.</p>
<p> <p align="center"> <iframe width="560" height="315"
 src="https://www.youtube.com/embed/Srwq7zyR9mg" frameborder="0"
 allow="accelerometer; autoplay; encrypted-media; gyroscope;
 picture-in-picture" allowfullscreen></iframe> </p> </p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>The current tutorial program shows a one-way coupling between the fluid and thesolid, where the solid motion is imposed (and not solved for), and read in thesolid domain by exploiting the location and the weights of the solid quadraturepoints. The structure of the code already allows one to implement a two-way coupling,by exploiting the possibility to read values of the fluid velocity on thequadrature points of the solid grid. For this to be more efficient in terms ofMPI communication patterns, one should maintain ownership of the quadraturepoints on the solid processor that owns the cells where they have been created.In the current code, it is sufficient to define the <a class="el" href="classIndexSet.html">IndexSet</a> of the vectorsused to exchange information of the quadrature points by using the solidpartition instead of the initial fluid partition. This allows the combination of the technique used in this tutorial program withthose presented in the tutorial <a class="el" href="step_60.html">step-60</a> to solve a fluid structure interactionproblem with distributed Lagrange multipliers, on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects. The timings above show that the current preconditioning strategy does not workwell for Nitsche penalization, and we should come up with a betterpreconditioner if we want to aim at larger problems. Moreover, a checkpointrestart strategy should be implemented to allow for longer simulations to beinterrupted and restored, as it is done for example in the <a class="el" href="step_69.html">step-69</a> tutorial.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2020 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Luca Heltai, Bruno Blais, Rene Gassmoeller, 2020</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>LA</div><div class="line">{</div><div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div><div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div><div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div><div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">} <span class="comment">// namespace LA</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step70</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesImmersedProblemParameters();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      rhs.set_time(time);</div><div class="line">      angular_velocity.set_time(time);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div><div class="line">    <span class="keywordtype">double</span>       final_time           = 1.0;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> viscosity    = 1.0;</div><div class="line">    <span class="keywordtype">double</span> penalty_term = 100;</div><div class="line"></div><div class="line">    std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div><div class="line"></div><div class="line">    std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div><div class="line">    std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div><div class="line">    std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div><div class="line">    std::string arguments_for_solid_grid = spacedim == 2 ?</div><div class="line">                                             <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div><div class="line">                                             <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div><div class="line">    std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div><div class="line">    std::string arguments_for_particle_grid =</div><div class="line">      spacedim == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span>          max_level_refinement = 8;</div><div class="line">    <span class="keywordtype">int</span>          min_level_refinement = 5;</div><div class="line">    std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div><div class="line">    <span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div><div class="line">    <span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div><div class="line">    <span class="keywordtype">int</span>          refinement_frequency = 5;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; rhs;</div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      angular_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  StokesImmersedProblemParameters&lt;dim,</div><div class="line">                                  spacedim&gt;::StokesImmersedProblemParameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div><div class="line">    , rhs(<span class="stringliteral">&quot;Right hand side&quot;</span>, spacedim + 1)</div><div class="line">    , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, final_time);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div><div class="line">                  initial_fluid_refinement,</div><div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div><div class="line">                  initial_solid_refinement,</div><div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div><div class="line">                  fluid_rtree_extraction_level,</div><div class="line">                  <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div><div class="line">      particle_insertion_refinement,</div><div class="line">      <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">      homogeneous_dirichlet_ids,</div><div class="line">      <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div><div class="line"></div><div class="line">    enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div><div class="line">                    arguments_for_particle_grid);</div><div class="line">    }</div><div class="line">    leave_subsection();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div><div class="line">                    refinement_strategy,</div><div class="line">                    <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">                    this-&gt;prm,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div><div class="line">    }</div><div class="line">    leave_subsection();</div><div class="line"></div><div class="line">    rhs.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div><div class="line">                                                              spacedim + 1);</div><div class="line">    });</div><div class="line">    angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">      this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    static_assert(spacedim &gt; 1,</div><div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">    SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div><div class="line">      : angular_velocity(angular_velocity)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> velocity;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(p);</div><div class="line">      velocity[0]        = -omega * p[1];</div><div class="line">      velocity[1]        = omega * p[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> velocity[component];</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    static_assert(spacedim &gt; 1,</div><div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">    SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;(spacedim)</div><div class="line">      , angular_velocity(angular_velocity)</div><div class="line">      , time_step(time_step)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = p;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> dtheta = angular_velocity.value(p) * time_step;</div><div class="line"></div><div class="line">      new_position[0] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[0] - <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[1];</div><div class="line">      new_position[1] = <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[0] + <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[1];</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> new_position[component];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div><div class="line">    {</div><div class="line">      time_step = new_time_step;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">    <span class="keywordtype">double</span>                                     time_step;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesImmersedProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesImmersedProblem(</div><div class="line">      <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_tracer_particles();</div><div class="line">    <span class="keywordtype">void</span> setup_solid_particles();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> initial_setup();</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_stokes_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_nitsche_restriction();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_and_transfer();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle, <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">                          std::string                                 fprefix,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div><div class="line"></div><div class="line">    <a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div><div class="line">    std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div><div class="line">    std::vector&lt;IndexSet&gt; solid_owned_dofs;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div><div class="line">    std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> system_matrix;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> solution;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> locally_relevant_solution;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div><div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> tracer_particle_velocities;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div><div class="line">    : par(par)</div><div class="line">    , mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">            (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">    , computing_timer(mpi_communicator,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">    , fluid_tria(mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::MeshSmoothing(</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_refinement |</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_coarsening))</div><div class="line">    , solid_tria(mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::MeshSmoothing(</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_refinement |</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_coarsening))</div><div class="line">    , fluid_dh(fluid_tria)</div><div class="line">    , solid_dh(solid_tria)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> read_grid_and_cad_files(<span class="keyword">const</span> std::string &amp;grid_file_name,</div><div class="line">                               <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div><div class="line">                               <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div><div class="line">  {</div><div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div><div class="line">    grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">    grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div><div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="namespacePatterns_1_1Tools.html#a59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>   = pair.first;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> extension = boost::algorithm::to_lower_copy(</div><div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div><div class="line"></div><div class="line">        TopoDS_Shape shape;</div><div class="line">        <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;iges&quot;</span> || extension == <span class="stringliteral">&quot;igs&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;step&quot;</span> || extension == <span class="stringliteral">&quot;stp&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> n_elements = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div><div class="line">        <span class="keywordflow">if</span> ((std::get&lt;0&gt;(n_elements) == 0))</div><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div><div class="line">            <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (spacedim == 3)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div><div class="line">            t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                            <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div><div class="line">                              shape));</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div><div class="line">                              TopoDS::Face(shape)));</div><div class="line">      }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    (void)ids_and_cad_file_names;</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        read_grid_and_cad_files(par.name_of_fluid_grid,</div><div class="line">                                par.arguments_for_fluid_grid,</div><div class="line">                                fluid_tria);</div><div class="line">      }</div><div class="line">    fluid_tria.refine_global(par.initial_fluid_refinement);</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">      {</div><div class="line">        read_grid_and_cad_files(par.name_of_solid_grid,</div><div class="line">                                par.arguments_for_solid_grid,</div><div class="line">                                solid_tria);</div><div class="line">      }</div><div class="line"></div><div class="line">    solid_tria.refine_global(par.initial_solid_refinement);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div><div class="line">  {</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div><div class="line">      mpi_communicator);</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">      particle_insert_tria,</div><div class="line">      par.name_of_particle_grid,</div><div class="line">      par.arguments_for_particle_grid);</div><div class="line">    particle_insert_tria.refine_global(par.particle_insertion_refinement);</div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div><div class="line">    particles_dof_handler.distribute_dofs(particles_fe);</div><div class="line"></div><div class="line">    std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div><div class="line">    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        all_boxes.emplace_back(cell-&gt;bounding_box());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div><div class="line">      <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, par.fluid_rtree_extraction_level);</div><div class="line"></div><div class="line">    global_fluid_bounding_boxes =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div><div class="line"></div><div class="line">    tracer_particle_handler.initialize(fluid_tria,</div><div class="line">                                       <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div><div class="line">                                              global_fluid_bounding_boxes,</div><div class="line">                                              tracer_particle_handler);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div><div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    locally_owned_tracer_particle_coordinates =</div><div class="line">      tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">        <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">    locally_relevant_tracer_particle_coordinates =</div><div class="line">      locally_owned_tracer_particle_coordinates;</div><div class="line"></div><div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">      [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">    fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div><div class="line">      tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(fluid_fe-&gt;degree + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div><div class="line">    solid_particle_handler.initialize(fluid_tria,</div><div class="line">                                      <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div><div class="line">                                      n_properties);</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div><div class="line">    quadrature_points_vec.reserve(quadrature.size() *</div><div class="line">                                  solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;double&gt;&gt; properties;</div><div class="line">    properties.reserve(quadrature.size() *</div><div class="line">                       solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div><div class="line">                                 quadrature,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : solid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_v.reinit(cell);</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; points.size(); ++q)</div><div class="line">            {</div><div class="line">              quadrature_points_vec.emplace_back(points[q]);</div><div class="line">              properties.emplace_back(</div><div class="line">                std::vector&lt;double&gt;(n_properties, JxW[q]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div><div class="line">             <span class="stringliteral">&quot;I was expecting the &quot;</span></div><div class="line">             <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div><div class="line">             <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div><div class="line">             <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">    solid_particle_handler.insert_global_particles(quadrature_points_vec,</div><div class="line">                                                   global_fluid_bounding_boxes,</div><div class="line">                                                   properties);</div><div class="line"></div><div class="line"></div><div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">      [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">    fluid_tria.signals.post_distributed_refinement.connect(</div><div class="line">      [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div><div class="line"></div><div class="line">    fluid_fe =</div><div class="line">      std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div><div class="line">                                           spacedim,</div><div class="line">                                           <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div><div class="line">                                                          1),</div><div class="line">                                           1);</div><div class="line"></div><div class="line"></div><div class="line">    solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div><div class="line">    solid_dh.distribute_dofs(*solid_fe);</div><div class="line"></div><div class="line">    fluid_quadrature_formula =</div><div class="line">      std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">    solid_quadrature_formula =</div><div class="line">      std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div><div class="line"></div><div class="line">    fluid_dh.distribute_dofs(*fluid_fe);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0);</div><div class="line">    stokes_sub_blocks[spacedim] = 1;</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">          &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div><div class="line">          &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div><div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    fluid_owned_dofs.resize(2);</div><div class="line">    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div><div class="line">    fluid_owned_dofs[1] =</div><div class="line">      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div><div class="line">    fluid_relevant_dofs.resize(2);</div><div class="line">    fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div><div class="line">    fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.reinit(locally_relevant_dofs);</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        fluid_dh,</div><div class="line">        0,</div><div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(spacedim + 1),</div><div class="line">        constraints,</div><div class="line">        fluid_fe-&gt;component_mask(velocities));</div><div class="line">      constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator,</div><div class="line">                                 fluid_dh.locally_owned_dofs());</div><div class="line">    {</div><div class="line">      system_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == spacedim || d == spacedim || c == d)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">        dsp,</div><div class="line">        locally_owned_dofs_per_processor,</div><div class="line">        mpi_communicator,</div><div class="line">        locally_relevant_dofs);</div><div class="line"></div><div class="line">      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">        dsp,</div><div class="line">        locally_owned_dofs_per_processor,</div><div class="line">        mpi_communicator,</div><div class="line">        locally_relevant_dofs);</div><div class="line">      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">    }</div><div class="line"></div><div class="line">    locally_relevant_solution.reinit(fluid_owned_dofs,</div><div class="line">                                     fluid_relevant_dofs,</div><div class="line">                                     mpi_communicator);</div><div class="line">    system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">    solution.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div><div class="line">  {</div><div class="line">    system_matrix         = 0;</div><div class="line">    preconditioner_matrix = 0;</div><div class="line">    system_rhs            = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div><div class="line">                                 *fluid_quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fluid_quadrature_formula-&gt;size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points,</div><div class="line">                                           Vector&lt;double&gt;(spacedim + 1));</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;              div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;              phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure(spacedim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell_matrix  = 0;</div><div class="line">          cell_matrix2 = 0;</div><div class="line">          cell_rhs     = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          par.rhs.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    rhs_values);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                {</div><div class="line">                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);</div><div class="line">                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);</div><div class="line">                  phi_p[k]      = fe_values[pressure].value(k, q);</div><div class="line">                }</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        (par.viscosity *</div><div class="line">                           <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) -</div><div class="line">                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">                      cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *</div><div class="line">                                            phi_p[j] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                    }</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                    fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                  cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">                                 rhs_values[q](component_i) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 system_matrix,</div><div class="line">                                                 system_rhs);</div><div class="line"></div><div class="line">          constraints.distribute_local_to_global(cell_matrix2,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 preconditioner_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);</div><div class="line"></div><div class="line">    SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div><div class="line">      fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div><div class="line">                                    fluid_fe-&gt;n_dofs_per_cell());</div><div class="line">    ::Vector&lt;double&gt; local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div><div class="line">      1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> particle = solid_particle_handler.begin();</div><div class="line">    <span class="keywordflow">while</span> (particle != solid_particle_handler.end())</div><div class="line">      {</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*cell, &amp;fluid_dh);</div><div class="line">        dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(cell);</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == particle, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pic)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = p.get_reference_location();</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = p.get_location();</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = p.get_properties()[0];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fluid_fe-&gt;n_dofs_per_cell(); ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div><div class="line">                  fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                <span class="keywordflow">if</span> (comp_i &lt; spacedim)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">                         ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div><div class="line">                          fluid_fe-&gt;system_to_component_index(j).first;</div><div class="line">                        <span class="keywordflow">if</span> (comp_i == comp_j)</div><div class="line">                          local_matrix(i, j) +=</div><div class="line">                            penalty_parameter * par.penalty_term *</div><div class="line">                            fluid_fe-&gt;shape_value(i, ref_q) *</div><div class="line">                            fluid_fe-&gt;shape_value(j, ref_q) * JxW;</div><div class="line">                      }</div><div class="line">                    local_rhs(i) += penalty_parameter * par.penalty_term *</div><div class="line">                                    solid_velocity.value(real_q, comp_i) *</div><div class="line">                                    fluid_fe-&gt;shape_value(i, ref_q) * JxW;</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               fluid_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line">        particle = pic.end();</div><div class="line">      }</div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_A;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_A.initialize(system_matrix.block(0, 0), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_S;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_S.initialize(preconditioner_matrix.block(1, 1), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, prec_A);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div><div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(S, prec_S);</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div><div class="line">                                          1e-8 * system_rhs.l2_norm(),</div><div class="line">                                          1.e-2);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div><div class="line">      std::array&lt;</div><div class="line">        ::LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;,</div><div class="line">        2&gt;{{amgA, amgS}});</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div><div class="line">                                 1e-10 * system_rhs.l2_norm());</div><div class="line"></div><div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">    constraints.set_zero(solution);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, P);</div><div class="line"></div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    locally_relevant_solution = solution;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div><div class="line">      VectorTools::compute_mean_value(fluid_dh,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div><div class="line">                                      locally_relevant_solution,</div><div class="line">                                      spacedim);</div><div class="line">    solution.block(1).add(-mean_pressure);</div><div class="line">    locally_relevant_solution.block(1) = solution.block(1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; error_per_cell(fluid_tria.n_active_cells());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div><div class="line">                                              par.velocity_degree + 1),</div><div class="line">                                            {},</div><div class="line">                                            locally_relevant_solution,</div><div class="line">                                            error_per_cell,</div><div class="line">                                            fluid_fe-&gt;component_mask(velocity));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">          refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div><div class="line">                                            error_per_cell,</div><div class="line">                                            par.refinement_fraction,</div><div class="line">                                            par.coarsening_fraction);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">          fluid_tria,</div><div class="line">          error_per_cell,</div><div class="line">          par.refinement_fraction,</div><div class="line">          par.coarsening_fraction,</div><div class="line">          par.max_cells);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;refine_flag_set() &amp;&amp;</div><div class="line">            cell-&gt;level() == par.max_level_refinement)</div><div class="line">          cell-&gt;clear_refine_flag();</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;coarsen_flag_set() &amp;&amp;</div><div class="line">            cell-&gt;level() == par.min_level_refinement)</div><div class="line">          cell-&gt;clear_coarsen_flag();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div><div class="line">      transfer(fluid_dh);</div><div class="line">    fluid_tria.prepare_coarsening_and_refinement();</div><div class="line">    transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div><div class="line">    fluid_tria.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    transfer.interpolate(solution);</div><div class="line">    constraints.distribute(solution);</div><div class="line">    locally_relevant_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle,</div><div class="line">                                                       <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names(spacedim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        spacedim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(fluid_dh);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(locally_relevant_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(fluid_tria.n_active_cells());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      subdomain(i) = fluid_tria.locally_owned_subdomain();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                   mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line">    times_and_names.push_back(std::make_pair(time, filename));</div><div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">    std::string                                 fprefix,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div><div class="line">    particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(particles);</div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    particles_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                        mpi_communicator);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div><div class="line">      times_and_names;</div><div class="line">    <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div><div class="line">      times_and_names[fprefix].push_back(std::make_pair(time, filename));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      times_and_names[fprefix] = {std::make_pair(time, filename)};</div><div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div><div class="line">                               <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) +</div><div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div><div class="line">                             <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div><div class="line">    <span class="keywordtype">double</span>       time         = 0;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; par.number_of_time_steps;</div><div class="line">         ++cycle, time += time_step)</div><div class="line">      {</div><div class="line">        par.set_time(time);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            make_grid();</div><div class="line">            initial_setup();</div><div class="line">            setup_dofs();</div><div class="line">            setup_tracer_particles();</div><div class="line">            setup_solid_particles();</div><div class="line">            tracer_particle_velocities.reinit(</div><div class="line">              locally_owned_tracer_particle_coordinates, mpi_communicator);</div><div class="line">            output_results(output_cycle, time);</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">              output_particles(tracer_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">              output_particles(solid_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div><div class="line">                                 <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div><div class="line"></div><div class="line">            SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div><div class="line">                                                   time_step);</div><div class="line">            solid_particle_handler.set_particle_positions(solid_position,</div><div class="line">                                                          <span class="keyword">false</span>);</div><div class="line">          }</div><div class="line"></div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div><div class="line">          <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div><div class="line">            fluid_dh,</div><div class="line">            tracer_particle_handler,</div><div class="line">            locally_relevant_solution,</div><div class="line">            tracer_particle_velocities,</div><div class="line">            fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div><div class="line"></div><div class="line">          tracer_particle_velocities *= time_step;</div><div class="line"></div><div class="line">          locally_relevant_tracer_particle_coordinates =</div><div class="line">            tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">              <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">          relevant_tracer_particle_displacements.reinit(</div><div class="line">            locally_owned_tracer_particle_coordinates,</div><div class="line">            locally_relevant_tracer_particle_coordinates,</div><div class="line">            mpi_communicator);</div><div class="line"></div><div class="line">          relevant_tracer_particle_displacements = tracer_particle_velocities;</div><div class="line"></div><div class="line">          tracer_particle_handler.set_particle_positions(</div><div class="line">            relevant_tracer_particle_displacements);</div><div class="line">        }</div><div class="line"></div><div class="line">        assemble_stokes_system();</div><div class="line">        assemble_nitsche_restriction();</div><div class="line">        solve();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle % par.output_frequency == 0)</div><div class="line">          {</div><div class="line">            output_results(output_cycle, time);</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">              output_particles(tracer_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">              output_particles(solid_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            ++output_cycle;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cycle % par.refinement_frequency == 0 &amp;&amp;</div><div class="line">            cycle != par.number_of_time_steps - 1)</div><div class="line">          refine_and_transfer();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step70</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step70;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2, 3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2, 3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_19.html">step-19</a>, <a class="el" href="step_32.html">step-32</a>, <a class="el" href="step_60.html">step-60</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems">Massively parallel non-matching grid simulations of fluid structure interaction problems</a>
      <ul>
        <li><a href="#Codimensiononecase">Co-dimension one case</a>
        <li><a href="#Codimensionzerocase">Co-dimension zero case</a>
        <li><a href="#Representationofand">Representation of Ω and Γ</a>
        <li><a href="#Usingparticlestotrack">Using particles to track Γ</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#Morereferences"> More references</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Runtimeparameterhandling">Run-time parameter handling</a>
        <li><a href="#TheStokesImmersedProblemclassdeclaration">The StokesImmersedProblem class declaration</a>
        <li><a href="#TheStokesImmersedProblemclassimplementation">The StokesImmersedProblem class implementation</a>
      <ul>
        <li><a href="#Objectconstructionandmeshinitializationfunctions">Object construction and mesh initialization functions</a>
        <li><a href="#Particleinitializationfunctions">Particle initialization functions</a>
        <li><a href="#DoFinitializationfunctions">DoF initialization functions</a>
        <li><a href="#Assemblyfunctions">Assembly functions</a>
        <li><a href="#Solvingthelinearsystem">Solving the linear system</a>
        <li><a href="#Meshrefinement">Mesh refinement</a>
        <li><a href="#Creatingoutputforvisualization">Creating output for visualization</a>
        <li><a href="#Therunfunction">The "run" function</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Twodimensionaltestcase"> Two dimensional test case </a>
        <li><a href="#Threedimensionaltestcase"> Three dimensional test case </a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-70/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Luca Heltai (International School for Advanced Studies, Trieste), Bruno Blais (Polytechnique Montréal), and Rene Gassmöller (University of California Davis) </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3829064"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3829064.svg" alt="10.5281/zenodo.3829064"/></a> </dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Massivelyparallelnonmatchinggridsimulationsoffluidstructureinteractionproblems"></a></p><h3>Massively parallel non-matching grid simulations of fluid structure interaction problems</h3>
<p>在本教程中，我们考虑了层流体系中的混合问题。这类问题出现在从化学工程到发电（如涡轮机械）等广泛的应用中。混合问题特别难以用数值来解决，因为它们通常涉及一个容器（有固定的边界，可能还有复杂的几何形状，如挡板），由域 \(\Omega\) 表示，和一个（或多个）浸入和旋转的叶轮（由域 \(\Omega^{\text{imp}}\) 表示）。我们希望解决流动方程的域是两个域之间的（与时间有关的）差值，即。 \(\Omega\setminus\Omega^{\text{imp}}\) .</p>
<p>对于旋转叶轮，使用任意拉格朗日欧拉公式（其中流体域&ndash;连同网格！）是不可能的，除非只考虑小时间（即小的流体域变形）。&ndash; 是不可能的，除非只考虑小时间（即小的流域变形）。如果想跟踪叶轮多次旋转时的流动演变，所产生的变形网格就会过于扭曲而无用。</p>
<p>在这种情况下，一个可行的替代策略是使用非匹配方法（类似于我们在<a class="el" href="step_60.html">step-60</a>中所做的），其中一个背景固定网格（可能在时间上进行局部细化以更好地捕捉实体运动）与一个旋转的、独立的网格相耦合。</p>
<p>为了保持步骤60中使用的相同符号，我们使用 \(\Omega\) 来表示 \({\mathbb R}^{\text{spacedim}}\) 中的域，代表流体和叶轮的容器，我们使用 \(\Gamma\) 在 \({\mathbb R}^{\text{dim}}\) 来表示整个叶轮（当它的<code>spacedim</code>度量非负值时，也就是说，当我们可以把它表示为维数<code>dim</code>等于<code>spacedim</code>的网格时），薄叶轮的同维度表示，或者只是整个叶轮的边界。</p>
<p>域 \(\Gamma\) 被嵌入到 \(\Omega\) （ \(\Gamma \subseteq \Omega\) ）中，它是不匹配的：一般来说，它不与任何体积网格的特征对齐。我们在 \(\Omega\) 上求解一个偏微分方程，通过一些惩罚技术在嵌入域 \(\Gamma\) 上强制执行一些问题的解决条件。在当前情况下，条件是流体在 \(\Gamma\) 上各点的速度等于固体叶轮在该点的速度。</p>
<p>我们在此描述的技术在文献中使用了许多名称之一：<b>immersed finite element method</b>和<b>fictitious boundary method</b>等。 其主要原理是两个网格的离散化保持完全独立。在本教程中，这种方法被用来求解由斯托克斯方程描述的粘性流体的运动，该流体被一个刚性的非变形叶轮搅动。</p>
<p>因此， \(\Omega\) 中求解的方程是蠕动流的斯托克斯方程（即 \(\text{Re}\rightarrow 0\) ），并且在与叶轮相关的移动*嵌入域* \(\Gamma\) 上应用无滑动边界条件。然而，这个教程可以很容易地扩展到其他方程（例如，纳维-斯托克斯方程、线性弹性方程等）。它可以被看作是<a class="el" href="step_60.html">step-60</a>的一个自然扩展，它可以通过MPI使用分布式并行计算架构解决大型问题。</p>
<p>然而，与第60步相反， \(\Gamma\) 上的迪里希特边界条件是弱加的，而不是通过使用拉格朗日乘法器，而且我们集中处理两个完全分布的三角形的耦合（这种组合在第60步的实施中是不可能的）。</p>
<p>当人们想在嵌入域上执行条件时，有两种有趣的情况发生 \(\Gamma\) 。</p>
<ul>
<li>嵌入域 \(\Gamma\) 的几何维度<code>dim</code>与域 \(\Omega\) 相同（<code>spacedim</code>），也就是说， \(\Gamma\) 的spacedim-维度不为零。在这种情况下，对 \(\Gamma\) 施加Dirichlet边界的边界条件是通过体积惩罚完成的。如果施加的惩罚只取决于速度，这通常被称为 \(\mathcal{L}^2\) 惩罚，而如果惩罚同时取决于速度及其梯度，则是 \(\mathcal{H}^1\) 惩罚。 \(\mathcal{L}^2\) 惩罚的情况与Darcy型方法非常相似。对 \(\mathcal{L}^2\) 和 \(\mathcal{H}^1\) 两种惩罚方法都进行了广泛的分析（例如，见 <b>[Angot1999]</b> ）。</li>
<li>嵌入域 \(\Gamma\) 的内在维度<code>dim</code>小于 \(\Omega\) 的维度（<code>spacedim</code>），因此其spacedim维度为零；例如，它是一条嵌入二维域的曲线，或一个嵌入三维域的表面。当然，这在物理上是不可能的，但是如果金属片的厚度可以忽略不计的话，我们可以把在流体中运动的非常薄的金属片视为本质上的低维。在这种情况下，通过应用<a href="https://en.wikipedia.org/wiki/Joachim_Nitsche">Nitsche</a>方法（见 <b>[Freund1995]</b> ）对 \(\Gamma\) 施加弱边界条件。</li>
</ul>
<p>这两种方法都有非常相似的要求，并导致高度相似的公式。因此，我们几乎以同样的方式对待它们。</p>
<p>在本教程中，我们对 \(\Gamma\) 的进一步细节不感兴趣：我们假设嵌入域的尺寸（<code>dim</code>）总是比嵌入域的尺寸 \(\Omega\) （<code>spacedim</code>）小一或相等。</p>
<p>我们要解决以下微分问题：给定 \(g\) 上的一个足够规则的函数 \(\Gamma\) ，找到 \((\textbf{u},p)\) 的解。</p>
<p class="formulaDsp">
\begin{eqnarray*} -\Delta \mathbf{u} + \nabla p &amp;=&amp; 0,\\ -\nabla \cdot \textbf{u} &amp;=&amp; 0,\\ \textbf{u} &amp;=&amp; \textbf{g} \text{ in } \Gamma,\\ \textbf{u} &amp;=&amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
<p>这个方程，我们通过缩放时间单位的方式将其规范化，使粘度的数值为1，描述了缓慢的粘性流动，如蜂蜜或岩浆。本教程的主要目的是展示如何用惩罚方法，以弱的方式将速度场条件 \(\mathbf{u} = \mathbf{g}\) 强加于非匹配的 \(\Gamma\) 。关于斯托克斯问题的更广泛的讨论，包括体力、不同的边界条件和解决策略，可以在步骤22中找到。</p>
<p>让我们开始单独考虑整个域 \(\Omega\) 中的斯托克斯问题。我们寻找一个速度场 \(\mathbf{u}\) 和一个压力场 \(p\) ，满足斯托克斯方程和 \(\partial\Omega\) 上的同质边界条件。</p>
<p>斯托克斯方程的微弱形式首先通过将其写成矢量形式而得到</p>
<p class="formulaDsp">
\begin{eqnarray*} \begin{pmatrix} {-\Delta \textbf{u} + \nabla p} \\ {-\textrm{div}\;\textbf{u}} \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix}, \end{eqnarray*}
</p>
<p>从左边开始与一个矢量值测试函数 \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) 形成点积，并在域 \(\Omega\) 上进行积分，得到以下一组方程。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\mathrm v, -\Delta \textbf{u} + \nabla p)_{\Omega} - (q,\textrm{div}\; \textbf{u})_{\Omega} = 0 \end{eqnarray*}
</p>
<p>这对所有的测试函数都必须成立 \(\phi = \begin{pmatrix}\textbf{v} \\ q\end{pmatrix}\) 。</p>
<p>通过部分积分并利用 \(\partial\Omega\) 的边界条件，我们得到以下变分问题。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega}&amp;=&amp; 0 \end{eqnarray*}
</p>
<p>其中 \((\cdot, \cdot)_{\Omega}\) 代表 \(L^2\) 标量积。这也是步骤22中使用的变异形式。</p>
<p>这个变分公式没有考虑到嵌入域。与<a class="el" href="step_60.html">step-60</a>相反，我们并不强行执行 \(\textbf{u}\) 对 \(\Gamma\) 的约束，而是通过惩罚项弱行执行这些约束。</p>
<p>对这种弱强加边界条件的分析取决于 \(\Gamma\) 的spacedim-dimensional度量是正的（如果<code>dim</code>等于<code>spacedim</code>）或零（如果<code>dim</code>小于<code>spacedim</code>）。我们讨论这两种情况。</p>
<p><a class="anchor" id="Codimensiononecase"></a></p><h4>Co-dimension one case</h4>
<p>在这种情况下，我们假设 \(\Gamma\) 是实际叶轮的边界，即嵌入二维域的封闭曲线或三维域的封闭表面。这种方法的思路首先是考虑在 \(\Gamma\) 上弱加迪里切特边界条件，遵循尼采方法。这是通过在流体域上使用以下修改后的公式来实现的，其中没有对 \(\Gamma\) 上的测试函数施加强条件。</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ - (\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ - (\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} + (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} + (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>过 \(\Gamma\) 的积分是低维积分。可以证明（见 <b>[Freund1995]</b> ），存在一个正的常数 \(C_1\) ，所以如果 \(\beta &gt; C_1\) ，边界的弱强加将是一致和稳定的。在 \(\Gamma\) 上的前两个附加积分（上式中的第二行）在通过部分积分后自然出现，此时我们不假设 \(\mathbf{v}\) 在 \(\Gamma\) 上是零。</p>
<p>上述方程中的第三行包含两个项，是为了确保弱形式的一致性而添加的，还有一个稳定项，是为了强制执行边界条件，其误差与近似误差一致。一致性项和稳定项是用实际的边界数据添加到右手边的 \(\mathbf{g}\) 。</p>
<p>当 \(\mathbf{u}\) 满足 \(\Gamma\) 上的条件 \(\mathbf{u}=\mathbf{g}\) 时， \(\Gamma\) 上的所有一致性和稳定性积分都被抵消，就剩下斯托克斯流的通常弱形式，也就是说，上述表述是一致的。</p>
<p>我们注意到，可以使用另一种（非对称的）表述方式。</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} - (\textrm{div}\; \textbf{v}, p)_{\Omega\setminus\Omega^{\text{imp}}} - (q, \textrm{div}\; \textbf{u})_{\Omega\setminus\Omega^{\text{imp}}} \\ -(\textbf{v},\nabla \textbf{u} \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},p)_{\Gamma} \\ +(\nabla\textbf{v}\cdot \textbf{n},\textbf{u})_{\Gamma} - (q, \textbf{u} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{u})_{\Gamma} \\ = (\nabla\textbf{v}\cdot \textbf{n},\textbf{g})_{\Gamma} - (q, \textbf{g} \cdot \textbf{n})_{\Gamma} + \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>注意第三行和第四行的第一项的不同符号。在这种情况下，稳定性和一致性条件成为 \(\beta &gt; 0\) 。在对称情况下， \(\beta\) 的值取决于 \(h\) ，一般来说，它被选择为 \(\beta = C h^{-1} \) ， \(h\) 是衡量被整合面的大小， \(C\) 是一个常数，以便 \(1 \leq C \leq 10\) 。这就像人们通常使用Nitsche惩罚方法来执行Dirichlet边界条件一样。</p>
<p>另一方面，非对称方法与非连续Galerkin方法的非对称内部惩罚方法（"NIPG "方法 <b>[Riviere1999]</b> ）的连续性的执行方式有关。即使非对称情况在稳定参数的可能选择方面似乎更有优势，我们还是选择了对称离散化，因为在这种情况下，可以证明对偶问题也是一致的，导致解决方案不仅能量准则以正确的顺序收敛，而且其 \(L^2\) 准则也是如此。此外，得到的矩阵仍然是对称的。</p>
<p>上述表述是在假设领域被精确离散的情况下进行的。然而，如果叶轮的变形是一个刚体运动，就有可能人为地将斯托克斯问题的解扩展到螺旋桨本身，因为刚体运动也是斯托克斯问题的解。我们的想法是在 \(\Omega^{\text{imp}}\) 内解决同样的问题，在 \(\Gamma\) 上施加同样的边界条件，使用同样的惩罚技术，并用在 \(\Omega\) 上全局连续的测试函数 \(\mathbf{v}\) 来测试。</p>
<p>这导致了以下（中间）配方。</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} \\ - (\textbf{v}, \lbrack \nabla \textbf{u} \rbrack \cdot \textbf{n})_{\Gamma} + (\textbf{v}\cdot \textbf{n},\lbrack p \rbrack )_{\Gamma} \\ - (\lbrack \nabla\textbf{v} \rbrack \cdot \textbf{n},\textbf{u})_{\Gamma} + (\lbrack q \rbrack, \textbf{u} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = - (\lbrack \nabla\textbf{v}\rbrack\cdot \textbf{n},\textbf{g})_{\Gamma} + (\lbrack q\rbrack, \textbf{g} \cdot n)_{\Gamma} + 2\beta (\textbf{v},\textbf{g})_{\Gamma}, \end{multline*}
</p>
<p>其中跳跃项，用 \(\lbrack \cdot \rbrack\) 表示，是相对于法向量 \(\textbf{n}\) 的一个固定方向计算的。2的因子出现在 \(\beta\) 前面，因为我们看到 \(\Gamma\) 的每一部分两次，一次来自流体内部，一次来自在其中移动的障碍物。对于 \(\Gamma\) 上的所有其他积分，我们对 \(\Gamma\) 的每一部分都访问了两次，但符号相反，因此得到的是跳跃项）。</p>
<p>这里我们注意到，与不连续的Galerkin方法不同，测试和试验函数在 \(\Gamma\) 中是连续的。此外，如果 \(\Gamma\) 不与单元边界对齐，所有的跳跃项也是零，因为一般来说，有限元函数空间在每个单元内都是平滑的，如果 \(\Gamma\) 只在有限的几个点上切过一个单元与它的边界相交，除了稳定化的贡献外， \(\Gamma\) 上的所有贡献都可以从公式中忽略掉，导致以下变量公式的最终形式。</p>
<p class="formulaDsp">
\begin{multline*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + 2\beta (\textbf{v},\textbf{u})_{\Gamma} \\ = 2\beta (\textbf{v},\textbf{g})_{\Gamma}. \end{multline*}
</p>
<p>在<a class="el" href="step_60.html">step-60</a>中，约束条件的施加需要以拉格朗日乘数的形式增加新的变量。本教程程序不存在这种情况。使用Nitsche方法施加边界条件只修改了系统矩阵和右手边，没有增加额外的未知数。然而，嵌入域上的速度矢量 \(\textbf{u}\) 不会与规定的速度 \(\textbf{g}\) 完全匹配，而只是达到一个数值误差，这个误差与有限元方法的插值误差相同。此外，与第60步一样，我们仍然需要在不匹配的嵌入网格上进行积分，以构建对 \(\Gamma\) 施加边界条件的必要边界项。</p>
<p><a class="anchor" id="Codimensionzerocase"></a></p><h4>Co-dimension zero case</h4>
<p>在这种情况下， \(\Gamma\) 具有相同的尺寸，但被嵌入到 \(\Omega\) 中。我们可以把它看作是一个在流体中移动的厚物体。在 \(\mathcal{L}^2\) 惩罚的情况下，额外的惩罚项可以被解释为 \(\Gamma\) 内的达西项，结果是。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta (\textbf{v},\textbf{u})_{\Gamma} = \beta (\textbf{v},\textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>这里，对 \(\Gamma\) 的积分只是对部分体积的积分。因此， \(\mathcal{L}^2\) 的惩罚包括增加一个体积项，约束流体的速度与 \(\Gamma\) 内刚体的速度保持一致。在这种情况下， \(\beta\) 必须被选择得足够大，以确保 \(\Gamma\) 中的迪里希特边界条件得到充分尊重，但也不能太高，以保持系统矩阵的适当调节。</p>
<p>一个 \(\mathcal{H}^1\) 的惩罚可以用类似的方式构建，在惩罚中加入一个粘性成分，以阻尼 \(\Gamma\) 内的速度梯度。</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla \textbf{v}, \nabla \textbf{u})_{\Omega} - &amp; (\textrm{div}\; \textbf{v}, p)_{\Omega} - (q, \textrm{div}\; \textbf{u})_{\Omega} + \beta_1 (\textbf{v},\textbf{u})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{u})_{\Gamma} = \beta_1 (\textbf{v},\textbf{g})_{\Gamma} + \beta_2 (\nabla \textbf{v}, \nabla \textbf{g})_{\Gamma}. \end{eqnarray*}
</p>
<p>请注意， \(L^2\) 的惩罚（<code>dim</code>等于<code>spacedim</code>）和Nitsche的惩罚（<code>dim</code>等于<code>spacedim-1</code>）导致了完全相同的数值实现，这要感谢deal.II的独立维度能力。</p>
<p><a class="anchor" id="Representationofand"></a></p><h4>Representation of Ω and Γ</h4>
<p>在本教程中，嵌入网格 \(\Gamma\) 和嵌入网格都是用 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. 来描述的。这两个三角形可以通过GridGenerator命名空间中的函数来建立，或者通过读取其他应用程序（例如GMSH，见步骤-49的讨论）产生的网格文件来建立。这比之前在第60步中的做法略微通用了一些。</p>
<p>无论是在 "dim=spacedim "还是 "dim&lt;spacedim "的情况下，增加沉没边界法，只是在系统矩阵和系统的右手边引入了额外的项，这些项是在 \(\Gamma\) 上积分的结果。这并没有改变必须解决的问题的变量数量。因此，挑战与必须进行的积分有关 \(\Gamma\) 。</p>
<p>在有限元中，我们将这个积分分成来自用于离散化 \(\Gamma\) 的所有单元的贡献，我们将 \(K\) 上的积分转换为参考元素 \(\hat K\) 上的积分，其中 \(F_{K}\) 是 \(\hat K\) 到 \(K\) 的映射，并使用正交公式计算 \(\hat K\) 上的积分。比如说。</p>
<p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \int_{\hat K} \hat{\textbf{u}}(\hat x) (\textbf{v} \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p>计算这个和是不容易的，因为我们必须评估 \((v_j \circ F_{K}) (\hat x_i)\) 。一般来说，如果 \(\Gamma\) 和 \(\Omega\) 没有对齐，那么 \(y_i = F_{K}(\hat x_i)\) 这个点相对于 \(\Omega\) 来说是完全任意的，除非我们想出一个办法，将 \(V_h(\Omega)\) 的所有基函数插在 \(\Omega\) 上的一个任意点上，否则我们无法计算出需要的积分。</p>
<p>要评估 \((v_j \circ F_{K}) (\hat x_i)\) ，需要采取以下步骤（如下图所示）。</p>
<ul>
<li>对于 \(\Gamma\) 中的一个给定单元 \(K\) ，计算实点 \(y_i \dealcoloneq F_{K} (\hat x_i)\) ，其中 \(x_i\) 是用于 \(K \subseteq \Gamma\) 上的积分的正交点之一。这是最容易的部分。 <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">FEValues::quadrature_point()</a> 给了我们所有正交点的实空间位置。</li>
<li>找到 \(\Omega\) 中 \(y_i\) 所在的单元。我们将称这个元素为 \(T\) 。</li>
<li>找到 \(T\) 内 \(y_i\) 的参考坐标。为此，我们需要将参考元素 \(\hat T\) 转换为元素 \(T\) ： \(\hat y_i = G^{-1}_{T} (y_i)\) 的映射 \(G_T\) 的逆映射。</li>
<li>评估 \(v_j\) 网格在此点 \(\hat y_i\) 的基函数 \(\Omega\) 。这也是比较简单的，使用FEValues。</li>
</ul>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png"/>
</div>
 <p>在步骤60中，上述第二至第四步是通过依次调用来计算的。</p>
<ul>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, 后面是</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. 然后我们</li>
<li>构建一个自定义的正交公式，包含参考单元格中的点，然后</li>
<li>构建一个FEValues对象，具有给定的正交公式，并以第一步中获得的单元格为初始化。</li>
</ul>
<p>虽然这种方法对目前的情况是可行的，但它并不适合于使用分布式三角形的平行模拟。事实上，由于嵌入域 \(\Gamma\) 单元上的正交点的位置与嵌入三角形的位置不一致，而且 \(\Gamma\) 是不断移动的，这就要求代表 \(\Gamma\) 的三角形被完整地存储在所有处理器中。随着处理器的数量和 \(\Gamma\) 中单元格数量的增加，这将导致内存方面的严重瓶颈。因此，在这一步骤中寻求一种替代策略。</p>
<p><a class="anchor" id="Usingparticlestotrack"></a></p><h4>Using particles to track Γ</h4>
<p>请记住，对于惩罚法（ \(\mathcal{L}^2\) 或 \(\mathcal{H}^1\) ）和尼采法，我们要计算的是由正交近似的积分。也就是说，我们需要计算</p>
<p class="formulaDsp">
\[ \beta (\textbf{v},\textbf{u})_{\Gamma} = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat{\textbf{u}}(\hat x_i) (\textbf{v} \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p> 如果你跟随上面的讨论，那么你会记得 \(\textbf{u}\) 和 \(\textbf{v}\) 是定义在流体网格上的形状函数。唯一定义在实体网格上的东西是。 \(F_K(\hat x_i)\) ，是实体单元上正交点的位置，是 \(\Gamma\) 的一部分， \(J_K\) 是其雅各布系数的行列式， \(w_i\) 是相应的正交权值。</p>
<p>现在要认识到的重要部分是这样的。 \(w_i\) 是正交公式的一个属性，不随时间变化。此外， \(F_K\) 的雅各布矩阵本身随着固体障碍物在流体中的移动而变化，但由于固体被认为是非变形的（它只是平移和旋转，但不扩张），雅各布矩阵的行列式保持不变。因此，乘积 \(J_K(\hat x_i) w_i\) （我们通常用<code>JxW</code>表示）在每个正交点上都保持不变。因此，我们唯一需要跟踪的是位置 \(x_i=F_K(\hat x_i)\) &ndash;但这些位置随着实体域的速度移动。</p>
<p>换句话说，我们实际上根本不需要保留实体网格。我们所需要的只是位置 \(x_i(t)\) 和相应的<code>JxW</code>值。由于这两个属性都是附着在实体材料上的点属性（或点向量），它们可以被理想化为一组不相连的无限小的 "粒子"，它们随着实体的运动携带所需的<code>JxW</code>信息。deal.II有能力以ParticleHandler类的形式在大规模并行计算中分配和存储这样一组粒子（关于实现的细节见 <b>[GLHPW2018]</b> ），我们将在本教程中使用这一功能。</p>
<p>因此，本步骤采取的方法如下。</p>
<ul>
<li>为域名 \(\Gamma\) 创建一个 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 。</li>
<li>在 <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> 上的正交点位置创建 \(\Gamma\) 。</li>
<li>调用 <a class="el" href="classParticles_1_1ParticleHandler.html#ac4bae8e82e7a021bd4c269f0df3f8bea">Particles::ParticleHandler::insert_global_particles()</a> 函数，将粒子分配到各个处理器上，*遵循实体三角形*的做法。</li>
<li>将 "JxW "值作为一个 "属性 "附加到每个 <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> 对象。</li>
</ul>
<p>这种结构的生成相对来说比较昂贵，但是每次模拟必须只生成一次。一旦 <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> 被生成，并且所需的信息被附加到粒子上，就可以利用粒子在ParticleHandler内按单元分组的事实，对 \(\Gamma\) 进行积分，使我们能够。</p>
<ul>
<li>在 \(\Omega\) 中至少包含一个粒子的所有单元格上循环操作</li>
<li>循环处理给定单元中的所有粒子</li>
<li>计算积分并填充全局矩阵。</li>
</ul>
<p>由于 <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> 可以管理粒子从一个处理器到另一个处理器的交换，嵌入的三角形可以通过位移粒子而被移动或变形。与这种位移相关的唯一约束是，颗粒的位移距离不应大于一个单元的大小。这是因为这是 <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> 能够追踪离开当前单元的粒子现在所处的单元的极限。</p>
<p>一旦整个问题（斯托克斯问题和沉没边界施加）被集合起来，最后的鞍点问题由迭代求解器解决，应用于舒尔补数 \(S\) （其构造例如在步骤22中描述），我们使用LinearOperator类构造 \(S\) 。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>我们在这里解决的问题是对斯托克斯流的时间可逆性的证明。这在科学教育实验中经常用泰勒-库伊特流和染料液滴来说明，在流体以周期性的方式位移后，染料液滴又恢复到原来的形状。</p>
<p> 


<iframe width="560" height="315" src="https://www.youtube.com/embed/p08_KlTKP50" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


</p>
<p>在目前的问题中，一个非常粘稠的流体被一个叶轮的旋转所搅动，在二维中，叶轮被一个矩形网格所模拟。叶轮旋转了一定的圈数，之后流动被逆转，从而在相反的方向上进行相同圈数的旋转。我们回顾一下，由于斯托克斯方程是自交的，蠕动流是可逆的。因此，如果叶轮运动在相反的方向上被逆转，流体应该回到其原来的位置。在本例中，我们通过插入一圈被动示踪剂颗粒来说明这一点，这些颗粒被流体平移并返回到原来的位置，从而证明了流动的时间可逆性。</p>
<p><a class="anchor" id="Morereferences"></a></p><h3>More references</h3>
<p>本教程程序使用了一些关于对流体内部的非匹配界面施加速度条件的技术。要了解更多的背景材料，你可能要查阅以下参考资料。 <b>[Freund1995]</b> , <b>[Angot1999]</b> , <b>[Glowinski1999]</b> , <b>[Boffi2008]</b> , <b>[Heltai2012]</b> 。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones. The switches close to the top that allow selecting between PETSc and Trilinos linear algebra capabilities are similar to the ones in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_50.html">step-50</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>LA</div><div class="line">{</div><div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div><div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div><div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div><div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">} <span class="comment">// namespace LA</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>These are the only new include files with regard to <a class="el" href="step_60.html">step-60</a>. In this tutorial, the non-matching coupling between the solid and the fluid is computed using an intermediate data structure that keeps track of how the locations of quadrature points of the solid evolve within the fluid mesh. This data structure needs to keep track of the position of the quadrature points on each cell describing the solid domain, of the quadrature weights, and possibly of the normal vector to each point, if the solid domain is of co-dimension one.</p>
<p>Deal.II offers these facilities in the <a class="el" href="namespaceParticles.html">Particles</a> namespace, through the ParticleHandler class. ParticleHandler is a class that allows you to manage a collection of particles (objects of type <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a>), representing a collection of points with some attached properties (e.g., an id) floating on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. The methods and classes in the namespace <a class="el" href="namespaceParticles.html">Particles</a> allows one to easily implement Particle-In-Cell methods and particle tracing on distributed triangulations.</p>
<p>We "abuse" this data structure to store information about the location of solid quadrature points embedded in the surrounding fluid grid, including integration weights, and possibly surface normals. The reason why we use this additional data structure is related to the fact that the solid and the fluid grids might be non-overlapping, and if we were using two separate triangulation objects, would be distributed independently among parallel processes.</p>
<p>In order to couple the two problems, we rely on the ParticleHandler class, storing in each particle the position of a solid quadrature point (which is in general not aligned to any of the fluid quadrature points), its weight, and any other information that may be required to couple the two problems. These locations are then propagated along with the (prescribed) velocity of the solid impeller.</p>
<p>Ownership of the solid quadrature points is initially inherited from the MPI partitioning on the solid mesh itself. The <a class="el" href="namespaceParticles.html">Particles</a> so generated are later distributed to the fluid mesh using the methods of the ParticleHandler class. This allows transparent exchange of information between MPI processes about the overlapping pattern between fluid cells and solid quadrature points.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>When generating the grids, we allow reading it from a file, and if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support, we also allow reading CAD files and use them as manifold descriptors for the grid (see <a class="el" href="step_54.html">step-54</a> for a detailed description of the various <a class="el" href="classManifold.html">Manifold</a> descriptors that are available in the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step70</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Runtimeparameterhandling"></a> </p><h3>Run-time parameter handling</h3>
<p>Similarly to what we have done in <a class="el" href="step_60.html">step-60</a>, we set up a class that holds all the parameters of our problem and derive it from the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class to simplify the management and creation of parameter files.</p>
<p>The <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> paradigm requires all parameters to be writable by the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> methods. In order to avoid bugs that would be very difficult to track down (such as writing things like <code>time = 0</code> instead of <code>time == 0</code>), we declare all the parameters in an external class, which is initialized before the actual <code>StokesImmersedProblem</code> class, and pass it to the main class as a <code>const</code> reference.</p>
<p>The constructor of the class is responsible for the connection between the members of this class and the corresponding entries in the <a class="el" href="classParameterHandler.html">ParameterHandler</a>. Thanks to the use of the <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter()</a> method, this connection is trivial, but requires all members of this class to be writeable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesImmersedProblemParameters();</div></div><!-- fragment --><p>however, since this class will be passed as a <code>const</code> reference to the StokesImmersedProblem class, we have to make sure we can still set the time correctly in the objects derived by the <a class="el" href="classFunction.html">Function</a> class defined herein. In order to do so, we declare both the <code>StokesImmersedProblemParameters::rhs</code> and <code>StokesImmersedProblemParameters::angular_velocity</code> members to be <code>mutable</code>, and define the following little helper method that sets their time to the correct value.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  rhs.set_time(time);</div><div class="line">  angular_velocity.set_time(time);</div><div class="line">}</div></div><!-- fragment --><p>The remainder of the class consists largely of member variables that describe the details of the simulation and its discretization. The following parameters are about where output should land, the spatial and temporal discretization (the default is the \(Q_2\times Q_1\) Taylor-Hood discretization which uses a polynomial degree of 2 for the velocity), and how many time steps should elapse before we generate graphical output again:</p>
<div class="fragment"><div class="line">std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div><div class="line"><span class="keywordtype">double</span>       final_time           = 1.0;</div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div></div><!-- fragment --><p>We allow every grid to be refined independently. In this tutorial, no physics is resolved on the solid grid, and its velocity is given as a datum. However it is relatively straightforward to incorporate some elasticity model in this tutorial, and transform it into a fully fledged FSI solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div></div><!-- fragment --><p>To provide a rough description of the fluid domain, we use the method <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> applied to the tree of bounding boxes of each locally owned cell of the fluid triangulation. The higher the level of the tree, the larger the number of extracted bounding boxes, and the more accurate is the description of the fluid domain. However, a large number of bounding boxes also implies a large communication cost, since the collection of bounding boxes is gathered by all processes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div></div><!-- fragment --><p>The only two numerical parameters used in the equations are the viscosity of the fluid, and the penalty term \(\beta\) used in the Nitsche formulation:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> viscosity    = 1.0;</div><div class="line"><span class="keywordtype">double</span> penalty_term = 100;</div></div><!-- fragment --><p>By default, we create a hyper_cube without colorization, and we use homogeneous Dirichlet boundary conditions. In this set we store the boundary ids to use when setting the boundary conditions:</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div></div><!-- fragment --><p>We illustrate here another way to create a <a class="el" href="classTriangulation.html">Triangulation</a> from a parameter file, using the method <a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments()</a>, that takes the name of a function in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, and its arguments as a single string representing the arguments as a tuple.</p>
<p>The mechanism with which the arguments are parsed from and to a string is explained in detail in the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class, which is used to translate from strings to most of the basic STL types (vectors, maps, tuples) and basic deal.II types (<a class="el" href="classPoint.html">Point</a>, <a class="el" href="classTensor.html">Tensor</a>, <a class="el" href="classBoundingBox.html">BoundingBox</a>, etc.).</p>
<p>In general objects that can be represented by rank 1 uniform elements (i.e., std::vector&lt;double&gt;, <a class="el" href="classPoint.html">Point&lt;dim&gt;</a>, std::set&lt;int&gt;, etc.) are comma separated. Additional ranks take a semicolon, allowing you to parse strings into objects of type <code>std::vector&lt;std::vector&lt;double&gt;&gt;</code>, or, for example, <code>std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;dim&gt;&gt;</code>, as <code>0.0, 0.1; 0.1, 0.2</code>. This string could be interpreted as a vector of two <a class="el" href="classPoint.html">Point</a> objects, or a vector of vector of doubles.</p>
<p>When the entries are not uniform, as in the tuple case, we use a colon to separate the various entries. For example, a string like <code>5: 0.1, 0.2</code> could be used to parse an object of type <code>std::pair&lt;int, <a class="el" href="classPoint.html">Point</a>&lt;2&gt;&gt;</code> or a <code>std::tuple&lt;int, std::vector&lt;double&gt;&gt;</code>.</p>
<p>In our case most of the arguments are <a class="el" href="classPoint.html">Point</a> objects (representing centers, corners, subdivision elements, etc.), integer values (number of subdivisions), double values (radius, lengths, etc.), or boolean options (such as the <code>colorize</code> option that many <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions take).</p>
<p>In the example below, we set reasonable default values, but these can be changed at run time by selecting any other supported function of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. If the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function fails, this program will interpret the name of the grid as a vtk grid filename, and the arguments as a map from manifold_id to the CAD files describing the geometry of the domain. Every CAD file will be analyzed and a <a class="el" href="classManifold.html">Manifold</a> of the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace will be generated according to the content of the CAD file itself.</p>
<p>To be as generic as possible, we do this for each of the generated grids: the fluid grid, the solid grid, but also the tracer particles which are also generated using a triangulation.</p>
<div class="fragment"><div class="line">std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div><div class="line">std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div><div class="line">std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div><div class="line">std::string arguments_for_solid_grid = spacedim == 2 ?</div><div class="line">                                         <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div><div class="line">                                         <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div><div class="line">std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div><div class="line">std::string arguments_for_particle_grid =</div><div class="line">  spacedim == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div></div><!-- fragment --><p>Similarly, we allow for different local refinement strategies. In particular, we limit the maximum number of refinement levels, in order to control the minimum size of the fluid grid, and guarantee that it is compatible with the solid grid. The minimum number of refinement levels is also controlled to ensured sufficient accuracy in the bulk of the flow. Additionally, we perform local refinement based on standard error estimators on the fluid velocity field.</p>
<p>We permit the user to choose between the two most common refinement strategies, namely <code>fixed_number</code> or <code>fixed_fraction</code>, that refer to the methods <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction()</a> and <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number()</a>.</p>
<p>Refinement may be done every few time steps, instead of continuously, and we control this value by the <code>refinement_frequency</code> parameter:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>          max_level_refinement = 8;</div><div class="line"><span class="keywordtype">int</span>          min_level_refinement = 5;</div><div class="line">std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div><div class="line"><span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div><div class="line"><span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div><div class="line"><span class="keywordtype">int</span>          refinement_frequency = 5;</div></div><!-- fragment --><p>Finally, the following two function objects are used to control the source term of Stokes flow and the angular velocity at which we move the solid body. In a more realistic simulation, the solid velocity or its deformation would come from the solution of an auxiliary problem on the solid domain. In this example step we leave this part aside, and simply impose a fixed rotational velocity field along the z-axis on the immersed solid, governed by a function that can be specified in the parameter file :</p>
<div class="fragment"><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; rhs;</div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">    angular_velocity;</div><div class="line">};</div></div><!-- fragment --><p>There remains the task of declaring what run-time parameters we can accept in input files. We split the parameters in various categories, by putting them in different sections of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class. We begin by declaring all the global parameters used by StokesImmersedProblem in the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">StokesImmersedProblemParameters&lt;dim,</div><div class="line">                                spacedim&gt;::StokesImmersedProblemParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div><div class="line">  , rhs(<span class="stringliteral">&quot;Right hand side&quot;</span>, spacedim + 1)</div><div class="line">  , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, final_time);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div><div class="line">                initial_fluid_refinement,</div><div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div><div class="line">                initial_solid_refinement,</div><div class="line">                <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div><div class="line">                fluid_rtree_extraction_level,</div><div class="line">                <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div><div class="line">                <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div><div class="line">    particle_insertion_refinement,</div><div class="line">    <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div><div class="line"></div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">    homogeneous_dirichlet_ids,</div><div class="line">    <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div></div><!-- fragment --><p>Next section is dedicated to the parameters used to create the various grids. We will need three different triangulations: <code>Fluid grid</code> is used to define the fluid domain, <code>Solid grid</code> defines the solid domain, and <code>Particle grid</code> is used to distribute some tracer particles, that are advected with the velocity and only used as passive tracers.</p>
<div class="fragment"><div class="line">enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div><div class="line">                arguments_for_particle_grid);</div><div class="line">}</div><div class="line">leave_subsection();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div><div class="line">                refinement_strategy,</div><div class="line">                <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">                this-&gt;prm,</div><div class="line">                <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div><div class="line">}</div><div class="line">leave_subsection();</div></div><!-- fragment --><p>The final task is to correct the default dimension for the right hand side function and define a meaningful default angular velocity instead of zero.</p>
<div class="fragment"><div class="line">  rhs.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">    <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div><div class="line">                                                            spacedim + 1);</div><div class="line">  });</div><div class="line">  angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">    this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                  <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p>Once the angular velocity is provided as a <a class="el" href="classFunction.html">Function</a> object, we reconstruct the pointwise solid velocity through the following class which derives from the <a class="el" href="classFunction.html">Function</a> class. It provides the value of the velocity of the solid body at a given position by assuming that the body rotates around the origin (or the \(z\) axis in 3d) with a given angular velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  static_assert(spacedim &gt; 1,</div><div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">  SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div><div class="line">    : angular_velocity(angular_velocity)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> velocity;</div></div><!-- fragment --><p>We assume that the angular velocity is directed along the z-axis, i.e., we model the actual angular velocity as if it was a two-dimensional rotation, irrespective of the actual value of <code>spacedim</code>.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(p);</div><div class="line">    velocity[0]        = -omega * p[1];</div><div class="line">    velocity[1]        = omega * p[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> velocity[component];</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">};</div></div><!-- fragment --><p>Similarly, we assume that the solid position can be computed explicitly at each time step, exploiting the knowledge of the angular velocity. We compute the exact position of the solid particle assuming that the solid is rotated by an amount equal to the time step multiplied by the angular velocity computed at the point <code>p</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  static_assert(spacedim &gt; 1,</div><div class="line">                <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">  SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;(spacedim)</div><div class="line">    , angular_velocity(angular_velocity)</div><div class="line">    , time_step(time_step)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = p;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> dtheta = angular_velocity.value(p) * time_step;</div><div class="line"></div><div class="line">    new_position[0] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[0] - <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[1];</div><div class="line">    new_position[1] = <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[0] + <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[1];</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> new_position[component];</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div><div class="line">  {</div><div class="line">    time_step = new_time_step;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">  <span class="keywordtype">double</span>                                     time_step;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassdeclaration"></a> </p><h3>The StokesImmersedProblem class declaration</h3>
<p>We are now ready to introduce the main class of our tutorial program. As usual, other than the constructor, we leave a single public entry point: the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> method. Everything else is left <code>private</code>, and accessed through the run method itself.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>StokesImmersedProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  StokesImmersedProblem(</div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div></div><!-- fragment --><p>The next section contains the <code>private</code> members of the class. The first method is similar to what is present in previous example. However it not only takes care of generating the grid for the fluid, but also the grid for the solid. The second computes the largest time step that guarantees that each particle moves of at most one cell. This is important to ensure that the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> can find which cell a particle ends up in, as it can only look from one cell to its immediate neighbors (because, in a parallel setting, every MPI process only knows about the cells it owns as well as their immediate neighbors).</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The next two functions initialize the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used in this class. We have two such objects: One represents passive tracers, used to plot the trajectories of fluid particles, while the the other represents material particles of the solid, which are placed at quadrature points of the solid grid.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_tracer_particles();</div><div class="line"><span class="keywordtype">void</span> setup_solid_particles();</div></div><!-- fragment --><p>The remainder of the set up is split in two parts: The first of the following two functions creates all objects that are needed once per simulation, whereas the other sets up all objects that need to be reinitialized at every refinement step.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> initial_setup();</div><div class="line"><span class="keywordtype">void</span> setup_dofs();</div></div><!-- fragment --><p>The assembly routine is very similar to other Stokes assembly routines, with the exception of the Nitsche restriction part, which exploits one of the particle handlers to integrate on a non-matching part of the fluid domain, corresponding to the position of the solid. We split these two parts into two separate functions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> assemble_stokes_system();</div><div class="line"><span class="keywordtype">void</span> assemble_nitsche_restriction();</div></div><!-- fragment --><p>The remaining functions solve the linear system (which looks almost identical to the one in <a class="el" href="step_60.html">step-60</a>) and then postprocess the solution: The refine_and_transfer() method is called only every <code>refinement_frequency</code> steps to adapt the mesh and also make sure that all the fields that were computed on the time step before refinement are transferred correctly to the new grid. This includes vector fields, as well as particle information. Similarly, we call the two output methods only every <code>output_frequency</code> steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> refine_and_transfer();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle, <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">                      std::string                                 fprefix,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Let us then move on to the member functions of the class. The first deals with run-time parameters that are read from a parameter file. As noted before, we make sure we cannot modify this object from within this class, by making it a <code>const</code> reference.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div></div><!-- fragment --><p>Then there is also the MPI communicator object that we will use to let processes send information across the network if the program runs in parallel, along with the <code>pcout</code> object and timer information that has also been employed by <a class="el" href="step_40.html">step-40</a>, for example:</p>
<div class="fragment"><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line"><span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div></div><!-- fragment --><p>Next is one of the main novelties with regard to <a class="el" href="step_60.html">step-60</a>. Here we assume that both the solid and the fluid are fully distributed triangulations. This allows the problem to scale to a very large number of degrees of freedom, at the cost of communicating all the overlapping regions between non matching triangulations. This is especially tricky, since we make no assumptions on the relative position or distribution of the various subdomains of the two triangulations. In particular, we assume that every process owns only a part of the <code>solid_tria</code>, and only a part of the <code>fluid_tria</code>, not necessarily in the same physical region, and not necessarily overlapping.</p>
<p>We could in principle try to create the initial subdivisions in such a way that each process's subdomains overlap between the solid and the fluid regions. However, this overlap would be destroyed during the simulation, and we would have to redistribute the DoFs again and again. The approach we follow in this tutorial is more flexible, and not much more expensive. We make two all-to-all communications at the beginning of the simulation to exchange information about an (approximate) information of the geometrical occupancy of each processor (done through a collection of bounding boxes).</p>
<p>This information is used by the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class to exchange (using a some-to-some communication pattern) all particles, so that every process knows about the particles that live on the region occupied by the fluid subdomain that it owns.</p>
<p>In order to couple the overlapping regions, we exploit the facilities implemented in the ParticleHandler class.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div></div><!-- fragment --><p>Next come descriptions of the finite elements in use, along with appropriate quadrature formulas and the corresponding <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the current implementation, only <code>fluid_fe</code> is really necessary. For completeness, and to allow easy extension, we also keep the <code>solid_fe</code> around, which is however initialized to a <a class="el" href="classFE__Nothing.html">FE_Nothing</a> finite element space, i.e., one that has no degrees of freedom.</p>
<p>We declare both finite element spaces as <code>std::unique_ptr</code> objects rather than regular member variables, to allow their generation after <code>StokesImmersedProblemParameters</code> has been initialized. In particular, they will be initialized in the <code>initial_setup()</code> method.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div><div class="line"></div><div class="line">std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div><div class="line">std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div><div class="line"></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div><div class="line"></div><div class="line">std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div></div><!-- fragment --><p>Similarly to how things are done in <a class="el" href="step_22.html">step-22</a>, we use a block system to treat the Stokes part of the problem, and follow very closely what was done there.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div><div class="line">std::vector&lt;IndexSet&gt; solid_owned_dofs;</div><div class="line"></div><div class="line">std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div><div class="line">std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div></div><!-- fragment --><p>Using this partitioning of degrees of freedom, we can then define all of the objects necessary to describe the linear systems in question:</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> system_matrix;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> solution;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> locally_relevant_solution;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> system_rhs;</div></div><!-- fragment --><p>Let us move to the particles side of this program. There are two <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects used to couple the solid with the fluid, and to describe the passive tracers. These, in many ways, play a role similar to the <a class="el" href="classDoFHandler.html">DoFHandler</a> class used in the discretization, i.e., they provide for an enumeration of particles and allow querying information about each particle.</p>
<div class="fragment"><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div><div class="line"><a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div></div><!-- fragment --><p>For every tracer particle, we need to compute the velocity field in its current position, and update its position using a discrete time stepping scheme. We do this using distributed linear algebra objects that store the coordinates of each particle's location or velocity. That is, these vectors have <code>tracer_particle_handler.n_global_particles() * spacedim</code> entries that we will store in a way so that parts of the vector are partitioned across all processes. (Implicitly, we here make the assumption that the <code>spacedim</code> coordinates of each particle are stored in consecutive entries of the vector.) Thus, we need to determine who the owner of each vector entry is. We set this owner to be equal to the process that generated that particle at time \(t=0\). This information is stored for every process in the <code>locally_owned_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>.</p>
<p>Once the particles have been distributed around to match the process that owns the region where the particle lives, we will need read access from that process to the corresponding velocity field. We achieve this by filling a read only velocity vector field that contains the relevant information in ghost entries. This is achieved using the <code>locally_relevant_tracer_particle_coordinates</code> <a class="el" href="classIndexSet.html">IndexSet</a>, that keeps track of how things change during the simulation, i.e., it keeps track of where particles that the current process owns have ended up being, and who owns the particles that ended up in my subdomain.</p>
<p>While this is not the most efficient strategy, we keep it this way to illustrate how things would work in a real fluid-structure interaction (FSI) problem. If a particle is linked to a specific solid degree of freedom, we are not free to choose who owns it, and we have to communicate this information around. We illustrate this here, and show that the communication pattern is point-to-point, and negligible in terms of total cost of the algorithm.</p>
<p>The vectors defined based on these subdivisions are then used to store the particles velocities (read-only, with ghost entries) and their displacement (read/write, no ghost entries).</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> tracer_particle_velocities;</div><div class="line"><a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div></div><!-- fragment --><p>One of the key points of this tutorial program is the coupling between two independent <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, one of which may be moving and deforming (with possibly large deformations) with respect to the other. When both the fluid and the solid triangulations are of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, every process has access only to its fraction of locally owned cells of each of the two triangulations. As mentioned above, in general, the locally owned domains are not overlapping.</p>
<p>In order to allow for the efficient exchange of information between non-overlapping <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, some algorithms of the library require the user to provide a rough description of the area occupied by the locally owned part of the triangulation, in the form of a collection of axis-aligned bounding boxes for each process, that provide a full covering of the locally owned part of the domain. This kind of information can then be used in situations where one needs to send information to the owner of the cell surrounding a known location, without knowing who that owner may in fact be. But, if one knows a collection of bounding boxes for the geometric area or volume each process owns, then we can determine a subset of all processes that might possibly own the cell in which that location lies: namely, all of those processes whose bounding boxes contain that point. Instead of sending the information associated to that location to all processes, one can then get away with only sending it to a small subset of the processes with point-to-point communication primitives. (You will notice that this also allows for the typical time-vs-memory trade-off: The more data we are willing to store about each process's owned area &ndash; in the form of more refined bounding box information &ndash; the less communication we have to perform.)</p>
<p>We construct this information by gathering a vector (of length <a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes()</a>) of vectors of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects. We fill this vector using the <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function, and allow the user to select what level of the tree to extract. The "level" corresponds to how coarse/fine the overlap of the area with bounding boxes should be.</p>
<p>As an example, this is what would be extracted by the <a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level()</a> function applied to a two dimensional hyper ball, distributed over three processes. Each image shows in green the bounding boxes associated to the locally owned cells of the triangulation on each process, and in violet the bounding boxes extracted from the rtree:</p>
<div class="image">
<img src="rtree-process-0.png" alt="rtree-process-0.png"/>
</div>
 <div class="image">
<img src="rtree-process-1.png" alt="rtree-process-1.png"/>
</div>
 <div class="image">
<img src="rtree-process-2.png" alt="rtree-process-2.png"/>
</div>
<p>We store these boxes in a global member variable, which is updated at every refinement step:</p>
<div class="fragment"><div class="line">  std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheStokesImmersedProblemclassimplementation"></a> </p><h3>The StokesImmersedProblem class implementation</h3>
<p><a class="anchor" id="Objectconstructionandmeshinitializationfunctions"></a> </p><h4>Object construction and mesh initialization functions</h4>
<p>In the constructor, we create the mpi_communicator as well as the triangulations and dof_handler for both the fluid and the solid. Using the mpi_communicator, both the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and <a class="el" href="classTimerOutput.html">TimerOutput</a> object are constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div><div class="line">  <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div><div class="line">  : par(par)</div><div class="line">  , mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">          (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">  , computing_timer(mpi_communicator,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  , fluid_tria(mpi_communicator,</div><div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::MeshSmoothing(</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_refinement |</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_coarsening))</div><div class="line">  , solid_tria(mpi_communicator,</div><div class="line">               typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::MeshSmoothing(</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_refinement |</div><div class="line">                 <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_coarsening))</div><div class="line">  , fluid_dh(fluid_tria)</div><div class="line">  , solid_dh(solid_tria)</div><div class="line">{}</div></div><!-- fragment --><p>In order to generate the grid, we first try to use the functions in the deal.II <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace, by leveraging the GridGenerator::generate_from_name_and_argument(). If this function fails, then we use the following method, where the name is interpreted as a filename, and the arguments are interpreted as a map from manifold ids to CAD files, and are converted to <a class="el" href="classManifold.html">Manifold</a> descriptors using the <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> namespace facilities. At the top, we read the file into a triangulation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> read_grid_and_cad_files(<span class="keyword">const</span> std::string &amp;grid_file_name,</div><div class="line">                             <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div><div class="line">                             <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div><div class="line">{</div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div><div class="line">  grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">  grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div></div><!-- fragment --><p>If we got to this point, then the <a class="el" href="classTriangulation.html">Triangulation</a> has been read, and we are ready to attach to it the correct manifold descriptions. We perform the next lines of code only if deal.II has been built with <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> support. For each entry in the map, we try to open the corresponding CAD file, we analyze it, and according to its content, opt for either a OpenCASCADE::ArcLengthProjectionLineManifold (if the CAD file contains a single <code>TopoDS_Edge</code> or a single <code>TopoDS_Wire</code>) or a <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a>, if the file contains a single face. Notice that if the CAD files do not contain single wires, edges, or faces, an assertion will be throw in the generation of the <a class="el" href="classManifold.html">Manifold</a>.</p>
<p>We use the <a class="el" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert</a> class to do the conversion from the string to a map between manifold ids and file names for us:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div><div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="namespacePatterns_1_1Tools.html#a59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>   = pair.first;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> extension = boost::algorithm::to_lower_copy(</div><div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div><div class="line"></div><div class="line">        TopoDS_Shape shape;</div><div class="line">        <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;iges&quot;</span> || extension == <span class="stringliteral">&quot;igs&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;step&quot;</span> || extension == <span class="stringliteral">&quot;stp&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div></div><!-- fragment --><p>Now we check how many faces are contained in the <code>Shape</code>. <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> is intrinsically 3D, so if this number is zero, we interpret this as a line manifold, otherwise as a <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> in <code>spacedim</code> = 3, or <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold</a> in <code>spacedim</code> = 2.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> n_elements = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div><div class="line"><span class="keywordflow">if</span> ((std::get&lt;0&gt;(n_elements) == 0))</div><div class="line">  tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div><div class="line">    <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">    <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (spacedim == 3)</div><div class="line">  {</div></div><!-- fragment --><p>We use this trick, because <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a> is only implemented for spacedim = 3. The check above makes sure that things actually work correctly.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div><div class="line">    t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                    <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div><div class="line">                      shape));</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div></div><!-- fragment --><p>We also allow surface descriptions in two dimensional spaces based on single NURBS patches. For this to work, the CAD file must contain a single <code>TopoDS_Face</code>.</p>
<div class="fragment"><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div><div class="line">                              TopoDS::Face(shape)));</div><div class="line">      }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    (void)ids_and_cad_file_names;</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">  }</span></div></div><!-- fragment --><p>Now let's put things together, and make all the necessary grids. As mentioned above, we first try to generate the grid internally, and if we fail (i.e., if we end up in the <code>catch</code> clause), then we proceed with the above function.</p>
<p>We repeat this pattern for both the fluid and the solid mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">        fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div><div class="line">      read_grid_and_cad_files(par.name_of_fluid_grid,</div><div class="line">                              par.arguments_for_fluid_grid,</div><div class="line">                              fluid_tria);</div><div class="line">    }</div><div class="line">  fluid_tria.refine_global(par.initial_fluid_refinement);</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">        solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      read_grid_and_cad_files(par.name_of_solid_grid,</div><div class="line">                              par.arguments_for_solid_grid,</div><div class="line">                              solid_tria);</div><div class="line">    }</div><div class="line"></div><div class="line">  solid_tria.refine_global(par.initial_solid_refinement);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Particleinitializationfunctions"></a> </p><h4>Particle initialization functions</h4>
<p>Once the solid and fluid grids have been created, we start filling the <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> objects. The first one we take care of is the one we use to keep track of passive tracers in the fluid. These are simply transported along, and in some sense their locations are unimportant: We just want to use them to see where flow is being transported. We could use any way we choose to determine where they are initially located. A convenient one is to create the initial locations as the vertices of a mesh in a shape of our choice &ndash; a choice determined by one of the run-time parameters in the parameter file.</p>
<p>In this implementation, we create tracers using the support points of a <a class="el" href="classFE__Q.html">FE_Q</a> finite element space defined on a temporary grid, which is then discarded. Of this grid, we only keep around the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects (stored in a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class) associated to the support points.</p>
<p>The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class offers the possibility to insert a set of particles that live physically in the part of the domain owned by the active process. However, in this case this function would not suffice. The particles generated as the locally owned support points of an <a class="el" href="classFE__Q.html">FE_Q</a> object on an arbitrary grid (non-matching with regard to the fluid grid) have no reasons to lie in the same physical region of the locally owned subdomain of the fluid grid. In fact this will almost never be the case, especially since we want to keep track of what is happening to the particles themselves.</p>
<p>In particle-in-cell methods (PIC), it is often customary to assign ownership of the particles to the process where the particles lie. In this tutorial we illustrate a different approach, which is useful if one wants to keep track of information related to the particles (for example, if a particle is associated to a given degree of freedom, which is owned by a specific process and not necessarily the same process that owns the fluid cell where the particle happens to be at any given time). In the approach used here, ownership of the particles is assigned once at the beginning, and one-to-one communication happens whenever the original owner needs information from the process that owns the cell where the particle lives. We make sure that we set ownership of the particles using the initial particle distribution, and keep the same ownership throughout the execution of the program.</p>
<p>With this overview out of the way, let us see what the function does. At the top, we create a temporary triangulation and <a class="el" href="classDoFHandler.html">DoFHandler</a> object from which we will take the node locations for initial particle locations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div><div class="line">{</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div><div class="line">    mpi_communicator);</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">    particle_insert_tria,</div><div class="line">    par.name_of_particle_grid,</div><div class="line">    par.arguments_for_particle_grid);</div><div class="line">  particle_insert_tria.refine_global(par.particle_insertion_refinement);</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div><div class="line">  particles_dof_handler.distribute_dofs(particles_fe);</div></div><!-- fragment --><p>This is where things start to get complicated. Since we may run this program in a parallel environment, every parallel process will now have created these temporary triangulations and DoFHandlers. But, in fully distributed triangulations, the active process only knows about the locally owned cells, and has no idea of how other processes have distributed their own cells. This is true for both the temporary triangulation created above as well as the fluid triangulation into which we want to embed the particles below. On the other hand, these locally known portions of the two triangulations will, in general, not overlap. That is, the locations of the particles we will create from the node locations of the temporary mesh are arbitrary, and may fall within a region of the fluid triangulation that the current process doesn't have access to (i.e., a region of the fluid domain where cells are artificial). In order to understand who to send those particles to, we need to have a (rough) idea of how the fluid grid is distributed among processors.</p>
<p>We construct this information by first building an index tree of boxes bounding the locally owned cells, and then extracting one of the first levels of the tree:</p>
<div class="fragment"><div class="line">std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div><div class="line">all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    all_boxes.emplace_back(cell-&gt;bounding_box());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div><div class="line">  <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, par.fluid_rtree_extraction_level);</div></div><!-- fragment --><p>Each process now has a collection of bounding boxes that completely enclose all locally owned processes (but that may overlap the bounding boxes of other processes). We then exchange this information between all participating processes so that every process knows the bounding boxes of all other processes.</p>
<p>Equipped with this knowledge, we can then initialize the <code>tracer_particle_handler</code> to the fluid mesh and generate the particles from the support points of the (temporary) tracer particles triangulation. This function call uses the <code>global_bounding_boxes</code> object we just constructed to figure out where to send the particles whose locations were derived from the locally owned part of the <code>particles_dof_handler</code>. At the end of this call, every particle will have been distributed to the correct process (i.e., the process that owns the fluid cell where the particle lives). We also output their number to the screen at this point.</p>
<div class="fragment"><div class="line">global_fluid_bounding_boxes =</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div><div class="line"></div><div class="line">tracer_particle_handler.initialize(fluid_tria,</div><div class="line">                                   <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div><div class="line"></div><div class="line"><a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div><div class="line">                                          global_fluid_bounding_boxes,</div><div class="line">                                          tracer_particle_handler);</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div><div class="line">      &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Each particle so created has a unique ID. At some point in the algorithm below, we will need vectors containing position and velocity information for each particle. This vector will have size <code>n_particles * spacedim</code>, and we will have to store the elements of this vector in a way so that each parallel process "owns" those elements that correspond to coordinates of the particles it owns. In other words, we have to partition the index space between zero and <code>n_particles * spacedim</code> among all processes. We can do this by querying the <code>tracer_particle_handler</code> for the IDs of its locally relevant particles, and construct the indices that would be needed to store in a (parallel distributed) vector of the position and velocity of all particles where we implicitly assume that we store the coordinates of each location or velocity in <code>spacedim</code> successive vector elements (this is what the IndexSet::tensor_priduct() function does).</p>
<div class="fragment"><div class="line">locally_owned_tracer_particle_coordinates =</div><div class="line">  tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">    <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div></div><!-- fragment --><p>At the beginning of the simulation, all particles are in their original position. When particles move, they may traverse to a part of the domain which is owned by another process. If this happens, the current process keeps formally "ownership" of the particles, but may need read access from the process where the particle has landed. We keep this information in another index set, which stores the indices of all particles that are currently on the current process's subdomain, independently if they have always been here or not.</p>
<p>Keeping this index set around allows us to leverage linear algebra classes for all communications regarding positions and velocities of the particles. This mimics what would happen in the case where another problem was solved in the solid domain (as in fluid-structure interaction. In this latter case, additional DOFs on the solid domain would be coupled to what is occurring in the fluid domain.</p>
<div class="fragment"><div class="line">locally_relevant_tracer_particle_coordinates =</div><div class="line">  locally_owned_tracer_particle_coordinates;</div></div><!-- fragment --><p>Finally, we make sure that upon refinement, particles are correctly transferred. When performing local refinement or coarsening, particles will land in another cell. We could in principle redistribute all particles after refining, however this would be overly expensive.</p>
<p>The <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> class has a way to transfer information from a cell to its children or to its parent upon refinement, without the need to reconstruct the entire data structure. This is done by registering two callback functions to the triangulation. These functions will receive a signal when refinement is about to happen, and when it has just happened, and will take care of transferring all information to the newly refined grid with minimal computational cost.</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">    [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">  fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div><div class="line">    tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p>Similarly to what we have done for passive tracers, we next set up the particles that track the quadrature points of the solid mesh. The main difference here is that we also want to attach a weight value (the "JxW" value of the quadrature point) to each of particle, so that we can compute integrals even without direct access to the original solid grid.</p>
<p>This is achieved by leveraging the "properties" concept of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> class. It is possible to store (in a memory efficient way) an arbitrary number of <code>double</code> numbers for each of the <a class="el" href="classParticles_1_1Particle.html">Particles::Particle</a> objects inside a <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> object. We use this possibility to store the JxW values of the quadrature points of the solid grid.</p>
<p>In our case, we only need to store one property per particle: the JxW value of the integration on the solid grid. This is passed at construction time to the solid_particle_handler object as the last argument</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(fluid_fe-&gt;degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div><div class="line">  solid_particle_handler.initialize(fluid_tria,</div><div class="line">                                    <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div><div class="line">                                    n_properties);</div></div><!-- fragment --><p>The number of particles that we generate locally is equal to the total number of locally owned cells times the number of quadrature points used in each cell. We store all these points in a vector, and their corresponding properties in a vector of vectors:</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div><div class="line">quadrature_points_vec.reserve(quadrature.size() *</div><div class="line">                              solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">std::vector&lt;std::vector&lt;double&gt;&gt; properties;</div><div class="line">properties.reserve(quadrature.size() *</div><div class="line">                   solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div><div class="line">                             quadrature,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : solid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      fe_v.reinit(cell);</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; points.size(); ++q)</div><div class="line">        {</div><div class="line">          quadrature_points_vec.emplace_back(points[q]);</div><div class="line">          properties.emplace_back(</div><div class="line">            std::vector&lt;double&gt;(n_properties, JxW[q]));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>We proceed in the same way we did with the tracer particles, reusing the computed bounding boxes. However, we first check that the <code>global_fluid_bounding_boxes</code> object has been actually filled. This should certainly be the case here, since this method is called after the one that initializes the tracer particles. However, we want to make sure that if in the future someone decides (for whatever reason) to initialize first the solid particle handler, or to copy just this part of the tutorial, a meaningful exception is thrown when things don't work as expected</p>
<p>Since we have already stored the position of the quadrature points, we can use these positions to insert the particles directly using the <code>solid_particle_handler</code> instead of having to go through a <a class="el" href="namespaceParticles_1_1Generators.html">Particles::Generators</a> function:</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div><div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div><div class="line">         <span class="stringliteral">&quot;I was expecting the &quot;</span></div><div class="line">         <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div><div class="line">         <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div><div class="line">         <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">solid_particle_handler.insert_global_particles(quadrature_points_vec,</div><div class="line">                                               global_fluid_bounding_boxes,</div><div class="line">                                               properties);</div></div><!-- fragment --><p>As in the previous function, we end by making sure that upon refinement, particles are correctly transferred:</p>
<div class="fragment"><div class="line">  fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">    [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">  fluid_tria.signals.post_distributed_refinement.connect(</div><div class="line">    [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DoFinitializationfunctions"></a> </p><h4>DoF initialization functions</h4>
<p>We set up the finite element space and the quadrature formula to be used throughout the step. For the fluid, we use Taylor-Hood elements (e.g. \(Q_k \times Q_{k-1}\)). Since we do not solve any equation on the solid domain, an empty finite element space is generated. A natural extension of this program would be to solve a fluid structure interaction problem, which would require that the <code>solid_fe</code> use more useful <a class="el" href="classFiniteElement.html">FiniteElement</a> class.</p>
<p>Like for many other functions, we store the time necessary to carry out the operations we perform here. The current function puts its timing information into a section with label "Initial setup". Numerous other calls to this timer are made in various functions. They allow to monitor the absolute and relative cost of each individual function to identify bottlenecks.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div><div class="line"></div><div class="line">  fluid_fe =</div><div class="line">    std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div><div class="line">                                         spacedim,</div><div class="line">                                         <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div><div class="line">                                                        1),</div><div class="line">                                         1);</div><div class="line"></div><div class="line"></div><div class="line">  solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div><div class="line">  solid_dh.distribute_dofs(*solid_fe);</div><div class="line"></div><div class="line">  fluid_quadrature_formula =</div><div class="line">    std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">  solid_quadrature_formula =</div><div class="line">    std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">}</div></div><!-- fragment --><p>We next construct the distributed block matrices and vectors which are used to solve the linear equations that arise from the problem. This function is adapted from <a class="el" href="step_55.html">step-55</a> and we refer to this step for a thorough explanation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div><div class="line"></div><div class="line">  fluid_dh.distribute_dofs(*fluid_fe);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0);</div><div class="line">  stokes_sub_blocks[spacedim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">        &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div><div class="line">        &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div><div class="line">        &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  fluid_owned_dofs.resize(2);</div><div class="line">  fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div><div class="line">  fluid_owned_dofs[1] =</div><div class="line">    fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div><div class="line">  fluid_relevant_dofs.resize(2);</div><div class="line">  fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div><div class="line">  fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.reinit(locally_relevant_dofs);</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      fluid_dh,</div><div class="line">      0,</div><div class="line">      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(spacedim + 1),</div><div class="line">      constraints,</div><div class="line">      fluid_fe-&gt;component_mask(velocities));</div><div class="line">    constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator,</div><div class="line">                               fluid_dh.locally_owned_dofs());</div><div class="line">  {</div><div class="line">    system_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == spacedim || d == spacedim || c == d)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">      dsp,</div><div class="line">      locally_owned_dofs_per_processor,</div><div class="line">      mpi_communicator,</div><div class="line">      locally_relevant_dofs);</div><div class="line"></div><div class="line">    system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">      dsp,</div><div class="line">      locally_owned_dofs_per_processor,</div><div class="line">      mpi_communicator,</div><div class="line">      locally_relevant_dofs);</div><div class="line">    preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line">  locally_relevant_solution.reinit(fluid_owned_dofs,</div><div class="line">                                   fluid_relevant_dofs,</div><div class="line">                                   mpi_communicator);</div><div class="line">  system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">  solution.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblyfunctions"></a> </p><h4>Assembly functions</h4>
<p>We assemble the system matrix, the preconditioner matrix, and the right hand side. The code is adapted from <a class="el" href="step_55.html">step-55</a>, which is essentially what <a class="el" href="step_27.html">step-27</a> also has, and is pretty standard if you know what the Stokes equations look like.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  system_matrix         = 0;</div><div class="line">  preconditioner_matrix = 0;</div><div class="line">  system_rhs            = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div><div class="line">                               *fluid_quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fluid_quadrature_formula-&gt;size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points,</div><div class="line">                                         Vector&lt;double&gt;(spacedim + 1));</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;              div_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;              phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure(spacedim);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_matrix  = 0;</div><div class="line">        cell_matrix2 = 0;</div><div class="line">        cell_rhs     = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        par.rhs.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                  rhs_values);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_u[k] = fe_values[velocities].gradient(k, q);</div><div class="line">                div_phi_u[k]  = fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]      = fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (par.viscosity *</div><div class="line">                         <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) -</div><div class="line">                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">                    cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *</div><div class="line">                                          phi_p[j] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                  fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">                               rhs_values[q](component_i) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                               cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(cell_matrix2,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               preconditioner_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">  system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>The following method is then the one that deals with the penalty terms that result from imposing the velocity on the impeller. It is, in a sense, the heart of the tutorial, but it is relatively straightforward. Here we exploit the <code>solid_particle_handler</code> to compute the Nitsche restriction or the penalization in the embedded domain.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);</div><div class="line"></div><div class="line">  SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div><div class="line">    fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div><div class="line">                                  fluid_fe-&gt;n_dofs_per_cell());</div><div class="line">  <a class="code" href="classVector.html">::Vector&lt;double&gt;</a> local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div><div class="line">    1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div></div><!-- fragment --><p>We loop over all the local particles. Although this could be achieved directly by looping over all the cells, this would force us to loop over numerous cells which do not contain particles. Consequently, we loop over all the particles, but, we get the reference of the cell in which the particle lies and then loop over all particles within that cell. This enables us to skip the cells which do not contain particles, yet to assemble the local matrix and rhs of each cell to apply the Nitsche restriction. Once we are done with all particles on one cell, we advance the <code>particle</code> iterator to the particle past the end of the ones on the current cell (this is the last line of the <code>while</code> loop's body).</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> particle = solid_particle_handler.begin();</div><div class="line"><span class="keywordflow">while</span> (particle != solid_particle_handler.end())</div><div class="line">  {</div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs    = 0;</div></div><!-- fragment --><p>We get an iterator to the cell within which the particle lies from the particle itself. We can then assemble the additional terms in the system matrix and the right hand side as we would normally.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*cell, &amp;fluid_dh);</div><div class="line">dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div></div><!-- fragment --><p>So then let us get the collection of cells that are located on this cell and iterate over them. From each particle we gather the location and the reference location of the particle as well as the additional information that is attached to the particle. In the present case, this information is the "JxW" of the quadrature points which were used to generate the particles.</p>
<p>Using this information, we can add the contribution of the quadrature point to the local_matrix and local_rhs. We can evaluate the value of the shape function at the position of each particle easily by using its reference location.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(cell);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == particle, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pic)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = p.get_reference_location();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = p.get_location();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = p.get_properties()[0];</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fluid_fe-&gt;n_dofs_per_cell(); ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div><div class="line">                fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">              <span class="keywordflow">if</span> (comp_i &lt; spacedim)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">                       ++j)</div><div class="line">                    {</div><div class="line">                      <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div><div class="line">                        fluid_fe-&gt;system_to_component_index(j).first;</div><div class="line">                      <span class="keywordflow">if</span> (comp_i == comp_j)</div><div class="line">                        local_matrix(i, j) +=</div><div class="line">                          penalty_parameter * par.penalty_term *</div><div class="line">                          fluid_fe-&gt;shape_value(i, ref_q) *</div><div class="line">                          fluid_fe-&gt;shape_value(j, ref_q) * JxW;</div><div class="line">                    }</div><div class="line">                  local_rhs(i) += penalty_parameter * par.penalty_term *</div><div class="line">                                  solid_velocity.value(real_q, comp_i) *</div><div class="line">                                  fluid_fe-&gt;shape_value(i, ref_q) * JxW;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                             local_rhs,</div><div class="line">                                             fluid_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">      particle = pic.end();</div><div class="line">    }</div><div class="line"></div><div class="line">  system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solvingthelinearsystem"></a> </p><h4>Solving the linear system</h4>
<p>This function solves the linear system with FGMRES with a block diagonal preconditioner and an algebraic multigrid (AMG) method for the diagonal blocks. The preconditioner applies a V cycle to the \((0,0)\) (i.e., the velocity-velocity) block and a CG with the mass matrix for the \((1,1)\) block (which is our approximation to the Schur complement: the pressure mass matrix assembled above).</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_A;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_A.initialize(system_matrix.block(0, 0), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_S;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_S.initialize(preconditioner_matrix.block(1, 1), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, prec_A);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div><div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(S, prec_S);</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div><div class="line">                                          1e-8 * system_rhs.l2_norm(),</div><div class="line">                                          1.e-2);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div><div class="line">      std::array&lt;</div><div class="line">        ::LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;,</div><div class="line">        2&gt;{{amgA, amgS}});</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div><div class="line">                                 1e-10 * system_rhs.l2_norm());</div><div class="line"></div><div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">    constraints.set_zero(solution);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, P);</div><div class="line"></div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    locally_relevant_solution = solution;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div><div class="line">      VectorTools::compute_mean_value(fluid_dh,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div><div class="line">                                      locally_relevant_solution,</div><div class="line">                                      spacedim);</div><div class="line">    solution.block(1).add(-mean_pressure);</div><div class="line">    locally_relevant_solution.block(1) = solution.block(1);</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="Meshrefinement"></a> </p><h4>Mesh refinement</h4>
<p>We deal with mesh refinement in a completely standard way:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> error_per_cell(fluid_tria.n_active_cells());</div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div><div class="line">                                            par.velocity_degree + 1),</div><div class="line">                                          {},</div><div class="line">                                          locally_relevant_solution,</div><div class="line">                                          error_per_cell,</div><div class="line">                                          fluid_fe-&gt;component_mask(velocity));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">        refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div><div class="line">                                          error_per_cell,</div><div class="line">                                          par.refinement_fraction,</div><div class="line">                                          par.coarsening_fraction);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">        fluid_tria,</div><div class="line">        error_per_cell,</div><div class="line">        par.refinement_fraction,</div><div class="line">        par.coarsening_fraction,</div><div class="line">        par.max_cells);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;refine_flag_set() &amp;&amp;</div><div class="line">          cell-&gt;level() == par.max_level_refinement)</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;coarsen_flag_set() &amp;&amp;</div><div class="line">          cell-&gt;level() == par.min_level_refinement)</div><div class="line">        cell-&gt;clear_coarsen_flag();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div><div class="line">    transfer(fluid_dh);</div><div class="line">  fluid_tria.prepare_coarsening_and_refinement();</div><div class="line">  transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div><div class="line">  fluid_tria.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  transfer.interpolate(solution);</div><div class="line">  constraints.distribute(solution);</div><div class="line">  locally_relevant_solution = solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingoutputforvisualization"></a> </p><h4>Creating output for visualization</h4>
<p>We output the results (velocity and pressure) on the fluid domain using the standard parallel capabilities of deal.II. A single compressed vtu file is written that agglomerates the information of all processors. An additional <code>.pvd</code> record is written to associate the physical time to the vtu files.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle,</div><div class="line">                                                     <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; solution_names(spacedim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      spacedim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(fluid_dh);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(locally_relevant_solution,</div><div class="line">                           solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(fluid_tria.n_active_cells());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">    subdomain(i) = fluid_tria.locally_owned_subdomain();</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                 mpi_communicator);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line">  times_and_names.push_back(std::make_pair(time, filename));</div><div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div><div class="line">}</div></div><!-- fragment --><p>Similarly, we write the particles (either from the solid or the tracers) as a single compressed vtu file through the <a class="el" href="classParticles_1_1DataOut.html">Particles::DataOut</a> object. This simple object does not write the additional information attached as "properties" to the particles, but only writes their id &ndash; but then, we don't care about the "JxW" values of these particle locations anyway, so no information that we may have wanted to visualize is lost.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">  std::string                                 fprefix,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div><div class="line">  particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(particles);</div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">  particles_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                      mpi_communicator);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div><div class="line">    times_and_names;</div><div class="line">  <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div><div class="line">    times_and_names[fprefix].push_back(std::make_pair(time, filename));</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    times_and_names[fprefix] = {std::make_pair(time, filename)};</div><div class="line">  std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunction"></a> </p><h4>The "run" function</h4>
<p>This function now orchestrates the entire simulation. It is very similar to the other time dependent tutorial programs &ndash; take <a class="el" href="step_21.html">step-21</a> or <a class="el" href="step_26.html">step-26</a> as an example. At the beginning, we output some status information and also save all current parameters to a file in the output directory, for reproducibility.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div><div class="line">                               <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) +</div><div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div><div class="line">                             <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a>);</div></div><!-- fragment --><p>We then start the time loop. We initialize all the elements of the simulation in the first cycle</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div><div class="line"><span class="keywordtype">double</span>       time         = 0;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; par.number_of_time_steps;</div><div class="line">     ++cycle, time += time_step)</div><div class="line">  {</div><div class="line">    par.set_time(time);</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">      {</div><div class="line">        make_grid();</div><div class="line">        initial_setup();</div><div class="line">        setup_dofs();</div><div class="line">        setup_tracer_particles();</div><div class="line">        setup_solid_particles();</div><div class="line">        tracer_particle_velocities.reinit(</div><div class="line">          locally_owned_tracer_particle_coordinates, mpi_communicator);</div><div class="line">        output_results(output_cycle, time);</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">          output_particles(tracer_particle_handler,</div><div class="line">                           <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                           output_cycle,</div><div class="line">                           time);</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">          output_particles(solid_particle_handler,</div><div class="line">                           <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                           output_cycle,</div><div class="line">                           time);</div><div class="line">        }</div><div class="line">      }</div></div><!-- fragment --><p>After the first time step, we displace the solid body at the beginning of each time step to take into account the fact that is has moved.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div><div class="line">                         <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div><div class="line"></div><div class="line">    SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div><div class="line">                                           time_step);</div><div class="line">    solid_particle_handler.set_particle_positions(solid_position,</div><div class="line">                                                  <span class="keyword">false</span>);</div><div class="line">  }</div></div><!-- fragment --><p>In order to update the state of the system, we first interpolate the fluid velocity at the position of the tracer particles and, with a naive explicit Euler scheme, advect the massless tracer particles.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div><div class="line">  <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div><div class="line">    fluid_dh,</div><div class="line">    tracer_particle_handler,</div><div class="line">    locally_relevant_solution,</div><div class="line">    tracer_particle_velocities,</div><div class="line">    fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div><div class="line"></div><div class="line">  tracer_particle_velocities *= time_step;</div><div class="line"></div><div class="line">  locally_relevant_tracer_particle_coordinates =</div><div class="line">    tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">      <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">  relevant_tracer_particle_displacements.reinit(</div><div class="line">    locally_owned_tracer_particle_coordinates,</div><div class="line">    locally_relevant_tracer_particle_coordinates,</div><div class="line">    mpi_communicator);</div><div class="line"></div><div class="line">  relevant_tracer_particle_displacements = tracer_particle_velocities;</div><div class="line"></div><div class="line">  tracer_particle_handler.set_particle_positions(</div><div class="line">    relevant_tracer_particle_displacements);</div><div class="line">}</div></div><!-- fragment --><p>Using these new locations, we can then assemble the Stokes system and solve it.</p>
<div class="fragment"><div class="line">assemble_stokes_system();</div><div class="line">assemble_nitsche_restriction();</div><div class="line">solve();</div></div><!-- fragment --><p>With the appropriate frequencies, we then write the information of the solid particles, the tracer particles, and the fluid domain into files for visualization, and end the time step by adapting the mesh.</p>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (cycle % par.output_frequency == 0)</div><div class="line">          {</div><div class="line">            output_results(output_cycle, time);</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">              output_particles(tracer_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">              output_particles(solid_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            ++output_cycle;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cycle % par.refinement_frequency == 0 &amp;&amp;</div><div class="line">            cycle != par.number_of_time_steps - 1)</div><div class="line">          refine_and_transfer();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step70</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The remainder of the code, the <code>main()</code> function, is standard, with the exception of the handling of input parameter files. We allow the user to specify an optional parameter file as an argument to the program. If nothing is specified, we use the default file "parameters.prm", which is created if non existent. The file name is scanned for the the string "23" first, and "3" afterwards. If the filename contains the string "23", the problem classes are instantiated with template arguments 2 and 3 respectively. If only the string "3" is found, then both template arguments are set to 3, otherwise both are set to 2.</p>
<p>If the program is called without any command line arguments (i.e., <code>argc==1</code>), then we just use "parameters.prm" by default.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step70;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2, 3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2, 3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-70/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>运行该程序的目录中包含一些样本参数文件，你可以用它们来重现本节介绍的结果。如果你没有在命令行中指定参数文件作为参数，程序将默认尝试读取文件"`parameters.prm`"，并执行二维版本的代码。正如在源代码的讨论中所解释的那样，如果你的文件名包含字符串 "23"，那么程序将运行一个三维问题，即共维度为1的沉入式实体。如果文件名包含字符串 "3"，它将运行一个三维问题，同维度的沉浸实体为零，否则它将运行一个二维问题，同维度的沉浸实体为零。</p>
<p>无论具体的参数文件名是什么，如果指定的文件不存在，当你执行程序时，你会得到一个异常，即找不到这样的文件。</p>
<div class="fragment"><div class="line">----------------------------------------------------</div><div class="line">Exception on processing:</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;74&gt; of file &lt;../source/base/parameter_acceptor.cc&gt; in <span class="keyword">function</span></div><div class="line">    <span class="keyword">static</span> void ::ParameterAcceptor::initialize(<span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>, ::<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;)</div><div class="line">The violated condition was:</div><div class="line">    <span class="keyword">false</span></div><div class="line">Additional information:</div><div class="line">    You specified &lt;parameters.prm&gt; as input parameter file, but it does not exist. We created it <span class="keywordflow">for</span> you.</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line"></div><div class="line"></div><div class="line">Aborting!</div><div class="line"></div><div class="line"></div><div class="line">----------------------------------------------------</div></div><!-- fragment --><p>然而，正如错误信息已经指出的，触发异常的代码也将生成指定的文件（"`parameters.prm`"在这种情况下），该文件仅仅包含这个程序关心的所有参数的默认值（对于正确的尺寸和辅助尺寸，根据文件名中是否包含字符串 "23 "或 "3"）。通过检查默认参数文件，我们看到以下内容。</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line">subsection Stokes Immersed Problem</div><div class="line">  <span class="keyword">set</span> Final time                            = 1</div><div class="line"><span class="preprocessor">  # Extraction level of the rtree used to construct global bounding boxes</span></div><div class="line">  <span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # Boundary Ids over which homogeneous Dirichlet boundary conditions are</span></div><div class="line"><span class="preprocessor">  # applied</span></div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # Initial mesh refinement used for the fluid domain Omega</span></div><div class="line">  <span class="keyword">set</span> Initial fluid refinement              = 5</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # Initial mesh refinement used for the solid domain Gamma</span></div><div class="line">  <span class="keyword">set</span> Initial solid refinement              = 5</div><div class="line">  <span class="keyword">set</span> Nitsche penalty term                  = 100</div><div class="line">  <span class="keyword">set</span> Number of time steps                  = 501</div><div class="line">  <span class="keyword">set</span> Output directory                      = .</div><div class="line">  <span class="keyword">set</span> Output frequency                      = 1</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # Refinement of the volumetric mesh used to insert the particles</span></div><div class="line">  <span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line">  <span class="keyword">set</span> Velocity degree                       = 2</div><div class="line">  <span class="keyword">set</span> Viscosity                             = 1</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  subsection Angular velocity</div><div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div><div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="preprocessor">    # components by a semicolon.</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 : -6.283185 # <span class="keywordflow">default</span>: 0</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div><div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor">    # your function expression.</span></div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line"></div><div class="line"></div><div class="line">  subsection Grid generation</div><div class="line">    <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div><div class="line">    <span class="keyword">set</span> Fluid grid generator arguments    = -1: 1: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line">    <span class="keyword">set</span> Particle grid generator arguments = 0.3, 0.3: 0.1: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Solid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line">    <span class="keyword">set</span> Solid grid generator arguments    = -.5, -.1: .5, .1: <span class="keyword">false</span></div><div class="line">  end</div><div class="line"></div><div class="line"></div><div class="line">  subsection Refinement and remeshing</div><div class="line">    <span class="keyword">set</span> Maximum number of cells        = 20000</div><div class="line">    <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement maximal level       = 8</div><div class="line">    <span class="keyword">set</span> Refinement minimal level       = 5</div><div class="line">    <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line">    <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">  end</div><div class="line"></div><div class="line"></div><div class="line">  subsection Right hand side</div><div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div><div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="preprocessor">    # components by a semicolon.</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div><div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor">    # your function expression.</span></div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line"></div><div class="line"></div><div class="line">end</div></div><!-- fragment --><p>如果你现在运行该程序，你会在参数<code>Output directory</code>（默认为当前目录）指定的目录下得到一个名为<code>parameters_22.prm</code>的文件，其中包含上述参数的简短版本（没有注释和文档），记录了所有用于运行程序的参数。</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line">  <span class="keyword">set</span> Final time                            = 1</div><div class="line">  <span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line">  <span class="keyword">set</span> Initial fluid refinement              = 5</div><div class="line">  <span class="keyword">set</span> Initial solid refinement              = 5</div><div class="line">  <span class="keyword">set</span> Nitsche penalty term                  = 100</div><div class="line">  <span class="keyword">set</span> Number of time steps                  = 501</div><div class="line">  <span class="keyword">set</span> Output directory                      = .</div><div class="line">  <span class="keyword">set</span> Output frequency                      = 1</div><div class="line">  <span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line">  <span class="keyword">set</span> Velocity degree                       = 2</div><div class="line">  <span class="keyword">set</span> Viscosity                             = 1</div><div class="line">  subsection Angular velocity</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 6.283185 : -6.283185</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Grid generation</div><div class="line">    <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a></div><div class="line">    <span class="keyword">set</span> Fluid grid generator arguments    = -1: 1: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line">    <span class="keyword">set</span> Particle grid generator arguments = 0.3, 0.3: 0.1: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Solid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line">    <span class="keyword">set</span> Solid grid generator arguments    = -.5, -.1: .5, .1: <span class="keyword">false</span></div><div class="line">  end</div><div class="line">  subsection Refinement and remeshing</div><div class="line">    <span class="keyword">set</span> Maximum number of cells        = 20000</div><div class="line">    <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement maximal level       = 8</div><div class="line">    <span class="keyword">set</span> Refinement minimal level       = 5</div><div class="line">    <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line">    <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">  end</div><div class="line">  subsection Right hand side</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>首先创建 "parameters.prm "文件（程序第一次运行时），然后创建 "output/parameters_22.prm "文件（每次使用现有的输入文件运行程序时），这是因为你可能想把大多数参数保留为默认值，只修改其中的一小部分，同时仍然能够重现结果，检查特定模拟使用了哪些参数。一般来说，将用于模拟的参数文件与模拟输出一起保存起来是很好的科学做法，这样你就可以在以后的时间里重复相同的运行。</p>
<p>另一个原因是输入文件可能只包含那些与默认值不同的参数。例如，你可以在本教程程序中使用以下（完全有效的）参数文件。</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line">  <span class="keyword">set</span> Final time                         = 1</div><div class="line">  <span class="keyword">set</span> Nitsche penalty term               = 10</div><div class="line">  <span class="keyword">set</span> Number of time steps               = 101</div><div class="line">  <span class="keyword">set</span> Velocity degree                    = 3</div><div class="line">end</div></div><!-- fragment --><p>你将使用Q3/Q2 Taylor-Hood有限元运行程序，进行101步，使用Nitsche惩罚为<code>10</code>，并将所有其他参数保持为默认值。输出目录不仅包含了这些参数的记录，而且包含了仿真中使用的所有参数。你可以在生成的文件<code>parameters_22.prm</code>中查看所有其他参数。</p>
<p><a class="anchor" id="Twodimensionaltestcase"></a></p><h3>Two dimensional test case </h3>
<p>默认问题产生了一个同维度的零叶轮，由一个旋转的矩形网格组成，在一个方向上旋转半个时间单位，在相反方向上旋转半个时间单位，恒定的角速度等于 \(\approx 2\pi \frac{\text{rad}}{\text{time unit}}\) 。因此，叶轮做了半个旋转，并返回到原来的位置。下面的动画显示了速度的大小，固体叶轮和示踪粒子的运动。</p>
<div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-70.2d_tracing.gif" width="500"/>
</div>
 </div> <p>在一个核心上，程序的输出将看起来像下面这样。</p>
<div class="fragment"><div class="line">bash@f$ mpirun -np 1 ./step-70 test.prm</div><div class="line">Running StokesImmersedProblem&lt;2&gt; <span class="keyword">using</span> Trilinos.</div><div class="line">Cycle 0:</div><div class="line">Time : 0, time step: 0.002</div><div class="line">   Number of degrees of freedom: 9539 (8450+1089 -- 0+0)</div><div class="line">Tracer particles: 337</div><div class="line">Solid particles: 9216</div><div class="line">   Solved in 158 iterations.</div><div class="line">   Number of degrees of freedom: 9845 (8722+1123 -- 9216+337)</div><div class="line">Cycle 1:</div><div class="line">Time : 0.002, time step: 0.002</div><div class="line">   Solved in 142 iterations.</div><div class="line">Cycle 2:</div><div class="line">Time : 0.004, time step: 0.002</div><div class="line">   Solved in 121 iterations.</div><div class="line">Cycle 3:</div><div class="line">Time : 0.006, time step: 0.002</div><div class="line">   Solved in 121 iterations.</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">Cycle 499:</div><div class="line">Time : 0.998, time step: 0.002</div><div class="line">   Solved in 199 iterations.</div><div class="line">Cycle 500:</div><div class="line">Time : 1, time step: 0.002</div><div class="line">   Solved in 196 iterations.</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |       302s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble Nitsche terms          |       501 |      43.3s |        14% |</div><div class="line">| Assemble Stokes terms           |       501 |      21.5s |       7.1% |</div><div class="line">| Initial setup                   |         1 |  0.000792s |         0% |</div><div class="line">| Output fluid                    |       502 |      31.8s |        11% |</div><div class="line">| Output solid particles          |       502 |      32.2s |        11% |</div><div class="line">| Output tracer particles         |       502 |      0.61s |       0.2% |</div><div class="line">| Refine                          |       100 |      4.68s |       1.5% |</div><div class="line">| Set solid particle position     |       500 |      3.34s |       1.1% |</div><div class="line">| Set tracer particle motion      |       501 |     0.729s |      0.24% |</div><div class="line">| Setup dofs                      |       101 |       2.2s |      0.73% |</div><div class="line">| Solve                           |       501 |       164s |        54% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>你可能会注意到，组装耦合系统比组装斯托克斯部分更昂贵。这在很大程度上取决于用于应用Nitsche限制的高斯点（固体粒子）的数量。在目前的情况下，所使用的示踪粒子的数量相对较少。因此，跟踪它们的运动是相对便宜的。</p>
<p>下面的影片显示了解决方案随时间的演变。</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/y4Gypj2jpXw"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p>这部电影显示了灰色的旋转障碍物（实际上是用足够大的点绘制的固体粒子的叠加，使它们重叠），浅色的<a href="https://en.wikipedia.org/wiki/Streamlines,_streaklines,_and_pathlines">streamlines of the fluid flow</a>（包括在模拟过程中特定时间形成的角顶点），以及蓝色色调的示踪粒子。</p>
<p>模拟结果显示，在结束的时候，示踪剂颗粒已经在一定程度上回到了原来的位置，尽管它们已经被流场扭曲了。下面的图片比较了粒子在一个时间单位的流动后的初始和最终位置。</p>
<div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-70.tracer_comparison.png" width="500"/>
</div>
 </div> <p>在这种情况下，我们看到在叶轮扫过的体积之外的示踪剂颗粒已经非常接近它们的初始位置，而在扫过的体积内的示踪剂颗粒的变形略大。这种变形是非物理性的。它是由用于平移粒子的显式欧拉方案引起的数值误差、由虚构领域引起的精度损失以及最后由斯托克斯方程的离散化误差引起的。前两个错误是造成这种变形的主要原因，它们可以通过使用更细的网格和更小的时间步长来缓解。</p>
<p><a class="anchor" id="Threedimensionaltestcase"></a></p><h3>Three dimensional test case </h3>
<p>为了玩一玩，我们将虚构的领域复杂化（取自https://grabcad.com/library/lungstors-blower-1），并在三个空间维度上运行共维一模拟，使用以下"`参数_23.prm`"文件。</p>
<div class="fragment"><div class="line">subsection Stokes Immersed Problem</div><div class="line">  <span class="keyword">set</span> Final time                            = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids    = 0</div><div class="line">  <span class="keyword">set</span> Fluid bounding boxes extraction level = 1</div><div class="line">  <span class="keyword">set</span> Initial fluid refinement              = 3</div><div class="line">  <span class="keyword">set</span> Initial solid refinement              = 0</div><div class="line">  <span class="keyword">set</span> Nitsche penalty term                  = 10</div><div class="line">  <span class="keyword">set</span> Number of time steps                  = 101</div><div class="line">  <span class="keyword">set</span> Output frequency                      = 1</div><div class="line">  <span class="keyword">set</span> Particle insertion refinement         = 3</div><div class="line">  <span class="keyword">set</span> Velocity degree                       = 2</div><div class="line">  <span class="keyword">set</span> Viscosity                             = 1</div><div class="line">  subsection Angular velocity</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = t &lt; .500001 ? 5 : -5</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,z,t</div><div class="line">  end</div><div class="line">  subsection Grid generation</div><div class="line">    <span class="keyword">set</span> Fluid grid generator              = <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a></div><div class="line">    <span class="keyword">set</span> Fluid grid generator arguments    = -50,-50, -10: 50, 50, 40: <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Solid grid generator              = impeller.vtk</div><div class="line">    <span class="keyword">set</span> Solid grid generator arguments    = 1:impeller.step</div><div class="line">    <span class="keyword">set</span> Particle grid generator           = <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a></div><div class="line">    <span class="keyword">set</span> Particle grid generator arguments = 30, 30, 20: 10: <span class="keyword">false</span></div><div class="line">  end</div><div class="line">  subsection Refinement and remeshing</div><div class="line">    <span class="keyword">set</span> Maximum number of cells        = 100000</div><div class="line">    <span class="keyword">set</span> Refinement coarsening fraction = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement fraction            = 0.3</div><div class="line">    <span class="keyword">set</span> Refinement maximal level       = 6</div><div class="line">    <span class="keyword">set</span> Refinement step frequency      = 5</div><div class="line">    <span class="keyword">set</span> Refinement strategy            = fixed_fraction</div><div class="line">  end</div><div class="line">  subsection Right hand side</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 0; 0; 0; 0</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,z,t</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>在这种情况下，定时输出有点不同。</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |  5.54e+03s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble Nitsche terms          |       101 |       111s |         2% |</div><div class="line">| Assemble Stokes terms           |       101 |       208s |       3.8% |</div><div class="line">| Initial setup                   |         1 |   0.00187s |         0% |</div><div class="line">| Output fluid                    |       102 |      15.5s |      0.28% |</div><div class="line">| Output solid particles          |       102 |      2.63s |         0% |</div><div class="line">| Output tracer particles         |       102 |      2.49s |         0% |</div><div class="line">| Refine                          |        20 |      18.4s |      0.33% |</div><div class="line">| Set solid particle position     |       100 |       6.1s |      0.11% |</div><div class="line">| Set tracer particle motion      |       101 |      10.8s |       0.2% |</div><div class="line">| Setup dofs                      |        21 |      13.9s |      0.25% |</div><div class="line">| Solve                           |       101 |  5.16e+03s |        93% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>现在，求解器在三维空间中占用了大部分的求解时间，就运行时间而言，粒子运动和Nitsche装配仍然相对不重要。</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/Srwq7zyR9mg"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>目前的教程程序显示了流体和固体之间的单向耦合，其中固体运动是强加的（而不是求解的），并通过利用固体正交点的位置和权重在固体域中读取。</p>
<p>代码的结构已经允许人们通过利用读取实体网格正交点上流体速度值的可能性来实现双向耦合。为了提高MPI通信模式的效率，我们应该将正交点的所有权保持在实体处理器上，该处理器拥有创建这些正交点的单元。在目前的代码中，通过使用实体分区而不是初始流体分区来定义用于交换正交点信息的向量索引集就足够了。</p>
<p>这使得本教程程序中使用的技术与教程步骤-60中提出的技术相结合，以解决带有分布式拉格朗日乘数的流体结构交互问题，在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象上。</p>
<p>上面的时间显示，目前的预处理策略对Nitsche惩罚的效果并不好，如果我们想瞄准更大的问题，我们应该想出一个更好的预处理方法。此外，应该实施检查点重启策略，以允许较长的模拟被中断和恢复，例如在<a class="el" href="step_69.html">step-69</a>教程中就是这样做的。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2020 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Luca Heltai, Bruno Blais, Rene Gassmoeller, 2020</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__linear__operator_8h.html">deal.II/lac/block_linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define FORCE_USE_OF_TRILINOS</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>LA</div><div class="line">{</div><div class="line"><span class="preprocessor">#if defined(DEAL_II_WITH_PETSC) &amp;&amp; !defined(DEAL_II_PETSC_WITH_COMPLEX) &amp;&amp; \</span></div><div class="line"><span class="preprocessor">  !(defined(DEAL_II_WITH_TRILINOS) &amp;&amp; defined(FORCE_USE_OF_TRILINOS))</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraPETSc;</div><div class="line"><span class="preprocessor">#  define USE_PETSC_LA</span></div><div class="line"><span class="preprocessor">#elif defined(DEAL_II_WITH_TRILINOS)</span></div><div class="line">  <span class="keyword">using namespace </span>dealii::LinearAlgebraTrilinos;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">#  error DEAL_II_WITH_PETSC or DEAL_II_WITH_TRILINOS required</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">} <span class="comment">// namespace LA</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__nothing_8h.html">deal.II/fe/fe_nothing.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__precondition_8h.html">deal.II/lac/petsc_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__minres_8h.html">deal.II/lac/solver_minres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particles_2data__out_8h.html">deal.II/particles/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generators_8h.html">deal.II/particles/generators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="particle__handler_8h.html">deal.II/particles/particle_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2particles_2utilities_8h.html">deal.II/particles/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="opencascade_2manifold__lib_8h.html">deal.II/opencascade/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2opencascade_2utilities_8h.html">deal.II/opencascade/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line"><span class="preprocessor">#  include &lt;TopoDS.hxx&gt;</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step70</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesImmersedProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesImmersedProblemParameters();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keywordtype">double</span> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      rhs.set_time(time);</div><div class="line">      angular_velocity.set_time(time);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::string output_directory = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> velocity_degree = 2;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_time_steps = 501;</div><div class="line">    <span class="keywordtype">double</span>       final_time           = 1.0;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_frequency = 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_fluid_refinement      = 5;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_solid_refinement      = 5;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> particle_insertion_refinement = 3;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fluid_rtree_extraction_level = 1;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> viscosity    = 1.0;</div><div class="line">    <span class="keywordtype">double</span> penalty_term = 100;</div><div class="line"></div><div class="line">    std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0};</div><div class="line"></div><div class="line">    std::string name_of_fluid_grid       = <span class="stringliteral">&quot;hyper_cube&quot;</span>;</div><div class="line">    std::string arguments_for_fluid_grid = <span class="stringliteral">&quot;-1: 1: false&quot;</span>;</div><div class="line">    std::string name_of_solid_grid       = <span class="stringliteral">&quot;hyper_rectangle&quot;</span>;</div><div class="line">    std::string arguments_for_solid_grid = spacedim == 2 ?</div><div class="line">                                             <span class="stringliteral">&quot;-.5, -.1: .5, .1: false&quot;</span> :</div><div class="line">                                             <span class="stringliteral">&quot;-.5, -.1, -.1: .5, .1, .1: false&quot;</span>;</div><div class="line">    std::string name_of_particle_grid = <span class="stringliteral">&quot;hyper_ball&quot;</span>;</div><div class="line">    std::string arguments_for_particle_grid =</div><div class="line">      spacedim == 2 ? <span class="stringliteral">&quot;0.3, 0.3: 0.1: false&quot;</span> : <span class="stringliteral">&quot;0.3, 0.3, 0.3 : 0.1: false&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span>          max_level_refinement = 8;</div><div class="line">    <span class="keywordtype">int</span>          min_level_refinement = 5;</div><div class="line">    std::string  refinement_strategy  = <span class="stringliteral">&quot;fixed_fraction&quot;</span>;</div><div class="line">    <span class="keywordtype">double</span>       coarsening_fraction  = 0.3;</div><div class="line">    <span class="keywordtype">double</span>       refinement_fraction  = 0.3;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cells            = 20000;</div><div class="line">    <span class="keywordtype">int</span>          refinement_frequency = 5;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt; rhs;</div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      angular_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  StokesImmersedProblemParameters&lt;dim,</div><div class="line">                                  spacedim&gt;::StokesImmersedProblemParameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Stokes Immersed Problem/&quot;</span>)</div><div class="line">    , rhs(<span class="stringliteral">&quot;Right hand side&quot;</span>, spacedim + 1)</div><div class="line">    , angular_velocity(<span class="stringliteral">&quot;Angular velocity&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Velocity degree&quot;</span>, velocity_degree, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1));</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Number of time steps&quot;</span>, number_of_time_steps);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output frequency&quot;</span>, output_frequency);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output directory&quot;</span>, output_directory);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Final time&quot;</span>, final_time);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Viscosity&quot;</span>, viscosity);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Nitsche penalty term&quot;</span>, penalty_term);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial fluid refinement&quot;</span>,</div><div class="line">                  initial_fluid_refinement,</div><div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the fluid domain Omega&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial solid refinement&quot;</span>,</div><div class="line">                  initial_solid_refinement,</div><div class="line">                  <span class="stringliteral">&quot;Initial mesh refinement used for the solid domain Gamma&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Fluid bounding boxes extraction level&quot;</span>,</div><div class="line">                  fluid_rtree_extraction_level,</div><div class="line">                  <span class="stringliteral">&quot;Extraction level of the rtree used to construct global &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;bounding boxes&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Particle insertion refinement&quot;</span>,</div><div class="line">      particle_insertion_refinement,</div><div class="line">      <span class="stringliteral">&quot;Refinement of the volumetric mesh used to insert the particles&quot;</span>);</div><div class="line"></div><div class="line">    add_parameter(</div><div class="line">      <span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">      homogeneous_dirichlet_ids,</div><div class="line">      <span class="stringliteral">&quot;Boundary Ids over which homogeneous Dirichlet boundary conditions are applied&quot;</span>);</div><div class="line"></div><div class="line">    enter_subsection(<span class="stringliteral">&quot;Grid generation&quot;</span>);</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator&quot;</span>, name_of_fluid_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Fluid grid generator arguments&quot;</span>, arguments_for_fluid_grid);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator&quot;</span>, name_of_solid_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Solid grid generator arguments&quot;</span>, arguments_for_solid_grid);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator&quot;</span>, name_of_particle_grid);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Particle grid generator arguments&quot;</span>,</div><div class="line">                    arguments_for_particle_grid);</div><div class="line">    }</div><div class="line">    leave_subsection();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    enter_subsection(<span class="stringliteral">&quot;Refinement and remeshing&quot;</span>);</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement step frequency&quot;</span>, refinement_frequency);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement maximal level&quot;</span>, max_level_refinement);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement minimal level&quot;</span>, min_level_refinement);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement strategy&quot;</span>,</div><div class="line">                    refinement_strategy,</div><div class="line">                    <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">                    this-&gt;prm,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;fixed_fraction|fixed_number&quot;</span>));</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement coarsening fraction&quot;</span>, coarsening_fraction);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Refinement fraction&quot;</span>, refinement_fraction);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Maximum number of cells&quot;</span>, max_cells);</div><div class="line">    }</div><div class="line">    leave_subsection();</div><div class="line"></div><div class="line">    rhs.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">      <a class="code" href="classFunctions_1_1ParsedFunction.html#a57fd4a680441ae940812431a421c9c40">Functions::ParsedFunction&lt;spacedim&gt;::declare_parameters</a>(this-&gt;prm,</div><div class="line">                                                              spacedim + 1);</div><div class="line">    });</div><div class="line">    angular_velocity.declare_parameters_call_back.connect([&amp;]() {</div><div class="line">      this-&gt;prm.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;t &lt; .500001 ? 6.283185 : -6.283185&quot;</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>SolidVelocity : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    static_assert(spacedim &gt; 1,</div><div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidVelocity for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">    SolidVelocity(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity)</div><div class="line">      : angular_velocity(angular_velocity)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, spacedim&gt;</a> velocity;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> omega = angular_velocity.value(p);</div><div class="line">      velocity[0]        = -omega * p[1];</div><div class="line">      velocity[1]        = omega * p[0];</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> velocity[component];</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keyword">class </span>SolidPosition : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    static_assert(spacedim &gt; 1,</div><div class="line">                  <span class="stringliteral">&quot;Cannot instantiate SolidPosition for spacedim == 1&quot;</span>);</div><div class="line"></div><div class="line">    SolidPosition(<span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>                               time_step)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;spacedim&gt;(spacedim)</div><div class="line">      , angular_velocity(angular_velocity)</div><div class="line">      , time_step(time_step)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> &amp;p,</div><div class="line">                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;spacedim&gt;</a> new_position = p;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> dtheta = angular_velocity.value(p) * time_step;</div><div class="line"></div><div class="line">      new_position[0] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[0] - <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[1];</div><div class="line">      new_position[1] = <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(dtheta) * p[0] + <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(dtheta) * p[1];</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> new_position[component];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_time_step(<span class="keyword">const</span> <span class="keywordtype">double</span> new_time_step)</div><div class="line">    {</div><div class="line">      time_step = new_time_step;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction&lt;spacedim&gt;</a> &amp;angular_velocity;</div><div class="line">    <span class="keywordtype">double</span>                                     time_step;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>StokesImmersedProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    StokesImmersedProblem(</div><div class="line">      <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_time_step() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_tracer_particles();</div><div class="line">    <span class="keywordtype">void</span> setup_solid_particles();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> initial_setup();</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_stokes_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_nitsche_restriction();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> refine_and_transfer();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle, <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> output_particles(<span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">                          std::string                                 fprefix,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par;</div><div class="line"></div><div class="line">    <a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a>      fluid_tria;</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim, spacedim&gt;</a> solid_tria;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt;      fluid_fe;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; solid_fe;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;Quadrature&lt;spacedim&gt;&gt; fluid_quadrature_formula;</div><div class="line">    std::unique_ptr&lt;Quadrature&lt;dim&gt;&gt;      solid_quadrature_formula;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a>      fluid_dh;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim, spacedim&gt;</a> solid_dh;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;MappingFEField&lt;dim, spacedim&gt;&gt; solid_mapping;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; fluid_owned_dofs;</div><div class="line">    std::vector&lt;IndexSet&gt; solid_owned_dofs;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; fluid_relevant_dofs;</div><div class="line">    std::vector&lt;IndexSet&gt; solid_relevant_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> system_matrix;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a34f060e2c5e047fdc12c76d047c7c098">LA::MPI::BlockSparseMatrix</a> preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> solution;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> locally_relevant_solution;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#aa4543bb429e129431d48d18c1bfebae3">LA::MPI::BlockVector</a> system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> tracer_particle_handler;</div><div class="line">    <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> solid_particle_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_tracer_particle_coordinates;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_tracer_particle_coordinates;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> tracer_particle_velocities;</div><div class="line">    <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">LA::MPI::Vector</a> relevant_tracer_particle_displacements;</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;BoundingBox&lt;spacedim&gt;&gt;&gt; global_fluid_bounding_boxes;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  StokesImmersedProblem&lt;dim, spacedim&gt;::StokesImmersedProblem(</div><div class="line">    <span class="keyword">const</span> StokesImmersedProblemParameters&lt;dim, spacedim&gt; &amp;par)</div><div class="line">    : par(par)</div><div class="line">    , mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">            (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">    , computing_timer(mpi_communicator,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">    , fluid_tria(mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::MeshSmoothing(</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_refinement |</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;spacedim&gt;::smoothing_on_coarsening))</div><div class="line">    , solid_tria(mpi_communicator,</div><div class="line">                 typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::MeshSmoothing(</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_refinement |</div><div class="line">                   <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::smoothing_on_coarsening))</div><div class="line">    , fluid_dh(fluid_tria)</div><div class="line">    , solid_dh(solid_tria)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> read_grid_and_cad_files(<span class="keyword">const</span> std::string &amp;grid_file_name,</div><div class="line">                               <span class="keyword">const</span> std::string &amp;ids_and_cad_file_names,</div><div class="line">                               <a class="code" href="classTriangulation.html">Triangulation&lt;dim, spacedim&gt;</a> &amp;tria)</div><div class="line">  {</div><div class="line">    <a class="code" href="classGridIn.html">GridIn&lt;dim, spacedim&gt;</a> grid_in;</div><div class="line">    grid_in.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(tria);</div><div class="line">    grid_in.<a class="code" href="classGridIn.html#ad30d9d6f2ff9920c4285e795c4495826">read</a>(grid_file_name);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_WITH_OPENCASCADE</span></div><div class="line">    <span class="keyword">using</span> map_type  = std::map&lt;types::manifold_id, std::string&gt;;</div><div class="line">    <span class="keyword">using</span> Converter = <a class="code" href="structPatterns_1_1Tools_1_1Convert.html">Patterns::Tools::Convert&lt;map_type&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;pair : <a class="code" href="namespacePatterns_1_1Tools.html#a59da8cbc1fc7db44bebb4fbc9dc4bbe9">Converter::to_value</a>(ids_and_cad_file_names))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>   = pair.first;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cad_file_name = pair.second;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> extension = boost::algorithm::to_lower_copy(</div><div class="line">          cad_file_name.substr(cad_file_name.find_last_of(<span class="charliteral">&#39;.&#39;</span>) + 1));</div><div class="line"></div><div class="line">        TopoDS_Shape shape;</div><div class="line">        <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;iges&quot;</span> || extension == <span class="stringliteral">&quot;igs&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (extension == <span class="stringliteral">&quot;step&quot;</span> || extension == <span class="stringliteral">&quot;stp&quot;</span>)</div><div class="line">          shape = <a class="code" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">OpenCASCADE::read_STEP</a>(cad_file_name);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                      <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;We found an extension that we &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;do not recognize as a CAD file &quot;</span></div><div class="line">                                        <span class="stringliteral">&quot;extension. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> n_elements = <a class="code" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">OpenCASCADE::count_elements</a>(shape);</div><div class="line">        <span class="keywordflow">if</span> ((std::get&lt;0&gt;(n_elements) == 0))</div><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(</div><div class="line">            <a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">            <a class="code" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">OpenCASCADE::ArclengthProjectionLineManifold&lt;dim, spacedim&gt;</a>(shape));</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (spacedim == 3)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> t = <span class="keyword">reinterpret_cast&lt;</span><a class="code" href="classTriangulation.html">Triangulation&lt;dim, 3&gt;</a> *<span class="keyword">&gt;</span>(&amp;tria);</div><div class="line">            t-&gt;<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                            <a class="code" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold&lt;dim, 3&gt;</a>(</div><div class="line">                              shape));</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(<a class="code" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">manifold_id</a>,</div><div class="line">                            <a class="code" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt;dim, spacedim&gt;</a>(</div><div class="line">                              TopoDS::Face(shape)));</div><div class="line">      }</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    (void)ids_and_cad_file_names;</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>(<span class="stringliteral">&quot;Generation of the grid failed.&quot;</span>));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">          fluid_tria, par.name_of_fluid_grid, par.arguments_for_fluid_grid);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Generating from name and argument failed.&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Trying to read from file name.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        read_grid_and_cad_files(par.name_of_fluid_grid,</div><div class="line">                                par.arguments_for_fluid_grid,</div><div class="line">                                fluid_tria);</div><div class="line">      }</div><div class="line">    fluid_tria.refine_global(par.initial_fluid_refinement);</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">          solid_tria, par.name_of_solid_grid, par.arguments_for_solid_grid);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">catch</span> (...)</div><div class="line">      {</div><div class="line">        read_grid_and_cad_files(par.name_of_solid_grid,</div><div class="line">                                par.arguments_for_solid_grid,</div><div class="line">                                solid_tria);</div><div class="line">      }</div><div class="line"></div><div class="line">    solid_tria.refine_global(par.initial_solid_refinement);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_tracer_particles()</div><div class="line">  {</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;spacedim&gt;</a> particle_insert_tria(</div><div class="line">      mpi_communicator);</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">      particle_insert_tria,</div><div class="line">      par.name_of_particle_grid,</div><div class="line">      par.arguments_for_particle_grid);</div><div class="line">    particle_insert_tria.refine_global(par.particle_insertion_refinement);</div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>       particles_fe(1);</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;spacedim&gt;</a> particles_dof_handler(particle_insert_tria);</div><div class="line">    particles_dof_handler.distribute_dofs(particles_fe);</div><div class="line"></div><div class="line">    std::vector&lt;BoundingBox&lt;spacedim&gt;&gt; all_boxes;</div><div class="line">    all_boxes.reserve(fluid_tria.n_locally_owned_active_cells());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        all_boxes.emplace_back(cell-&gt;bounding_box());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> local_boxes =</div><div class="line">      <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, par.fluid_rtree_extraction_level);</div><div class="line"></div><div class="line">    global_fluid_bounding_boxes =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator, local_boxes);</div><div class="line"></div><div class="line">    tracer_particle_handler.initialize(fluid_tria,</div><div class="line">                                       <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceParticles_1_1Generators.html#a498c6b70c8c3169a3d1513418beb9e15">Particles::Generators::dof_support_points</a>(particles_dof_handler,</div><div class="line">                                              global_fluid_bounding_boxes,</div><div class="line">                                              tracer_particle_handler);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Tracer particles: &quot;</span></div><div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    locally_owned_tracer_particle_coordinates =</div><div class="line">      tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">        <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">    locally_relevant_tracer_particle_coordinates =</div><div class="line">      locally_owned_tracer_particle_coordinates;</div><div class="line"></div><div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">      [&amp;]() { tracer_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">    fluid_tria.signals.post_distributed_refinement.connect([&amp;]() {</div><div class="line">      tracer_particle_handler.register_load_callback_function(<span class="keyword">false</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_solid_particles()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature(fluid_fe-&gt;degree + 1);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_properties = 1;</div><div class="line">    solid_particle_handler.initialize(fluid_tria,</div><div class="line">                                      <a class="code" href="structStaticMappingQ1.html">StaticMappingQ1&lt;spacedim&gt;::mapping</a>,</div><div class="line">                                      n_properties);</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;spacedim&gt;&gt; quadrature_points_vec;</div><div class="line">    quadrature_points_vec.reserve(quadrature.size() *</div><div class="line">                                  solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;double&gt;&gt; properties;</div><div class="line">    properties.reserve(quadrature.size() *</div><div class="line">                       solid_tria.n_locally_owned_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim, spacedim&gt;</a> fe_v(*solid_fe,</div><div class="line">                                 quadrature,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : solid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_v.reinit(cell);</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;points = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">          <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; points.size(); ++q)</div><div class="line">            {</div><div class="line">              quadrature_points_vec.emplace_back(points[q]);</div><div class="line">              properties.emplace_back(</div><div class="line">                std::vector&lt;double&gt;(n_properties, JxW[q]));</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!global_fluid_bounding_boxes.empty(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>(</div><div class="line">             <span class="stringliteral">&quot;I was expecting the &quot;</span></div><div class="line">             <span class="stringliteral">&quot;global_fluid_bounding_boxes to be filled at this stage. &quot;</span></div><div class="line">             <span class="stringliteral">&quot;Make sure you fill this vector before trying to use it &quot;</span></div><div class="line">             <span class="stringliteral">&quot;here. Bailing out.&quot;</span>));</div><div class="line"></div><div class="line">    solid_particle_handler.insert_global_particles(quadrature_points_vec,</div><div class="line">                                                   global_fluid_bounding_boxes,</div><div class="line">                                                   properties);</div><div class="line"></div><div class="line"></div><div class="line">    fluid_tria.signals.pre_distributed_refinement.connect(</div><div class="line">      [&amp;]() { solid_particle_handler.register_store_callback_function(); });</div><div class="line"></div><div class="line">    fluid_tria.signals.post_distributed_refinement.connect(</div><div class="line">      [&amp;]() { solid_particle_handler.register_load_callback_function(<span class="keyword">false</span>); });</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Solid particles: &quot;</span> &lt;&lt; solid_particle_handler.n_global_particles()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::initial_setup()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Initial setup&quot;</span>);</div><div class="line"></div><div class="line">    fluid_fe =</div><div class="line">      std::make_unique&lt;FESystem&lt;spacedim&gt;&gt;(<a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree),</div><div class="line">                                           spacedim,</div><div class="line">                                           <a class="code" href="classFE__Q.html">FE_Q&lt;spacedim&gt;</a>(par.velocity_degree -</div><div class="line">                                                          1),</div><div class="line">                                           1);</div><div class="line"></div><div class="line"></div><div class="line">    solid_fe = std::make_unique&lt;FE_Nothing&lt;dim, spacedim&gt;&gt;();</div><div class="line">    solid_dh.distribute_dofs(*solid_fe);</div><div class="line"></div><div class="line">    fluid_quadrature_formula =</div><div class="line">      std::make_unique&lt;QGauss&lt;spacedim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">    solid_quadrature_formula =</div><div class="line">      std::make_unique&lt;QGauss&lt;dim&gt;&gt;(par.velocity_degree + 1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup dofs&quot;</span>);</div><div class="line"></div><div class="line">    fluid_dh.distribute_dofs(*fluid_fe);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(spacedim + 1, 0);</div><div class="line">    stokes_sub_blocks[spacedim] = 1;</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(fluid_dh, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = dofs_per_block[0], n_p = dofs_per_block[1];</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; fluid_dh.n_dofs() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">          &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="stringliteral">&quot; -- &quot;</span></div><div class="line">          &lt;&lt; solid_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;+&#39;</span></div><div class="line">          &lt;&lt; tracer_particle_handler.n_global_particles() &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    fluid_owned_dofs.resize(2);</div><div class="line">    fluid_owned_dofs[0] = fluid_dh.locally_owned_dofs().get_view(0, n_u);</div><div class="line">    fluid_owned_dofs[1] =</div><div class="line">      fluid_dh.locally_owned_dofs().get_view(n_u, n_u + n_p);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(fluid_dh, locally_relevant_dofs);</div><div class="line">    fluid_relevant_dofs.resize(2);</div><div class="line">    fluid_relevant_dofs[0] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u);</div><div class="line">    fluid_relevant_dofs[1] = locally_relevant_dofs.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p);</div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.reinit(locally_relevant_dofs);</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(fluid_dh, constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        fluid_dh,</div><div class="line">        0,</div><div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(spacedim + 1),</div><div class="line">        constraints,</div><div class="line">        fluid_fe-&gt;component_mask(velocities));</div><div class="line">      constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> locally_owned_dofs_per_processor =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(mpi_communicator,</div><div class="line">                                 fluid_dh.locally_owned_dofs());</div><div class="line">    {</div><div class="line">      system_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == spacedim || d == spacedim || c == d)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">        dsp,</div><div class="line">        locally_owned_dofs_per_processor,</div><div class="line">        mpi_communicator,</div><div class="line">        locally_relevant_dofs);</div><div class="line"></div><div class="line">      system_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(spacedim + 1, spacedim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; spacedim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; spacedim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == spacedim &amp;&amp; d == spacedim)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(dofs_per_block, dofs_per_block);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        fluid_dh, coupling, dsp, constraints, <span class="keyword">false</span>);</div><div class="line">      <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(</div><div class="line">        dsp,</div><div class="line">        locally_owned_dofs_per_processor,</div><div class="line">        mpi_communicator,</div><div class="line">        locally_relevant_dofs);</div><div class="line">      preconditioner_matrix.reinit(fluid_owned_dofs, dsp, mpi_communicator);</div><div class="line">    }</div><div class="line"></div><div class="line">    locally_relevant_solution.reinit(fluid_owned_dofs,</div><div class="line">                                     fluid_relevant_dofs,</div><div class="line">                                     mpi_communicator);</div><div class="line">    system_rhs.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">    solution.reinit(fluid_owned_dofs, mpi_communicator);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_stokes_system()</div><div class="line">  {</div><div class="line">    system_matrix         = 0;</div><div class="line">    preconditioner_matrix = 0;</div><div class="line">    system_rhs            = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Stokes terms&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;spacedim&gt;</a> fe_values(*fluid_fe,</div><div class="line">                                 *fluid_quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fluid_quadrature_formula-&gt;size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix2(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points,</div><div class="line">                                           Vector&lt;double&gt;(spacedim + 1));</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, spacedim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;              div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;              phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a>     pressure(spacedim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_dh.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell_matrix  = 0;</div><div class="line">          cell_matrix2 = 0;</div><div class="line">          cell_rhs     = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          par.rhs.vector_value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                    rhs_values);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">                {</div><div class="line">                  grad_phi_u[k] = fe_values[velocities].gradient(k, q);</div><div class="line">                  div_phi_u[k]  = fe_values[velocities].divergence(k, q);</div><div class="line">                  phi_p[k]      = fe_values[pressure].value(k, q);</div><div class="line">                }</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    {</div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                        (par.viscosity *</div><div class="line">                           <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) -</div><div class="line">                         div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">                      cell_matrix2(i, j) += 1.0 / par.viscosity * phi_p[i] *</div><div class="line">                                            phi_p[j] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                    }</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component_i =</div><div class="line">                    fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                  cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">                                 rhs_values[q](component_i) * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                 cell_rhs,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 system_matrix,</div><div class="line">                                                 system_rhs);</div><div class="line"></div><div class="line">          constraints.distribute_local_to_global(cell_matrix2,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 preconditioner_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::assemble_nitsche_restriction()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assemble Nitsche terms&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(spacedim);</div><div class="line"></div><div class="line">    SolidVelocity&lt;spacedim&gt; solid_velocity(par.angular_velocity);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; fluid_dof_indices(</div><div class="line">      fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>     local_matrix(fluid_fe-&gt;n_dofs_per_cell(),</div><div class="line">                                    fluid_fe-&gt;n_dofs_per_cell());</div><div class="line">    ::Vector&lt;double&gt; local_rhs(fluid_fe-&gt;n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> penalty_parameter =</div><div class="line">      1.0 / <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(fluid_tria);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> particle = solid_particle_handler.begin();</div><div class="line">    <span class="keywordflow">while</span> (particle != solid_particle_handler.end())</div><div class="line">      {</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell = particle-&gt;get_surrounding_cell(fluid_tria);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dh_cell =</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;spacedim&gt;::cell_iterator</a>(*cell, &amp;fluid_dh);</div><div class="line">        dh_cell-&gt;get_dof_indices(fluid_dof_indices);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> pic = solid_particle_handler.particles_in_cell(cell);</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(pic.begin() == particle, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p : pic)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;ref_q  = p.get_reference_location();</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;real_q = p.get_location();</div><div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> &amp;JxW    = p.get_properties()[0];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fluid_fe-&gt;n_dofs_per_cell(); ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> comp_i =</div><div class="line">                  fluid_fe-&gt;system_to_component_index(i).first;</div><div class="line">                <span class="keywordflow">if</span> (comp_i &lt; spacedim)</div><div class="line">                  {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fluid_fe-&gt;n_dofs_per_cell();</div><div class="line">                         ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keyword">auto</span> comp_j =</div><div class="line">                          fluid_fe-&gt;system_to_component_index(j).first;</div><div class="line">                        <span class="keywordflow">if</span> (comp_i == comp_j)</div><div class="line">                          local_matrix(i, j) +=</div><div class="line">                            penalty_parameter * par.penalty_term *</div><div class="line">                            fluid_fe-&gt;shape_value(i, ref_q) *</div><div class="line">                            fluid_fe-&gt;shape_value(j, ref_q) * JxW;</div><div class="line">                      }</div><div class="line">                    local_rhs(i) += penalty_parameter * par.penalty_term *</div><div class="line">                                    solid_velocity.value(real_q, comp_i) *</div><div class="line">                                    fluid_fe-&gt;shape_value(i, ref_q) * JxW;</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                               local_rhs,</div><div class="line">                                               fluid_dof_indices,</div><div class="line">                                               system_matrix,</div><div class="line">                                               system_rhs);</div><div class="line">        particle = pic.end();</div><div class="line">      }</div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    system_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_A;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_A.initialize(system_matrix.block(0, 0), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    LA::MPI::PreconditionAMG prec_S;</div><div class="line">    {</div><div class="line">      LA::MPI::PreconditionAMG::AdditionalData data;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">      data.symmetric_operator = <span class="keyword">true</span>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">      prec_S.initialize(preconditioner_matrix.block(1, 1), data);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = linear_operator&lt;LA::MPI::Vector&gt;(system_matrix.block(0, 0));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgA = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, prec_A);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> S =</div><div class="line">      linear_operator&lt;LA::MPI::Vector&gt;(preconditioner_matrix.block(1, 1));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> amgS = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(S, prec_S);</div><div class="line"></div><div class="line">    <a class="code" href="classReductionControl.html">ReductionControl</a>          inner_solver_control(100,</div><div class="line">                                          1e-8 * system_rhs.l2_norm(),</div><div class="line">                                          1.e-2);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LA::MPI::Vector&gt;</a> cg(inner_solver_control);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> invS = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, cg, amgS);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> P = block_diagonal_operator&lt;2, LA::MPI::BlockVector&gt;(</div><div class="line">      std::array&lt;</div><div class="line">        ::LinearOperator&lt;typename LA::MPI::BlockVector::BlockType&gt;,</div><div class="line">        2&gt;{{amgA, amgS}});</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_matrix.m(),</div><div class="line">                                 1e-10 * system_rhs.l2_norm());</div><div class="line"></div><div class="line">    <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;LA::MPI::BlockVector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">    constraints.set_zero(solution);</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, P);</div><div class="line"></div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    locally_relevant_solution = solution;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mean_pressure =</div><div class="line">      VectorTools::compute_mean_value(fluid_dh,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(par.velocity_degree + 2),</div><div class="line">                                      locally_relevant_solution,</div><div class="line">                                      spacedim);</div><div class="line">    solution.block(1).add(-mean_pressure);</div><div class="line">    locally_relevant_solution.block(1) = solution.block(1);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::refine_and_transfer()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>               t(computing_timer, <span class="stringliteral">&quot;Refine&quot;</span>);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity(0);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; error_per_cell(fluid_tria.n_active_cells());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;spacedim&gt;::estimate</a>(fluid_dh,</div><div class="line">                                            <a class="code" href="classQGauss.html">QGauss&lt;spacedim - 1&gt;</a>(</div><div class="line">                                              par.velocity_degree + 1),</div><div class="line">                                            {},</div><div class="line">                                            locally_relevant_solution,</div><div class="line">                                            error_per_cell,</div><div class="line">                                            fluid_fe-&gt;component_mask(velocity));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_fraction&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::</a></div><div class="line"><a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">          refine_and_coarsen_fixed_fraction</a>(fluid_tria,</div><div class="line">                                            error_per_cell,</div><div class="line">                                            par.refinement_fraction,</div><div class="line">                                            par.coarsening_fraction);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (par.refinement_strategy == <span class="stringliteral">&quot;fixed_number&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">          fluid_tria,</div><div class="line">          error_per_cell,</div><div class="line">          par.refinement_fraction,</div><div class="line">          par.coarsening_fraction,</div><div class="line">          par.max_cells);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : fluid_tria.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;refine_flag_set() &amp;&amp;</div><div class="line">            cell-&gt;level() == par.max_level_refinement)</div><div class="line">          cell-&gt;clear_refine_flag();</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;coarsen_flag_set() &amp;&amp;</div><div class="line">            cell-&gt;level() == par.min_level_refinement)</div><div class="line">          cell-&gt;clear_coarsen_flag();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;spacedim, LA::MPI::BlockVector&gt;</a></div><div class="line">      transfer(fluid_dh);</div><div class="line">    fluid_tria.prepare_coarsening_and_refinement();</div><div class="line">    transfer.prepare_for_coarsening_and_refinement(locally_relevant_solution);</div><div class="line">    fluid_tria.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    transfer.interpolate(solution);</div><div class="line">    constraints.distribute(solution);</div><div class="line">    locally_relevant_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  StokesImmersedProblem&lt;dim, spacedim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle,</div><div class="line">                                                       <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output fluid&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; solution_names(spacedim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        spacedim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(fluid_dh);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(locally_relevant_solution,</div><div class="line">                             solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(fluid_tria.n_active_cells());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      subdomain(i) = fluid_tria.locally_owned_subdomain();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                   mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line">    times_and_names.push_back(std::make_pair(time, filename));</div><div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;solution.pvd&quot;</span>);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> StokesImmersedProblem&lt;dim, spacedim&gt;::output_particles(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler&lt;spacedim&gt;</a> &amp;particles,</div><div class="line">    std::string                                 fprefix,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                          iter,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classParticles_1_1DataOut.html">Particles::DataOut&lt;spacedim&gt;</a> particles_out;</div><div class="line">    particles_out.<a class="code" href="classParticles_1_1DataOut.html#adf095165dc286310226584b2b9972701">build_patches</a>(particles);</div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      (fprefix + <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(iter) + <span class="stringliteral">&quot;.vtu&quot;</span>);</div><div class="line">    particles_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + filename,</div><div class="line">                                        mpi_communicator);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::map&lt;std::string, std::vector&lt;std::pair&lt;double, std::string&gt;&gt;&gt;</div><div class="line">      times_and_names;</div><div class="line">    <span class="keywordflow">if</span> (times_and_names.find(fprefix) != times_and_names.end())</div><div class="line">      times_and_names[fprefix].push_back(std::make_pair(time, filename));</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      times_and_names[fprefix] = {std::make_pair(time, filename)};</div><div class="line">    std::ofstream ofile(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + fprefix + <span class="stringliteral">&quot;.pvd&quot;</span>);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(ofile, times_and_names[fprefix]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">StokesImmersedProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line"><span class="preprocessor">#ifdef USE_PETSC_LA</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using PETSc.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Running StokesImmersedProblem&lt;&quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">Utilities::dim_string</a>(dim, spacedim) &lt;&lt; <span class="stringliteral">&quot;&gt; using Trilinos.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    par.prm.print_parameters(par.output_directory + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;used_parameters_&quot;</span> +</div><div class="line">                               <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(spacedim) +</div><div class="line">                               <span class="stringliteral">&quot;.prm&quot;</span>,</div><div class="line">                             <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827a3c8ad66ea26104112458e2ce35b5028f">ParameterHandler::Short</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step    = par.final_time / (par.number_of_time_steps - 1);</div><div class="line">    <span class="keywordtype">double</span>       time         = 0;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> output_cycle = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; par.number_of_time_steps;</div><div class="line">         ++cycle, time += time_step)</div><div class="line">      {</div><div class="line">        par.set_time(time);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time : &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot;, time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            make_grid();</div><div class="line">            initial_setup();</div><div class="line">            setup_dofs();</div><div class="line">            setup_tracer_particles();</div><div class="line">            setup_solid_particles();</div><div class="line">            tracer_particle_velocities.reinit(</div><div class="line">              locally_owned_tracer_particle_coordinates, mpi_communicator);</div><div class="line">            output_results(output_cycle, time);</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">              output_particles(tracer_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">              output_particles(solid_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer,</div><div class="line">                                 <span class="stringliteral">&quot;Set solid particle position&quot;</span>);</div><div class="line"></div><div class="line">            SolidPosition&lt;spacedim&gt; solid_position(par.angular_velocity,</div><div class="line">                                                   time_step);</div><div class="line">            solid_particle_handler.set_particle_positions(solid_position,</div><div class="line">                                                          <span class="keyword">false</span>);</div><div class="line">          }</div><div class="line"></div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Set tracer particle motion&quot;</span>);</div><div class="line">          <a class="code" href="namespaceParticles_1_1Utilities.html#a054f60295f7694c31a30b0019d94df73">Particles::Utilities::interpolate_field_on_particles</a>(</div><div class="line">            fluid_dh,</div><div class="line">            tracer_particle_handler,</div><div class="line">            locally_relevant_solution,</div><div class="line">            tracer_particle_velocities,</div><div class="line">            fluid_fe-&gt;component_mask(<a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>(0)));</div><div class="line"></div><div class="line">          tracer_particle_velocities *= time_step;</div><div class="line"></div><div class="line">          locally_relevant_tracer_particle_coordinates =</div><div class="line">            tracer_particle_handler.locally_owned_particle_ids().tensor_product(</div><div class="line">              <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(spacedim));</div><div class="line"></div><div class="line">          relevant_tracer_particle_displacements.reinit(</div><div class="line">            locally_owned_tracer_particle_coordinates,</div><div class="line">            locally_relevant_tracer_particle_coordinates,</div><div class="line">            mpi_communicator);</div><div class="line"></div><div class="line">          relevant_tracer_particle_displacements = tracer_particle_velocities;</div><div class="line"></div><div class="line">          tracer_particle_handler.set_particle_positions(</div><div class="line">            relevant_tracer_particle_displacements);</div><div class="line">        }</div><div class="line"></div><div class="line">        assemble_stokes_system();</div><div class="line">        assemble_nitsche_restriction();</div><div class="line">        solve();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle % par.output_frequency == 0)</div><div class="line">          {</div><div class="line">            output_results(output_cycle, time);</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output tracer particles&quot;</span>);</div><div class="line">              output_particles(tracer_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;tracer&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Output solid particles&quot;</span>);</div><div class="line">              output_particles(solid_particle_handler,</div><div class="line">                               <span class="stringliteral">&quot;solid&quot;</span>,</div><div class="line">                               output_cycle,</div><div class="line">                               time);</div><div class="line">            }</div><div class="line">            ++output_cycle;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cycle % par.refinement_frequency == 0 &amp;&amp;</div><div class="line">            cycle != par.number_of_time_steps - 1)</div><div class="line">          refine_and_transfer();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step70</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>Step70;</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(1);</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line">      std::string prm_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        prm_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;23&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2, 3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2, 3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (prm_file.find(<span class="stringliteral">&quot;3&quot;</span>) != std::string::npos)</div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;3&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;3&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          StokesImmersedProblemParameters&lt;2&gt; par;</div><div class="line">          <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file);</div><div class="line"></div><div class="line">          StokesImmersedProblem&lt;2&gt; problem(par);</div><div class="line">          problem.run();</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
