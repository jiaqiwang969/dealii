<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_71.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-71 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-71 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#AmotivationWhywouldIusethesetools">A motivation: Why would I use these tools?</a>
        <li><a href="#Theoryformagnetomechanicalmaterials">Theory for magneto-mechanical materials</a>
      <ul>
        <li><a href="#Thermodynamicprinciples">Thermodynamic principles</a>
        <li><a href="#Constitutivelaws">Constitutive laws</a>
      <ul>
        <li><a href="#Magnetoelasticconstitutivelaw">Magnetoelastic constitutive law</a>
        <li><a href="#Magnetoviscoelasticconstitutivelaw">Magneto-viscoelastic constitutive law</a>
      </ul>
      </ul>
        <li><a href="#Rheologicalexperiment">Rheological experiment</a>
        <li><a href="#Suggestedliterature">Suggested literature</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#AnintroductoryexampleThefundamentalsofautomaticandsymbolicdifferentiation">An introductory example: The fundamentals of automatic and symbolic differentiation</a>
      <ul>
        <li><a href="#Ananalyticalfunction">An analytical function</a>
        <li><a href="#Computingderivativesusingautomaticdifferentiation">Computing derivatives using automatic differentiation</a>
        <li><a href="#Handcalculatedderivativesoftheanalyticalsolution">Hand-calculated derivatives of the analytical solution</a>
        <li><a href="#Computingderivativesusingsymbolicdifferentiation">Computing derivatives using symbolic differentiation</a>
        <li><a href="#TheSimpleExamplerunfunction">The SimpleExample::run() function</a>
      </ul>
        <li><a href="#AmorecomplexexampleUsingautomaticandsymbolicdifferentiationtocomputederivativesatcontinuumpoints">A more complex example: Using automatic and symbolic differentiation to compute derivatives at continuum points</a>
      <ul>
        <li><a href="#Constitutiveparameters">Constitutive parameters</a>
        <li><a href="#ConstitutivelawsBaseclass">Constitutive laws: Base class</a>
        <li><a href="#Magnetoelasticconstitutivelawusingautomaticdifferentiation">Magnetoelastic constitutive law (using automatic differentiation)</a>
        <li><a href="#Magnetoviscoelasticconstitutivelawusingsymbolicalgebraanddifferentiation">Magneto-viscoelastic constitutive law (using symbolic algebra and differentiation)</a>
      </ul>
        <li><a href="#AmorecomplexexamplecontinuedParametersandhandderivedmaterialclasses">A more complex example (continued): Parameters and hand-derived material classes</a>
      <ul>
        <li><a href="#Magnetoelasticconstitutivelawhandderived">Magnetoelastic constitutive law (hand-derived)</a>
        <li><a href="#Magnetoviscoelasticconstitutivelawhandderived">Magneto-viscoelastic constitutive law (hand-derived)</a>
        <li><a href="#Rheologicalexperimentparameters">Rheological experiment parameters</a>
        <li><a href="#RheologicalexperimentParallelplaterotationalrheometer">Rheological experiment: Parallel plate rotational rheometer</a>
        <li><a href="#TheCoupledConstitutiveLawsrunfunction">The CoupledConstitutiveLaws::run() function</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Introductoryexample">Introductory example</a>
        <li><a href="#Constitutivemodelling">Constitutive modelling</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Jean-Paul Pelteret. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The aim of this tutorial is, quite simply, to introduce the fundamentals of both <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic</a> and <a href="https://en.wikipedia.org/wiki/Computer_algebra">symbolic differentiation</a> (respectively abbreviated as AD and SD): Ways in which one can, in source code, describe a function \(\mathbf f(\mathbf x)\) and automatically also obtain a representation of derivatives \(\nabla \mathbf f(\mathbf x)\) (the "Jacobian"), \(\nabla^2 \mathbf f(\mathbf x)\) (the "Hessian"), etc., without having to write additional lines of code. Doing this is quite helpful in solving nonlinear or optimization problems where one would like to only describe the nonlinear equation or the objective function in the code, without having to also provide their derivatives (which are necessary for a Newton method for solving a nonlinear problem, or for finding a minimizer).</p>
<p>Since AD and SD tools are somewhat independent of finite elements and boundary value problems, this tutorial is going to be different to the others that you may have read beforehand. It will focus specifically on how these frameworks work and the principles and thinking behind them, and will forgo looking at them in the direct context of a finite element simulation.</p>
<p>We will, in fact, look at two different sets of problems that have greatly different levels of complexity, but when framed properly hold sufficient similarity that the same AD and SD frameworks can be leveraged. With these examples the aim is to build up an understanding of the steps that are required to use the AD and SD tools, the differences between them, and hopefully identify where they could be immediately be used in order to improve or simplify existing code.</p>
<p>It's plausible that you're wondering what AD and SD are, in the first place. Well, that question is easy to answer but without context is not very insightful. So we're not going to cover that in this introduction, but will rather defer this until the first introductory example where we lay out the key points as this example unfolds. To complement this, we should mention that the core theory for both frameworks is extensively discussed in the <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module, so it bears little repeating here.</p>
<p>Since we have to pick <em>some</em> sufficiently interesting topic to investigate and identify where AD and SD can be used effectively, the main problem that's implemented in the second half of the tutorial is one of modeling a coupled constitutive law, specifically a magneto-active material (with hysteretic effects). As a means of an introduction to that, later in the introduction some grounding theory for that class of materials will be presented. Naturally, this is not a field (or even a class of materials) that is of interest to a wide audience. Therefore, the author wishes to express up front that this theory and any subsequent derivations mustn't be considered the focus of this tutorial. Instead, keep in mind the complexity of the problem that arises from the relatively innocuous description of the constitutive law, and what we might (in the context of a boundary value problem) need to derive from that. We will perform some computations with these constitutive laws at the level of a representative continuum point (so, remaining in the realm of continuum mechanics), and will produce some benchmark results around which we can frame a final discussion on the topic of computational performance.</p>
<p>Once we have the foundation upon which we can build further concepts, we will see how AD in particular can be exploited at a finite element (rather than continuum) level: this is a topic that is covered in <a class="el" href="step_72.html">step-72</a>, as well as <a class="el" href="step_33.html">step-33</a>. But before then, let's take a moment to think about why we might want to consider using these sorts of tools, and what benefits they can potentially offer you.</p>
<p><a class="anchor" id="AmotivationWhywouldIusethesetools"></a></p><h3>A motivation: Why would I use these tools?</h3>
<p>The primary driver for using AD or SD is typically that there is some situation that requires differentiation to be performed, and that doing so is sufficiently challenging to make the prospect of using an external tool to perform that specific task appealing. A broad categorization for the circumstances under which AD or SD can be rendered most useful include (but are probably not limited to) the following:</p><ul>
<li><b>Rapid prototyping:</b> For a new class of problems where you're trying to implement a solution quickly, and want to remove some of the intricate details (in terms of both the mathematics as well as the organizational structure of the code itself). You might be willing to justify any additional computational cost, which would be offset by an increased agility in restructuring your code or modifying the part of the problem that is introducing some complex nonlinearity with minimal effort.</li>
<li><b>Complex problems:</b> It could very well be that some problems just happen to have a nonlinearity that is incredibly challenging to linearize or formulate by hand. Having this challenge taken care of for you by a tool that is, for the most part, robust, reliable, and accurate may alleviate some of the pains in implementing certain problems. Examples of this include <a class="el" href="step_15.html">step-15</a>, where the derivative of the nonlinear PDE we solve is not incredibly difficult to derive, but sufficiently cumbersome that one has to pay attention in doing so by hand, and where implementing the corresponding finite element formulation of the Newton step takes more than just the few lines that it generally takes to implement the bilinear form; <a class="el" href="step_33.html">step-33</a> (where we actually use AD) is an even more extreme example.</li>
<li><b>Verification:</b> For materials and simulations that exhibit nonlinear response, an accurate rather than only approximate material tangent (the term mechanical engineers use for the derivative of a material law) can be the difference between convergent and divergent behavior, especially at high external (or coupling) loads. As the complexity of the problem increases, so do the opportunities to introduce subtle (or, perhaps, not-so-subtle) errors that produce predictably negative results. Additionally, there is a lot to be gained by verifying that the implementation is completely correct. For example, certain categories of problems are known to exhibit instabilities, and therefore when you start to lose quadratic convergence in a nonlinear solver (e.g., Newton's method) then this may not be a huge surprise to the investigator. However, it is hard (if not impossible) to distinguish between convergence behavior that is produced as you near an unstable solution and when you simply have an error in the material or finite element linearization, and start to drift off the optimal convergence path due to that. Having a method of verifying the correctness of the implementation of a constitutive law linearization, for example, is perhaps the only meaningful way that you can use to catch such errors, assuming that you've got nobody else to scrutinize your code. Thankfully, with some tactical programming it is quite straight-forward to structure a code for reuse, such that you can use the same classes in production code and directly verify them in, for instance, a unit-test framework.</li>
</ul>
<p>This tutorial program will have two parts: One where we just introduce the basic ideas of automatic and symbolic differentiation support in deal.II using a simple set of examples; and one where we apply this to a realistic but much more complicated case. For that second half, the next section will provide some background on magneto-mechanical materials &ndash; you can skip this section if all you want to learn about is what AD and SD actually are, but you probably want to read over this section if you are interested in how to apply AD and SD for concrete situations.</p>
<p><a class="anchor" id="Theoryformagnetomechanicalmaterials"></a></p><h3>Theory for magneto-mechanical materials</h3>
<p><a class="anchor" id="Thermodynamicprinciples"></a></p><h4>Thermodynamic principles</h4>
<p>As a prelude to introducing the coupled magneto-mechanical material law that we'll use to model a magneto-active polymer, we'll start with a very concise summary of the salient thermodynamics to which these constitutive laws must subscribe. The basis for the theory, as summarized here, is described in copious detail by Truesdell and Toupin <b>[Truesdell1960a]</b> and Coleman and Noll <b>[Coleman1963a]</b>, and follows the logic laid out by Holzapfel <b>[Holzapfel2007a]</b>.</p>
<p>Starting from the first law of thermodynamics, and following a few technical assumptions, it can be shown the the balance between the kinetic plus internal energy rates and the power supplied to the system from external sources is given by the following relationship that equates the rate of change of the energy in an (arbitrary) volume \(V\) on the left, and the sum of forces acting on that volume on the right: </p><p class="formulaDsp">
\[ D_{t} \int\limits_{V} \left[ \frac{1}{2} \rho_{0} \mathbf{v} \cdot \mathbf{v} + U^{*}_{0} \right] dV = \int\limits_{V} \left[ \rho_{0} \mathbf{v} \cdot \mathbf{a} + \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - D_{t} M^{*}_{0} - \nabla_{0} \cdot \mathbf{Q} + R_{0} \right] dV . \]
</p>
<p> Here \(D_{t}\) represents the total time derivative, \(\rho_{0}\) is the material density as measured in the Lagrangian reference frame, \(\mathbf{v}\) is the material velocity and \(\mathbf{a}\) its acceleration, \(U^{*}_{0}\) is the internal energy per unit reference volume, \(\mathbf{P}^{\text{tot}}\) is the total Piola stress tensor and \(\dot{\mathbf{F}}\) is the time rate of the deformation gradient tensor, \(\boldsymbol{\mathbb{H}}\) and \(\boldsymbol{\mathbb{B}}\) are, respectively, the magnetic field vector and the magnetic induction (or magnetic flux density) vector, \(\mathbb{E}\) and \(\mathbb{D}\) are the electric field vector and electric displacement vector, and \(\mathbf{Q}\) and \(R_{0}\) represent the referential thermal flux vector and thermal source. The material differential operator \(\nabla_{0} (\bullet) \dealcoloneq \frac{d(\bullet)}{d\mathbf{X}}\) where \(\mathbf{X}\) is the material position vector. With some rearrangement of terms, invoking the arbitrariness of the integration volume \(V\), the total internal energy density rate \(\dot{E}_{0}\) can be identified as </p><p class="formulaDsp">
\[ \dot{E}_{0} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \nabla_{0} \cdot \mathbf{Q} + R_{0} . \]
</p>
<p> The total internal energy includes contributions that arise not only due to mechanical deformation (the first term), and thermal fluxes and sources (the fourth and fifth terms), but also due to the intrinsic energy stored in the magnetic and electric fields themselves (the second and third terms, respectively).</p>
<p>The second law of thermodynamics, known also as the entropy inequality principle, informs us that certain thermodynamic processes are irreversible. After accounting for the total entropy and rate of entropy input, the Clausius-Duhem inequality can be derived. In local form (and in the material configuration), this reads </p><p class="formulaDsp">
\[ \theta \dot{\eta}_{0} - R_{0} + \nabla_{0} \cdot \mathbf{Q} - \frac{1}{\theta} \nabla_{0} \theta \cdot \mathbf{Q} \geq 0 . \]
</p>
<p> The quantity \(\theta\) is the absolute temperature, and \(\eta_{0}\) represents the entropy per unit reference volume.</p>
<p>Using this to replace \(R_{0} - \nabla_{0} \cdot \mathbf{Q}\) in the result stemming from the first law of thermodynamics, we now have the relation </p><p class="formulaDsp">
\[ \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} + \theta \dot{\eta}_{0} - \dot{E}_{0} - \frac{1}{\theta} \nabla_{0} \theta \cdot \mathbf{Q} \geq 0 . \]
</p>
<p> On the basis of Fourier's law, which informs us that heat flows from regions of high temperature to low temperature, the last term is always positive and can be ignored. This renders the local dissipation inequality </p><p class="formulaDsp">
\[ \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \left[ \dot{E}_{0} - \theta \dot{\eta}_{0} \right] \geq 0 . \]
</p>
<p> It is postulated <b>[Holzapfel2007a]</b> that the Legendre transformation </p><p class="formulaDsp">
\[ \psi^{*}_{0} = \psi^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}}, \mathbb{D}, \theta \right) = E_{0} - \theta \eta_{0} , \]
</p>
<p> from which we may define the free energy density function \(\psi^{*}_{0}\) with the stated parameterization, exists and is valid. Taking the material rate of this equation and substituting it into the local dissipation inequality results in the generic expression </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \dot{\theta} \eta_{0} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}}, \mathbb{D}, \theta \right) \geq 0 . \]
</p>
<p> Under the assumption of isothermal conditions, and that the electric field does not excite the material in a manner that is considered non-negligible, then this dissipation inequality reduces to </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}} \right) \geq 0 . \]
</p>
<p><a class="anchor" id="Constitutivelaws"></a></p><h4>Constitutive laws</h4>
<p>When considering materials that exhibit mechanically dissipative behavior, it can be shown that this can be captured within the dissipation inequality through the augmentation of the material free energy density function with additional parameters that represent internal variables <b>[Holzapfel1996a]</b>. Consequently, we write it as </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{B}} \right) \geq 0 . \]
</p>
<p> where \(\mathbf{F}_{v}^{i} = \mathbf{F}_{v}^{i} \left( t \right)\) represents the internal variable (which acts like a measure of the deformation gradient) associated with the <code>i</code>th mechanical dissipative (viscous) mechanism. As can be inferred from its parameterization, each of these internal parameters is considered to evolve in time. Currently the free energy density function \(\psi^{*}_{0}\) is parameterized in terms of the magnetic induction \(\boldsymbol{\mathbb{B}}\). This is the natural parameterization that comes as a consequence of the considered balance laws. Should such a class of materials to be incorporated within a finite-element model, it would be ascertained that a certain formulation of the magnetic problem, known as the magnetic vector potential formulation, would need to be adopted. This has its own set of challenges, so where possible the more simple magnetic scalar potential formulation may be preferred. In that case, the magnetic problem needs to be parameterized in terms of the magnetic field \(\boldsymbol{\mathbb{H}}\). To make this re-parameterization, we execute a final Legendre transformation </p><p class="formulaDsp">
\[ \tilde{\psi}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) = \psi^{*}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{B}} \right) - \boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{B}} . \]
</p>
<p> At the same time, we may take advantage of the principle of material frame indifference in order to express the energy density function in terms of symmetric deformation measures: </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) = \tilde{\psi}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) . \]
</p>
<p> The upshot of these two transformations (leaving out considerable explicit and hidden details) renders the final expression for the reduced dissipation inequality as </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{S}^{\text{tot}} : \frac{1}{2} \dot{\mathbf{C}} - \boldsymbol{\mathbb{B}} \cdot \dot{\boldsymbol{\mathbb{H}}} - \dot{\psi}_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \geq 0 . \]
</p>
<p> (Notice the sign change on the second term on the right hand side, and the transfer of the time derivative to the magnetic induction vector.) The stress quantity \(\mathbf{S}^{\text{tot}}\) is known as the total Piola-Kirchhoff stress tensor and its energy conjugate \(\mathbf{C} = \mathbf{F}^{T} \cdot \mathbf{F}\) is the right Cauchy-Green deformation tensor, and \(\mathbf{C}_{v}^{i} = \mathbf{C}_{v}^{i} \left( t \right)\) is the re-parameterized internal variable associated with the <code>i</code>th mechanical dissipative (viscous) mechanism.</p>
<p>Expansion of the material rate of the energy density function, and rearrangement of the various terms, results in the expression </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \left[ \mathbf{S}^{\text{tot}} - 2 \frac{\partial \psi_{0}}{\partial \mathbf{C}} \right] : \frac{1}{2} \dot{\mathbf{C}} - \sum\limits_{i}\left[ 2 \frac{\partial \psi_{0}}{\partial \mathbf{C}_{v}^{i}} \right] : \frac{1}{2} \dot{\mathbf{C}}_{v}^{i} + \left[ - \boldsymbol{\mathbb{B}} - \frac{\partial \psi_{0}}{\partial \boldsymbol{\mathbb{H}}} \right] \cdot \dot{\boldsymbol{\mathbb{H}}} \geq 0 . \]
</p>
<p> At this point, its worth noting the use of the <a href="https://en.wikipedia.org/wiki/Partial_derivative">partial derivatives</a> \(\partial \left( \bullet \right)\). This is an important detail that will be fundamental to a certain design choice made within the tutorial. As brief reminder of what this signifies, the partial derivative of a multi-variate function returns the derivative of that function with respect to one of those variables while holding the others constant: </p><p class="formulaDsp">
\[ \frac{\partial f\left(x, y\right)}{\partial x} = \frac{d f\left(x, y\right)}{d x} \Big\vert_{y} . \]
</p>
<p> More specific to what's encoded in the dissipation inequality (with the very general free energy density function \(\psi_{0}\) with its parameterization yet to be formalized), if one of the input variables is a function of another, it is also held constant and the chain rule does not propagate any further, while the computing total derivative would imply judicious use of the chain rule. This can be better understood by comparing the following two statements: </p><p class="formulaDsp">
\begin{align*} \frac{\partial f\left(x, y\left(x\right)\right)}{\partial x} &amp;= \frac{d f\left(x, y\left(x\right)\right)}{d x} \Big\vert_{y} \\ \frac{d f\left(x, y\left(x\right)\right)}{d x} &amp;= \frac{d f\left(x, y\left(x\right)\right)}{d x} \Big\vert_{y} + \frac{d f\left(x, y\left(x\right)\right)}{d y} \Big\vert_{x} \frac{d y\left(x\right)}{x} . \end{align*}
</p>
<p>Returning to the thermodynamics of the problem, we next exploit the arbitrariness of the quantities \(\dot{\mathbf{C}}\) and \(\dot{\boldsymbol{\mathbb{H}}}\), by application of the Coleman-Noll procedure <b>[Coleman1963a]</b>, <b>[Coleman1967a]</b>. This leads to the identification of the kinetic conjugate quantities </p><p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}} = \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} , \\ \boldsymbol{\mathbb{B}} = \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} . \]
</p>
<p> (Again, note the use of the partial derivatives to define the stress and magnetic induction in this generalized setting.) From what terms remain in the dissipative power (namely those related to the mechanical dissipative mechanisms), if they are assumed to be independent of one another then, for each mechanism <code>i</code>, </p><p class="formulaDsp">
\[ \frac{\partial \psi_{0}}{\partial \mathbf{C}_{v}^{i}} : \dot{\mathbf{C}}_{v}^{i} \leq 0 . \]
</p>
<p> This constraint must be satisfied through the appropriate choice of free energy function, as well as a carefully considered evolution law for the internal variables.</p>
<p>In the case that there are no dissipative mechanisms to be captured within the constitutive model (e.g., if the material to be modelled is magneto-hyperelastic) then the free energy density function \(\psi_{0} = \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) reduces to a stored energy density function, and the total stress and magnetic induction can be simplified </p><p class="formulaDsp">
\begin{align*} \mathbf{S}^{\text{tot}} = \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;\dealcoloneq 2 \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} , \\ \boldsymbol{\mathbb{B}} = \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;\dealcoloneq - \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} , \end{align*}
</p>
<p> where the operator \(d\) denotes the total derivative operation.</p>
<p>For completeness, the linearization of the stress tensor and magnetic induction are captured within the fourth-order total referential elastic tangent tensor \(\mathcal{H}^{\text{tot}} \), the second-order magnetostatic tangent tensor \(\mathbb{D}\) and the third-order total referential magnetoelastic coupling tensor \(\mathfrak{P}^{\text{tot}}\). Irrespective of the parameterization of \(\mathbf{S}^{\text{tot}}\) and \(\boldsymbol{\mathbb{B}}\), these quantities may be computed by </p><p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} &amp;= 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} , \\ \mathbb{D} &amp;= \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} &amp;= - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} , \\ \left[ \mathfrak{P}^{\text{tot}} \right]^{T} &amp;= 2 \frac{d \boldsymbol{\mathbb{B}}}{d \mathbf{C}} . \end{align*}
</p>
<p> For the case of rate-dependent materials, this expands to </p><p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= 4 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C} \otimes d \mathbf{C}} , \\ \mathbb{D} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= -\frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \mathbf{C}} , \\ \left[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \right]^{T} &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} , \end{align*}
</p>
<p> while for rate-independent materials the linearizations are </p><p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= 4 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C} \otimes d \mathbf{C}} , \\ \mathbb{D} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= -\frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \mathbf{C}} , \\ \left[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \right]^{T} &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} . \end{align*}
</p>
<p> The subtle difference between them is the application of a partial derivative during the calculation of the first derivatives. We'll see later how this affects the choice of AD versus SD for this specific application. For now, we'll simply introduce the two specific materials that are implemented within this tutorial.</p>
<p><a class="anchor" id="Magnetoelasticconstitutivelaw"></a></p><h5>Magnetoelastic constitutive law</h5>
<p>The first material that we'll consider is one that is governed by a magneto-hyperelastic constitutive law. This material responds to both deformation as well as immersion in a magnetic field, but exhibits no time- or history-dependent behavior (such as dissipation through viscous damping or magnetic hysteresis, etc.). The <em>stored energy density function</em> for such a material is only parameterized in terms of the (current) field variables, but not their time derivatives or past values.</p>
<p>We'll choose the energy density function, which captures both the energy stored in the material due to deformation and magnetization, as well as the energy stored in the magnetic field itself, to be </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p> and for which the variable \(d = \text{tr}(\mathbf{I})\) ( \(\mathbf{I}\) being the rank-2 identity tensor) represents the spatial dimension and \(\mathbf{F}\) is the deformation gradient tensor. To give some brief background to the various components of \(\psi_{0}\), the first two terms bear a great resemblance to the stored energy density function for a (hyperelastic) Neohookean material. The only difference between what's used here and the Neohookean material is the scaling of the elastic shear modulus by the magnetic field-sensitive saturation function \(f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)\) (see <b>[Pelteret2018a]</b>, equation 29). This function will, in effect, cause the material to stiffen in the presence of a strong magnetic field. As it is governed by a sigmoid-type function, the shear modulus will asymptotically converge on the specified saturation shear modulus. It can also be shown that the last term in \(\psi_{0}\) is the stored energy density function for magnetic field (as derived from first principles), scaled by the relative permeability constant. This definition collectively implies that the material is linearly magnetized, i.e., the magnetization vector and magnetic field vector are aligned. (This is certainly not obvious with the magnetic energy stated in its current form, but when the magnetic induction and magnetization are derived from \(\psi_{0}\) and all magnetic fields are expressed in the <em>current configuration</em> then this correlation becomes clear.) As for the specifics of what the magnetic induction, stress tensor, and the various material tangents look like, we'll defer presenting these to the tutorial body where the full, unassisted implementation of the constitutive law is defined.</p>
<p><a class="anchor" id="Magnetoviscoelasticconstitutivelaw"></a></p><h5>Magneto-viscoelastic constitutive law</h5>
<p>The second material that we'll formulate is one for a magneto-viscoelastic material with a single dissipative mechanism <code>i</code>. The <em>free energy density function</em> that we'll be considering is defined as </p><p class="formulaDsp">
\begin{align*} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \\ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \\ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \end{align*}
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p> and the evolution law </p><p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \left( \mathbf{C} \right) = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v} \right] \]
</p>
<p> for the internal viscous variable. We've chosen the magnetoelastic part of the energy \(\psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) to match that of the first material model that we explored, so this part needs no further explanation. As for the viscous part \(\psi_{0}^{MVE}\), this component of the free energy (in conjunction with the evolution law for the viscous deformation tensor) is taken from <b>[Linder2011a]</b> (with the additional scaling by the viscous saturation function described in <b>[Pelteret2018a]</b>). It is derived in a thermodynamically consistent framework that, at its core, models the movement of polymer chains on a micro-scale level.</p>
<p>To proceed beyond this point, we'll also need to consider the time discretization of the evolution law. Choosing the implicit first-order backwards difference scheme, then </p><p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \approx \frac{\mathbf{C}_{v}^{(t)} - \mathbf{C}_{v}^{(t-1)}}{\Delta t} = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v}^{(t)} \right] \]
</p>
<p> where the superscript \((t)\) denotes that the quantity is taken at the current timestep, and \((t-1)\) denotes quantities taken at the previous timestep (i.e., a history variable). The timestep size \(\Delta t\) is the difference between the current time and that of the previous timestep. Rearranging the terms so that all internal variable quantities at the current time are on the left hand side of the equation, we get </p><p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p> that matches <b>[Linder2011a]</b> equation 54.</p>
<p><a class="anchor" id="Rheologicalexperiment"></a></p><h3>Rheological experiment</h3>
<p>Now that we have shown all of these formulas for the thermodynamics and theory governing magneto-mechanics and constitutive models, let us outline what the program will do with all of this. We wish to do something <em>meaningful</em> with the materials laws that we've formulated, and so it makes sense to subject them to some mechanical and magnetic loading conditions that are, in some way, representative of some conditions that might be found either in an application or in a laboratory setting. One way to achieve that aim would be to embed these constitutive laws in a finite element model to simulate a device. In this instance, though, we'll keep things simple (we are focusing on the automatic and symbolic differentiation concepts, after all) and will find a concise way to faithfully replicate an industry-standard rheological experiment using an analytical expression for the loading conditions.</p>
<p>The rheological experiment that we'll reproduce, which idealizes a laboratory experiment that was used to characterize magneto-active polymers, is detailed in <b>[Pelteret2018a]</b> (as well as <b>[Pelteret2019a]</b>, in which it is documented along with the real-world experiments). The images below provide a visual description of the problem set up.</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.parallel_plate-geometry.png" height="300"/>
</div>
 <p>The basic functional geometry of the parallel-plate rotational rheometer. The smooth rotor (blue) applies a torque to an experimental sample (red) of radius \(r\) and height \(H\) while an axially aligned magnetic field generated by a a magneto-rheological device. Although the time-dependent deformation profile of the may be varied, one common experiment would be to subject the material to a harmonic torsional deformation of constant amplitude and frequency \(\omega\). </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.parallel_plate-kinematics.png" height="300"/>
</div>
 <p>Schematic of the kinematics of the problem, assuming no preloading or compression of the sample. A point \(\mathbf{P}\) located at azimuth \(\Theta\) is displaced to location \(\mathbf{p}\) at azimuth \(\theta = \Theta + \alpha\). </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>Under the assumptions that an incompressible medium is being tested, and that the deformation profile through the sample thickness is linear, then the displacement at some measurement point \(\mathbf{X}\) within the sample, expressed in radial coordinates, is </p><p class="formulaDsp">
\begin{align*} r(\mathbf{X}) &amp;= \frac{R(X_{1}, X_{2})}{\sqrt{\lambda_{3}}} , \\ \theta(\mathbf{X}) &amp; = \Theta(X_{1}, X_{2}) + \underbrace{\tau(t) \lambda_{3} X_{3}}_{\alpha(X_{3}, t)} , \\ z(\mathbf{X}) &amp;= \lambda_{3} X_{3} \end{align*}
</p>
<p> where \(R(X_{1}, X_{2})\) and \(\Theta(X_{1}, X_{2})\) are the radius at &ndash; and angle of &ndash; the sampling point, \(\lambda_{3}\) is the (constant) axial deformation, \(\tau(t) = \frac{A}{RH} \sin\left(\omega t\right)\) is the time-dependent torsion angle per unit length that will be prescribed using a sinusoidally repeating oscillation of fixed amplitude \(A\). The magnetic field is aligned axially, i.e., in the \(X_{3}\) direction.</p>
<p>This summarizes everything that we need to fully characterize the idealized loading at any point within the rheological sample. We'll set up the problem in such a way that we "pick" a representative point with this sample, and subject it to a harmonic shear deformation at a constant axial deformation (by default, a compressive load) and a constant, axially applied magnetic field. We will record the stress and magnetic induction at this point, and will output that data to file for post-processing. Although its not necessary for this particular problem, we will also be computing the tangents as well. Even though they are not directly used in this particular piece of work, these second derivatives are needed to embed the constitutive law within a finite element model (one possible extension to this work). We'll therefore take the opportunity to check our hand calculations for correctness using the assisted differentiation frameworks.</p>
<p><a class="anchor" id="Suggestedliterature"></a></p><h3>Suggested literature</h3>
<p>In addition to the already mentioned <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module, the following are a few references that discuss in more detail</p><ul>
<li>magneto-mechanics, and some aspects of automated differentiation frameworks: <b>[Pao1978a]</b>, <b>[Pelteret2019a]</b>, and</li>
<li>the automation of finite element frameworks using AD and/or SD: <b>[Logg2012a]</b>, <b>[Korelc2016a]</b>.</li>
</ul>
<p><br />
</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>We start by including all the necessary deal.II header files and some C++ related ones. This first header will give us access to a data structure that will allow us to store arbitrary data within it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="general__data__storage_8h.html">deal.II/algorithms/general_data_storage.h</a>&gt;</span></div></div><!-- fragment --><p>Next come some core classes, including one that provides an implementation for time-stepping.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numbers_8h.html">deal.II/base/numbers.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="symmetric__tensor_8h.html">deal.II/base/symmetric_tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>Then some headers that define some useful coordinate transformations and kinematic relationships that are often found in nonlinear elasticity.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transformations_8h.html">deal.II/physics/transformations.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinematics_8h.html">deal.II/physics/elasticity/kinematics.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="standard__tensors_8h.html">deal.II/physics/elasticity/standard_tensors.h</a>&gt;</span></div></div><!-- fragment --><p>The following two headers provide all of the functionality that we need to perform automatic differentiation, and use the symbolic computer algebra system that deal.II can utilize. The headers of all automatic differentiation and symbolic differentiation wrapper classes, and any ancillary data structures that are required, are all collected inside these unifying headers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sd_8h.html">deal.II/differentiation/sd.h</a>&gt;</span></div></div><!-- fragment --><p>Including this header allows us the capability to write output to a file stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>As per usual, the entire tutorial program is defined within its own unique namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step71</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="AnintroductoryexampleThefundamentalsofautomaticandsymbolicdifferentiation"></a> </p><h3>An introductory example: The fundamentals of automatic and symbolic differentiation</h3>
<p>Automatic and symbolic differentiation have some magical and mystical qualities. Although their use in a project can be beneficial for a multitude of reasons, the barrier to understanding how to use these frameworks or how they can be leveraged may exceed the patience of the developer that is trying to (reliably) integrate them into their work.</p>
<p>Although it is the wish of the author to successfully illustrate how these tools can be integrated into workflows for finite element modelling, it might be best to first take a step back and start right from the basics. So to start off with, we'll first have a look at differentiating a "simple" mathematical function using both frameworks, so that the fundamental operations (both their sequence and function) can be firmly established and understood with minimal complication. In the second part of this tutorial we will put these fundamentals into practice and build on them further.</p>
<p>Accompanying the description of the algorithmic steps to use the frameworks will be a simplified view as to what they <em>might</em> be doing in the background. This description will be very much one designed to aid understanding, and the reader is encouraged to view the <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module documentation for a far more formal description into how these tools actually work.</p>
<p><a class="anchor" id="Ananalyticalfunction"></a> </p><h4>An analytical function</h4>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SimpleExample</div><div class="line">{</div></div><!-- fragment --><p>In order to convince the reader that these tools are indeed useful in practice, let us choose a function for which it is not too difficult to compute the analytical derivatives by hand. It's just sufficiently complicated to make you think about whether or not you truly want to go through with this exercise, and might also make you question whether you are completely sure that your calculations and implementation for its derivatives are correct. The point, of course, is that differentiation of functions is in a sense relatively formulaic and should be something computers are good at &ndash; if we could build on existing software that understands the rules, we wouldn't have to bother with doing it ourselves.</p>
<p>We choose the two variable trigonometric function \(f(x,y) = \cos\left(\frac{y}{x}\right)\) for this purpose. Notice that this function is templated on the number type. This is done because we can often (but not always) use special auto-differentiable and symbolic types as drop-in replacements for real or complex valued types, and these will then perform some elementary calculations, such as evaluate a function value along with its derivatives. We will exploit that property and make sure that we need only define our function once, and then it can be re-used in whichever context we wish to perform differential operations on it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumberType&gt;</div><div class="line"><a class="code" href="classNumberType.html">NumberType</a> f(<span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x);</div><div class="line">}</div></div><!-- fragment --><p>Rather than revealing this function's derivatives immediately, we'll forward declare functions that return them and defer their definition to later. As implied by the function names, they respectively return the derivatives \(\frac{df(x,y)}{dx}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{df(x,y)}{dy}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx^{2}}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx dy}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy dx}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>and, lastly, \(\frac{d^{2}f(x,y)}{dy^{2}}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p><a class="anchor" id="Computingderivativesusingautomaticdifferentiation"></a> </p><h4>Computing derivatives using automatic differentiation</h4>
<p>To begin, we'll use AD as the tool to automatically compute derivatives for us. We will evaluate the function with the arguments <code>x</code> and <code>y</code>, and expect the resulting value and all of the derivatives to match to within the given tolerance.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">run_and_verify_ad(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">{</div></div><!-- fragment --><p>Our function \(f(x,y)\) is a scalar-valued function, with arguments that represent the typical input variables that one comes across in algebraic calculations or tensor calculus. For this reason, the <a class="el" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction</a> class is the appropriate wrapper class to use to do the computations that we require. (As a point of comparison, if the function arguments represented finite element cell degrees-of-freedom, we'd want to treat them differently.) The spatial dimension of the problem is irrelevant since we have no vector- or tensor-valued arguments to accommodate, so the <code>dim</code> template argument is arbitrarily assigned a value of 1. The second template argument stipulates which AD framework will be used (deal.II has support for several external AD frameworks), and what the underlying number type provided by this framework is to be used. This number type influences the maximum order of the differential operation, and the underlying algorithms that are used to compute them. Given its template nature, this choice is a compile-time decision because many (but not all) of the AD libraries exploit compile-time meta-programming to implement these special number types in an efficient manner. The third template parameter states what the result type is; in our case, we're working with <code>double</code>s.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     dim = 1;</div><div class="line">constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"><span class="keyword">using</span> ADHelper =</div><div class="line">  <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div></div><!-- fragment --><p>It is necessary that we pre-register with our <code>ADHelper</code> class how many arguments (what we will call "independent variables") the function \(f(x,y)\) has. Those arguments are <code>x</code> and <code>y</code>, so obviously there are two of them.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = 2;</div></div><!-- fragment --><p>We now have sufficient information to create and initialize an instance of the helper class. We can also get the concrete number type that will be used in all subsequent calculations. This is useful, because we can write everything from here on by referencing this type, and if we ever want to change the framework used, or number type (e.g., if we need more differential operations) then we need only adjust the <code>ADTypeCode</code> template parameter.</p>
<div class="fragment"><div class="line">ADHelper ad_helper(n_independent_variables);</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div></div><!-- fragment --><p>The next step is to register the numerical values of the independent variables with the helper class. This is done because the function and its derivatives will be evaluated for exactly these arguments. Since we register them in the order <code>{x,y}</code>, the variable <code>x</code> will be assigned component number <code>0</code>, and <code>y</code> will be component <code>1</code> &ndash; a detail that will be used in the next few lines.</p>
<div class="fragment"><div class="line">ad_helper.register_independent_variables({x, y});</div></div><!-- fragment --><p>We now ask for the helper class to give to us the independent variables with their auto-differentiable representation. These are termed "sensitive variables", because from this point on any operations that we do with the components <code>independent_variables_ad</code> are tracked and recorded by the AD framework, and will be considered when we ask for the derivatives of something that they're used to compute. What the helper returns is a <code>vector</code> of auto-differentiable numbers, but we can be sure that the zeroth element represents <code>x</code> and the first element <code>y</code>. Just to make completely sure that there's no ambiguity of what number type these variables are, we suffix all of the auto-differentiable variables with <code>ad</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; independent_variables_ad =</div><div class="line">  ad_helper.get_sensitive_variables();</div><div class="line"><span class="keyword">const</span> ADNumberType &amp;x_ad = independent_variables_ad[0];</div><div class="line"><span class="keyword">const</span> ADNumberType &amp;y_ad = independent_variables_ad[1];</div></div><!-- fragment --><p>We can immediately pass in our sensitive representation of the independent variables to our templated function that computes \(f(x,y)\). This also returns an auto-differentiable number.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType f_ad = f(x_ad, y_ad);</div></div><!-- fragment --><p>So now the natural question to ask is what we have actually just computed by passing these special <code>x_ad</code> and <code>y_ad</code> variables to the function <code>f</code>, instead of the original <code>double</code> variables <code>x</code> and <code>y</code>? In other words, how is all of this related to the computation of the derivatives that we were wanting to determine? Or, more concisely: What is so special about this returned <code>ADNumberType</code> object that gives it the ability to magically return derivatives?</p>
<p>In essence, how this <em>could</em> be done is the following: This special number can be viewed as a data structure that stores the function value, and the prescribed number of derivatives. For a once-differentiable number expecting two arguments, it might look like this:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="keyword">struct </span>ADNumberType</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> value;          <span class="comment">// The value of the object</span></div><div class="line">  <span class="keywordtype">double</span> derivatives[2]; <span class="comment">// Array of derivatives of the object with</span></div><div class="line">                         <span class="comment">// respect to x and y</span></div><div class="line">};</div></div><!-- fragment --> </div><p>For our independent variable <code>x_ad</code>, the starting value of <code>x_ad.value</code> would simply be its assigned value (i.e., the real value of that this variable represents). The derivative <code>x_ad.derivatives[0]</code> would be initialized to <code>1</code>, since <code>x</code> is the zeroth independent variable and \(\frac{d(x)}{dx} = 1\). The derivative <code>x.derivatives[1]</code> would be initialized to zero, since the first independent variable is <code>y</code> and \(\frac{d(x)}{dy} = 0\).</p>
<p>For the function derivatives to be meaningful, we must assume that not only is this function differentiable in an analytical sense, but that it is also differentiable at the evaluation point <code>x,y</code>. We can exploit both of these assumptions: when we use this number type in mathematical operations, the AD framework <em>could</em> overload the operations (e.g., <code>operator+()</code>, <code>operator*()</code> as well as <code>sin()</code>, <code>exp()</code>, etc.) such that the returned result has the expected value. At the same time, it would then compute the derivatives through the knowledge of exactly what function is being overloaded and rigorous application of the chain-rule. So, the <code>sin()</code> function (with its argument <code>a</code> itself being a function of the independent variables <code>x</code> and <code>y</code>) <em>might</em> be defined as follows:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">ADNumberType <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<span class="keyword">const</span> ADNumberType &amp;a)</div><div class="line">{</div><div class="line">  ADNumberType output;</div><div class="line">     </div><div class="line"></div><div class="line">  <span class="comment">// For the input argument &quot;a&quot;, &quot;a.value&quot; is simply its value.</span></div><div class="line">  output.value = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(a.value);</div><div class="line">     </div><div class="line"></div><div class="line">  <span class="comment">// We know that the derivative of sin(a) is cos(a), but we need</span></div><div class="line">  <span class="comment">// to also consider the chain rule and that the input argument</span></div><div class="line">  <span class="comment">// `a` is also differentiable with respect to the original</span></div><div class="line">  <span class="comment">// independent variables `x` and `y`. So `a.derivatives[0]`</span></div><div class="line">  <span class="comment">// and `a.derivatives[1]` respectively represent the partial</span></div><div class="line">  <span class="comment">// derivatives of `a` with respect to its inputs `x` and `y`.</span></div><div class="line">  output.derivatives[0] = <a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(a.value)*a.derivatives[0];</div><div class="line">  output.derivatives[1] = <a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(a.value)*a.derivatives[1];</div><div class="line">     </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> output;</div><div class="line">}</div></div><!-- fragment --> </div><p>All of that could of course also be done for second and even higher order derivatives.</p>
<p>So it is now clear that with the above representation the <code>ADNumberType</code> is carrying around some extra data that represents the various derivatives of differentiable functions with respect to the original (sensitive) independent variables. It should therefore be noted that there is computational overhead associated with using them (as we compute extra functions when doing derivative computations) as well as memory overhead in storing these results. So the prescribed number of levels of differential operations should ideally be kept to a minimum to limit computational cost. We could, for instance, have computed the first derivatives ourself and then have used the <a class="el" href="classDifferentiation_1_1AD_1_1VectorFunction.html">Differentiation::AD::VectorFunction</a> helper class to determine the gradient of the collection of dependent functions, which would be the second derivatives of the original scalar function.</p>
<p>It is also worth noting that because the chain rule is indiscriminately applied and we only see the beginning and end-points of the calculation <code>{x,y}</code> \(\rightarrow\) <code>f(x,y)</code>, we will only ever be able to query the total derivatives of <code>f</code>; the partial derivatives (<code>a.derivatives[0]</code> and <code>a.derivatives[1]</code> in the above example) are intermediate values and are hidden from us.</p>
<p>Okay, since we now at least have some idea as to exactly what <code>f_ad</code> represents and what is encoded within it, let's put all of that to some actual use. To gain access to those hidden derivative results, we register the final result with the helper class. After this point, we can no longer change the value of <code>f_ad</code> and have those changes reflected in the results returned by the helper class.</p>
<div class="fragment"><div class="line">ad_helper.register_dependent_variable(f_ad);</div></div><!-- fragment --><p>The next step is to extract the derivatives (specifically, the function gradient and Hessian). To do so we first create some temporary data structures (with the result type <code>double</code>) to store the derivatives (noting that all derivatives are returned at once, and not individually)...</p>
<div class="fragment"><div class="line">Vector&lt;double&gt;     Df(ad_helper.n_dependent_variables());</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2f(ad_helper.n_dependent_variables(),</div><div class="line">                       ad_helper.n_independent_variables());</div></div><!-- fragment --><p>... and we then request that the helper class compute these derivatives, and the function value itself. And that's it. We have everything that we were aiming to get.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_f = ad_helper.compute_value();</div><div class="line">ad_helper.compute_gradient(Df);</div><div class="line">ad_helper.compute_hessian(D2f);</div></div><!-- fragment --><p>We can convince ourselves that the AD framework is correct by comparing it to the analytical solution. (Or, if you're like the author, you'll be doing the opposite and will rather verify that your implementation of the analytical solution is correct!)</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                       std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                       std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                       std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div></div><!-- fragment --><p>Because we know the ordering of the independent variables, we know which component of the gradient relates to which derivative...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx = Df[0];</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy = Df[1];</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div></div><!-- fragment --><p>... and similar for the Hessian.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx = D2f[0][0];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy = D2f[0][1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx = D2f[1][0];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy = D2f[1][1];</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">}</div></div><!-- fragment --><p>That's pretty great. There wasn't too much work involved in computing second-order derivatives of this trigonometric function.</p>
<p><a class="anchor" id="Handcalculatedderivativesoftheanalyticalsolution"></a> </p><h4>Hand-calculated derivatives of the analytical solution</h4>
<p>Since we now know how much "implementation effort" it takes to have the AD framework compute those derivatives for us, let's compare that to the same computed by hand and implemented in several stand-alone functions.</p>
<p>Here are the two first derivatives of \(f(x,y) = \cos\left(\frac{y}{x}\right)\):</p>
<p>\(\frac{df(x,y)}{dx} = \frac{y}{x^2} \sin\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(x != 0.0, <a class="code" href="group__Exceptions.html#ga2e959da7bfd82df428770c0339c377ba">ExcDivideByZero</a>());</div><div class="line">  <span class="keywordflow">return</span> y * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / (x * x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{df(x,y)}{dx} = -\frac{1}{x} \sin\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / x;</div><div class="line">}</div></div><!-- fragment --><p>And here are the four second derivatives of \(f(x,y)\):</p>
<p>\(\frac{d^{2}f(x,y)}{dx^{2}} = -\frac{y}{x^4} (2x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> -y * (2 * x * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) + y * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) /</div><div class="line">         (x * x * x * x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx dy} = \frac{1}{x^3} (x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy dx} = \frac{1}{x^3} (x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\) (as expected, on the basis of <a href="https://en.wikipedia.org/wiki/Symmetry_of_second_derivatives">Schwarz's theorem</a>)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy^{2}} = -\frac{1}{x^2} \cos\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> -(<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) / (x * x);</div><div class="line">}</div></div><!-- fragment --><p>Hmm... there's a lot of places in the above where we could have introduced an error in the above, especially when it comes to applying the chain rule. Although they're no silver bullet, at the very least these AD frameworks can serve as a verification tool to make sure that we haven't made any errors (either by calculation or by implementation) that would negatively affect our results.</p>
<p>The point of this example of course is that we might have chosen a relatively simple function \(f(x,y)\) for which we can hand-verify that the derivatives the AD framework computed is correct. But the AD framework didn't care that the function was simple: It could have been a much much more convoluted expression, or could have depended on more than two variables, and it would still have been able to compute the derivatives &ndash; the only difference would have been that <em>we</em> wouldn't have been able to come up with the derivatives any more to verify correctness of the AD framework.</p>
<p><a class="anchor" id="Computingderivativesusingsymbolicdifferentiation"></a> </p><h4>Computing derivatives using symbolic differentiation</h4>
<p>We'll now repeat the same exercise using symbolic differentiation. The term "symbolic differentiation" is a little bit misleading because differentiation is just one tool that the Computer Algebra System (CAS) (i.e., the symbolic framework) provides. Nevertheless, in the context of finite element modeling and applications it is the most common use of a CAS and will therefore be the one that we'll focus on. Once more, we'll supply the argument values <code>x</code> and <code>y</code> with which to evaluate our function \(f(x,y) = \cos\left(\frac{y}{x}\right)\) and its derivatives, and a tolerance with which to test the correctness of the returned results.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">run_and_verify_sd(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">{</div></div><!-- fragment --><p>The first step that we need to take is to form the symbolic variables that represent the function arguments that we wish to differentiate with respect to. Again, these will be the independent variables for our problem and as such are, in some sense, primitive variables that have no dependencies on any other variable. We create these types of (independent) variables by initializing a symbolic type <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>, which is a wrapper to a set of classes used by the symbolic framework, with a unique identifier. On this occasion it makes sense that this identifier, a <code>std::string</code>, be simply <code>"x"</code> for the \(x\) argument, and likewise <code>"y"</code> for the \(y\) argument to the dependent function. Like before, we'll suffix symbolic variable names with <code>sd</code> so that we can clearly see which variables are symbolic (as opposed to numeric) in nature.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> x_sd(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> y_sd(<span class="stringliteral">&quot;y&quot;</span>);</div></div><!-- fragment --><p>Using the templated function that computes \(f(x,y)\), we can pass these independent variables as arguments to the function. The returned result will be another symbolic type that represents the sequence of operations used to compute \(\cos\left(\frac{y}{x}\right)\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_sd = f(x_sd, y_sd);</div></div><!-- fragment --><p>At this point it is legitimate to print out the expression <code>f_sd</code>, and if we did so </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;f(x,y) = &quot;</span> &lt;&lt; f_sd &lt;&lt; std::endl;</div></div><!-- fragment --> </div><p> we would see <code>f(x,y) = cos(y/x)</code> printed to the console.</p>
<p>You might notice that we've constructed our symbolic function <code>f_sd</code> with no context as to how we might want to use it: In contrast to the AD approach shown above, what we were returned from calling <code>f(x_sd, y_sd)</code> is not the evaluation of the function <code>f</code> at some specific point, but is in fact a symbolic representation of the evaluation at a generic, as yet undetermined, point. This is one of the key points that makes symbolic frameworks (the CAS) different from automatic differentiation frameworks. Each of the variables <code>x_sd</code> and <code>y_sd</code>, and even the composite dependent function <code>f_sd</code>, are in some sense respectively "placeholders" for numerical values and a composition of operations. In fact, the individual components that are used to compose the function are also placeholders. The sequence of operations are encoded into in a tree-like data structure (conceptually similar to an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>).</p>
<p>Once we form these data structures we can defer any operations that we might want to do with them until some later time. Each of these placeholders represents something, but we have the opportunity to define or redefine what they represent at any convenient point in time. So for this particular problem it makes sense that we somehow want to associate "x" and "y" with <em>some</em> numerical value (with type yet to be determined), but we could conceptually (and if it made sense) assign the ratio "y/x" a value instead of the variables "x" and "y" individually. We could also associate with "x" or "y" some other symbolic function <code>g(a,b)</code>. Any of these operations involves manipulating the recorded tree of operations, and substituting the salient nodes on the tree (and that nodes' subtree) with something else. The key word here is "substitution", and indeed there are many functions in the <a class="el" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a> namespace that have this word in their names.</p>
<p>This capability makes the framework entirely generic. In the context of finite element simulations, the types of operations that we would typically perform with our symbolic types are function composition, differentiation, substitution (partial or complete), and evaluation (i.e., conversion of the symbolic type to its numerical counterpart). But should you need it, a CAS is often capable of more than just this: It could be forming anti-derivatives (integrals) of functions, perform simplifications on the expressions that form a function (e.g., replace \((\sin a)^2 + (\cos a)^2\) by \(1\); or, more simply: if the function did an operation like <code>1+2</code>, a CAS could replace it by <code>3</code>), and so forth: The <em>expression</em> that a variable represents is obtained from how the function \(f\) is implemented, but a CAS can do with it whatever its functionality happens to be.</p>
<p>Specifically, to compute the symbolic representation of the first derivatives of the dependent function with respect to its individual independent variables, we use the <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">Differentiation::SD::Expression::differentiate()</a> function with the independent variable given as its argument. Each call will cause the CAS to go through the tree of operations that compose <code>f_sd</code> and differentiate each node of the expression tree with respect to the given symbolic argument.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dx_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dy_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div></div><!-- fragment --><p>To compute the symbolic representation of the second derivatives, we simply differentiate the first derivatives with respect to the independent variables. So to compute a higher order derivative, we first need to compute the lower order derivative. (As the return type of the call to <code><a class="el" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">differentiate()</a></code> is an expression, we could in principal execute double differentiation directly from the scalar by chaining two calls together. But this is unnecessary in this particular case, since we have the intermediate results at hand.)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dx_sd =</div><div class="line">  df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dy_sd =</div><div class="line">  df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dx_sd =</div><div class="line">  df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dy_sd =</div><div class="line">  df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div></div><!-- fragment --><p>Printing the expressions for the first and second derivatives, as computed by the CAS, using the statements </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;df_dx_sd: &quot;</span> &lt;&lt; df_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;df_dy_sd: &quot;</span> &lt;&lt; df_dy_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dx_dx_sd: &quot;</span> &lt;&lt; d2f_dx_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dx_dy_sd: &quot;</span> &lt;&lt; d2f_dx_dy_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dy_dx_sd: &quot;</span> &lt;&lt; d2f_dy_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dy_dy_sd: &quot;</span> &lt;&lt; d2f_dy_dy_sd &lt;&lt; std::endl;</div></div><!-- fragment --> </div><p> renders the following output: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">df_dx_sd: y*sin(y/x)/x**2</div><div class="line">df_dy_sd: -sin(y/x)/x</div><div class="line">d2f_dx_dx_sd: -y**2*cos(y/x)/x**4 - 2*y*sin(y/x)/x**3</div><div class="line">d2f_dx_dy_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3</div><div class="line">d2f_dy_dx_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3</div><div class="line">d2f_dy_dy_sd: -cos(y/x)/x**2</div></div><!-- fragment --> </div><p> This compares favorably to the analytical expressions for these derivatives that were presented earlier.</p>
<p>Now that we have formed the symbolic expressions for the function and its derivatives, we want to evaluate them for the numeric values for the main function arguments <code>x</code> and <code>y</code>. To accomplish this, we construct a <em>substitution map</em>, which maps the symbolic values to their numerical counterparts.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a> =</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::pair&lt;Differentiation::SD::Expression, double&gt;{x_sd, x},</div><div class="line">    std::pair&lt;Differentiation::SD::Expression, double&gt;{y_sd, y});</div></div><!-- fragment --><p>The last step in the process is to convert all symbolic variables and operations into numerical values, and produce the numerical result of this operation. To do this we combine the substitution map with the symbolic variable in the step we have already mentioned above: "substitution".</p>
<p>Once we pass this substitution map to the CAS, it will substitute each instance of the symbolic variable (or, more generally, sub-expression) with its numerical counterpart and then propagate these results up the operation tree, simplifying each node on the tree if possible. If the tree is reduced to a single value (i.e., we have substituted all of the independent variables with their numerical counterpart) then the evaluation is complete.</p>
<p>Due to the strongly-typed nature of C++, we need to instruct the CAS to convert its representation of the result into an intrinsic data type (in this case a <code>double</code>). This is the "evaluation" step, and through the template type we define the return type of this process. Conveniently, these two steps can be done at once if we are certain that we've performed a full substitution.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_f =</div><div class="line">  f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                       std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                       std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                       std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div></div><!-- fragment --><p>We can do the same for the first derivatives...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx =</div><div class="line">  df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy =</div><div class="line">  df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div></div><!-- fragment --><p>... and the second derivatives. Notice that we can reuse the same substitution map for each of these operations because we wish to evaluate all of these functions for the same values of <code>x</code> and <code>y</code>. Modifying the values in the substitution map renders the result of same symbolic expression evaluated with different values being assigned to the independent variables. We could also happily have each variable represent a real value in one pass, and a complex value in the next.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx =</div><div class="line">    d2f_dx_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy =</div><div class="line">    d2f_dx_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx =</div><div class="line">    d2f_dy_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy =</div><div class="line">    d2f_dy_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheSimpleExamplerunfunction"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SimpleExample::run()</a> function</h4>
<p>The function used to drive these initial examples is straightforward. We'll arbitrarily choose some values at which to evaluate the function (although knowing that <code>x = 0</code> is not permissible), and then pass these values to the functions that use the AD and SD frameworks.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = 1.23;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = 0.91;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using automatic differentiation...&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    run_and_verify_ad(x, y);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using symbolic differentiation.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    run_and_verify_sd(x, y);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace SimpleExample</span></div></div><!-- fragment --><p><a class="anchor" id="AmorecomplexexampleUsingautomaticandsymbolicdifferentiationtocomputederivativesatcontinuumpoints"></a> </p><h3>A more complex example: Using automatic and symbolic differentiation to compute derivatives at continuum points</h3>
<p>Now that we've introduced the principles behind automatic and symbolic differentiation, we'll put them into action by formulating two coupled magneto-mechanical constitutive laws: one that is rate-independent, and another that exhibits rate-dependent behavior.</p>
<p>As you will recall from the introduction, the material constitutive laws we will consider are far more complicated than the simple example above. This is not just because of the form of the function \(\psi_{0}\) that we will consider, but in particular because \(\psi_{0}\) doesn't just depend on two scalar variables, but instead on a whole bunch of <em>tensors</em>, each with several components. In some cases, these are <em>symmetric</em> tensors, for which only a subset of components is in fact independent, and one has to think about what it actually means to compute a derivative such as \(\frac{\partial\psi_{0}}{\partial \mathbf{C}}\) where \(\mathbf C\) is a symmetric tensor. How all of this will work will, hopefully, become clear below. It will also become clear that doing this by hand is going to be, at the very best, <em>exceedingly</em> tedious* and, at worst, riddled with hard-to-find bugs.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>CoupledConstitutiveLaws</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Constitutiveparameters"></a> </p><h4>Constitutive parameters</h4>
<p>We start with a description of the various material parameters that appear in the description of the energy function \(\psi_{0}\).</p>
<p>The ConstitutiveParameters class is used to hold these values. Values for all parameters (both constitutive and rheological) are taken from <b>[Pelteret2018a]</b>, and are given values that produce a constitutive response that is broadly representative of a real, laboratory-made magneto-active polymer, though the specific values used here are of no consequence to the purpose of this program of course.</p>
<p>The first four constitutive parameters respectively represent</p><ul>
<li>the elastic shear modulus \(\mu_{e}\),</li>
<li>the elastic shear modulus at magnetic saturation \(\mu_{e}^{\infty}\),</li>
<li>the saturation magnetic field strength for the elastic shear modulus \(h_{e}^{\text{sat}}\), and</li>
<li>the Poisson ratio \(\nu\).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>ConstitutiveParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConstitutiveParameters();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mu_e       = 30.0e3;</div><div class="line">  <span class="keywordtype">double</span> mu_e_inf   = 250.0e3;</div><div class="line">  <span class="keywordtype">double</span> mu_e_h_sat = 212.2e3;</div><div class="line">  <span class="keywordtype">double</span> nu_e       = 0.49;</div></div><!-- fragment --><p>The next four, which only pertain to the rate-dependent material, are parameters for</p><ul>
<li>the viscoelastic shear modulus \(\mu_{v}\),</li>
<li>the viscoelastic shear modulus at magnetic saturation \(\mu_{v}^{\infty}\),</li>
<li>the saturation magnetic field strength for the viscoelastic shear modulus \(h_{v}^{\text{sat}}\), and</li>
<li>the characteristic relaxation time \(\tau\).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mu_v       = 20.0e3;</div><div class="line"><span class="keywordtype">double</span> mu_v_inf   = 35.0e3;</div><div class="line"><span class="keywordtype">double</span> mu_v_h_sat = 92.84e3;</div><div class="line"><span class="keywordtype">double</span> tau_v      = 0.6;</div></div><!-- fragment --><p>The last parameter is the relative magnetic permeability \(\mu_{r}\).</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> mu_r = 6.0;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">};</div></div><!-- fragment --><p>The parameters are initialized through the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> framework, which is discussed in detail in <a class="el" href="step_60.html">step-60</a>.</p>
<div class="fragment"><div class="line">ConstitutiveParameters::ConstitutiveParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Constitutive Parameters/&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Elastic shear modulus&quot;</span>, mu_e);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Elastic shear modulus at magnetic saturation&quot;</span>, mu_e_inf);</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Saturation magnetic field strength for elastic shear modulus&quot;</span>,</div><div class="line">    mu_e_h_sat);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Poisson ratio&quot;</span>, nu_e);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus&quot;</span>, mu_v);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus at magnetic saturation&quot;</span>,</div><div class="line">                mu_v_inf);</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Saturation magnetic field strength for viscoelastic shear modulus&quot;</span>,</div><div class="line">    mu_v_h_sat);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Characteristic relaxation time&quot;</span>, tau_v);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Relative magnetic permeability&quot;</span>, mu_r);</div><div class="line"></div><div class="line">  parse_parameters_call_back.connect([&amp;]() { initialized = <span class="keyword">true</span>; });</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutivelawsBaseclass"></a> </p><h4>Constitutive laws: Base class</h4>
<p>Since we'll be formulating two constitutive laws for the same class of materials, it makes sense to define a base class that ensures a unified interface to them.</p>
<p>The class declaration starts with the constructor that will accept the set of constitutive parameters that, in conjunction with the material law itself, dictate the material response.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coupled_Magnetomechanical_Constitutive_Law_Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div></div><!-- fragment --><p>Instead of computing and returning the kinetic variables or their linearization at will, we'll calculate and store these values within a single method. These cached results will then be returned upon request. We'll defer the precise explanation as to why we'd want to do this to a later stage. What is important for now is to see that this function accepts all of the field variables, namely the magnetic field vector \(\boldsymbol{\mathbb{H}}\) and right Cauchy-Green deformation tensor \(\mathbf{C}\), as well as the time discretizer. These, in addition to the <code>constitutive_parameters</code>, are all the fundamental quantities that are required to compute the material response.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) = 0;</div></div><!-- fragment --><p>The next few functions provide the interface to probe the material response due subject to the applied deformation and magnetic loading.</p>
<p>Since the class of materials can be expressed in terms of a free energy \(\psi_{0}\), we can compute that...</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>... as well as the two kinetic quantities:</p><ul>
<li>the magnetic induction vector \(\boldsymbol{\mathbb{B}}\), and</li>
<li>the total Piola-Kirchhoff stress tensor \(\mathbf{S}^{\text{tot}}\)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>... and the linearization of the kinetic quantities, which are:</p><ul>
<li>the magnetostatic tangent tensor \(\mathbb{D}\),</li>
<li>the total referential magnetoelastic coupling tensor \(\mathfrak{P}^{\text{tot}}\), and</li>
<li>the total referential elastic tangent tensor \(\mathcal{H}^{\text{tot}}\).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>We'll also define a method that provides a mechanism for this class instance to do any additional tasks before moving on to the next timestep. Again, the reason for doing this will become clear a little later.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep()</div><div class="line">{}</div></div><!-- fragment --><p>In the <code>protected</code> part of the class, we store a reference to an instance of the constitutive parameters that govern the material response. For convenience, we also define some functions that return various constitutive parameters (both explicitly defined, as well as calculated).</p>
<p>The parameters related to the elastic response of the material are, in order:</p><ul>
<li>the elastic shear modulus,</li>
<li>the elastic shear modulus at saturation magnetic field,</li>
<li>the saturation magnetic field strength for the elastic shear modulus,</li>
<li>the Poisson ratio,</li>
<li>the Lam&eacute; parameter, and</li>
<li>the bulk modulus.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_nu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_lambda_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_kappa_e() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The parameters related to the elastic response of the material are, in order:</p><ul>
<li>the viscoelastic shear modulus,</li>
<li>the viscoelastic shear modulus at magnetic saturation,</li>
<li>the saturation magnetic field strength for the viscoelastic shear modulus, and</li>
<li>the characteristic relaxation time.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_mu_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_mu_v_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_mu_v_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_tau_v() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The parameters related to the magnetic response of the material are, in order:</p><ul>
<li>the relative magnetic permeability, and</li>
<li>the magnetic permeability constant \(\mu_{0}\) (not really a material constant, but rather a universal constant that we'll group here for simplicity).</li>
</ul>
<p>We'll also implement a function that returns the timestep size from the time discretizion.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> get_mu_r() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> get_mu_0() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span>           get_delta_t(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>In the following, let us start by implementing the several relatively trivial member functions of the class just defined:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">  : constitutive_parameters(constitutive_parameters)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(get_kappa_e() &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_e;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_e_inf;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_e_h_sat;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_nu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.nu_e;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_lambda_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_kappa_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (2.0 * get_mu_e() * (1.0 + get_nu_e())) /</div><div class="line">         (3.0 * (1.0 - 2.0 * get_nu_e()));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_v;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_v_inf;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_v_h_sat;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_tau_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.tau_v;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_r()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_r;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">constexpr <span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_0()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 4.0 * numbers::PI * 1e-7;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_delta_t(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> time.<a class="code" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">get_previous_step_size</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Magnetoelasticconstitutivelawusingautomaticdifferentiation"></a> </p><h4>Magnetoelastic constitutive law (using automatic differentiation)</h4>
<p>We'll begin by considering a non-dissipative material, namely one that is governed by a magneto-hyperelastic constitutive law that exhibits stiffening when immersed in a magnetic field. As described in the introduction, the stored energy density function for such a material might be given by </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) . \]
</p>
<p>Now on to the class that implements this behavior. Since we expect that this class fully describes a single material, we'll mark it as "final" so that the inheritance tree terminated here. At the top of the class, we define the helper type that we will use in the AD computations for our scalar energy density function. Note that we expect it to return values of type <code>double</code>. We also have to specify the number of spatial dimensions, <code>dim</code>, so that the link between vector, tensor and symmetric tensor fields and the number of components that they contain may be established. The concrete <code>ADTypeCode</code> used for the ADHelper class will be provided as a template argument at the point where this class is actually used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><span class="keyword">class </span>Magnetoelastic_Constitutive_Law_AD final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> ADHelper =</div><div class="line">    <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line">  <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoelastic_Constitutive_Law_AD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div></div><!-- fragment --><p>Since the public interface to the base class is pure-<code>virtual</code>, here we'll declare that this class will override all of these base class methods.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>In the <code>private</code> part of the class, we need to define some extractors that will help us set independent variables and later get the computed values related to the dependent variables. If this class were to be used in the context of a finite element problem, then each of these extractors is (most likely) related to the gradient of a component of the solution field (in this case, displacement and magnetic scalar potential). As you can probably infer by now, here "C" denotes the right Cauchy-Green tensor and "H" denotes the magnetic field vector.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>             H_components;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor&lt;2&gt;</a> C_components;</div></div><!-- fragment --><p>This is an instance of the automatic differentiation helper that we'll set up to do all of the differential calculations related to the constitutive law...</p>
<div class="fragment"><div class="line">ADHelper ad_helper;</div></div><!-- fragment --><p>... and the following three member variables will store the output from the <code>ad_helper</code>. The <code>ad_helper</code> returns the derivatives with respect to all field variables at once, so we'll retain the full gradient vector and Hessian matrix. From that, we'll extract the individual entries that we're actually interested in.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span>             psi;</div><div class="line">  Vector&lt;double&gt;     Dpsi;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2psi;</div><div class="line">};</div></div><!-- fragment --><p>When setting up the field component extractors, it is completely arbitrary as to how they are ordered. But it is important that the extractors do not have overlapping indices. The total number of components of these extractors defines the number of independent variables that the <code>ad_helper</code> needs to track, and with respect to which we'll be taking derivatives. The resulting data structures <code>Dpsi</code> and <code>D2psi</code> must also be sized accordingly. Once the <code>ad_helper</code> is configured (its input argument being the total number of components of \(\mathbf{C}\) and \(\boldsymbol{\mathbb{H}}\)), we can directly interrogate it as to how many independent variables it uses.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::</div><div class="line">  Magnetoelastic_Constitutive_Law_AD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , H_components(0)</div><div class="line">  , C_components(<a class="code" href="classTensor.html">Tensor</a>&lt;1, dim&gt;::n_independent_components)</div><div class="line">  , ad_helper(<a class="code" href="classTensor.html">Tensor</a>&lt;1, dim&gt;::n_independent_components +</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt;::n_independent_components)</div><div class="line">  , psi(0.0)</div><div class="line">  , Dpsi(ad_helper.n_independent_variables())</div><div class="line">  , D2psi(ad_helper.n_independent_variables(),</div><div class="line">          ad_helper.n_independent_variables())</div><div class="line">{}</div></div><!-- fragment --><p>As stated before, due to the way that the automatic differentiation libraries work, the <code>ad_helper</code> will always returns the derivatives of the energy density function with respect to all field variables simultaneously. For this reason, it does not make sense to compute the derivatives in the functions <code>get_B()</code>, <code>get_S()</code>, etc. because we'd be doing a lot of extra computations that are then simply discarded. So, the best way to deal with that is to have a single function call that does all of the calculations up-front, and then we extract the stored data as its needed. That's what we'll do in the <code>update_internal_data()</code> method. As the material is rate-independent, we can ignore the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C) &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Since we reuse the <code>ad_helper</code> data structure at each time step, we need to clear it of all stale information before use.</p>
<div class="fragment"><div class="line">ad_helper.reset();</div></div><!-- fragment --><p>The next step is to set the values for all field components. These define the "point" around which we'll be computing the function gradients and their linearization. The extractors that we created before provide the association between the fields and the registry within the <code>ad_helper</code> &ndash; they'll be used repeatedly to ensure that we have the correct interpretation of which variable corresponds to which component of <code>H</code> or <code>C</code>.</p>
<div class="fragment"><div class="line">ad_helper.register_independent_variable(H, H_components);</div><div class="line">ad_helper.register_independent_variable(C, C_components);</div></div><!-- fragment --><p>Now that we've done the initial setup, we can retrieve the AD counterparts of our fields. These are truly the independent variables for the energy function, and are "sensitive" to the calculations that are performed with them. Notice that the AD number are treated as a special number type, and can be used in many templated classes (in this example, as the scalar type for the <a class="el" href="classTensor.html">Tensor</a> and <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, ADNumberType&gt;</a> H_ad =</div><div class="line">  ad_helper.get_sensitive_variables(H_components);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_ad =</div><div class="line">  ad_helper.get_sensitive_variables(C_components);</div></div><!-- fragment --><p>We can also use them in many functions that are templated on the scalar type. So, for these intermediate values that we require, we can perform tensor operations and some mathematical functions. The resulting type will also be an automatically differentiable number, which encodes the operations performed in these functions.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType det_F_ad = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C_ad));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_inv_ad = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C_ad);</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F_ad &gt; ADNumberType(0.0),</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>Next we'll compute the scaling function that will cause the shear modulus to change (increase) under the influence of a magnetic field...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType f_mu_e_ad =</div><div class="line">  1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_ad * H_ad) /</div><div class="line">                    (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()));</div></div><!-- fragment --><p>... and then we can define the material stored energy density function. We'll see later that this example is sufficiently complex to warrant the use of AD to, at the very least, verify an unassisted implementation.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType psi_ad =</div><div class="line">  0.5 * this-&gt;get_mu_e() * f_mu_e_ad *</div><div class="line">    (<a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C_ad) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad))                 </div><div class="line">  + this-&gt;get_lambda_e() * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) </div><div class="line">  - 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F_ad *</div><div class="line">      (H_ad * C_inv_ad * H_ad); </div></div><!-- fragment --><p>The stored energy density function is, in fact, the dependent variable for this problem, so as a final step in the "configuration" phase, we register its definition with the <code>ad_helper</code>.</p>
<div class="fragment"><div class="line">ad_helper.register_dependent_variable(psi_ad);</div></div><!-- fragment --><p>Finally, we can retrieve the resulting value of the stored energy density function, as well as its gradient and Hessian with respect to the input fields, and cache them.</p>
<div class="fragment"><div class="line">  psi = ad_helper.compute_value();</div><div class="line">  ad_helper.compute_gradient(Dpsi);</div><div class="line">  ad_helper.compute_hessian(D2psi);</div><div class="line">}</div></div><!-- fragment --><p>The following few functions then allow for querying the so-stored value of \(\psi_{0}\), and to extract the desired components of the gradient vector and Hessian matrix. We again make use of the extractors to express which parts of the total gradient vector and Hessian matrix we wish to retrieve. They only return the derivatives of the energy function, so for our definitions of the kinetic variables and their linearization a few more manipulations are required to form the desired result.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> psi;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dpsi_dH =</div><div class="line">    ad_helper.extract_gradient_component(Dpsi, H_components);</div><div class="line">  <span class="keywordflow">return</span> -dpsi_dH;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dpsi_dC =</div><div class="line">    ad_helper.extract_gradient_component(Dpsi, C_components);</div><div class="line">  <span class="keywordflow">return</span> 2.0 * dpsi_dC;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> dpsi_dH_dH =</div><div class="line">    ad_helper.extract_hessian_component(D2psi, H_components, H_components);</div><div class="line">  <span class="keywordflow">return</span> -<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(dpsi_dH_dH);</div><div class="line">}</div></div><!-- fragment --><p>Note that for coupled terms the order of the extractor arguments is especially important, as it dictates the order in which the directional derivatives are taken. So, if we'd reversed the order of the extractors in the call to <code>extract_hessian_component()</code> then we'd actually have been retrieving part of \(\left[ \mathfrak{P}^{\text{tot}} \right]^{T}\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> dpsi_dC_dH =</div><div class="line">    ad_helper.extract_hessian_component(D2psi, C_components, H_components);</div><div class="line">  <span class="keywordflow">return</span> -2.0 * dpsi_dC_dH;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dpsi_dC_dC =</div><div class="line">    ad_helper.extract_hessian_component(D2psi, C_components, C_components);</div><div class="line">  <span class="keywordflow">return</span> 4.0 * dpsi_dC_dC;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Magnetoviscoelasticconstitutivelawusingsymbolicalgebraanddifferentiation"></a> </p><h4>Magneto-viscoelastic constitutive law (using symbolic algebra and differentiation)</h4>
<p>The second material law that we'll consider will be one that represents a magneto-viscoelastic material with a single dissipative mechanism. We'll consider the free energy density function for such a material to be defined as </p><p class="formulaDsp">
\begin{align*} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \\ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \\ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \end{align*}
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right), \]
</p>
<p> in conjunction with the evolution law for the internal viscous variable </p><p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p> that was discretized using a first-order backward difference approximation.</p>
<p>Again, let us see how this is implemented in a concrete class. Instead of the AD framework used in the previous class, we will now utilize the SD approach. To support this, the class constructor accepts not only the <code>constitutive_parameters</code>, but also two additional variables that will be used to initialize a <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a>. We'll give more context to this later.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law_SD final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags);</div></div><!-- fragment --><p>Like for the automatic differentiation helper, the <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> will return a collection of results all at once. So, in order to do that just once, we'll utilize a similar approach to before and do all of the expensive calculations within the <code>update_internal_data()</code> function, and cache the results for layer extraction.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>Since we're dealing with a rate dependent material, we'll have to update the history variable at the appropriate time. That will be the purpose of this function.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div></div><!-- fragment --><p>In the <code>private</code> part of the class, we will want to keep track of the internal viscous deformation, so the following two (real-valued, non-symbolic) member variables respectively hold</p><ul>
<li>the value of internal variable time step (and, if embedded within a nonlinear solver framework, Newton step), and</li>
<li>the value of internal variable at the previous timestep.</li>
</ul>
<p>(We've labeled these variables "Q" so that they're easy to identify; in a sea of calculations it is not necessarily easy to distinguish <code>Cv</code> or <code>C_v</code> from <code>C</code>.)</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div></div><!-- fragment --><p>As we'll be using symbolic types, we'll need to define some symbolic variables to use with the framework. (They are all suffixed with "SD" to make it easy to distinguish the symbolic types or expressions from real-valued types or scalars.) This can be done once up front (potentially even as <code>static</code> variables) to minimize the overhead associated with creating these variables. For the ultimate in generic programming, we can even describe the constitutive parameters symbolically, <em>potentially</em> allowing a single class instance to be reused with different inputs for these values too.</p>
<p>These are the symbolic scalars that represent the elastic, viscous, and magnetic material parameters (defined mostly in the same order as they appear in the <code>ConstitutiveParameters</code> class). We also store a symbolic expression, <code>delta_t_sd</code>, that represents the time step size):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_inf_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_h_sat_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> lambda_e_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_inf_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_h_sat_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> tau_v_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> delta_t_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_r_sd;</div></div><!-- fragment --><p>Next we define some tensorial symbolic variables that represent the independent field variables, upon which the energy density function is parameterized:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          H_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_sd;</div></div><!-- fragment --><p>And similarly we have the symbolic representation of the internal viscous variables (both its current value and its value at the previous timestep):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t1_sd;</div></div><!-- fragment --><p>We should also store the definitions of the dependent expressions: Although we'll only compute them once, we require them to retrieve data from the <code>optimizer</code> that is declared below. Furthermore, when serializing a material class like this one (not done as a part of this tutorial) we'd either need to serialize these expressions as well or we'd need to reconstruct them upon reloading.</p>
<div class="fragment"><div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>                          psi_sd;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          B_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> S_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> BB_sd;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim, Differentiation::SD::Expression&gt;</a>          PP_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim, Differentiation::SD::Expression&gt;</a> HH_sd;</div></div><!-- fragment --><p>The next variable is then the optimizer that is used to evaluate the dependent functions. More specifically, it provides the possibility to accelerate the evaluation of the symbolic dependent expressions. This is a vital tool, because the native evaluation of lengthy expressions (using no method of acceleration, but rather direct evaluation directly of the symbolic expressions) can be very slow. The <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> class provides a mechanism by which to transform the symbolic expression tree into another code path that, for example, shares intermediate results between the various dependent expressions (meaning that these intermediate values only get calculated once per evaluation) and/or compiling the code using a just-in-time compiler (thereby retrieving near-native performance for the evaluation step).</p>
<p>Performing this code transformation is very computationally expensive, so we store the optimizer so that it is done just once per class instance. This also further motivates the decision to make the constitutive parameters themselves symbolic. We could then reuse a single instance of this <code>optimizer</code> across several materials (with the same energy function, of course) and potentially multiple continuum points (if embedded within a finite element simulation).</p>
<p>As specified by the template parameter, the numerical result will be of type <code>double</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer&lt;double&gt;</a> optimizer;</div></div><!-- fragment --><p>During the evaluation phase, we must map the symbolic variables to their real-valued counterparts. The next method will provide this functionality.</p>
<p>The final method of this class will configure the <code>optimizer</code>.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> initialize_optimizer();</div><div class="line">};</div></div><!-- fragment --><p>As the resting deformation state is one at which the material is considered to be completely relaxed, the internal viscous variables are initialized with the identity tensor, i.e. \(\mathbf{C}_{v} = \mathbf{I}\). The various symbolic variables representing the constitutive parameters, time step size, and field and internal variables all get a unique identifier. The optimizer is passed the two parameters that declare which optimization (acceleration) technique should be applied, as well as which additional steps should be taken by the CAS to help improve performance during evaluation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::</div><div class="line">  Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , mu_e_sd(<span class="stringliteral">&quot;mu_e&quot;</span>)</div><div class="line">  , mu_e_inf_sd(<span class="stringliteral">&quot;mu_e_inf&quot;</span>)</div><div class="line">  , mu_e_h_sat_sd(<span class="stringliteral">&quot;mu_e_h_sat&quot;</span>)</div><div class="line">  , lambda_e_sd(<span class="stringliteral">&quot;lambda_e&quot;</span>)</div><div class="line">  , mu_v_sd(<span class="stringliteral">&quot;mu_v&quot;</span>)</div><div class="line">  , mu_v_inf_sd(<span class="stringliteral">&quot;mu_v_inf&quot;</span>)</div><div class="line">  , mu_v_h_sat_sd(<span class="stringliteral">&quot;mu_v_h_sat&quot;</span>)</div><div class="line">  , tau_v_sd(<span class="stringliteral">&quot;tau_v&quot;</span>)</div><div class="line">  , delta_t_sd(<span class="stringliteral">&quot;delta_t&quot;</span>)</div><div class="line">  , mu_r_sd(<span class="stringliteral">&quot;mu_r&quot;</span>)</div><div class="line">  , H_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#acf16bdf4d5a0b48dd84496e379742426">make_vector_of_symbols</a>&lt;dim&gt;(<span class="stringliteral">&quot;H&quot;</span>))</div><div class="line">  , C_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;C&quot;</span>))</div><div class="line">  , Q_t_sd(</div><div class="line">      <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t&quot;</span>))</div><div class="line">  , Q_t1_sd(</div><div class="line">      <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t1&quot;</span>))</div><div class="line">  , optimizer(optimizer_type, optimization_flags)</div><div class="line">{</div><div class="line">  initialize_optimizer();</div><div class="line">}</div></div><!-- fragment --><p>The substitution map simply pairs all of the following data together:</p><ul>
<li>the constitutive parameters (with values retrieved from the base class),</li>
<li>the time step size (with its value retrieved from the time discretizer),</li>
<li>the field values (with their values being prescribed by an external function that is calling into this <code>Magnetoviscoelastic_Constitutive_Law_SD</code> instance), and</li>
<li>the current and previous internal viscous deformation (with their values stored within this class instance).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::make_substitution_map</a>(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::make_pair(mu_e_sd, this-&gt;get_mu_e()),</div><div class="line">    std::make_pair(mu_e_inf_sd, this-&gt;get_mu_e_inf()),</div><div class="line">    std::make_pair(mu_e_h_sat_sd, this-&gt;get_mu_e_h_sat()),</div><div class="line">    std::make_pair(lambda_e_sd, this-&gt;get_lambda_e()),</div><div class="line">    std::make_pair(mu_v_sd, this-&gt;get_mu_v()),</div><div class="line">    std::make_pair(mu_v_inf_sd, this-&gt;get_mu_v_inf()),</div><div class="line">    std::make_pair(mu_v_h_sat_sd, this-&gt;get_mu_v_h_sat()),</div><div class="line">    std::make_pair(tau_v_sd, this-&gt;get_tau_v()),</div><div class="line">    std::make_pair(delta_t_sd, delta_t),</div><div class="line">    std::make_pair(mu_r_sd, this-&gt;get_mu_r()),</div><div class="line">    std::make_pair(H_sd, H),</div><div class="line">    std::make_pair(C_sd, C),</div><div class="line">    std::make_pair(Q_t_sd, Q_t),</div><div class="line">    std::make_pair(Q_t1_sd, Q_t1));</div><div class="line">}</div></div><!-- fragment --><p>Due to the "natural" use of the symbolic expressions, much of the procedure to configure the <code>optimizer</code> looks very similar to that which is used to construct the automatic differentiation helper. Nevertheless, we'll detail these steps again to highlight the differences that underlie the two frameworks.</p>
<p>The function starts with expressions that symbolically encode the determinant of the deformation gradient (as expressed in terms of the right Cauchy-Green deformation tensor, our primary field variable), as well as the inverse of \(\mathbf{C}\) itself:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::initialize_optimizer()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> det_F_sd =</div><div class="line">    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C_sd));</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_inv_sd =</div><div class="line">    <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C_sd);</div></div><!-- fragment --><p>Next is the symbolic representation of the saturation function for the elastic part of the free energy density function, followed by the magnetoelastic contribution to the free energy density function. This all has the same structure as we'd seen previously.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_e_sd =</div><div class="line">  1.0 +</div><div class="line">  (mu_e_inf_sd / mu_e_sd - 1.0) *</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_ME_sd =</div><div class="line">  0.5 * mu_e_sd * f_mu_e_sd *</div><div class="line">    (<a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C_sd) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd)) +</div><div class="line">  lambda_e_sd * std::log(det_F_sd) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd) -</div><div class="line">  0.5 * this-&gt;get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);</div></div><!-- fragment --><p>In addition, we define the magneto-viscoelastic contribution to the free energy density function. The first component required to implement this is a scaling function that will cause the viscous shear modulus to change (increase) under the influence of a magnetic field (see <b>[Pelteret2018a]</b>, equation 29). Thereafter we can compute the dissipative component of the energy density function; its expression is stated in <b>[Pelteret2018a]</b> (equation 28), which is a straight-forward extension of an energy density function formulated in <b>[Linder2011a]</b> (equation 46).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_v_sd =</div><div class="line">  1.0 +</div><div class="line">  (mu_v_inf_sd / mu_v_sd - 1.0) *</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_MVE_sd =</div><div class="line">  0.5 * mu_v_sd * f_mu_v_sd *</div><div class="line">  (Q_t_sd * (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, -2.0 / dim) * C_sd) - dim -</div><div class="line">   std::log(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t_sd)));</div></div><!-- fragment --><p>From these building blocks, we can then define the material's total free energy density function:</p>
<div class="fragment"><div class="line">psi_sd = psi_ME_sd + psi_MVE_sd;</div></div><!-- fragment --><p>As it stands, to the CAS the variable <code>Q_t_sd</code> appears to be independent of <code>C_sd</code>. Our tensorial symbolic expression <code>Q_t_sd</code> just has an identifier associated with it, and there is nothing that links it to the other tensorial symbolic expression <code>C_sd</code>. So any derivatives taken with respect to <code>C_sd</code> will ignore this inherent dependence which, as we can see from the evolution law, is in fact \(\mathbf{C}_{v} = \mathbf{C}_{v} \left( \mathbf{C}, t \right)\). This means that deriving any function \(f = f(\mathbf{C}, \mathbf{Q})\) with respect to \(\mathbf{C}\) will return partial derivatives \(\frac{\partial f(\mathbf{C}, \mathbf{Q})}{\partial \mathbf{C}} \Big\vert_{\mathbf{Q}}\) as opposed to the total derivative \(\frac{d f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{d \mathbf{C}} = \frac{\partial f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{\partial \mathbf{C}} \Big\vert_{\mathbf{Q}} + \frac{\partial f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{\partial \mathbf{Q}} \Big\vert_{\mathbf{C}} : \frac{d \mathbf{Q}(\mathbf{C}))}{d \mathbf{C}}\).</p>
<p>By contrast, with the current AD libraries the total derivative would always be returned. This implies that the computed kinetic variables would be incorrect for this class of material model, making AD the incorrect tool from which to derive (at the continuum point level) the constitutive law for this dissipative material from an energy density function.</p>
<p>It is this specific level of control that characterizes a defining difference difference between the SD and AD frameworks. In a few lines we'll be manipulating the expression for the internal variable <code>Q_t_sd</code> such that it produces the correct linearization.</p>
<p>But, first, we'll compute the symbolic expressions for the kinetic variables, i.e., the magnetic induction vector and the Piola-Kirchhoff stress tensor. The code that performs the differentiation quite closely mimics the definition stated in the theory.</p>
<div class="fragment"><div class="line">B_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, H_sd);</div><div class="line">S_sd = 2.0 * <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, C_sd);</div></div><!-- fragment --><p>Since the next step is to linearize the above, it is the appropriate time to inform the CAS of the explicit dependency of <code>Q_t_sd</code> on <code>C_sd</code>, i.e., state that \(\mathbf{C}_{v} = \mathbf{C}_{v} \left( \mathbf{C}, t \right)\). This means that all future differential operations made with respect to <code>C_sd</code> will take into account this dependence (i.e., compute total derivatives). In other words, we will transform some expression such that their intrinsic parameterization changes from \(f(\mathbf{C}, \mathbf{Q})\) to \(f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))\).</p>
<p>To do this, we consider the time-discrete evolution law. From that, we have the explicit expression for the internal variable in terms of its history as well as the primary field variable. That is what it described in this expression:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a></div><div class="line">  Q_t_sd_explicit =</div><div class="line">    (1.0 / (1.0 + delta_t_sd / tau_v_sd)) *</div><div class="line">    (Q_t1_sd +</div><div class="line">     (delta_t_sd / tau_v_sd * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, 2.0 / dim) * C_inv_sd));</div></div><!-- fragment --><p>Next we produce an intermediate substitution map, which will take every instance of <code>Q_t_sd</code> (our identifier) found in an expression and replace it with the full expression held in <code>Q_t_sd_explicit</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">  substitution_map_explicit = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::make_pair(Q_t_sd, Q_t_sd_explicit));</div></div><!-- fragment --><p>We can the perform this substitution on the two kinetic variables and immediately differentiate the result that appears after that substitution with the field variables. (If you'd like, this could be split up into two steps with the intermediate results stored in a temporary variable.) Again, if you overlook the "complexity" generated by the substitution, these calls that linearize the kinetic variables and produce the three tangent tensors quite closely resembles what's stated in the theory.</p>
<div class="fragment"><div class="line">BB_sd = <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(B_sd, substitution_map_explicit),</div><div class="line">  H_sd));</div><div class="line">PP_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit), H_sd);</div><div class="line">HH_sd =</div><div class="line">  2.0 *</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit),</div><div class="line">    C_sd);</div></div><!-- fragment --><p>Now we need to tell the <code>optimizer</code> what entries we need to provide numerical values for in order for it to successfully perform its calculations. These essentially act as the input arguments to all dependent functions that the <code>optimizer</code> must evaluate. They are, collectively, the independent variables for the problem, the history variables, the time step sie and the constitutive parameters (since we've not hard encoded them in the energy density function).</p>
<p>So what we really want is to provide it a collection of symbols, which one could accomplish in this way: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">optimizer.register_symbols(<a class="code" href="namespaceDifferentiation_1_1SD.html#a8349584858c74f233cc2ca0151eecfad">Differentiation::SD::make_symbol_map</a>(</div><div class="line">  mu_e_sd, mu_e_inf_sd, mu_e_h_sat_sd, lambda_e_sd,</div><div class="line">  mu_v_sd, mu_v_inf_sd, mu_v_h_sat_sd, tau_v_sd,</div><div class="line">  delta_t_sd, mu_r_sd,</div><div class="line">  H_sd, C_sd,</div><div class="line">  Q_t_sd, Q_t1_sd));</div></div><!-- fragment --> </div><p> But this is all actually already encoded as the keys of the substitution map. Doing the above would also mean that we need to manage the symbols in two places (here and when constructing the substitution map), which is annoying and a potential source of error if this material class is modified or extended. Since we're not interested in the values at this point, it is alright if the substitution map is filled with invalid data for the values associated with each key entry. So we'll simply create a fake substitution map, and extract the symbols from that. Note that any substitution map passed to the <code>optimizer</code> will have to, at the very least, contain entries for these symbols.</p>
<div class="fragment"><div class="line">optimizer.register_symbols(</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD_1_1Utilities.html#a373adeda1cf11d824bb41a679d061a3d">Differentiation::SD::Utilities::extract_symbols</a>(</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>({}, {}, 0)));</div></div><!-- fragment --><p>We then inform the optimizer of what values we want calculated, which in our situation encompasses all of the dependent variables (namely the energy density function and its various derivatives).</p>
<div class="fragment"><div class="line">optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);</div></div><!-- fragment --><p>The last step is to finalize the optimizer. With this call it will determine an equivalent code path that will evaluate all of the dependent functions at once, but with less computational cost than when evaluating the symbolic expression directly. Note: This is an expensive call, so we want execute it as few times as possible. We've done it in the constructor of our class, which achieves the goal of being called only once per class instance.</p>
<div class="fragment"><div class="line">  optimizer.optimize();</div><div class="line">}</div></div><!-- fragment --><p>Since the configuration of the <code>optimizer</code> was done up front, there's very little to do each time we want to compute kinetic variables or their linearization (derivatives).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">{</div></div><!-- fragment --><p>To update the internal history variable, we first need to compute a few fundamental quantities, which we've seen before. We can also ask the time discretizer for the time step size that was used to iterate from the previous time step to the current one.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C);</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>Now we can update the (real valued) internal viscous deformation tensor, as per the definition given by the evolution law in conjunction with the chosen time discretization scheme.</p>
<div class="fragment"><div class="line">Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">      (Q_t1 + (delta_t / this-&gt;get_tau_v()) * std::pow(det_F, 2.0 / dim) *</div><div class="line">                C_inv);</div></div><!-- fragment --><p>Next we pass the optimizer the numeric values that we wish the independent variables, time step size and (implicit to this call), the constitutive parameters to represent.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> substitution_map = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(C, H, delta_t);</div></div><!-- fragment --><p>When making this next call, the call path used to (numerically) evaluate the dependent functions is quicker than dictionary substitution.</p>
<div class="fragment"><div class="line">  optimizer.substitute(substitution_map);</div><div class="line">}</div></div><!-- fragment --><p>Having called <code>update_internal_data()</code>, it is then valid to extract data from the optimizer. When doing the evaluation, we need the exact symbolic expressions of the data to extracted from the optimizer. The implication of this is that we needed to store the symbolic expressions of all dependent variables for the lifetime of the optimizer (naturally, the same is implied for the input variables).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(psi_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(B_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(S_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(BB_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(PP_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(HH_sd);</div><div class="line">}</div></div><!-- fragment --><p>When moving forward in time, the "current" state of the internal variable instantaneously defines the state at the "previous" timestep. As such, we record value of history variable for use as the "past value" at the next time step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_end_of_timestep()</div><div class="line">{</div><div class="line">  Q_t1 = Q_t;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AmorecomplexexamplecontinuedParametersandhandderivedmaterialclasses"></a> </p><h3>A more complex example (continued): Parameters and hand-derived material classes</h3>
<p>Now that we've seen how the AD and SD frameworks can make light(er) work of defining these constitutive laws, we'll implement the equivalent classes by hand for the purpose of verification and to do some preliminary benchmarking of the frameworks versus a native implementation.</p>
<p>At the expense of the author's sanity, what is documented below (hopefully accurately) are the full definitions for the kinetic variables and their tangents, as well as some intermediate computations. Since the structure and design of the constitutive law classes has been outlined earlier, we'll gloss over it and simply delineate between the various stages of calculations in the <code>update_internal_data()</code> method definition. It should be easy enough to link the derivative calculations (with their moderately expressive variable names) to their documented definitions that appear in the class descriptions. We will, however, take the opportunity to present two different paradigms for implementing constitutive law classes. The second will provide more flexibility than the first (thereby making it more easily extensible, in the author's opinion) at the expense of some performance.</p>
<p><a class="anchor" id="Magnetoelasticconstitutivelawhandderived"></a> </p><h4>Magnetoelastic constitutive law (hand-derived)</h4>
<p>From the stored energy that, as mentioned earlier, is defined as </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) , \\ \text{det}(\mathbf{F}) = \sqrt{\text{det}(\mathbf{C})} \]
</p>
<p> for this magnetoelastic material, the first derivatives that correspond to the magnetic induction vector and total Piola-Kirchhoff stress tensor are </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{d \psi_{0}}{d \boldsymbol{\mathbb{H}}} = - \frac{1}{2} \mu_{e} \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] \frac{d f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\begin{align} \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} &amp;= \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} - 2 \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \right] + 4 \lambda_{e} \ln \left(\text{det}(\mathbf{F}) \right) \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} - \mu_{0} \mu_{r} \left[ \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} + \text{det}(\mathbf{F}) \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} \right] \\ &amp;= \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{I} - \mathbf{C}^{-1} \right] + 2 \lambda_{e} \ln \left(\text{det}(\mathbf{F}) \right) \mathbf{C}^{-1} - \mu_{0} \mu_{r} \left[ \frac{1}{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \mathbf{C}^{-1} - \text{det}(\mathbf{F}) \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{d f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} = \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \text{sech}^{2} \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \left[ \frac{4} {\left(h_{e}^{\text{sat}}\right)^{2}} \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} = \mathbf{I} \quad \text{(the second-order identity tensor)} \]
</p>
 <p class="formulaDsp">
\[ \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} = \frac{1}{2} \text{det}(\mathbf{F}) \mathbf{C}^{-1} \]
</p>
 <p class="formulaDsp">
\[ \frac{d C^{-1}_{ab}}{d C_{cd}} = - \text{sym} \left( C^{-1}_{ac} C^{-1}_{bd} \right) = -\frac{1}{2} \left[ C^{-1}_{ac} C^{-1}_{bd} + C^{-1}_{ad} C^{-1}_{bc} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} = - \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> The use of the symmetry operator \(\text{sym} \left( \bullet \right)\) in the one derivation above helps to ensure that the resulting rank-4 tensor, which holds minor symmetries due to the symmetry of \(\mathbf{C}\), still maps rank-2 symmetric tensors to rank-2 symmetric tensors. See the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class documentation and the introduction to <a class="el" href="step_44.html">step-44</a> and for further explanation as to what symmetry means in the context of fourth-order tensors.</p>
<p>The linearization of each of the kinematic variables with respect to their arguments are </p><p class="formulaDsp">
\[ \mathbb{D} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} = - \frac{1}{2} \mu_{e} \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] \frac{d^{2} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \mathbf{C}^{-1} \]
</p>
 <p class="formulaDsp">
\begin{align} \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} &amp;= - \mu_{e} \left[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} - 2 \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \right] \otimes \frac{d f_{\mu_{e} \left( \boldsymbol{\mathbb{H}} \right)}}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \left[ \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \otimes \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \boldsymbol{\mathbb{H}}} \right] + \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} \\ &amp;= - \mu_{e} \left[ \mathbf{I} - \mathbf{C}^{-1} \right] \otimes \frac{d f_{\mu_{e} \left( \boldsymbol{\mathbb{H}} \right)}}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \left[ \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] + \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C} \otimes \mathbf{C} \boldsymbol{\mathbb{H}}} \end{align}
</p>
 <p class="formulaDsp">
\begin{align} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} &amp;= 2 \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] + 4 \lambda_{e} \left[ \mathbf{C}^{-1} \otimes \left[ \frac{1}{\text{det}(\mathbf{F})} \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} \right] + \ln \left(\text{det}(\mathbf{F}) \right) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;- \mu_{0} \mu_{r} \left[ \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \mathbf{C}^{-1} \otimes \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{0} \mu_{r} \left[ \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \otimes \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} - \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} \right] \\ &amp;= 2 \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] + 4 \lambda_{e} \left[ \frac{1}{2} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \ln \left(\text{det}(\mathbf{F}) \right) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;- \mu_{0} \mu_{r} \left[ - \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] + \frac{1}{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{0} \mu_{r} \left[ \frac{1}{2} \text{det}(\mathbf{F}) \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \otimes \mathbf{C}^{-1} - \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{d^{2} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} = -2 \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \text{sech}^{2} \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \left[ \frac{4} {\left(h_{e}^{\text{sat}}\right)^{2}} \mathbf{I} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \boldsymbol{\mathbb{H}}} = 2 \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \]
</p>
 <p class="formulaDsp">
\[ \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} \Rightarrow \frac{d^{2} \left[ \mathbb{H}_{e} C^{-1}_{ef} \mathbb{H}_{f} \right]}{d C_{ab} d \mathbb{H}_{c}} = - C^{-1}_{ac} C^{-1}_{be} \mathbb{H}_{e} - C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{bc} \]
</p>
 <p class="formulaDsp">
\begin{align} \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} &amp;= -\frac{d \left[\left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]\right]}{d \mathbf{C}} \\ \Rightarrow \frac{d^{2} \left[ \mathbb{H}_{e} C^{-1}_{ef} \mathbb{H}_{f} \right]}{d C_{ab} d C_{cd}} &amp;= \text{sym} \left( C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{cf} \mathbb{H}_{f} C^{-1}_{bd} + C^{-1}_{ce} \mathbb{H}_{e} C^{-1}_{bf} \mathbb{H}_{f} C^{-1}_{ad} \right) \\ &amp;= \frac{1}{2} \left[ C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{cf} \mathbb{H}_{f} C^{-1}_{bd} + C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{df} \mathbb{H}_{f} C^{-1}_{bc} + C^{-1}_{ce} \mathbb{H}_{e} C^{-1}_{bf} \mathbb{H}_{f} C^{-1}_{ad} + C^{-1}_{be} \mathbb{H}_{e} C^{-1}_{df} \mathbb{H}_{f} C^{-1}_{ac} \right] \end{align}
</p>
<p>Well, that escalated quickly &ndash; although the the definition of \(\psi_{0}\) and \(f_{\mu_e}\) might have given some hints that the calculating the kinetic fields and their linearization would take some effort, it is likely that there's a little more complexity to the final definitions that perhaps initially thought. Knowing what we now do, it's probably fair to say that we really do not want to compute first and second derivatives of these functions with respect to their arguments &ndash; regardless of well we did in calculus classes, or how good a programmer we may be.</p>
<p>In the class method definition where these are ultimately implemented, we've composed these calculations slightly differently. Some intermediate steps are also retained to give another perspective of how to systematically compute the derivatives. Additionally, some calculations are decomposed less or further to reuse some of the intermediate values and, hopefully, aid the reader to follow the derivative operations.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoelastic_Constitutive_Law final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoelastic_Constitutive_Law(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span>                  psi;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoelastic_Constitutive_Law&lt;dim&gt;::Magnetoelastic_Constitutive_Law(</div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , psi(0.0)</div><div class="line">{}</div></div><!-- fragment --><p>For this class's update method, we'll simply precompute a collection of intermediate values (for function evaluations, derivative calculations, and the like) and "manually" arrange them in the order that's required to maximize their reuse. This means that we have to manage this ourselves, and decide what values must be compute before others, all while keeping some semblance of order or structure in the code itself. It's effective, but perhaps a little tedious. It also doesn't do too much to help future extension of the class, because all of these values remain local to this single method.</p>
<p>Interestingly, this basic technique of precomputing intermediate expressions that are used in more than one place has a name: <a href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">common subexpression elimination (CSE)</a>. It is a strategy used by Computer Algebra Systems to reduce the computational expense when they are tasked with evaluating similar expressions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C));</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C);</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>The saturation function for the magneto-elastic energy.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> two_h_dot_h_div_h_sat_squ =</div><div class="line">  (2.0 * H * H) / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat());</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(two_h_dot_h_div_h_sat_squ);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e =</div><div class="line">  1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">          tanh_two_h_dot_h_div_h_sat_squ;</div></div><!-- fragment --><p>The first derivative of the saturation function, noting that \(\frac{d \tanh(x)}{dx} = \text{sech}^{2}(x)\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> dtanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(two_h_dot_h_div_h_sat_squ), 2.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dtwo_h_dot_h_div_h_sat_squ_dH =</div><div class="line">  2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) * H;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH =</div><div class="line">  (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">  (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH);</div></div><!-- fragment --><p>The second derivative of saturation function, noting that \(\frac{d \text{sech}^{2}(x)}{dx} = -2 \tanh(x) \text{sech}^{2}(x)\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> d2tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">  -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2two_h_dot_h_div_h_sat_squ_dH_dH =</div><div class="line">  2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) *</div><div class="line">  <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">  (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">  (d2tanh_two_h_dot_h_div_h_sat_squ *</div><div class="line">     <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dtwo_h_dot_h_div_h_sat_squ_dH,</div><div class="line">                              dtwo_h_dot_h_div_h_sat_squ_dH)) +</div><div class="line">   dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);</div></div><!-- fragment --><p>Some intermediate quantities attained directly from the field / kinematic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         log_det_F         = <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         tr_C              = <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H       = C_inv * H;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         H_dot_C_inv_dot_H = H * C_inv_dot_H;</div></div><!-- fragment --><p>First derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d_tr_C_dC =</div><div class="line">  <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> ddet_F_dC     = 0.5 * det_F * C_inv;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dlog_det_F_dC = 0.5 * C_inv;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dC_inv_dC;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = 0; <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>; B &lt; dim; ++B)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">        dC_inv_dC[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][B][C][D] -=               </div><div class="line">          0.5 * (C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][C] * C_inv[B][D]     </div><div class="line">                 + C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][D] * C_inv[B][C]); </div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dH_dot_C_inv_dot_H_dC =</div><div class="line">  -<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H));</div></div><!-- fragment --><p>Second derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2det_F_dC_dC =</div><div class="line">  0.5 * (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv, ddet_F_dC) + det_F * dC_inv_dC);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = 0; <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">      d2H_dot_C_inv_dot_H_dC_dH[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][B][C] -=</div><div class="line">        C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][C] * C_inv_dot_H[B] + </div><div class="line">        C_inv_dot_H[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>] * C_inv[B][C];  </div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = 0; <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>; B &lt; dim; ++B)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">        d2H_dot_C_inv_dot_H_dC_dC[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][B][C][D] +=</div><div class="line">          0.5 * (C_inv_dot_H[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                 C_inv_dot_H[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                 C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][D] +</div><div class="line">                 C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][C]);</div></div><!-- fragment --><p>The stored energy density function.</p>
<div class="fragment"><div class="line">psi =</div><div class="line">  (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">    (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">  this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F)) -</div><div class="line">  (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div></div><!-- fragment --><p>The kinetic quantities.</p>
<div class="fragment"><div class="line">B = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">      df_mu_e_dH </div><div class="line">    + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">        dH_dot_C_inv_dot_H_dH; </div><div class="line"></div><div class="line">S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                        </div><div class="line">      (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              </div><div class="line">    + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) </div><div class="line">    - 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *            </div><div class="line">        (H_dot_C_inv_dot_H * ddet_F_dC                               </div><div class="line">         + det_F * dH_dot_C_inv_dot_H_dC);                           </div></div><!-- fragment --><p>The linearization of the kinetic quantities.</p>
<div class="fragment"><div class="line">  BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * </div><div class="line">         d2f_mu_e_dH_dH                                             </div><div class="line">       + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">           d2H_dot_C_inv_dot_H_dH_dH; </div><div class="line"></div><div class="line">  PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *                                  </div><div class="line">         <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   </div><div class="line">                       df_mu_e_dH)                                        </div><div class="line">       +                                                                  </div><div class="line">       2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">         (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) </div><div class="line">          + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           </div><div class="line"></div><div class="line">  HH =</div><div class="line">    4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">    + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">        (2.0 * <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">         + 2.0 * log_det_F * d2log_det_F_dC_dC)                          </div><div class="line">    - 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">        (H_dot_C_inv_dot_H * d2det_F_dC_dC                               </div><div class="line">         + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               </div><div class="line">         + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               </div><div class="line">         + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> psi;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> B;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> S;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> BB;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> PP;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> HH;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Magnetoviscoelasticconstitutivelawhandderived"></a> </p><h4>Magneto-viscoelastic constitutive law (hand-derived)</h4>
<p>As mentioned before, the free energy density function for the magneto-viscoelastic material with one dissipative mechanism that we'll be considering is defined as </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \]
</p>
 <p class="formulaDsp">
\[ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\[ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p> and the evolution law </p><p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \left( \mathbf{C} \right) = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v} \right] \]
</p>
<p> that itself is parameterized in terms of \(\mathbf{C}\). By design, the magnetoelastic part of the energy \(\psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) is identical to that of the magnetoelastic material presented earlier. So, for the derivatives of the various contributions stemming from this part of the energy, please refer to the previous section. We'll continue to highlight the specific contributions from those terms by superscripting the salient terms with \(ME\), while contributions from the magneto-viscoelastic component are superscripted with \(MVE\). Furthermore, the magnetic saturation function \(f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right)\) for the damping term has the identical form as that of the elastic term (i.e., \(f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right)\) ), and so the structure of its derivatives are identical to that seen before; the only change is for the three constitutive parameters that are now associated with the viscous shear modulus \(\mu_{v}\) rather than the elastic shear modulus \(\mu_{e}\).</p>
<p>For this magneto-viscoelastic material, the first derivatives that correspond to the magnetic induction vector and total Piola-Kirchhoff stress tensor are </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \Big\vert_{\mathbf{C}, \mathbf{C}_{v}} \equiv \boldsymbol{\mathbb{B}}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \boldsymbol{\mathbb{B}}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} - \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \Big\vert_{\mathbf{C}_{v}, \boldsymbol{\mathbb{H}}} \equiv \mathbf{S}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathbf{S}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} + 2 \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \]
</p>
<p> with the viscous contributions being </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \Big\vert_{\mathbf{C}, \mathbf{C}_{v}} = - \frac{1}{2} \mu_{v} \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \frac{\partial f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \Big\vert_{\mathbf{C}_{v}, \boldsymbol{\mathbb{H}}} = \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \right] \]
</p>
<p> and with </p><p class="formulaDsp">
\[ \frac{\partial f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \equiv \frac{d f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} . \]
</p>
<p> The time-discretized evolution law, </p><p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} \left( \mathbf{C} \right) = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p> will also dictate how the linearization of the internal variable with respect to the field variables is composed.</p>
<p>Observe that in order to attain the <em>correct</em> expressions for the magnetic induction vector and total Piola-Kirchhoff stress tensor for this dissipative material, we must adhere strictly to the outcome of applying the Coleman-Noll procedure: we must take <em>partial derivatives</em> of the free energy density function with respect to the field variables. (For our non-dissipative magnetoelastic material, taking either partial or total derivatives would have had the same result, so there was no need to draw your attention to this before.) The crucial part of the operation is to freeze the internal variable \(\mathbf{C}_{v}^{(t)} \left( \mathbf{C} \right)\) while computing the derivatives of \(\psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v} \left( \mathbf{C} \right), \boldsymbol{\mathbb{H}} \right)\) with respect to \(\mathbf{C}\) &ndash; the dependence of \(\mathbf{C}_{v}^{(t)}\) on \(\mathbf{C}\) is not to be taken into account. When deciding whether to use AD or SD to perform this task the choice is clear &ndash; only the symbolic framework provides a mechanism to do this; as was mentioned before, AD can only return total derivatives so it is unsuitable for the task.</p>
<p>To wrap things up, we'll present the material tangents for this rate-dependent coupled material. The linearization of both kinetic variables with respect to their arguments are </p><p class="formulaDsp">
\[ \mathbb{D} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} \equiv \mathbb{D}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathbb{D}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}^{ME}}{d \boldsymbol{\mathbb{H}}} + \frac{d \boldsymbol{\mathbb{B}}^{MVE}}{d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} \equiv \mathfrak{P}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathfrak{P}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}, ME}}{d \boldsymbol{\mathbb{H}}} - \frac{d \mathbf{S}^{\text{tot}, MVE}}{d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} \equiv \mathcal{H}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathcal{H}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}, ME}}{d \mathbf{C}} + 2 \frac{d \mathbf{S}^{\text{tot}, MVE}}{d \mathbf{C}} \]
</p>
<p> where the tangents for the viscous contributions are </p><p class="formulaDsp">
\[ \mathbb{D}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{1}{2} \mu_{v} \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \frac{\partial^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathfrak{P}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \mu_{v} \left[ \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \right] \otimes \frac{d f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\begin{align} \mathcal{H}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] \otimes \left[ \mathbf{C}_{v} + \mathbf{C} : \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ \frac{1}{d^{2}} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ -\frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \otimes \mathbf{C}^{-1} + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{\partial^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \equiv \frac{d^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \]
</p>
<p> and, from the evolution law, </p><p class="formulaDsp">
\[ \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \equiv \frac{d \mathbf{C}_{v}^{(t)}}{d \mathbf{C}} = \frac{\frac{\Delta t}{\tau_{v}} }{1 + \frac{\Delta t}{\tau_{v}}} \left[ \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{\frac{2}{d}} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \left[\text{det}\left(\mathbf{F}\right)\right]^{\frac{2}{d}} \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] . \]
</p>
<p> Notice that just the last term of \(\mathcal{H}^{\text{tot}, MVE}\) contains the tangent of the internal variable. The linearization of this particular evolution law is linear. For an example of a nonlinear evolution law, for which this linearization must be solved for in an iterative manner, see <b>[Koprowski-Theiss2011a]</b>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoviscoelastic_Constitutive_Law(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>                  psi;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div></div><!-- fragment --><p>A data structure that is used to store all intermediate calculations. We'll see shortly precisely how this can be leveraged to make the part of the code where we actually perform calculations clean and easy (well, at least easier) to follow and maintain. But for now, we can say that it will allow us to move the parts of the code where we compute the derivatives of intermediate quantities away from where they are used.</p>
<div class="fragment"><div class="line"><span class="keyword">mutable</span> <a class="code" href="classGeneralDataStorage.html">GeneralDataStorage</a> cache;</div></div><!-- fragment --><p>The next two functions are used to update the state of the field and internal variables, and will be called before we perform any detailed calculations.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_primary_variables(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> update_internal_variable(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time);</div></div><!-- fragment --><p>The remainder of the class interface is dedicated to methods that are used to compute the components required to calculate the free energy density function, and all of its derivatives:</p>
<p>The kinematic, or field, variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C() <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_f_mu(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the first derivative of saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_df_mu_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the second derivative of saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_d2f_mu_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Intermediate quantities attained directly from the field / kinematic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C_inv() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_log_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_trace_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_H_dot_C_inv_dot_H() <span class="keyword">const</span>;</div></div><!-- fragment --><p>First derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_dC_inv_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d_tr_C_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_ddet_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dlog_det_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dC() <span class="keyword">const</span>;</div></div><!-- fragment --><p>Derivative of internal variable with respect to field variables. Notice that we only need this one derivative of the internal variable, as this variable is only differentiated as part of the linearization of the kinetic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">get_dQ_t_dC(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Second derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2log_det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dH_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dC() <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::Magnetoviscoelastic_Constitutive_Law(<span class="keyword">const</span> ConstitutiveParameters</div><div class="line">                                               &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , psi(0.0)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">{</div></div><!-- fragment --><p>Record the applied deformation state as well as the magnetic load. Thereafter, update internal (viscous) variable based on new deformation state.</p>
<div class="fragment"><div class="line">set_primary_variables(C, H);</div><div class="line">update_internal_variable(time);</div></div><!-- fragment --><p>Get the values for the elastic and viscous saturation function based on the current magnetic field...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e = get_f_mu(this-&gt;get_mu_e(),</div><div class="line">                               this-&gt;get_mu_e_inf(),</div><div class="line">                               this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_v = get_f_mu(this-&gt;get_mu_v(),</div><div class="line">                               this-&gt;get_mu_v_inf(),</div><div class="line">                               this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>... as well as their first derivatives...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH = get_df_mu_dH(this-&gt;get_mu_e(),</div><div class="line">                                               this-&gt;get_mu_e_inf(),</div><div class="line">                                               this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_v_dH = get_df_mu_dH(this-&gt;get_mu_v(),</div><div class="line">                                               this-&gt;get_mu_v_inf(),</div><div class="line">                                               this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>... and their second derivatives.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">  get_d2f_mu_dH_dH(this-&gt;get_mu_e(),</div><div class="line">                   this-&gt;get_mu_e_inf(),</div><div class="line">                   this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_v_dH_dH =</div><div class="line">  get_d2f_mu_dH_dH(this-&gt;get_mu_v(),</div><div class="line">                   this-&gt;get_mu_v_inf(),</div><div class="line">                   this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>Intermediate quantities. Note that, since we're fetching these values from a cache that has a lifetime that outlasts this function call, we can alias the result rather than copying the value from the cache.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;                 det_F = get_det_F();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;log_det_F         = get_log_det_F();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;tr_C              = get_trace_C();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();</div></div><!-- fragment --><p>First derivatives of intermediate values, as well as the that of the internal variable with respect to the right Cauchy-Green deformation tensor.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d_tr_C_dC     = get_d_tr_C_dC();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;ddet_F_dC     = get_ddet_F_dC();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dlog_det_F_dC = get_dlog_det_F_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;dQ_t_dC = get_dQ_t_dC(time);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dC =</div><div class="line">  get_dH_dot_C_inv_dot_H_dC();</div></div><!-- fragment --><p>Second derivatives of intermediate values.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2log_det_F_dC_dC =</div><div class="line">  get_d2log_det_F_dC_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2det_F_dC_dC = get_d2det_F_dC_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dH_dH =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dH_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dH =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dC_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dC =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dC_dC();</div></div><!-- fragment --><p>Since the definitions of the linearizations become particularly lengthy, we'll decompose the free energy density function into three additive components:</p><ul>
<li>the "Neo-Hookean"-like term,</li>
<li>the rate-dependent term, and</li>
<li>the term that resembles that of the energy stored in the magnetic field.</li>
</ul>
<p>To remain consistent, each of these contributions will be individually added to the variables that we want to compute in that same order.</p>
<p>So, first of all this is the energy density function itself:</p>
<div class="fragment"><div class="line">psi = (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">        (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">      this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F));</div><div class="line">psi += (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">       (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t)));</div><div class="line">psi -=</div><div class="line">  (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div></div><!-- fragment --><p>... followed by the magnetic induction vector and Piola-Kirchhoff stress:</p>
<div class="fragment"><div class="line">B =</div><div class="line">  -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;</div><div class="line">B -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">     (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">      <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t))) *</div><div class="line">     df_mu_v_dH;</div><div class="line">B += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">     dH_dot_C_inv_dot_H_dH;</div><div class="line"></div><div class="line">S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                         </div><div class="line">      (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               </div><div class="line">    + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); </div><div class="line">S += 2.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">     ((Q_t * C) *</div><div class="line">        ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) +</div><div class="line">      std::pow(det_F, -2.0 / dim) * Q_t);                <span class="comment">// dC/dC = II</span></div><div class="line">S -= 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">     (H_dot_C_inv_dot_H * ddet_F_dC                      </div><div class="line">      + det_F * dH_dot_C_inv_dot_H_dC);                  </div></div><!-- fragment --><p>... and lastly the tangents due to the linearization of the kinetic variables.</p>
<div class="fragment"><div class="line">BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">     d2f_mu_e_dH_dH;</div><div class="line">BB -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">      (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">       <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t))) *</div><div class="line">      d2f_mu_v_dH_dH;</div><div class="line">BB += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">      d2H_dot_C_inv_dot_H_dH_dH;</div><div class="line"></div><div class="line">PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *</div><div class="line">     <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),</div><div class="line">                   df_mu_e_dH);</div><div class="line">PP -= 2.0 * (0.5 * this-&gt;get_mu_v()) *</div><div class="line">      <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>((Q_t * C) *</div><div class="line">                                     ((-2.0 / dim) *</div><div class="line">                                      std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                                      ddet_F_dC) +</div><div class="line">                                   std::pow(det_F, -2.0 / dim) * Q_t),</div><div class="line">                    df_mu_v_dH);</div><div class="line">PP += 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *</div><div class="line">      (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +</div><div class="line">       det_F * d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line"></div><div class="line">HH =</div><div class="line">  4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">  + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">      (2.0 * <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">       + 2.0 * log_det_F * d2log_det_F_dC_dC);                         </div><div class="line">HH += 4.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">      (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                       ddet_F_dC,</div><div class="line">                     C * dQ_t_dC + Q_t) +</div><div class="line">       (Q_t * <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>) *</div><div class="line">         (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC,</div><div class="line">                        (-2.0 / dim) * (-2.0 / dim - 1.0) *</div><div class="line">                          std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +</div><div class="line">          ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">           d2det_F_dC_dC)) +</div><div class="line">       <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Q_t,</div><div class="line">                     (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                       ddet_F_dC) +</div><div class="line">       <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, -2.0 / dim) * dQ_t_dC);</div><div class="line">HH -= 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">      (H_dot_C_inv_dot_H * d2det_F_dC_dC                  </div><div class="line">       + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  </div><div class="line">       + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  </div><div class="line">       + det_F * d2H_dot_C_inv_dot_H_dC_dC);              </div></div><!-- fragment --><p>Now that we're done using all of those temporary variables stored in our cache, we can clear it out to free up some memory.</p>
<div class="fragment"><div class="line">  cache.reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> psi;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> B;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> S;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> BB;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> PP;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> HH;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_end_of_timestep()</div><div class="line">{</div><div class="line">  Q_t1 = Q_t;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_variable(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">  Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">        (Q_t1 + (delta_t / this-&gt;get_tau_v()) *</div><div class="line">                  std::pow(get_det_F(), 2.0 / dim) * get_C_inv());</div><div class="line">}</div></div><!-- fragment --><p>The next few functions implement the generalized formulation for the saturation function, as well as its various derivatives.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_two_h_dot_h_div_h_sat_squ(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;H = get_H();</div><div class="line">  <span class="keywordflow">return</span> (2.0 * H * H) / (mu_h_sat * mu_h_sat);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));</div><div class="line">}</div></div><!-- fragment --><p>A scaling function that will cause the shear modulus to change (increase) under the influence of a magnetic field.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_f_mu(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1.0 +</div><div class="line">         (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">}</div></div><!-- fragment --><p>First derivative of scaling function</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),</div><div class="line">                  2.0);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_df_mu_dH(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">         (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">          get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">         get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *</div><div class="line">         <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2f_mu_dH_dH(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">         (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">            <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(</div><div class="line">              <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),</div><div class="line">                            get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +</div><div class="line">          get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">            get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));</div><div class="line">}</div></div><!-- fragment --><p>For the cached calculation approach that we've adopted for this material class, the root of all calculations are the field variables, and the immutable ancillary data such as the constitutive parameters and time step size. As such, we need to enter them into the cache in a different manner to the other variables, since they are inputs that are prescribed from outside the class itself. This function simply adds them to the cache directly from the input arguments, checking that there is no equivalent data there in the first place (we expect to call the <code>update_internal_data()</code> method only once per time step, or Newton iteration).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::set_primary_variables(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>Set value for \(\boldsymbol{\mathbb{H}}\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string name_H(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_H),</div><div class="line">       <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">         <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">cache.add_unique_copy(name_H, H);</div></div><!-- fragment --><p>Set value for \(\mathbf{C}\).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string name_C(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_C),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">           <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">  cache.add_unique_copy(name_C, C);</div><div class="line">}</div></div><!-- fragment --><p>After that, we can fetch them from the cache at any point in time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div></div><!-- fragment --><p>With the primary variables guaranteed to be in the cache when we need them, we can not compute all intermediate values (either directly, or indirectly) from them.</p>
<p>If the cache does not already store the value that we're looking for, then we quickly calculate it, store it in the cache and return the value just stored in the cache. That way we can return it as a reference and avoid copying the object. The same goes for any values that a compound function might depend on. Said another way, if there is a dependency chain of calculations that come before the one that we're currently interested in doing, then we're guaranteed to resolve the dependencies before we proceed with using any of those values. Although there is a cost to fetching data from the cache, the "resolved dependency" concept might be sufficiently convenient to make it worth looking past the extra cost. If these material laws are embedded within a finite element framework, then the added cost might not even be noticeable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;det_F&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(get_C()));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line">      cache.add_unique_copy(name, det_F);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      cache.add_unique_copy(name, <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(get_C()));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_log_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;log(det_F)&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, std::log(get_det_F()));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_trace_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;trace(C)&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(get_C()));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv_dot_H&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, get_C_inv() * get_H());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H_dot_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H_dot_C_inv_dot_H&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dQ_t_dC(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dQ_t_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>  delta_t = this-&gt;get_delta_t(time);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;det_F   = get_det_F();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dQ_t_dC =</div><div class="line">        (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">        (delta_t / this-&gt;get_tau_v()) *</div><div class="line">        ((2.0 / dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim - 1.0) *</div><div class="line">           <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">         <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim) * get_dC_inv_dC());</div><div class="line"></div><div class="line">      cache.add_unique_copy(name, dQ_t_dC);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dC_inv_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dC_inv_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>        dC_inv_dC;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = 0; <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              dC_inv_dC[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][B][C][D] -=               </div><div class="line">                0.5 * (C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][C] * C_inv[B][D]     </div><div class="line">                       + C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][D] * C_inv[B][C]); </div><div class="line"></div><div class="line">      cache.add_unique_copy(name, dC_inv_dC);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d_tr_C_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d_tr_C_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name,</div><div class="line">                          <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_ddet_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;ddet_F_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dlog_det_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dlog_det_F_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 0.5 * get_C_inv());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dH&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">      cache.add_unique_copy(</div><div class="line">        name, -<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H)));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2log_det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2log_det_F_dC_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2det_F_dC_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name,</div><div class="line">                          0.5 *</div><div class="line">                            (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">                             get_det_F() * get_dC_inv_dC()));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dH_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dH_dH&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 2.0 * get_C_inv());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dH&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = 0; <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            d2H_dot_C_inv_dot_H_dC_dH[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][B][C] -=</div><div class="line">              C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][C] * C_inv_dot_H[B] + </div><div class="line">              C_inv_dot_H[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>] * C_inv[B][C];  </div><div class="line"></div><div class="line">      cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;3, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dC()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> = 0; <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a> &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              d2H_dot_C_inv_dot_H_dC_dC[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][B][C][D] +=</div><div class="line">                0.5 * (C_inv_dot_H[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                       C_inv_dot_H[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][D] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>][C]);</div><div class="line"></div><div class="line">      cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Rheologicalexperimentparameters"></a> </p><h4>Rheological experiment parameters</h4>
<p>The <code>RheologicalExperimentParameters</code> class is used to drive the numerical experiments that are to be conducted on the coupled materials that we've implemented constitutive laws for.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RheologicalExperimentParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RheologicalExperimentParameters();</div></div><!-- fragment --><p>These are dimensions of the rheological specimen that is to be simulated. They, effectively, define the measurement point for our virtual experiment.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sample_radius = 0.01;</div><div class="line"><span class="keywordtype">double</span> sample_height = 0.001;</div></div><!-- fragment --><p>The three steady-state loading parameters are respectively</p><ul>
<li>the axial stretch,</li>
<li>the shear strain amplitude, and</li>
<li>the axial magnetic field strength.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> lambda_2 = 0.95;</div><div class="line"><span class="keywordtype">double</span> gamma_12 = 0.05;</div><div class="line"><span class="keywordtype">double</span> H_2      = 60.0e3;</div></div><!-- fragment --><p>Moreover, the parameters for the time-dependent rheological loading conditions are</p><ul>
<li>the loading cycle frequency,</li>
<li>the number of load cycles, and</li>
<li>the number of discrete timesteps per cycle.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>       frequency         = 1.0 / (2.0 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles          = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps_per_cycle = 2500;</div></div><!-- fragment --><p>We also declare some self-explanatory parameters related to output data generated for the experiments conducted with rate-dependent and rate-independent materials.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span>        output_data_to_file = <span class="keyword">true</span>;</div><div class="line">std::string output_filename_rd =</div><div class="line">  <span class="stringliteral">&quot;experimental_results-rate_dependent.csv&quot;</span>;</div><div class="line">std::string output_filename_ri =</div><div class="line">  <span class="stringliteral">&quot;experimental_results-rate_independent.csv&quot;</span>;</div></div><!-- fragment --><p>The next few functions compute time-related parameters for the experiment...</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> start_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> end_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> delta_t() <span class="keyword">const</span>;</div></div><!-- fragment --><p>... while the following two prescribe the mechanical and magnetic loading at any given time...</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> get_H(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>... and this last one outputs the status of the experiment to the console.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">bool</span> print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">RheologicalExperimentParameters::RheologicalExperimentParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Rheological Experiment/&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_radius);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_height);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Axial stretch&quot;</span>, lambda_2);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Shear strain amplitude&quot;</span>, gamma_12);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Axial magnetic field strength&quot;</span>, H_2);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Frequency&quot;</span>, frequency);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Number of loading cycles&quot;</span>, n_cycles);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Discretisation for each cycle&quot;</span>, n_steps_per_cycle);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output experimental results to file&quot;</span>, output_data_to_file);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output file name (rate dependent constitutive law)&quot;</span>,</div><div class="line">                output_filename_rd);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output file name (rate independent constitutive law)&quot;</span>,</div><div class="line">                output_filename_ri);</div><div class="line"></div><div class="line">  parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> RheologicalExperimentParameters::start_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0.0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> RheologicalExperimentParameters::end_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> n_cycles / frequency;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> RheologicalExperimentParameters::delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span></div><div class="line">RheologicalExperimentParameters::print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;</div><div class="line">}</div></div><!-- fragment --><p>The applied magnetic field is always aligned with the axis of rotation of the rheometer's rotor.</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> RheologicalExperimentParameters::get_H(<span class="keyword">const</span> <span class="keywordtype">double</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>({0.0, 0.0, H_2});</div><div class="line">}</div></div><!-- fragment --><p>The applied deformation (gradient) is computed based on the geometry of the rheometer and the sample, the sampling point, and the experimental parameters. From the displacement profile documented in the introduction, the deformation gradient may be expressed in Cartesian coordinates as </p><p class="formulaDsp">
\[ \mathbf{F} = \begin{bmatrix} \frac{\cos\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\frac{\sin\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\tau R \sqrt{\lambda_{3}} \sin\left(\Theta + \alpha\right) \\ \frac{\sin\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; \frac{\cos\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\tau R \sqrt{\lambda_{3}} \cos\left(\Theta + \alpha\right) \\ 0 &amp; 0 &amp; \lambda_{3} \end{bmatrix} \]
</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> RheologicalExperimentParameters::get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((sample_radius &gt; 0.0 &amp;&amp; sample_height &gt; 0.0),</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical sample dimensions&quot;</span>));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(lambda_2 &gt; 0.0,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical applied axial stretch&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> sqrt_lambda_2     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(lambda_2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_max =</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(std::tan(gamma_12) * sample_height /</div><div class="line">              sample_radius); <span class="comment">// Small strain approximation</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>       = sample_radius * alpha_max;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>       = 2.0 * numbers::PI * frequency; <span class="comment">// in rad /s</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> gamma_t = A * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(w * time);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tau_t =</div><div class="line">    gamma_t /</div><div class="line">    (sample_radius * sample_height); <span class="comment">// Torsion angle per unit length</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_t = tau_t * lambda_2 * sample_height;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">  F[0][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">  F[0][1] = -inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">  F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">  F[1][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">  F[1][1] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">  F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">  F[2][0] = 0.0;</div><div class="line">  F[2][1] = 0.0;</div><div class="line">  F[2][2] = lambda_2;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((F[0][0] &gt; 0) &amp;&amp; (F[1][1] &gt; 0) &amp;&amp; (F[2][2] &gt; 0),</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical deformation gradient component.&quot;</span>));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(F) - 1.0) &lt; 1e-6,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian is not equal to unity.&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="RheologicalexperimentParallelplaterotationalrheometer"></a> </p><h4>Rheological experiment: Parallel plate rotational rheometer</h4>
<p>This is the function that will drive the numerical experiments.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> run_rheological_experiment(</div><div class="line">  <span class="keyword">const</span> RheologicalExperimentParameters &amp;experimental_parameters,</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    &amp;material_hand_calculated,</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    &amp;               material_assisted_computation,</div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> &amp;     timer,</div><div class="line">  <span class="keyword">const</span> std::string filename)</div><div class="line">{</div></div><!-- fragment --><p>We can take the hand-implemented constitutive law and compare the results that we attain with it to those that we get using AD or SD. In this way, we can verify that they produce identical results (which indicates that either both implementations have a high probability of being correct, or that they're incorrect with identical flaws being present in both). Either way, it is a decent sanity check for the fully self-implemented variants and can certainly be used as a debugging strategy when differences between the results are detected).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> check_material_class_results =</div><div class="line">  [](</div><div class="line">    <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;to_verify,</div><div class="line">    <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;blessed,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-6) {</div><div class="line">    (void)to_verify;</div><div class="line">    (void)blessed;</div><div class="line">    (void)tol;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(std::abs(blessed.get_psi() - to_verify.get_psi()) &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for psi. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(std::abs(</div><div class="line">                        blessed.get_psi() - to_verify.get_psi()))));</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for B. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for S. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for BB. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for PP. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for HH. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">  };</div></div><!-- fragment --><p>We'll be outputting the constitutive response of the material to file for post-processing, so here we declare a <code>stream</code> that will act as a buffer for this output. We'll use a simple CSV format for the outputted results.</p>
<div class="fragment"><div class="line">std::ostringstream stream;</div><div class="line">stream</div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\n&quot;</span>;</div></div><!-- fragment --><p>Using the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> class, we iterate through each timestep using a fixed time step size.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(experimental_parameters.start_time(),</div><div class="line">                       experimental_parameters.end_time() +</div><div class="line">                         experimental_parameters.delta_t(),</div><div class="line">                       experimental_parameters.delta_t());</div><div class="line">     time.is_at_end() == <span class="keyword">false</span>;</div><div class="line">     time.advance_time())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (experimental_parameters.print_status(time.get_step_number()))</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep = &quot;</span> &lt;&lt; time.get_step_number()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; @ time = &quot;</span> &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;s.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>We fetch and compute the loading to be applied to the material at this time step...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> H =</div><div class="line">  experimental_parameters.get_H(time.get_current_time());</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F =</div><div class="line">  experimental_parameters.get_F(time.get_current_time());</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C =</div><div class="line">  <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">Physics::Elasticity::Kinematics::C</a>(F);</div></div><!-- fragment --><p>... then we update the state of the materials...</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Hand calculated&quot;</span>);</div><div class="line">  material_hand_calculated.update_internal_data(C, H, time);</div><div class="line">  material_hand_calculated.update_end_of_timestep();</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assisted computation&quot;</span>);</div><div class="line">  material_assisted_computation.update_internal_data(C, H, time);</div><div class="line">  material_assisted_computation.update_end_of_timestep();</div><div class="line">}</div></div><!-- fragment --><p>... and test for discrepancies between the two.</p>
<div class="fragment"><div class="line">check_material_class_results(material_hand_calculated,</div><div class="line">                             material_assisted_computation);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">  {</div></div><!-- fragment --><p>The next thing that we will do is collect some results to post-process. All quantities are in the "current configuration" (rather than the "reference configuration", in which all quantities computed by the constitutive laws are framed).</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> h =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Covariant.html#ad438f09c3045e448805f62b27c2f8d29">Physics::Transformations::Covariant::push_forward</a>(H, F);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> b =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">          material_hand_calculated.get_B(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> sigma =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">          material_hand_calculated.get_S(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">      stream &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; h[2] &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; b[2]</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; F[1][2] * 100.0 &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; sigma[1][2] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, we output the strain-stress and magnetic loading history to file.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">    {</div><div class="line">      std::ofstream output(filename);</div><div class="line">      output &lt;&lt; stream.str();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheCoupledConstitutiveLawsrunfunction"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">CoupledConstitutiveLaws::run()</a> function</h4>
<p>The purpose of this driver function is to read in all of the parameters from file and, based off of that, create a representative instance of each constitutive law and invoke the function that conducts a rheological experiment with it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters          constitutive_parameters;</div><div class="line">  <span class="keyword">const</span> RheologicalExperimentParameters experimental_parameters;</div><div class="line"></div><div class="line">  std::string parameter_file;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    parameter_file = argv[1];</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line">  <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div></div><!-- fragment --><p>We start the actual work by configuring and running the experiment using our rate-independent constitutive law. The automatically differentiable number type is hard-coded here, but with some clever templating it is possible to select which framework to use at run time (e.g., as selected through the parameter file). We'll simultaneously perform the experiments with the counterpary material law that was fully implemented by hand, and check what it computes against our assisted implementation.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                    <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                    <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">  std::cout</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;Coupled magnetoelastic constitutive law using automatic differentiation.&quot;</span></div><div class="line">    &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"></div><div class="line">  Magnetoelastic_Constitutive_Law&lt;dim&gt; material(constitutive_parameters);</div><div class="line">  Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt; material_ad(</div><div class="line">    constitutive_parameters);</div><div class="line"></div><div class="line">  run_rheological_experiment(experimental_parameters,</div><div class="line">                             material,</div><div class="line">                             material_ad,</div><div class="line">                             timer,</div><div class="line">                             experimental_parameters.output_filename_ri);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Next we do the same for the rate-dependent constitutive law. The highest performance option is selected as default if SymEngine is set up to use the LLVM just-in-time compiler which (in conjunction with some aggressive compilation flags) produces the fastest code evaluation path of all of the available option. As a fall-back, the so called "lambda" optimizer (which only requires a C++11 compliant compiler) will be selected. At the same time, we'll ask the CAS to perform common subexpression elimination to minimize the number of intermediate calculations used during evaluation. We'll record how long it takes to execute the "initialization" step inside the constructor for the SD implementation, as this is where the abovementioned transformations occur.</p>
<div class="fragment"><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">        std::cout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Coupled magneto-viscoelastic constitutive law using symbolic differentiation.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_SYMENGINE_WITH_LLVM</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using LLVM optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba7c7d2b9e8389cc541dc5a615e05bcf1e">Differentiation::SD::OptimizerType::llvm</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a1ad0cce13bc606ad6742e9841ccdfe15">Differentiation::SD::OptimizationFlags::optimize_all</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using lambda optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">Differentiation::SD::OptimizerType::lambda</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a3df84265620315a025367510c90d0474">Differentiation::SD::OptimizationFlags::optimize_cse</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        Magnetoviscoelastic_Constitutive_Law&lt;dim&gt; material(</div><div class="line">          constitutive_parameters);</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Initialize symbolic CL&quot;</span>);</div><div class="line">        Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt; material_sd(</div><div class="line">          constitutive_parameters, optimizer_type, optimization_flags);</div><div class="line">        timer.<a class="code" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a>();</div><div class="line"></div><div class="line">        run_rheological_experiment(experimental_parameters,</div><div class="line">                                   material,</div><div class="line">                                   material_sd,</div><div class="line">                                   timer,</div><div class="line">                                   experimental_parameters.output_filename_rd);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace CoupledConstitutiveLaws</span></div><div class="line"></div><div class="line">} <span class="comment">// namespace Step71</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The main function only calls the driver functions for the two sets of examples that are to be executed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::SimpleExample::run</a>();</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::CoupledConstitutiveLaws::run</a>(argc, argv);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Introductoryexample"></a></p><h3>Introductory example</h3>
<p>The first exploratory example produces the following output. It is verified that all three implementations produce identical results. </p><div class="fragment"><div class="line">&gt; ./step-71</div><div class="line">Simple example <span class="keyword">using</span> automatic differentiation...</div><div class="line">... all calculations are correct!</div><div class="line">Simple example <span class="keyword">using</span> symbolic differentiation.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --><p><a class="anchor" id="Constitutivemodelling"></a></p><h3>Constitutive modelling</h3>
<p>To help summarize the results from the virtual experiment itself, below are some graphs showing the shear stress, plotted against the shear strain, at a select location within the material sample. The plots show the stress-strain curves under three different magnetic loads, and for the last cycle of the (mechanical) loading profile, when the rate-dependent material reaches a repeatable ("steady-state") response. These types of graphs are often referred to as <a href="https://en.wikipedia.org/wiki/Lissajous_curve">Lissajous plots</a>. The area of the ellipse that the curve takes for viscoelastic materials provides some measure of how much energy is dissipated by the material, and its ellipticity indicates the phase shift of the viscous response with respect to the elastic response.</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.lissajous_plot-me.png" width="400"/>
</div>
 <p>Lissajous plot for the magneto-elastic material. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.lissajous_plot-mve.png" width="400"/>
</div>
 <p>Lissajous plot for the magneto-viscoelastic material. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>It is not surprising to see that the magneto-elastic material response has an unloading curve that matches the loading curve &ndash; the material is non-dissipative after all. But here it's clearly noticeable how the gradient of the curve increases as the applied magnetic field increases. The tangent at any point along this curve is related to the instantaneous shear modulus and, due to the way that the energy density function was defined, we expect that the shear modulus increases as the magnetic field strength increases. We observe much the same behavior for the magneto-viscoelastic material. The major axis of the ellipse traced by the loading-unloading curve has a slope that increases as a greater magnetic load is applied. At the same time, the more energy is dissipated by the material.</p>
<p>As for the code output, this is what is printed to the console for the part pertaining to the rheological experiment conducted with the magnetoelastic material: </p><div class="fragment"><div class="line">Coupled magnetoelastic constitutive law <span class="keyword">using</span> automatic differentiation.</div><div class="line">Timestep = 0 @ time = 0s.</div><div class="line">Timestep = 125 @ time = 0.314159s.</div><div class="line">Timestep = 250 @ time = 0.628318s.</div><div class="line">Timestep = 375 @ time = 0.942477s.</div><div class="line">...</div><div class="line">Timestep = 12250 @ time = 30.7876s.</div><div class="line">Timestep = 12375 @ time = 31.1018s.</div><div class="line">Timestep = 12500 @ time = 31.4159s.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --><p>And this portion of the output pertains to the experiment performed with the magneto-viscoelastic material: </p><div class="fragment"><div class="line">Coupled magneto-viscoelastic constitutive law <span class="keyword">using</span> symbolic differentiation.</div><div class="line">Using LLVM optimizer.</div><div class="line">Timestep = 0 @ time = 0s.</div><div class="line">Timestep = 125 @ time = 0.314159s.</div><div class="line">Timestep = 250 @ time = 0.628318s.</div><div class="line">Timestep = 375 @ time = 0.942477s.</div><div class="line">...</div><div class="line">Timestep = 12250 @ time = 30.7876s.</div><div class="line">Timestep = 12375 @ time = 31.1018s.</div><div class="line">Timestep = 12500 @ time = 31.4159s.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --><p>The timer output is also emitted to the console, so we can compare time taken to perform the hand- and assisted- calculations and get some idea of the overhead of using the AD and SD frameworks. Here are the timings taken from the magnetoelastic experiment using the AD framework, based on the Sacado component of the Trilinos library: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |       3.2s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |      3.02s |        95% |</div><div class="line">| Hand calculated                 |     12501 |    0.0464s |       1.5% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> With respect to the computations performed using automatic differentiation (as a reminder, this is with two levels of differentiation using the Sacado library in conjunction with dynamic forward auto-differentiable types), we observe that the assisted computations takes about \(65 \times\) longer to compute the desired quantities. This does seem like quite a lot of overhead but, as mentioned in the introduction, it's entirely subjective and circumstance-dependent as to whether or not this is acceptable or not: Do you value computer time more than human time for doing the necessary hand-computations of derivatives, verify their correctness, implement them, and verify the correctness of the implementation? If you develop a research code that will only be run for a relatively small number of experiments, you might value your own time more. If you develop a production code that will be run over and over on 10,000-core clusters for hours, your considerations might be different. In any case, the one nice feature of the AD approach is the "drop in" capability when functions and classes are templated on the scalar type. This means that minimal effort is required to start working with it.</p>
<p>In contrast, the timings for magneto-viscoelastic material as implemented using just-in-time (JIT) compiled symbolic algebra indicate that, at some non-negligible cost during initialization, the calculations themselves are a lot more efficiently executed: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.34s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |     0.376s |        28% |</div><div class="line">| Hand calculated                 |     12501 |     0.368s |        27% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.466s |        35% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> Since the initialization phase need, most likely, only be executed once per thread, this initial expensive phase can be offset by the repeated use of a single <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> instance. Even though the magneto-viscoelastic constitutive law has more terms to calculate when compared to its magnetoelastic counterpart, it still is a whole order of magnitude faster to execute the computations of the kinetic variables and tangents. And when compared to the hand computed variant that uses the caching scheme, the calculation time is nearly equal. So although using the symbolic framework requires a paradigm shift in terms of how one implements and manipulates the symbolic expressions, it can offer good performance and flexibility that the AD frameworks lack.</p>
<p>On the point of data caching, the added cost of value caching for the magneto-viscoelastic material implementation is, in fact, about a \(6\times\) increase in the time spent in <code>update_internal_data()</code> when compared to the implementation using intermediate values for the numerical experiments conducted with this material. Here's a sample output of the timing comparison extracted for the "hand calculated" variant when the caching data structure is removed: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.01s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |     0.361s |        36% |</div><div class="line">| Hand calculated                 |     12501 |    0.0562s |       5.6% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.469s |        47% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>With some minor adjustment we can quite easily test the different optimization schemes for the batch optimizer. So let's compare the computational expense associated with the <code>LLVM</code> batch optimizer setting versus the alternatives. Below are the timings reported for the <code>lambda</code> optimization method (retaining the use of CSE): </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      3.87s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |      3.12s |        81% |</div><div class="line">| Hand calculated                 |     12501 |     0.394s |        10% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.209s |       5.4% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> The primary observation here is that an order of magnitude greater time is spent in the "Assisted computation" section when compared to the <code>LLVM</code> approach.</p>
<p>Last of all we'll test how <code>dictionary</code> substitution, in conjunction with CSE, performs. Dictionary substitution simply does all of the evaluation within the native CAS framework itself, with no transformation of the underlying data structures taking place. Only the use of CSE, which caches intermediate results, will provide any "acceleration" in this instance. With that in mind, here are the results from this selection: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |  1.54e+03s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |  1.54e+03s |     1e+02% |</div><div class="line">| Hand calculated                 |     12501 |     0.563s |         0% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.184s |         0% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> Needless to say, compared to the other two methods, these results took quite some time to produce... The <code>dictionary</code> substitution method is perhaps only really viable for simple expressions or when the number of calls is sufficiently small.</p>
<p><a class="anchor" id="SowhichframeworkshouldIuse"></a></p><h1>So, which framework should I use?</h1>
<p>Perhaps you've been convinced that these tools have some merit, and can be of immediate help or use to you. The obvious question now is which one to use. Focusing specifically at a continuum point level, where you would be using these frameworks to compute derivatives of a constitutive law in particular, we can say the following:</p><ul>
<li>Automatic differentiation probably provides the simplest entry point into the world of assisted differentiation.</li>
<li>Given a sufficiently generic implementation of a constitutive framework, AD can often be used as a drop-in replacement for the intrinsic scalar types and the helper classes can then be leveraged to compute first (and possibly higher order) derivatives with minimal effort.</li>
<li>As a qualification to the above point, being a "drop-in replacement" does not mean that you must not be contentious of what the algorithms that these numbers are being passed through are doing. It is possible to inadvertently perform an operation that would, upon differentiating, return an incorrect result. So this is definitely something that one should be aware of. A concrete example: When computing the eigenvalues of a tensor, if the tensor is diagonal then a short-cut to the result is simply to return the diagonal entries directly (as extracted from the input tensor). This is completely correct in terms of computing the eigenvalues themselves, but not going through the algorithm that would otherwise compute the eigenvalues for a non-diagonal tensor has had an unintended side-effect, namely that the eigenvalues appear (to the AD framework) to be completely decoupled from one another and their cross-sensitivities are not encoded in the returned result. Upon differentiating, many entries of the derivative tensor will be missing. To fix this issue, one has to ensure that the standard eigenvalue solving algorithm is used so that the sensitivities of the returned eigenvalues with respect to one another are encoded in the result.</li>
<li>Computations involving AD number types may be expensive. The expense increases (sometimes quite considerably) as the order of the differential operations increases. This may be mitigated by computational complexity of surrounding operations (such as a linear solve, for example), but is ultimately problem specific.</li>
<li>AD is restricted to the case where only total derivatives are required. If a differential operation requires a partial derivative with respect to an independent variable then it is not appropriate to use it.</li>
<li>Each AD library has its own quirks (sad to say but, in the author's experience, true), so it may take some trial and error to find the appropriate library and choice of AD number to suit your purposes. The reason for these "quirks" often boils down to the overall philosophy behind the library (data structures, the use of template meta-programming, etc.) as well as the mathematical implementation of the derivative computations (for example, manipulations of results using logarithmic functions to change basis might restrict the domain for the input values &ndash; details all hidden from the user, of course). Furthermore, one library might be able to compute the desired results quicker than another, so some initial exploration might be beneficial in that regard.</li>
<li>Symbolic differentiation (well, the use of a CAS in general) provides the most flexible framework with which to perform assisted computations.</li>
<li>The SD framework can do everything that the AD frameworks can, with the additional benefit of having low-level control over when certain manipulations and operations are performed.</li>
<li>Acceleration of expression evaluation is possible, potentially leading to near-native performance of the SD framework compared to some hand implementations (this comparison being dependent on the overall program design, of course) at the expense of the initial optimization call.</li>
<li>Clever use of the <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> could minimize the expense of the costly call that optimizes the dependent expressions. The possibility to serialize the <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> that often (but not always) this expensive call can be done once and then reused in a later simulation.</li>
<li>If two or more material laws differ by only their material parameters, for instance, then a single batch optimizer can be shared between them as long as those material parameters are considered to be symbolic. The implication of this is that you can "differentiate once, evaluate in many contexts".</li>
<li>The SD framework may partially be used as a "drop-in replacement" for scalar types, but one (at the very least) has to add some more framework around it to perform the value substitution step, converting symbolic types to their numerical counterparts.</li>
<li>It may not be possible to use SD numbers within some specialized algorithms. For example, if an algorithm has an exit point or code branch based off of some concrete, numerical value that the (symbolic) input argument should take, then obviously this isn't going to work. One either has to reimplement the algorithm specifically for SD number types (somewhat inconvenient, but frequently possible as conditionals are supported by the <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class), or one must use a creative means around this specific issue (e.g., introduce a symbolic expression that represents the result returned by this algorithm, perhaps declaring it to be a <a href="https://dealii.org/developer/doxygen/deal.II/namespaceDifferentiation_1_1SD.html#a876041f6048705c7a8ad0855cdb1bd7a">symbolic function</a> if that makes sense within the context in which it is to be used. This can later be substituted by its numerical values, and if declared a symbolic function then its deferred derivatives may also be incorporated into the calculations as substituted results.).</li>
<li>The biggest drawback to using SD is that using it requires a paradigm shift, and that one has to frame most problems differently in order to take the most advantage of it. (Careful consideration of how the data structures are used and reused is also essential to get it to work effectively.) This may mean that one needs to play around with it a bit and build up an understanding of what the sequence of typical operations is and what specifically each step does in terms of manipulating the underlying data. If one has the time and inclination to do so, then the benefits of using this tool may be substantial.</li>
</ul>
<p><a class="anchor" id="Possibilitiesforextension"></a></p><h1>Possibilities for extension</h1>
<p>There are a few logical ways in which this program could be extended:</p><ul>
<li>Perhaps the most obvious extension would be to implement and test other constitutive models. This could still be within the realm of coupled magneto-mechanical problems, perhaps considering alternatives to the "Neo-Hookean"-type elastic part of the energy functions, changing the constitutive law for the dissipative energy (and its associated evolution law), or including magnetic hysteretic effects or damage models for the composite polymer that these material seek to model.</li>
<li>Of course, the implemented models could be modified or completely replaced with models that are focused on other aspects of physics, such as electro-active polymers, biomechanical materials, elastoplastic media, etc.</li>
<li>Implement a different time-discretization scheme for the viscoelastic evolution law.</li>
<li>Instead of deriving everything directly from an energy density function, use the <a class="el" href="classDifferentiation_1_1AD_1_1VectorFunction.html">Differentiation::AD::VectorFunction</a> to directly linearize the kinetic quantities. This would mean that only a once-differentiable auto-differentiable number type would be required, and would certainly improve the performance greatly. Such an approach would also offer the opportunity for dissipative materials, such as the magneto-viscoelastic one consider here, to be implemented in conjunction with AD. This is because the linearization invokes the total derivative of the dependent variables with respect to the field variables, which is exactly what the AD frameworks can provide.</li>
<li>Investigate using other auto-differentiable number types and frameworks (such as ADOL-C). Since each AD library has its own implementation, the choice of which to use could result in performance increases and, in the most unfortunate cases, more stable computations. It can at least be said that for the AD libraries that deal.II supports, the accuracy of results should be largely unaffected by this decision.</li>
<li>Embed one of these constitutive laws within a finite element simulation.</li>
</ul>
<p>With less effort, one could think about re-writing nonlinear problem solvers such as the one implemented in <a class="el" href="step_15.html">step-15</a> using AD or SD approaches to compute the Newton matrix. Indeed, this is done in <a class="el" href="step_72.html">step-72</a>.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Jean-Paul Pelteret, 2021</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="general__data__storage_8h.html">deal.II/algorithms/general_data_storage.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numbers_8h.html">deal.II/base/numbers.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="symmetric__tensor_8h.html">deal.II/base/symmetric_tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transformations_8h.html">deal.II/physics/transformations.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinematics_8h.html">deal.II/physics/elasticity/kinematics.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="standard__tensors_8h.html">deal.II/physics/elasticity/standard_tensors.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sd_8h.html">deal.II/differentiation/sd.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step71</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SimpleExample</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumberType&gt;</div><div class="line">    <a class="code" href="classNumberType.html">NumberType</a> f(<span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    run_and_verify_ad(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">    {</div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     dim = 1;</div><div class="line">      constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line">      <span class="keyword">using</span> ADHelper =</div><div class="line">        <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = 2;</div><div class="line"></div><div class="line">      ADHelper ad_helper(n_independent_variables);</div><div class="line">      <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">      ad_helper.register_independent_variables({x, y});</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; independent_variables_ad =</div><div class="line">        ad_helper.get_sensitive_variables();</div><div class="line">      <span class="keyword">const</span> ADNumberType &amp;x_ad = independent_variables_ad[0];</div><div class="line">      <span class="keyword">const</span> ADNumberType &amp;y_ad = independent_variables_ad[1];</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType f_ad = f(x_ad, y_ad);</div><div class="line"></div><div class="line"></div><div class="line">      ad_helper.register_dependent_variable(f_ad);</div><div class="line"></div><div class="line">      Vector&lt;double&gt;     Df(ad_helper.n_dependent_variables());</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2f(ad_helper.n_dependent_variables(),</div><div class="line">                             ad_helper.n_independent_variables());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_f = ad_helper.compute_value();</div><div class="line">      ad_helper.compute_gradient(Df);</div><div class="line">      ad_helper.compute_hessian(D2f);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                             std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx = Df[0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy = Df[1];</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx = D2f[0][0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy = D2f[0][1];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx = D2f[1][0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy = D2f[1][1];</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(x != 0.0, <a class="code" href="group__Exceptions.html#ga2e959da7bfd82df428770c0339c377ba">ExcDivideByZero</a>());</div><div class="line">      <span class="keywordflow">return</span> y * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / (x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / x;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -y * (2 * x * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) + y * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) /</div><div class="line">             (x * x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -(<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) / (x * x);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    run_and_verify_sd(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> x_sd(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> y_sd(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_sd = f(x_sd, y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dx_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dy_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dx_sd =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dy_sd =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dx_sd =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dy_sd =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> substitution_map =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">          std::pair&lt;Differentiation::SD::Expression, double&gt;{x_sd, x},</div><div class="line">          std::pair&lt;Differentiation::SD::Expression, double&gt;{y_sd, y});</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_f =</div><div class="line">        f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                             std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx =</div><div class="line">        d2f_dx_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy =</div><div class="line">        d2f_dx_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx =</div><div class="line">        d2f_dy_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy =</div><div class="line">        d2f_dy_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> x = 1.23;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> y = 0.91;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using automatic differentiation...&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      run_and_verify_ad(x, y);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using symbolic differentiation.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      run_and_verify_sd(x, y);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace SimpleExample</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>CoupledConstitutiveLaws</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">class </span>ConstitutiveParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ConstitutiveParameters();</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_e       = 30.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_e_inf   = 250.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_e_h_sat = 212.2e3;</div><div class="line">      <span class="keywordtype">double</span> nu_e       = 0.49;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_v       = 20.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_v_inf   = 35.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_v_h_sat = 92.84e3;</div><div class="line">      <span class="keywordtype">double</span> tau_v      = 0.6;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_r = 6.0;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    ConstitutiveParameters::ConstitutiveParameters()</div><div class="line">      : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Constitutive Parameters/&quot;</span>)</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Elastic shear modulus&quot;</span>, mu_e);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Elastic shear modulus at magnetic saturation&quot;</span>, mu_e_inf);</div><div class="line">      add_parameter(</div><div class="line">        <span class="stringliteral">&quot;Saturation magnetic field strength for elastic shear modulus&quot;</span>,</div><div class="line">        mu_e_h_sat);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Poisson ratio&quot;</span>, nu_e);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus&quot;</span>, mu_v);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus at magnetic saturation&quot;</span>,</div><div class="line">                    mu_v_inf);</div><div class="line">      add_parameter(</div><div class="line">        <span class="stringliteral">&quot;Saturation magnetic field strength for viscoelastic shear modulus&quot;</span>,</div><div class="line">        mu_v_h_sat);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Characteristic relaxation time&quot;</span>, tau_v);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Relative magnetic permeability&quot;</span>, mu_r);</div><div class="line"></div><div class="line">      parse_parameters_call_back.connect([&amp;]() { initialized = <span class="keyword">true</span>; });</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Coupled_Magnetomechanical_Constitutive_Law_Base</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep()</div><div class="line">      {}</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_nu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_lambda_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_kappa_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_tau_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_r() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">double</span> get_mu_0() <span class="keyword">const</span>;</div><div class="line">      <span class="keywordtype">double</span>           get_delta_t(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : constitutive_parameters(constitutive_parameters)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(get_kappa_e() &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e_inf;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e_h_sat;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_nu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.nu_e;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_lambda_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_kappa_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (2.0 * get_mu_e() * (1.0 + get_nu_e())) /</div><div class="line">             (3.0 * (1.0 - 2.0 * get_nu_e()));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v_inf;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v_h_sat;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_tau_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.tau_v;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_r()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_r;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_0()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 4.0 * numbers::PI * 1e-7;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_delta_t(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> time.<a class="code" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">get_previous_step_size</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoelastic_Constitutive_Law_AD final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> ADHelper =</div><div class="line">        <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line">      <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoelastic_Constitutive_Law_AD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>             H_components;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor&lt;2&gt;</a> C_components;</div><div class="line"></div><div class="line">      ADHelper ad_helper;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>             psi;</div><div class="line">      Vector&lt;double&gt;     Dpsi;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2psi;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::</div><div class="line">      Magnetoelastic_Constitutive_Law_AD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , H_components(0)</div><div class="line">      , C_components(<a class="code" href="classTensor.html">Tensor</a>&lt;1, dim&gt;::n_independent_components)</div><div class="line">      , ad_helper(<a class="code" href="classTensor.html">Tensor</a>&lt;1, dim&gt;::n_independent_components +</div><div class="line">                  <a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt;::n_independent_components)</div><div class="line">      , psi(0.0)</div><div class="line">      , Dpsi(ad_helper.n_independent_variables())</div><div class="line">      , D2psi(ad_helper.n_independent_variables(),</div><div class="line">              ad_helper.n_independent_variables())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C) &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      ad_helper.reset();</div><div class="line"></div><div class="line">      ad_helper.register_independent_variable(H, H_components);</div><div class="line">      ad_helper.register_independent_variable(C, C_components);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, ADNumberType&gt;</a> H_ad =</div><div class="line">        ad_helper.get_sensitive_variables(H_components);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_ad =</div><div class="line">        ad_helper.get_sensitive_variables(C_components);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType det_F_ad = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C_ad));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_inv_ad = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C_ad);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F_ad &gt; ADNumberType(0.0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType f_mu_e_ad =</div><div class="line">        1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">                <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_ad * H_ad) /</div><div class="line">                          (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType psi_ad =</div><div class="line">        0.5 * this-&gt;get_mu_e() * f_mu_e_ad *</div><div class="line">          (<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C_ad) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad))                 </div><div class="line">        + this-&gt;get_lambda_e() * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) </div><div class="line">        - 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F_ad *</div><div class="line">            (H_ad * C_inv_ad * H_ad); </div><div class="line"></div><div class="line">      ad_helper.register_dependent_variable(psi_ad);</div><div class="line"></div><div class="line">      psi = ad_helper.compute_value();</div><div class="line">      ad_helper.compute_gradient(Dpsi);</div><div class="line">      ad_helper.compute_hessian(D2psi);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dpsi_dH =</div><div class="line">        ad_helper.extract_gradient_component(Dpsi, H_components);</div><div class="line">      <span class="keywordflow">return</span> -dpsi_dH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dpsi_dC =</div><div class="line">        ad_helper.extract_gradient_component(Dpsi, C_components);</div><div class="line">      <span class="keywordflow">return</span> 2.0 * dpsi_dC;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> dpsi_dH_dH =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, H_components, H_components);</div><div class="line">      <span class="keywordflow">return</span> -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(dpsi_dH_dH);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> dpsi_dC_dH =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, C_components, H_components);</div><div class="line">      <span class="keywordflow">return</span> -2.0 * dpsi_dC_dH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dpsi_dC_dC =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, C_components, C_components);</div><div class="line">      <span class="keywordflow">return</span> 4.0 * dpsi_dC_dC;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law_SD final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_inf_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_h_sat_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> lambda_e_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_inf_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_h_sat_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> tau_v_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> delta_t_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_r_sd;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          H_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_sd;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t1_sd;</div><div class="line"></div><div class="line">      <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>                          psi_sd;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          B_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> S_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> BB_sd;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim, Differentiation::SD::Expression&gt;</a>          PP_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim, Differentiation::SD::Expression&gt;</a> HH_sd;</div><div class="line"></div><div class="line">      <a class="code" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer&lt;double&gt;</a> optimizer;</div><div class="line"></div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> initialize_optimizer();</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::</div><div class="line">      Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , mu_e_sd(<span class="stringliteral">&quot;mu_e&quot;</span>)</div><div class="line">      , mu_e_inf_sd(<span class="stringliteral">&quot;mu_e_inf&quot;</span>)</div><div class="line">      , mu_e_h_sat_sd(<span class="stringliteral">&quot;mu_e_h_sat&quot;</span>)</div><div class="line">      , lambda_e_sd(<span class="stringliteral">&quot;lambda_e&quot;</span>)</div><div class="line">      , mu_v_sd(<span class="stringliteral">&quot;mu_v&quot;</span>)</div><div class="line">      , mu_v_inf_sd(<span class="stringliteral">&quot;mu_v_inf&quot;</span>)</div><div class="line">      , mu_v_h_sat_sd(<span class="stringliteral">&quot;mu_v_h_sat&quot;</span>)</div><div class="line">      , tau_v_sd(<span class="stringliteral">&quot;tau_v&quot;</span>)</div><div class="line">      , delta_t_sd(<span class="stringliteral">&quot;delta_t&quot;</span>)</div><div class="line">      , mu_r_sd(<span class="stringliteral">&quot;mu_r&quot;</span>)</div><div class="line">      , H_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#acf16bdf4d5a0b48dd84496e379742426">make_vector_of_symbols</a>&lt;dim&gt;(<span class="stringliteral">&quot;H&quot;</span>))</div><div class="line">      , C_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;C&quot;</span>))</div><div class="line">      , Q_t_sd(</div><div class="line">          <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t&quot;</span>))</div><div class="line">      , Q_t1_sd(</div><div class="line">          <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t1&quot;</span>))</div><div class="line">      , optimizer(optimizer_type, optimization_flags)</div><div class="line">    {</div><div class="line">      initialize_optimizer();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::make_substitution_map</a>(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">        std::make_pair(mu_e_sd, this-&gt;get_mu_e()),</div><div class="line">        std::make_pair(mu_e_inf_sd, this-&gt;get_mu_e_inf()),</div><div class="line">        std::make_pair(mu_e_h_sat_sd, this-&gt;get_mu_e_h_sat()),</div><div class="line">        std::make_pair(lambda_e_sd, this-&gt;get_lambda_e()),</div><div class="line">        std::make_pair(mu_v_sd, this-&gt;get_mu_v()),</div><div class="line">        std::make_pair(mu_v_inf_sd, this-&gt;get_mu_v_inf()),</div><div class="line">        std::make_pair(mu_v_h_sat_sd, this-&gt;get_mu_v_h_sat()),</div><div class="line">        std::make_pair(tau_v_sd, this-&gt;get_tau_v()),</div><div class="line">        std::make_pair(delta_t_sd, delta_t),</div><div class="line">        std::make_pair(mu_r_sd, this-&gt;get_mu_r()),</div><div class="line">        std::make_pair(H_sd, H),</div><div class="line">        std::make_pair(C_sd, C),</div><div class="line">        std::make_pair(Q_t_sd, Q_t),</div><div class="line">        std::make_pair(Q_t1_sd, Q_t1));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::initialize_optimizer()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> det_F_sd =</div><div class="line">        <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C_sd));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_inv_sd =</div><div class="line">        <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_e_sd =</div><div class="line">        1.0 +</div><div class="line">        (mu_e_inf_sd / mu_e_sd - 1.0) *</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_ME_sd =</div><div class="line">        0.5 * mu_e_sd * f_mu_e_sd *</div><div class="line">          (<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C_sd) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd)) +</div><div class="line">        lambda_e_sd * std::log(det_F_sd) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd) -</div><div class="line">        0.5 * this-&gt;get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_v_sd =</div><div class="line">        1.0 +</div><div class="line">        (mu_v_inf_sd / mu_v_sd - 1.0) *</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_MVE_sd =</div><div class="line">        0.5 * mu_v_sd * f_mu_v_sd *</div><div class="line">        (Q_t_sd * (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, -2.0 / dim) * C_sd) - dim -</div><div class="line">         std::log(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t_sd)));</div><div class="line"></div><div class="line">      psi_sd = psi_ME_sd + psi_MVE_sd;</div><div class="line"></div><div class="line"></div><div class="line">      B_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, H_sd);</div><div class="line">      S_sd = 2.0 * <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, C_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a></div><div class="line">        Q_t_sd_explicit =</div><div class="line">          (1.0 / (1.0 + delta_t_sd / tau_v_sd)) *</div><div class="line">          (Q_t1_sd +</div><div class="line">           (delta_t_sd / tau_v_sd * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, 2.0 / dim) * C_inv_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">        substitution_map_explicit = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">          std::make_pair(Q_t_sd, Q_t_sd_explicit));</div><div class="line"></div><div class="line">      BB_sd = <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(B_sd, substitution_map_explicit),</div><div class="line">        H_sd));</div><div class="line">      PP_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit), H_sd);</div><div class="line">      HH_sd =</div><div class="line">        2.0 *</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit),</div><div class="line">          C_sd);</div><div class="line"></div><div class="line">      optimizer.register_symbols(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD_1_1Utilities.html#a373adeda1cf11d824bb41a679d061a3d">Differentiation::SD::Utilities::extract_symbols</a>(</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>({}, {}, 0)));</div><div class="line"></div><div class="line">      optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);</div><div class="line"></div><div class="line">      optimizer.optimize();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (Q_t1 + (delta_t / this-&gt;get_tau_v()) * std::pow(det_F, 2.0 / dim) *</div><div class="line">                      C_inv);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> substitution_map = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(C, H, delta_t);</div><div class="line"></div><div class="line">      optimizer.substitute(substitution_map);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(psi_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(B_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(S_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(BB_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(PP_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(HH_sd);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_end_of_timestep()</div><div class="line">    {</div><div class="line">      Q_t1 = Q_t;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoelastic_Constitutive_Law final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoelastic_Constitutive_Law(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keywordtype">double</span>                  psi;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoelastic_Constitutive_Law&lt;dim&gt;::Magnetoelastic_Constitutive_Law(</div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , psi(0.0)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> two_h_dot_h_div_h_sat_squ =</div><div class="line">        (2.0 * H * H) / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(two_h_dot_h_div_h_sat_squ);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e =</div><div class="line">        1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">                tanh_two_h_dot_h_div_h_sat_squ;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dtanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(two_h_dot_h_div_h_sat_squ), 2.0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dtwo_h_dot_h_div_h_sat_squ_dH =</div><div class="line">        2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) * H;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH =</div><div class="line">        (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">        (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> d2tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2two_h_dot_h_div_h_sat_squ_dH_dH =</div><div class="line">        2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) *</div><div class="line">        <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">        (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">        (d2tanh_two_h_dot_h_div_h_sat_squ *</div><div class="line">           <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dtwo_h_dot_h_div_h_sat_squ_dH,</div><div class="line">                                    dtwo_h_dot_h_div_h_sat_squ_dH)) +</div><div class="line">         dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         log_det_F         = <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         tr_C              = <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H       = C_inv * H;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         H_dot_C_inv_dot_H = H * C_inv_dot_H;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d_tr_C_dC =</div><div class="line">        <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> ddet_F_dC     = 0.5 * det_F * C_inv;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dlog_det_F_dC = 0.5 * C_inv;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dC_inv_dC;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              dC_inv_dC[A][B][C][D] -=               </div><div class="line">                0.5 * (C_inv[A][C] * C_inv[B][D]     </div><div class="line">                       + C_inv[A][D] * C_inv[B][C]); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dH_dot_C_inv_dot_H_dC =</div><div class="line">        -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2det_F_dC_dC =</div><div class="line">        0.5 * (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv, ddet_F_dC) + det_F * dC_inv_dC);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=</div><div class="line">              C_inv[A][C] * C_inv_dot_H[B] + </div><div class="line">              C_inv_dot_H[A] * C_inv[B][C];  </div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">                0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                       C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);</div><div class="line"></div><div class="line">      psi =</div><div class="line">        (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">          (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">        this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F)) -</div><div class="line">        (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div><div class="line"></div><div class="line">      B = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">            df_mu_e_dH </div><div class="line">          + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">              dH_dot_C_inv_dot_H_dH; </div><div class="line"></div><div class="line">      S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                        </div><div class="line">            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              </div><div class="line">          + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) </div><div class="line">          - 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *            </div><div class="line">              (H_dot_C_inv_dot_H * ddet_F_dC                               </div><div class="line">               + det_F * dH_dot_C_inv_dot_H_dC);                           </div><div class="line"></div><div class="line">      BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * </div><div class="line">             d2f_mu_e_dH_dH                                             </div><div class="line">           + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">               d2H_dot_C_inv_dot_H_dH_dH; </div><div class="line"></div><div class="line">      PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *                                  </div><div class="line">             <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   </div><div class="line">                           df_mu_e_dH)                                        </div><div class="line">           +                                                                  </div><div class="line">           2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">             (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) </div><div class="line">              + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           </div><div class="line"></div><div class="line">      HH =</div><div class="line">        4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">        + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">            (2.0 * <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">             + 2.0 * log_det_F * d2log_det_F_dC_dC)                          </div><div class="line">        - 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">            (H_dot_C_inv_dot_H * d2det_F_dC_dC                               </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               </div><div class="line">             + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> B;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> S;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> BB;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> PP;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> HH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoviscoelastic_Constitutive_Law(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>                  psi;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classGeneralDataStorage.html">GeneralDataStorage</a> cache;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> set_primary_variables(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                 <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> update_internal_variable(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_f_mu(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">      get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_df_mu_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_d2f_mu_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C_inv() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_log_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_trace_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_H_dot_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_dC_inv_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d_tr_C_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_ddet_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dlog_det_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">      get_dQ_t_dC(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2log_det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dH_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dC() <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::Magnetoviscoelastic_Constitutive_Law(<span class="keyword">const</span> ConstitutiveParameters</div><div class="line">                                                   &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , psi(0.0)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">    {</div><div class="line">      set_primary_variables(C, H);</div><div class="line">      update_internal_variable(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e = get_f_mu(this-&gt;get_mu_e(),</div><div class="line">                                     this-&gt;get_mu_e_inf(),</div><div class="line">                                     this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_v = get_f_mu(this-&gt;get_mu_v(),</div><div class="line">                                     this-&gt;get_mu_v_inf(),</div><div class="line">                                     this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH = get_df_mu_dH(this-&gt;get_mu_e(),</div><div class="line">                                                     this-&gt;get_mu_e_inf(),</div><div class="line">                                                     this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_v_dH = get_df_mu_dH(this-&gt;get_mu_v(),</div><div class="line">                                                     this-&gt;get_mu_v_inf(),</div><div class="line">                                                     this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">        get_d2f_mu_dH_dH(this-&gt;get_mu_e(),</div><div class="line">                         this-&gt;get_mu_e_inf(),</div><div class="line">                         this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_v_dH_dH =</div><div class="line">        get_d2f_mu_dH_dH(this-&gt;get_mu_v(),</div><div class="line">                         this-&gt;get_mu_v_inf(),</div><div class="line">                         this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;                 det_F = get_det_F();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;log_det_F         = get_log_det_F();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;tr_C              = get_trace_C();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d_tr_C_dC     = get_d_tr_C_dC();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;ddet_F_dC     = get_ddet_F_dC();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dlog_det_F_dC = get_dlog_det_F_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;dQ_t_dC = get_dQ_t_dC(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dC =</div><div class="line">        get_dH_dot_C_inv_dot_H_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2log_det_F_dC_dC =</div><div class="line">        get_d2log_det_F_dC_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2det_F_dC_dC = get_d2det_F_dC_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dH_dH =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dH_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dH =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dC_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dC =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dC_dC();</div><div class="line"></div><div class="line">      psi = (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">              (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">            this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F));</div><div class="line">      psi += (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">             (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">              <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t)));</div><div class="line">      psi -=</div><div class="line">        (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div><div class="line"></div><div class="line">      B =</div><div class="line">        -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;</div><div class="line">      B -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">           (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t))) *</div><div class="line">           df_mu_v_dH;</div><div class="line">      B += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">           dH_dot_C_inv_dot_H_dH;</div><div class="line"></div><div class="line">      S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                         </div><div class="line">            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               </div><div class="line">          + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); </div><div class="line">      S += 2.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">           ((Q_t * C) *</div><div class="line">              ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) +</div><div class="line">            std::pow(det_F, -2.0 / dim) * Q_t);                <span class="comment">// dC/dC = II</span></div><div class="line">      S -= 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">           (H_dot_C_inv_dot_H * ddet_F_dC                      </div><div class="line">            + det_F * dH_dot_C_inv_dot_H_dC);                  </div><div class="line"></div><div class="line">      BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">           d2f_mu_e_dH_dH;</div><div class="line">      BB -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">            (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">             <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t))) *</div><div class="line">            d2f_mu_v_dH_dH;</div><div class="line">      BB += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">            d2H_dot_C_inv_dot_H_dH_dH;</div><div class="line"></div><div class="line">      PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *</div><div class="line">           <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),</div><div class="line">                         df_mu_e_dH);</div><div class="line">      PP -= 2.0 * (0.5 * this-&gt;get_mu_v()) *</div><div class="line">            <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>((Q_t * C) *</div><div class="line">                                           ((-2.0 / dim) *</div><div class="line">                                            std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                                            ddet_F_dC) +</div><div class="line">                                         std::pow(det_F, -2.0 / dim) * Q_t),</div><div class="line">                          df_mu_v_dH);</div><div class="line">      PP += 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *</div><div class="line">            (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +</div><div class="line">             det_F * d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line"></div><div class="line">      HH =</div><div class="line">        4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">        + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">            (2.0 * <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">             + 2.0 * log_det_F * d2log_det_F_dC_dC);                         </div><div class="line">      HH += 4.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">            (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                             ddet_F_dC,</div><div class="line">                           C * dQ_t_dC + Q_t) +</div><div class="line">             (Q_t * <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>) *</div><div class="line">               (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC,</div><div class="line">                              (-2.0 / dim) * (-2.0 / dim - 1.0) *</div><div class="line">                                std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +</div><div class="line">                ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                 d2det_F_dC_dC)) +</div><div class="line">             <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Q_t,</div><div class="line">                           (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                             ddet_F_dC) +</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, -2.0 / dim) * dQ_t_dC);</div><div class="line">      HH -= 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">            (H_dot_C_inv_dot_H * d2det_F_dC_dC                  </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  </div><div class="line">             + det_F * d2H_dot_C_inv_dot_H_dC_dC);              </div><div class="line"></div><div class="line"></div><div class="line">      cache.reset();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> B;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> S;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> BB;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> PP;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> HH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_end_of_timestep()</div><div class="line">    {</div><div class="line">      Q_t1 = Q_t;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_variable(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">      Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (Q_t1 + (delta_t / this-&gt;get_tau_v()) *</div><div class="line">                      std::pow(get_det_F(), 2.0 / dim) * get_C_inv());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_two_h_dot_h_div_h_sat_squ(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;H = get_H();</div><div class="line">      <span class="keywordflow">return</span> (2.0 * H * H) / (mu_h_sat * mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_f_mu(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 1.0 +</div><div class="line">             (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),</div><div class="line">                      2.0);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_df_mu_dH(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">             (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">              get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">             get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *</div><div class="line">             <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2f_mu_dH_dH(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">             (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">                <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(</div><div class="line">                  <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),</div><div class="line">                                get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +</div><div class="line">              get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">                get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::set_primary_variables(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name_H(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_H),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">               <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">      cache.add_unique_copy(name_H, H);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string name_C(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_C),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">               <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">      cache.add_unique_copy(name_C, C);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;det_F&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(get_C()));</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line">          cache.add_unique_copy(name, det_F);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          cache.add_unique_copy(name, <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(get_C()));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_log_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;log(det_F)&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, std::log(get_det_F()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_trace_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;trace(C)&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(get_C()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv_dot_H&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, get_C_inv() * get_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H_dot_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H_dot_C_inv_dot_H&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dQ_t_dC(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dQ_t_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>  delta_t = this-&gt;get_delta_t(time);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;det_F   = get_det_F();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dQ_t_dC =</div><div class="line">            (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (delta_t / this-&gt;get_tau_v()) *</div><div class="line">            ((2.0 / dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim - 1.0) *</div><div class="line">               <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim) * get_dC_inv_dC());</div><div class="line"></div><div class="line">          cache.add_unique_copy(name, dQ_t_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dC_inv_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dC_inv_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line">          <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>        dC_inv_dC;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">                  dC_inv_dC[A][B][C][D] -=               </div><div class="line">                    0.5 * (C_inv[A][C] * C_inv[B][D]     </div><div class="line">                           + C_inv[A][D] * C_inv[B][C]); </div><div class="line"></div><div class="line">          cache.add_unique_copy(name, dC_inv_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d_tr_C_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d_tr_C_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name,</div><div class="line">                              <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_ddet_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;ddet_F_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dlog_det_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dlog_det_F_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          cache.add_unique_copy(</div><div class="line">            name, -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H)));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2log_det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2log_det_F_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2det_F_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name,</div><div class="line">                              0.5 *</div><div class="line">                                (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">                                 get_det_F() * get_dC_inv_dC()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dH_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dH_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 2.0 * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=</div><div class="line">                  C_inv[A][C] * C_inv_dot_H[B] + </div><div class="line">                  C_inv_dot_H[A] * C_inv[B][C];  </div><div class="line"></div><div class="line">          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;3, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dC()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">          <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">                  d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">                    0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                           C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                           C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +</div><div class="line">                           C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);</div><div class="line"></div><div class="line">          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">class </span>RheologicalExperimentParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RheologicalExperimentParameters();</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> sample_radius = 0.01;</div><div class="line">      <span class="keywordtype">double</span> sample_height = 0.001;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> lambda_2 = 0.95;</div><div class="line">      <span class="keywordtype">double</span> gamma_12 = 0.05;</div><div class="line">      <span class="keywordtype">double</span> H_2      = 60.0e3;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>       frequency         = 1.0 / (2.0 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles          = 5;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps_per_cycle = 2500;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span>        output_data_to_file = <span class="keyword">true</span>;</div><div class="line">      std::string output_filename_rd =</div><div class="line">        <span class="stringliteral">&quot;experimental_results-rate_dependent.csv&quot;</span>;</div><div class="line">      std::string output_filename_ri =</div><div class="line">        <span class="stringliteral">&quot;experimental_results-rate_independent.csv&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> start_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> end_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> delta_t() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> get_H(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    RheologicalExperimentParameters::RheologicalExperimentParameters()</div><div class="line">      : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Rheological Experiment/&quot;</span>)</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_radius);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_height);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Axial stretch&quot;</span>, lambda_2);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Shear strain amplitude&quot;</span>, gamma_12);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Axial magnetic field strength&quot;</span>, H_2);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Frequency&quot;</span>, frequency);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Number of loading cycles&quot;</span>, n_cycles);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Discretisation for each cycle&quot;</span>, n_steps_per_cycle);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output experimental results to file&quot;</span>, output_data_to_file);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output file name (rate dependent constitutive law)&quot;</span>,</div><div class="line">                    output_filename_rd);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output file name (rate independent constitutive law)&quot;</span>,</div><div class="line">                    output_filename_ri);</div><div class="line"></div><div class="line">      parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::start_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.0;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::end_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> n_cycles / frequency;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    RheologicalExperimentParameters::print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> RheologicalExperimentParameters::get_H(<span class="keyword">const</span> <span class="keywordtype">double</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>({0.0, 0.0, H_2});</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> RheologicalExperimentParameters::get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((sample_radius &gt; 0.0 &amp;&amp; sample_height &gt; 0.0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical sample dimensions&quot;</span>));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(lambda_2 &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical applied axial stretch&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> sqrt_lambda_2     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(lambda_2);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_max =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(std::tan(gamma_12) * sample_height /</div><div class="line">                  sample_radius); <span class="comment">// Small strain approximation</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> A       = sample_radius * alpha_max;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> w       = 2.0 * numbers::PI * frequency; <span class="comment">// in rad /s</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma_t = A * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(w * time);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tau_t =</div><div class="line">        gamma_t /</div><div class="line">        (sample_radius * sample_height); <span class="comment">// Torsion angle per unit length</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_t = tau_t * lambda_2 * sample_height;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">      F[0][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[0][1] = -inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[1][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[1][1] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[2][0] = 0.0;</div><div class="line">      F[2][1] = 0.0;</div><div class="line">      F[2][2] = lambda_2;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((F[0][0] &gt; 0) &amp;&amp; (F[1][1] &gt; 0) &amp;&amp; (F[2][2] &gt; 0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical deformation gradient component.&quot;</span>));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(F) - 1.0) &lt; 1e-6,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian is not equal to unity.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> run_rheological_experiment(</div><div class="line">      <span class="keyword">const</span> RheologicalExperimentParameters &amp;experimental_parameters,</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">        &amp;material_hand_calculated,</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">        &amp;               material_assisted_computation,</div><div class="line">      <a class="code" href="classTimerOutput.html">TimerOutput</a> &amp;     timer,</div><div class="line">      <span class="keyword">const</span> std::string filename)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> check_material_class_results =</div><div class="line">        [](</div><div class="line">          <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;to_verify,</div><div class="line">          <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;blessed,</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-6) {</div><div class="line">          (void)to_verify;</div><div class="line">          (void)blessed;</div><div class="line">          (void)tol;</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(std::abs(blessed.get_psi() - to_verify.get_psi()) &lt; tol,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for psi. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(std::abs(</div><div class="line">                              blessed.get_psi() - to_verify.get_psi()))));</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for B. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for S. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for BB. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for PP. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for HH. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">        };</div><div class="line"></div><div class="line">      std::ostringstream stream;</div><div class="line">      stream</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\n&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(experimental_parameters.start_time(),</div><div class="line">                             experimental_parameters.end_time() +</div><div class="line">                               experimental_parameters.delta_t(),</div><div class="line">                             experimental_parameters.delta_t());</div><div class="line">           time.is_at_end() == <span class="keyword">false</span>;</div><div class="line">           time.advance_time())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (experimental_parameters.print_status(time.get_step_number()))</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep = &quot;</span> &lt;&lt; time.get_step_number()</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; @ time = &quot;</span> &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;s.&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> H =</div><div class="line">            experimental_parameters.get_H(time.get_current_time());</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F =</div><div class="line">            experimental_parameters.get_F(time.get_current_time());</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C =</div><div class="line">            <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">Physics::Elasticity::Kinematics::C</a>(F);</div><div class="line"></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Hand calculated&quot;</span>);</div><div class="line">            material_hand_calculated.update_internal_data(C, H, time);</div><div class="line">            material_hand_calculated.update_end_of_timestep();</div><div class="line">          }</div><div class="line"></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assisted computation&quot;</span>);</div><div class="line">            material_assisted_computation.update_internal_data(C, H, time);</div><div class="line">            material_assisted_computation.update_end_of_timestep();</div><div class="line">          }</div><div class="line"></div><div class="line">          check_material_class_results(material_hand_calculated,</div><div class="line">                                       material_assisted_computation);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> h =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Covariant.html#ad438f09c3045e448805f62b27c2f8d29">Physics::Transformations::Covariant::push_forward</a>(H, F);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> b =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">                  material_hand_calculated.get_B(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> sigma =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">                  material_hand_calculated.get_S(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">              stream &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; h[2] &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; b[2]</div><div class="line">                     &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; F[1][2] * 100.0 &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; sigma[1][2] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">        {</div><div class="line">          std::ofstream output(filename);</div><div class="line">          output &lt;&lt; stream.str();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters          constitutive_parameters;</div><div class="line">      <span class="keyword">const</span> RheologicalExperimentParameters experimental_parameters;</div><div class="line"></div><div class="line">      std::string parameter_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        parameter_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">        std::cout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Coupled magnetoelastic constitutive law using automatic differentiation.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"></div><div class="line">        Magnetoelastic_Constitutive_Law&lt;dim&gt; material(constitutive_parameters);</div><div class="line">        Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt; material_ad(</div><div class="line">          constitutive_parameters);</div><div class="line"></div><div class="line">        run_rheological_experiment(experimental_parameters,</div><div class="line">                                   material,</div><div class="line">                                   material_ad,</div><div class="line">                                   timer,</div><div class="line">                                   experimental_parameters.output_filename_ri);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">        std::cout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Coupled magneto-viscoelastic constitutive law using symbolic differentiation.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_SYMENGINE_WITH_LLVM</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using LLVM optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba7c7d2b9e8389cc541dc5a615e05bcf1e">Differentiation::SD::OptimizerType::llvm</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a1ad0cce13bc606ad6742e9841ccdfe15">Differentiation::SD::OptimizationFlags::optimize_all</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using lambda optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">Differentiation::SD::OptimizerType::lambda</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a3df84265620315a025367510c90d0474">Differentiation::SD::OptimizationFlags::optimize_cse</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        Magnetoviscoelastic_Constitutive_Law&lt;dim&gt; material(</div><div class="line">          constitutive_parameters);</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Initialize symbolic CL&quot;</span>);</div><div class="line">        Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt; material_sd(</div><div class="line">          constitutive_parameters, optimizer_type, optimization_flags);</div><div class="line">        timer.<a class="code" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a>();</div><div class="line"></div><div class="line">        run_rheological_experiment(experimental_parameters,</div><div class="line">                                   material,</div><div class="line">                                   material_sd,</div><div class="line">                                   timer,</div><div class="line">                                   experimental_parameters.output_filename_rd);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace CoupledConstitutiveLaws</span></div><div class="line"></div><div class="line">} <span class="comment">// namespace Step71</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::SimpleExample::run</a>();</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::CoupledConstitutiveLaws::run</a>(argc, argv);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <table class="tutorial" width="50%"> <tr><th
 colspan="2"><b><small>Table of contents</small></b><b><small>Table of
 contents</small></b></th></tr> <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#AmotivationWhywouldIusethesetools">A motivation: Why would I
 use these tools?</a><a href="#AmotivationWhywouldIusethesetools">A
 motivation: Why would I use these tools?</a>
 <li><a href="#Theoryformagnetomechanicalmaterials">Theory for
 magneto-mechanical materials</a><a
 href="#Theoryformagnetomechanicalmaterials">Theory for magneto-mechanical
 materials</a>
 <ul>
 <li><a href="#Thermodynamicprinciples">Thermodynamic principles</a><a
 href="#Thermodynamicprinciples">Thermodynamic principles</a>
 <li><a href="#Constitutivelaws">Constitutive laws</a><a
 href="#Constitutivelaws">Constitutive laws</a>
 <ul>
 <li><a href="#Magnetoelasticconstitutivelaw">Magnetoelastic constitutive
 law</a><a href="#Magnetoelasticconstitutivelaw">Magnetoelastic constitutive
 law</a>
 <li><a href="#Magnetoviscoelasticconstitutivelaw">Magneto-viscoelastic
 constitutive law</a><a
 href="#Magnetoviscoelasticconstitutivelaw">Magneto-viscoelastic
 constitutive law</a>
 </ul>
 </ul>
 <li><a href="#Rheologicalexperiment">Rheological experiment</a><a
 href="#Rheologicalexperiment">Rheological experiment</a>
 <li><a href="#Suggestedliterature">Suggested literature</a><a
 href="#Suggestedliterature">Suggested literature</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a
 href="#AnintroductoryexampleThefundamentalsofautomaticandsymbolicdifferentiation">An
 introductory example: The fundamentals of automatic and symbolic
 differentiation</a><a
 href="#AnintroductoryexampleThefundamentalsofautomaticandsymbolicdifferentiation">An
 introductory example: The fundamentals of automatic and symbolic
 differentiation</a>
 <ul>
 <li><a href="#Ananalyticalfunction">An analytical function</a><a
 href="#Ananalyticalfunction">An analytical function</a>
 <li><a href="#Computingderivativesusingautomaticdifferentiation">Computing
 derivatives using automatic differentiation</a><a
 href="#Computingderivativesusingautomaticdifferentiation">Computing
 derivatives using automatic differentiation</a>
 <li><a
 href="#Handcalculatedderivativesoftheanalyticalsolution">Hand-calculated
 derivatives of the analytical solution</a><a
 href="#Handcalculatedderivativesoftheanalyticalsolution">Hand-calculated
 derivatives of the analytical solution</a>
 <li><a href="#Computingderivativesusingsymbolicdifferentiation">Computing
 derivatives using symbolic differentiation</a><a
 href="#Computingderivativesusingsymbolicdifferentiation">Computing
 derivatives using symbolic differentiation</a>
 <li><a href="#TheSimpleExamplerunfunction">The SimpleExample::run()
 function</a><a href="#TheSimpleExamplerunfunction">The SimpleExample::run()
 function</a>
 </ul>
 <li><a
 href="#AmorecomplexexampleUsingautomaticandsymbolicdifferentiationtocomputederivativesatcontinuumpoints">A
 more complex example: Using automatic and symbolic differentiation to
 compute derivatives at continuum points</a><a
 href="#AmorecomplexexampleUsingautomaticandsymbolicdifferentiationtocomputederivativesatcontinuumpoints">A
 more complex example: Using automatic and symbolic differentiation to
 compute derivatives at continuum points</a>
 <ul>
 <li><a href="#Constitutiveparameters">Constitutive parameters</a><a
 href="#Constitutiveparameters">Constitutive parameters</a>
 <li><a href="#ConstitutivelawsBaseclass">Constitutive laws: Base
 class</a><a href="#ConstitutivelawsBaseclass">Constitutive laws: Base
 class</a>
 <li><a
 href="#Magnetoelasticconstitutivelawusingautomaticdifferentiation">Magnetoelastic
 constitutive law (using automatic differentiation)</a><a
 href="#Magnetoelasticconstitutivelawusingautomaticdifferentiation">Magnetoelastic
 constitutive law (using automatic differentiation)</a>
 <li><a
 href="#Magnetoviscoelasticconstitutivelawusingsymbolicalgebraanddifferentiation">Magneto-viscoelastic
 constitutive law (using symbolic algebra and differentiation)</a><a
 href="#Magnetoviscoelasticconstitutivelawusingsymbolicalgebraanddifferentiation">Magneto-viscoelastic
 constitutive law (using symbolic algebra and differentiation)</a>
 </ul>
 <li><a
 href="#AmorecomplexexamplecontinuedParametersandhandderivedmaterialclasses">A
 more complex example (continued): Parameters and hand-derived material
 classes</a><a
 href="#AmorecomplexexamplecontinuedParametersandhandderivedmaterialclasses">A
 more complex example (continued): Parameters and hand-derived material
 classes</a>
 <ul>
 <li><a href="#Magnetoelasticconstitutivelawhandderived">Magnetoelastic
 constitutive law (hand-derived)</a><a
 href="#Magnetoelasticconstitutivelawhandderived">Magnetoelastic
 constitutive law (hand-derived)</a>
 <li><a
 href="#Magnetoviscoelasticconstitutivelawhandderived">Magneto-viscoelastic
 constitutive law (hand-derived)</a><a
 href="#Magnetoviscoelasticconstitutivelawhandderived">Magneto-viscoelastic
 constitutive law (hand-derived)</a>
 <li><a href="#Rheologicalexperimentparameters">Rheological experiment
 parameters</a><a href="#Rheologicalexperimentparameters">Rheological
 experiment parameters</a>
 <li><a
 href="#RheologicalexperimentParallelplaterotationalrheometer">Rheological
 experiment: Parallel plate rotational rheometer</a><a
 href="#RheologicalexperimentParallelplaterotationalrheometer">Rheological
 experiment: Parallel plate rotational rheometer</a>
 <li><a href="#TheCoupledConstitutiveLawsrunfunction">The
 CoupledConstitutiveLaws::run() function</a><a
 href="#TheCoupledConstitutiveLawsrunfunction">The
 CoupledConstitutiveLaws::run() function</a>
 </ul>
 <li><a href="#Themainfunction">The main() function</a><a
 href="#Themainfunction">The main() function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Introductoryexample">Introductory example</a><a
 href="#Introductoryexample">Introductory example</a>
 <li><a href="#Constitutivemodelling">Constitutive modelling</a><a
 href="#Constitutivemodelling">Constitutive modelling</a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Jean-Paul Pelteret. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The aim of this tutorial is, quite simply, to introduce the fundamentals of both<a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic</a>and <a href="https://en.wikipedia.org/wiki/Computer_algebra">symbolic differentiation</a>(respectively abbreviated as ADand SD): Ways in which one can, in source code, describe a function \(\mathbf f(\mathbf x)\) and automatically also obtain a representation of derivatives \(\nabla \mathbf f(\mathbf x)\) (the "Jacobian"), \(\nabla^2 \mathbf f(\mathbf x)\) (the "Hessian"), etc., without havingto write additional lines of code. Doing this is quite helpful insolving nonlinear or optimization problems where one would like toonly describe the nonlinear equation or the objective function in thecode, without having to also provide their derivatives (which arenecessary for a Newton method for solving a nonlinear problem, or forfinding a minimizer). Since AD and SD tools are somewhat independent of finite elements and boundary valueproblems, this tutorial is going to be different to the others that you may haveread beforehand. It will focus specifically on how these frameworks work andthe principles and thinking behind them, and will forgo looking at them in thedirect context of a finite element simulation. We will, in fact, look at two different sets of problems that have greatlydifferent levels of complexity, but when framed properly hold sufficientsimilarity that the same AD and SD frameworks can be leveraged. With theseexamples the aim is to build up an understanding of the steps that are requiredto use the AD and SD tools, the differences between them, and hopefully identifywhere they could be immediately be used in order to improve or simplify existingcode. It's plausible that you're wondering what AD and SD are, in the first place. Well,that question is easy to answer but without context is not very insightful. Sowe're not going to cover that in this introduction, but will rather defer thisuntil the first introductory example where we lay out the key points as thisexample unfolds. To complement this, we should mention that the core theory forboth frameworks is extensively discussed in the <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module, soit bears little repeating here. Since we have to picksome* sufficiently interesting topic to investigateand identify where AD and SD can be used effectively, the main problem that'simplemented in the second half of the tutorial is one of modeling a coupledconstitutive law, specifically a magneto-active material (with hysteretic effects).As a means of an introduction to that, later in the introduction some groundingtheory for that class of materials will be presented.Naturally, this is not a field (or even a class of materials) that is ofinterest to a wide audience. Therefore, the author wishes to express up frontthat this theory and any subsequent derivations mustn't be considered the focusof this tutorial. Instead, keep in mind the complexity of the problem that arisesfrom the relatively innocuous description of the constitutive law, and what wemight (in the context of a boundary value problem) need to derive from that.We will perform some computations with these constitutive laws at the level of arepresentative continuum point (so, remaining in the realm of continuummechanics), and will produce some benchmark results around which we can framea final discussion on the topic of computational performance. Once we have the foundation upon which we can build further concepts, wewill see how AD in particular can be exploited at a finite element (rather thancontinuum) level: this is a topic that is covered in <a class="el" href="step_72.html">step-72</a> , as well as <a class="el" href="step_33.html">step-33</a> .But before then, let's take a moment to think about why we might want to considerusing these sorts of tools, and what benefits they can potentially offer you.</p>
<p><a class="anchor" id="AmotivationWhywouldIusethesetools"></a></p><h3>A motivation: Why would I use these tools?</h3>
<p>The primary driver for using AD or SD is typically that there is some situationthat requires differentiation to be performed, and that doing so is sufficientlychallenging to make the prospect of using an external tool to perform that specifictask appealing. A broad categorization for the circumstances under which AD orSD can be rendered most useful include (but are probably not limited to) thefollowing:</p>
<ul>
<li><b>Rapid prototyping:</b> For a new class of problems where you're trying to implement a solution quickly, and want to remove some of the intricate details (in terms of both the mathematics as well as the organizational structure of the code itself). You might be willing to justify any additional computational cost, which would be offset by an increased agility in restructuring your code or modifying the part of the problem that is introducing some complex nonlinearity with minimal effort.</li>
<li><b>Complex problems:</b> It could very well be that some problems just happen to have a nonlinearity that is incredibly challenging to linearize or formulate by hand. Having this challenge taken care of for you by a tool that is, for the most part, robust, reliable, and accurate may alleviate some of the pains in implementing certain problems. Examples of this include <a class="el" href="step_15.html">step-15</a> , where the derivative of the nonlinear PDE we solve is not incredibly difficult to derive, but sufficiently cumbersome that one has to pay attention in doing so by hand, and where implementing the corresponding finite element formulation of the Newton step takes more than just the few lines that it generally takes to implement the bilinear form; <a class="el" href="step_33.html">step-33</a> (where we actually use AD) is an even more extreme example.</li>
<li><b>Verification:</b> For materials and simulations that exhibit nonlinear response, an accurate rather than only approximate material tangent (the term mechanical engineers use for the derivative of a material law) can be the difference between convergent and divergent behavior, especially at high external (or coupling) loads. As the complexity of the problem increases, so do the opportunities to introduce subtle (or, perhaps, not-so-subtle) errors that produce predictably negative results. Additionally, there is a lot to be gained by verifying that the implementation is completely correct. For example, certain categories of problems are known to exhibit instabilities, and therefore when you start to lose quadratic convergence in a nonlinear solver (e.g., Newton's method) then this may not be a huge surprise to the investigator. However, it is hard (if not impossible) to distinguish between convergence behavior that is produced as you near an unstable solution and when you simply have an error in the material or finite element linearization, and start to drift off the optimal convergence path due to that. Having a method of verifying the correctness of the implementation of a constitutive law linearization, for example, is perhaps the only meaningful way that you can use to catch such errors, assuming that you've got nobody else to scrutinize your code. Thankfully, with some tactical programming it is quite straight-forward to structure a code for reuse, such that you can use the same classes in production code and directly verify them in, for instance, a unit-test framework. This tutorial program will have two parts: One where we just introducethe basic ideas of automatic and symbolic differentiation support indeal.II using a simple set of examples; and one where we apply this toa realistic but much more complicated case. For that second half, thenext section will provide some background on magneto-mechanicalmaterials</li>
<li>you can skip this section if all you want to learnabout is what AD and SD actually are, but you probably want to readover this section if you are interested in how to apply AD and SD forconcrete situations.</li>
</ul>
<p><a class="anchor" id="Theoryformagnetomechanicalmaterials"></a></p><h3>Theory for magneto-mechanical materials</h3>
<p><a class="anchor" id="Thermodynamicprinciples"></a></p><h4>Thermodynamic principles</h4>
<p>As a prelude to introducing the coupled magneto-mechanical material law that we'll useto model a magneto-active polymer, we'll start with a very concise summary ofthe salient thermodynamics to which these constitutive laws must subscribe.The basis for the theory, as summarized here, is described in copious detail byTruesdell and Toupin <b>[Truesdell1960a]</b> and Coleman and Noll <b>[Coleman1963a]</b> ,and follows the logic laid out by Holzapfel <b>[Holzapfel2007a]</b> . Starting from the first law of thermodynamics, and following a few technicalassumptions, it can be shown the the balance between the kinetic plus internalenergy rates and the power supplied to the system from externalsources is given by the following relationship that equates the rateof change of the energy in an (arbitrary) volume \(V\) on the left, andthe sum of forces acting on that volume on the right: </p><p class="formulaDsp">
\[ D_{t} \int\limits_{V} \left[ \frac{1}{2} \rho_{0} \mathbf{v} \cdot \mathbf{v} + U^{*}_{0} \right] dV = \int\limits_{V} \left[ \rho_{0} \mathbf{v} \cdot \mathbf{a} + \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - D_{t} M^{*}_{0} - \nabla_{0} \cdot \mathbf{Q} + R_{0} \right] dV . \]
</p>
<p> \(D_{t}\) represents the total time derivative, \(\rho_{0}\) is the material density as measured in the Lagrangian reference frame, \(\mathbf{v}\) is the material velocity and \(\mathbf{a}\) its acceleration, \(U^{*}_{0}\) is the internal energy per unit reference volume, \(\mathbf{P}^{\text{tot}}\) is the total Piola stress tensor and \(\dot{\mathbf{F}}\) isthe time rate of the deformation gradient tensor, \(\boldsymbol{\mathbb{H}}\) and \(\boldsymbol{\mathbb{B}}\) are, respectively, the magnetic field vector and themagnetic induction (or magnetic flux density) vector, \(\mathbb{E}\) and \(\mathbb{D}\) are the electric field vector and electricdisplacement vector, and \(\mathbf{Q}\) and \(R_{0}\) represent the referential thermal flux vector and thermalsource.The material differential operator \(\nabla_{0} (\bullet) \dealcoloneq \frac{d(\bullet)}{d\mathbf{X}}\) where \(\mathbf{X}\) is the material position vector.With some rearrangement of terms, invoking the arbitrariness of the integrationvolume \(V\) , the total internal energy density rate \(\dot{E}_{0}\) can be identified as </p><p class="formulaDsp">
\[ \dot{E}_{0} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \nabla_{0} \cdot \mathbf{Q} + R_{0} . \]
</p>
<p> total internal energy includes contributions that arise not only due tomechanical deformation (the first term), and thermal fluxes and sources (thefourth and fifth terms), but also due to the intrinsic energy stored in themagnetic and electric fields themselves (the second and third terms,respectively). The second law of thermodynamics, known also as the entropy inequality principle,informs us that certain thermodynamic processes are irreversible. After accountingfor the total entropy and rate of entropy input, the Clausius-Duhem inequalitycan be derived. In local form (and in the material configuration), this reads </p><p class="formulaDsp">
\[ \theta \dot{\eta}_{0} - R_{0} + \nabla_{0} \cdot \mathbf{Q} - \frac{1}{\theta} \nabla_{0} \theta \cdot \mathbf{Q} \geq 0 . \]
</p>
<p> quantity \(\theta\) is the absolute temperature, and \(\eta_{0}\) represents the entropy per unit reference volume. Using this to replace \(R_{0} - \nabla_{0} \cdot \mathbf{Q}\) in the resultstemming from the first law of thermodynamics, we now have the relation </p><p class="formulaDsp">
\[ \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} + \theta \dot{\eta}_{0} - \dot{E}_{0} - \frac{1}{\theta} \nabla_{0} \theta \cdot \mathbf{Q} \geq 0 . \]
</p>
<p> the basis of Fourier's law, which informs us that heat flows from regionsof high temperature to low temperature, the last term is always positive andcan be ignored.This renders the local dissipation inequality </p><p class="formulaDsp">
\[ \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \left[ \dot{E}_{0} - \theta \dot{\eta}_{0} \right] \geq 0 . \]
</p>
<p> is postulated <b>[Holzapfel2007a]</b> that the Legendre transformation </p><p class="formulaDsp">
\[ \psi^{*}_{0} = \psi^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}}, \mathbb{D}, \theta \right) = E_{0} - \theta \eta_{0} , \]
</p>
<p> which we may define the free energy density function \(\psi^{*}_{0}\) with the statedparameterization, exists and is valid.Taking the material rate of this equation and substituting it into the localdissipation inequality results in the generic expression </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \dot{\theta} \eta_{0} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}}, \mathbb{D}, \theta \right) \geq 0 . \]
</p>
<p> the assumption of isothermal conditions, and that the electric field doesnot excite the material in a manner that is considered non-negligible, then thisdissipation inequality reduces to </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}} \right) \geq 0 . \]
</p>
<p> <a class="anchor" id="Constitutivelaws"></a></p><h4>Constitutive laws</h4>
<p>When considering materials that exhibit mechanically dissipative behavior,it can be shown that this can be captured within the dissipation inequalitythrough the augmentation of the material free energy density function with additionalparameters that represent internal variables <b>[Holzapfel1996a]</b> . Consequently,we write it as </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{B}} \right) \geq 0 . \]
</p>
<p> \(\mathbf{F}_{v}^{i} = \mathbf{F}_{v}^{i} \left( t \right)\) represents theinternal variable (which acts like a measure of the deformation gradient)associated with the <code>i</code>th mechanical dissipative (viscous) mechanism.As can be inferred from its parameterization, each of these internal parametersis considered to evolve in time.Currently the free energy density function \(\psi^{*}_{0}\) is parameterized in terms ofthe magnetic induction \(\boldsymbol{\mathbb{B}}\) . This is the natural parameterization thatcomes as a consequence of the considered balance laws. Should such a class ofmaterials to be incorporated within a finite-element model, it would be ascertainedthat a certain formulation of the magnetic problem, known as the magnetic vectorpotential formulation, would need to be adopted. This has its own set of challenges,so where possible the more simple magnetic scalar potential formulation may bepreferred. In that case, the magnetic problem needs to be parameterized in termsof the magnetic field \(\boldsymbol{\mathbb{H}}\) . To make this re-parameterization, we executea final Legendre transformation </p><p class="formulaDsp">
\[ \tilde{\psi}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) = \psi^{*}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{B}} \right) - \boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{B}} . \]
</p>
<p> the same time, we may take advantage of the principle of material frameindifference in order to express the energy density function in terms of symmetricdeformation measures: </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) = \tilde{\psi}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) . \]
</p>
<p> upshot of these two transformations (leaving out considerable explicit andhidden details) renders the final expression for the reduced dissipationinequality as </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{S}^{\text{tot}} : \frac{1}{2} \dot{\mathbf{C}} - \boldsymbol{\mathbb{B}} \cdot \dot{\boldsymbol{\mathbb{H}}} - \dot{\psi}_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \geq 0 . \]
</p>
<p>(Notice the sign change on the second term on the right hand side, and thetransfer of the time derivative to the magnetic induction vector.)The stress quantity \(\mathbf{S}^{\text{tot}}\) is known as the total Piola-Kirchhoffstress tensor and its energy conjugate \(\mathbf{C} = \mathbf{F}^{T} \cdot \mathbf{F}\) is the right Cauchy-Green deformation tensor, and \(\mathbf{C}_{v}^{i} = \mathbf{C}_{v}^{i} \left( t \right)\) is the re-parameterizedinternal variable associated with the <code>i</code>th mechanical dissipative (viscous)mechanism. Expansion of the material rate of the energy density function, and rearrangement of thevarious terms, results in the expression </p><p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \left[ \mathbf{S}^{\text{tot}} - 2 \frac{\partial \psi_{0}}{\partial \mathbf{C}} \right] : \frac{1}{2} \dot{\mathbf{C}} - \sum\limits_{i}\left[ 2 \frac{\partial \psi_{0}}{\partial \mathbf{C}_{v}^{i}} \right] : \frac{1}{2} \dot{\mathbf{C}}_{v}^{i} + \left[ - \boldsymbol{\mathbb{B}} - \frac{\partial \psi_{0}}{\partial \boldsymbol{\mathbb{H}}} \right] \cdot \dot{\boldsymbol{\mathbb{H}}} \geq 0 . \]
</p>
<p> this point, its worth noting the use of the<a href="https://en.wikipedia.org/wiki/Partial_derivative">partial derivatives</a> \(\partial \left( \bullet \right)\) . This is an important detail that will befundamental to a certain design choice made within the tutorial.As brief reminder of what this signifies, the partial derivative of amulti-variate function returns the derivative of that function with respectto one of those variables while holding the others constant: </p><p class="formulaDsp">
\[ \frac{\partial f\left(x, y\right)}{\partial x} = \frac{d f\left(x, y\right)}{d x} \Big\vert_{y} . \]
</p>
<p> specific to what's encoded in the dissipation inequality (with the very generalfree energy density function \(\psi_{0}\) with its parameterization yet to be formalized),if one of the input variables is a function of another, it is also held constantand the chain rule does not propagate any further, while the computing totalderivative would imply judicious use of the chain rule. This can be betterunderstood by comparing the following two statements: </p><p class="formulaDsp">
\begin{align*} \frac{\partial f\left(x, y\left(x\right)\right)}{\partial x} &amp;= \frac{d f\left(x, y\left(x\right)\right)}{d x} \Big\vert_{y} \\ \frac{d f\left(x, y\left(x\right)\right)}{d x} &amp;= \frac{d f\left(x, y\left(x\right)\right)}{d x} \Big\vert_{y} + \frac{d f\left(x, y\left(x\right)\right)}{d y} \Big\vert_{x} \frac{d y\left(x\right)}{x} . \end{align*}
</p>
<p>Returning to the thermodynamics of the problem, we next exploit the arbitrarinessof the quantities \(\dot{\mathbf{C}}\) and \(\dot{\boldsymbol{\mathbb{H}}}\) ,by application of the Coleman-Noll procedure <b>[Coleman1963a]</b> , <b>[Coleman1967a]</b> .This leads to the identification of the kinetic conjugate quantities </p><p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}} = \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} , \\ \boldsymbol{\mathbb{B}} = \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} . \]
</p>
<p>(Again, note the use of the partial derivatives to define the stress and magneticinduction in this generalized setting.)From what terms remain in the dissipative power (namely those related to themechanical dissipative mechanisms), if they are assumed to be independent ofone another then, for each mechanism <code>i</code>, </p><p class="formulaDsp">
\[ \frac{\partial \psi_{0}}{\partial \mathbf{C}_{v}^{i}} : \dot{\mathbf{C}}_{v}^{i} \leq 0 . \]
</p>
<p> constraint must be satisfied through the appropriate choice of free energyfunction, as well as a carefully considered evolution law for the internalvariables. In the case that there are no dissipative mechanisms to be captured within theconstitutive model (e.g., if the material to be modelled is magneto-hyperelastic)then the free energy density function \(\psi_{0} = \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) reduces to a storedenergy density function, and the total stress and magnetic induction can be simplified </p><p class="formulaDsp">
\begin{align*} \mathbf{S}^{\text{tot}} = \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;\dealcoloneq 2 \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} , \\ \boldsymbol{\mathbb{B}} = \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;\dealcoloneq - \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} , \end{align*}
</p>
<p> where the operator \(d\) denotes the total derivative operation. For completeness, the linearization of the stress tensor and magnetic inductionare captured within the fourth-order total referential elastic tangent tensor \(\mathcal{H}^{\text{tot}} \) , the second-order magnetostatic tangent tensor \(\mathbb{D}\) and thethird-order total referential magnetoelastic coupling tensor \(\mathfrak{P}^{\text{tot}}\) .Irrespective of the parameterization of \(\mathbf{S}^{\text{tot}}\) and \(\boldsymbol{\mathbb{B}}\) ,these quantities may be computed by </p><p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} &amp;= 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} , \\ \mathbb{D} &amp;= \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} &amp;= - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} , \\ \left[ \mathfrak{P}^{\text{tot}} \right]^{T} &amp;= 2 \frac{d \boldsymbol{\mathbb{B}}}{d \mathbf{C}} . \end{align*}
</p>
<p> For the case of rate-dependent materials, this expands to </p><p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= 4 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C} \otimes d \mathbf{C}} , \\ \mathbb{D} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= -\frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \mathbf{C}} , \\ \left[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \right]^{T} &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} , \end{align*}
</p>
<p> while for rate-independent materials the linearizations are </p><p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= 4 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C} \otimes d \mathbf{C}} , \\ \mathbb{D} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= -\frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \mathbf{C}} , \\ \left[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \right]^{T} &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} . \end{align*}
</p>
<p> The subtle difference between them is the application of a partial derivative duringthe calculation of the first derivatives. We'll see later how this affects the choiceof AD versus SD for this specific application. For now, we'll simply introducethe two specific materials that are implemented within this tutorial. <a class="anchor" id="Magnetoelasticconstitutivelaw"></a></p><h5>Magnetoelastic constitutive law</h5>
<p>The first material that we'll consider is one that is governed by amagneto-hyperelastic constitutive law. This material responds to bothdeformation as well as immersion in a magnetic field, but exhibits notime- or history-dependent behavior (such as dissipation through viscousdamping or magnetic hysteresis, etc.). Thestored energy densityfunction* for such a material is only parameterized in terms of the(current) field variables, but not their time derivatives or past values. We'll choose the energy density function, which captures both the energystored in the material due to deformation and magnetization, as well asthe energy stored in the magnetic field itself, to be </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p> for which the variable \(d = \text{tr}(\mathbf{I})\) ( \(\mathbf{I}\) being the rank-2 identity tensor) represents the spatial dimension and \(\mathbf{F}\) is the deformation gradient tensor. To give some briefbackground to the various components of \(\psi_{0}\) , the first two termsbear a great resemblance to the stored energy density function for a(hyperelastic) Neohookean material. The only difference between what'sused here and the Neohookean material is the scaling of the elastic shearmodulus by the magnetic field-sensitive saturation function \(f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)\) (see <b>[Pelteret2018a]</b> , equation29). This function will, in effect, cause the material to stiffen in thepresence of a strong magnetic field. As it is governed by a sigmoid-typefunction, the shear modulus will asymptotically converge on the specifiedsaturation shear modulus. It can also be shown that the last term in \(\psi_{0}\) is the stored energy density function for magnetic field (asderived from first principles), scaled by the relative permeabilityconstant. This definition collectively implies that the material islinearly magnetized, i.e., the magnetization vector and magnetic fieldvector are aligned. (This is certainly not obvious with the magnetic energystated in its current form, but when the magnetic induction and magnetizationare derived from \(\psi_{0}\) and all magnetic fields are expressed in the <em> current configuration </em> then this correlation becomes clear.)As for the specifics of what the magnetic induction, stress tensor, and thevarious material tangents look like, we'll defer presenting these to thetutorial body where the full, unassisted implementation of the constitutivelaw is defined. <a class="anchor" id="Magnetoviscoelasticconstitutivelaw"></a></p><h5>Magneto-viscoelastic constitutive law</h5>
<p>The second material that we'll formulate is one for amagneto-viscoelastic material with a single dissipative mechanism <code>i</code>.Thefree energy density function* that we'll be considering is defined as </p><p class="formulaDsp">
\begin{align*} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \\ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \\ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \end{align*}
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p> the evolution law </p><p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \left( \mathbf{C} \right) = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v} \right] \]
</p>
<p> the internal viscous variable.We've chosen the magnetoelastic part of the energy \(\psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) to match that of the first material model that we explored, so this partneeds no further explanation. As for the viscous part \(\psi_{0}^{MVE}\) ,this component of the free energy (in conjunction with the evolution law forthe viscous deformation tensor) is taken from <b>[Linder2011a]</b> (with theadditional scaling by the viscous saturation function described in <b>[Pelteret2018a]</b> ). It is derived in a thermodynamically consistentframework that, at its core, models the movement of polymer chains on amicro-scale level. To proceed beyond this point, we'll also need to consider the timediscretization of the evolution law.Choosing the implicit first-order backwards difference scheme, then </p><p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \approx \frac{\mathbf{C}_{v}^{(t)} - \mathbf{C}_{v}^{(t-1)}}{\Delta t} = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v}^{(t)} \right] \]
</p>
<p> the superscript \((t)\) denotes that the quantity is taken at thecurrent timestep, and \((t-1)\) denotes quantities taken at the previoustimestep (i.e., a history variable). The timestep size \(\Delta t\) is thedifference between the current time and that of the previous timestep.Rearranging the terms so that all internal variable quantities at thecurrent time are on the left hand side of the equation, we get </p><p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p> matches <b>[Linder2011a]</b> equation 54. <a class="anchor" id="Rheologicalexperiment"></a></p><h3>Rheological experiment</h3>
<p>Now that we have shown all of these formulas for the thermodynamics and theorygoverning magneto-mechanics and constitutive models, let us outline what theprogram will do with all of this.We wish to do somethingmeaningful* with the materials laws that we've formulated,and so it makes sense to subject them to some mechanical and magnetic loadingconditions that are, in some way, representative of some conditions that mightbe found either in an application or in a laboratory setting. One way to achievethat aim would be to embed these constitutive laws in a finite element model tosimulate a device. In this instance, though, we'll keep things simple (we arefocusing on the automatic and symbolic differentiation concepts, after all)and will find a concise way to faithfully replicate an industry-standardrheological experiment using an analytical expression for the loading conditions. The rheological experiment that we'll reproduce,which idealizes a laboratory experiment that was used to characterizemagneto-active polymers, is detailed in <b>[Pelteret2018a]</b> (as well as <b>[Pelteret2019a]</b> , in which it is documented along with thereal-world experiments). The images below provide a visual description ofthe problem set up. </p><table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.parallel_plate-geometry.png" height="300"/>
</div>
 <p>The basic functional geometry of the parallel-plate rotational rheometer. The smooth rotor (blue) applies a torque to an experimental sample (red) of radius \(r\) and height \(H\) while an axially aligned magnetic field generated by a a magneto-rheological device. Although the time-dependent deformation profile of the may be varied, one common experiment would be to subject the material to a harmonic torsional deformation of constant amplitude and frequency \(\omega\). </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.parallel_plate-kinematics.png" height="300"/>
</div>
 <p>Schematic of the kinematics of the problem, assuming no preloading or compression of the sample. A point \(\mathbf{P}\) located at azimuth \(\Theta\) is displaced to location \(\mathbf{p}\) at azimuth \(\theta = \Theta + \alpha\). </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>Under the assumptions that an incompressible medium is being tested,and that the deformation profile through the sample thickness is linear,then the displacement at some measurement point \(\mathbf{X}\) withinthe sample, expressed in radial coordinates, is </p><p class="formulaDsp">
\begin{align*} r(\mathbf{X}) &amp;= \frac{R(X_{1}, X_{2})}{\sqrt{\lambda_{3}}} , \\ \theta(\mathbf{X}) &amp; = \Theta(X_{1}, X_{2}) + \underbrace{\tau(t) \lambda_{3} X_{3}}_{\alpha(X_{3}, t)} , \\ z(\mathbf{X}) &amp;= \lambda_{3} X_{3} \end{align*}
</p>
<p> where \(R(X_{1}, X_{2})\) and \(\Theta(X_{1}, X_{2})\) are the radius at</p>
<ul>
<li>and angle of</li>
<li>the sampling point, \(\lambda_{3}\) is the (constant) axial deformation, \(\tau(t) = \frac{A}{RH} \sin\left(\omega t\right)\) is the time-dependenttorsion angle per unit length that will be prescribed using asinusoidally repeating oscillation of fixed amplitude \(A\) .The magnetic field is aligned axially, i.e., in the \(X_{3}\) direction. This summarizes everything that we need to fully characterize the idealizedloading at any point within the rheological sample. We'll set up the problemin such a way that we "pick" a representative point with this sample, andsubject it to a harmonic shear deformation at a constant axial deformation(by default, a compressive load) and a constant, axially applied magneticfield. We will record the stress and magnetic induction at this point, andwill output that data to file for post-processing. Although its not necessaryfor this particular problem, we will also be computing the tangents as well.Even though they are not directly used in this particular piece of work, thesesecond derivatives are needed to embed the constitutive law within afinite element model (one possible extension to this work). We'll thereforetake the opportunity to check our hand calculations for correctness usingthe assisted differentiation frameworks. <a class="anchor" id="Suggestedliterature"></a><h3>Suggested literature</h3>
</li>
</ul>
<p>In addition to the already mentioned <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module, the following are a fewreferences that discuss in more detail</p>
<ul>
<li>magneto-mechanics, and some aspects of automated differentiation frameworks: <b>[Pao1978a]</b> , <b>[Pelteret2019a]</b> , and</li>
<li>the automation of finite element frameworks using AD and/or SD: <b>[Logg2012a]</b> , <b>[Korelc2016a]</b> . <br />
</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>We start by including all the necessary deal.II header files and some C++ related ones. This first header will give us access to a data structure that will allow us to store arbitrary data within it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="general__data__storage_8h.html">deal.II/algorithms/general_data_storage.h</a>&gt;</span></div></div><!-- fragment --><p>Next come some core classes, including one that provides an implementation for time-stepping.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numbers_8h.html">deal.II/base/numbers.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="symmetric__tensor_8h.html">deal.II/base/symmetric_tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>Then some headers that define some useful coordinate transformations and kinematic relationships that are often found in nonlinear elasticity.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transformations_8h.html">deal.II/physics/transformations.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinematics_8h.html">deal.II/physics/elasticity/kinematics.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="standard__tensors_8h.html">deal.II/physics/elasticity/standard_tensors.h</a>&gt;</span></div></div><!-- fragment --><p>The following two headers provide all of the functionality that we need to perform automatic differentiation, and use the symbolic computer algebra system that deal.II can utilize. The headers of all automatic differentiation and symbolic differentiation wrapper classes, and any ancillary data structures that are required, are all collected inside these unifying headers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sd_8h.html">deal.II/differentiation/sd.h</a>&gt;</span></div></div><!-- fragment --><p>Including this header allows us the capability to write output to a file stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>As per usual, the entire tutorial program is defined within its own unique namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step71</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="AnintroductoryexampleThefundamentalsofautomaticandsymbolicdifferentiation"></a> </p><h3>An introductory example: The fundamentals of automatic and symbolic differentiation</h3>
<p>Automatic and symbolic differentiation have some magical and mystical qualities. Although their use in a project can be beneficial for a multitude of reasons, the barrier to understanding how to use these frameworks or how they can be leveraged may exceed the patience of the developer that is trying to (reliably) integrate them into their work. Although it is the wish of the author to successfully illustrate how these tools can be integrated into workflows for finite element modelling, it might be best to first take a step back and start right from the basics. So to start off with, we'll first have a look at differentiating a "simple" mathematical function using both frameworks, so that the fundamental operations (both their sequence and function) can be firmly established and understood with minimal complication. In the second part of this tutorial we will put these fundamentals into practice and build on them further. Accompanying the description of the algorithmic steps to use the frameworks will be a simplified view as to what theymight* be doing in the background. This description will be very much one designed to aid understanding, and the reader is encouraged to view the <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module documentation for a far more formal description into how these tools actually work.</p>
<p><a class="anchor" id="Ananalyticalfunction"></a> </p><h4>An analytical function</h4>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SimpleExample</div><div class="line">{</div></div><!-- fragment --><p>In order to convince the reader that these tools are indeed useful in practice, let us choose a function for which it is not too difficult to compute the analytical derivatives by hand. It's just sufficiently complicated to make you think about whether or not you truly want to go through with this exercise, and might also make you question whether you are completely sure that your calculations and implementation for its derivatives are correct. The point, of course, is that differentiation of functions is in a sense relatively formulaic and should be something computers are good at</p>
<ul>
<li>if we could build on existing software that understands the rules, we wouldn't have to bother with doing it ourselves. We choose the two variable trigonometric function \(f(x,y) = \cos\left(\frac{y}{x}\right)\) for this purpose. Notice that this function is templated on the number type. This is done because we can often (but not always) use special auto-differentiable and symbolic types as drop-in replacements for real or complex valued types, and these will then perform some elementary calculations, such as evaluate a function value along with its derivatives. We will exploit that property and make sure that we need only define our function once, and then it can be re-used in whichever context we wish to perform differential operations on it.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumberType&gt;</div><div class="line"><a class="code" href="classNumberType.html">NumberType</a> f(<span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x);</div><div class="line">}</div></div><!-- fragment --><p>Rather than revealing this function's derivatives immediately, we'll forward declare functions that return them and defer their definition to later. As implied by the function names, they respectively return the derivatives \(\frac{df(x,y)}{dx}\) :</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{df(x,y)}{dy}\) :</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx^{2}}\) :</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx dy}\) :</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy dx}\) :</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>and, lastly, \(\frac{d^{2}f(x,y)}{dy^{2}}\) :</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p><a class="anchor" id="Computingderivativesusingautomaticdifferentiation"></a> </p><h4>Computing derivatives using automatic differentiation</h4>
<p>To begin, we'll use AD as the tool to automatically compute derivatives for us. We will evaluate the function with the arguments <code>x</code> and <code>y</code>, and expect the resulting value and all of the derivatives to match to within the given tolerance.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">run_and_verify_ad(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">{</div></div><!-- fragment --><p>Our function \(f(x,y)\) is a scalar-valued function, with arguments that represent the typical input variables that one comes across in algebraic calculations or tensor calculus. For this reason, the <a class="el" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction</a> class is the appropriate wrapper class to use to do the computations that we require. (As a point of comparison, if the function arguments represented finite element cell degrees-of-freedom, we'd want to treat them differently.) The spatial dimension of the problem is irrelevant since we have no vector- or tensor-valued arguments to accommodate, so the <code>dim</code> template argument is arbitrarily assigned a value of 1. The second template argument stipulates which AD framework will be used (deal.II has support for several external AD frameworks), and what the underlying number type provided by this framework is to be used. This number type influences the maximum order of the differential operation, and the underlying algorithms that are used to compute them. Given its template nature, this choice is a compile-time decision because many (but not all) of the AD libraries exploit compile-time meta-programming to implement these special number types in an efficient manner. The third template parameter states what the result type is; in our case, we're working with <code>double</code>s.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     dim = 1;</div><div class="line">constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"><span class="keyword">using</span> ADHelper =</div><div class="line">  <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div></div><!-- fragment --><p>It is necessary that we pre-register with our <code>ADHelper</code> class how many arguments (what we will call "independent variables") the function \(f(x,y)\) has. Those arguments are <code>x</code> and <code>y</code>, so obviously there are two of them.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = 2;</div></div><!-- fragment --><p>We now have sufficient information to create and initialize an instance of the helper class. We can also get the concrete number type that will be used in all subsequent calculations. This is useful, because we can write everything from here on by referencing this type, and if we ever want to change the framework used, or number type (e.g., if we need more differential operations) then we need only adjust the <code>ADTypeCode</code> template parameter.</p>
<div class="fragment"><div class="line">ADHelper ad_helper(n_independent_variables);</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div></div><!-- fragment --><p>The next step is to register the numerical values of the independent variables with the helper class. This is done because the function and its derivatives will be evaluated for exactly these arguments. Since we register them in the order <code>{x,y}</code>, the variable <code>x</code> will be assigned component number <code>0</code>, and <code>y</code> will be component <code>1</code></p>
<ul>
<li>a detail that will be used in the next few lines.</li>
</ul>
<div class="fragment"><div class="line">ad_helper.register_independent_variables({x, y});</div></div><!-- fragment --><p>We now ask for the helper class to give to us the independent variables with their auto-differentiable representation. These are termed "sensitive
 variables", because from this point on any operations that we do with the components <code>independent_variables_ad</code> are tracked and recorded by the AD framework, and will be considered when we ask for the derivatives of something that they're used to compute. What the helper returns is a <code>vector</code> of auto-differentiable numbers, but we can be sure that the zeroth element represents <code>x</code> and the first element <code>y</code>. Just to make completely sure that there's no ambiguity of what number type these variables are, we suffix all of the auto-differentiable variables with <code>ad</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; independent_variables_ad =</div><div class="line">  ad_helper.get_sensitive_variables();</div><div class="line"><span class="keyword">const</span> ADNumberType &amp;x_ad = independent_variables_ad[0];</div><div class="line"><span class="keyword">const</span> ADNumberType &amp;y_ad = independent_variables_ad[1];</div></div><!-- fragment --><p>We can immediately pass in our sensitive representation of the independent variables to our templated function that computes \(f(x,y)\) . This also returns an auto-differentiable number.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType f_ad = f(x_ad, y_ad);</div></div><!-- fragment --><p>So now the natural question to ask is what we have actually just computed by passing these special <code>x_ad</code> and <code>y_ad</code> variables to the function <code>f</code>, instead of the original <code>double</code> variables <code>x</code> and <code>y</code>? In other words, how is all of this related to the computation of the derivatives that we were wanting to determine? Or, more concisely: What is so special about this returned <code>ADNumberType</code> object that gives it the ability to magically return derivatives? In essence, how thiscould* be done is the following: This special number can be viewed as a data structure that stores the function value, and the prescribed number of derivatives. For a once-differentiable number expecting two arguments, it might look like this: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line"><span class="keyword">struct </span>ADNumberType</div><div class="line">{</div><div class="line"><span class="keywordtype">double</span> value;          <span class="comment">// The value of the object</span></div><div class="line"><span class="keywordtype">double</span> derivatives[2]; <span class="comment">// Array of derivatives of the object with</span></div><div class="line">                       <span class="comment">// respect to x and y</span></div><div class="line">};</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> For our independent variable <code>x_ad</code>, the starting value of <code>x_ad.value</code> would simply be its assigned value (i.e., the real value of that this variable represents). The derivative <code>x_ad.derivatives[0]</code> would be initialized to <code>1</code>, since <code>x</code> is the zeroth independent variable and \(\frac{d(x)}{dx} = 1\) . The derivative <code>x.derivatives[1]</code> would be initialized to zero, since the first independent variable is <code>y</code> and \(\frac{d(x)}{dy} = 0\) . For the function derivatives to be meaningful, we must assume that not only is this function differentiable in an analytical sense, but that it is also differentiable at the evaluation point <code>x,y</code>. We can exploit both of these assumptions: when we use this number type in mathematical operations, the AD frameworkcould* overload the operations (e.g., <code>operator+()</code>, <code>operator*()</code> as well as <code>sin()</code>, <code>exp()</code>, etc.) such that the returned result has the expected value. At the same time, it would then compute the derivatives through the knowledge of exactly what function is being overloaded and rigorous application of the chain-rule. So, the <code>sin()</code> function (with its argument <code>a</code> itself being a function of the independent variables <code>x</code> and <code>y</code>)might* be defined as follows: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line">ADNumberType <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<span class="keyword">const</span> ADNumberType &amp;a)</div><div class="line">{</div><div class="line">ADNumberType output;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// For the input argument &quot;a&quot;, &quot;a.value&quot; is simply its value.</span></div><div class="line">output.value = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(a.value);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// We know that the derivative of sin(a) is cos(a), but we need</span></div><div class="line"><span class="comment">// to also consider the chain rule and that the input argument</span></div><div class="line"><span class="comment">// `a` is also differentiable with respect to the original</span></div><div class="line"><span class="comment">// independent variables `x` and `y`. So `a.derivatives[0]`</span></div><div class="line"><span class="comment">// and `a.derivatives[1]` respectively represent the partial</span></div><div class="line"><span class="comment">// derivatives of `a` with respect to its inputs `x` and `y`.</span></div><div class="line">output.derivatives[0] = <a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(a.value)*a.derivatives[0];</div><div class="line">output.derivatives[1] = <a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(a.value)*a.derivatives[1];</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">return</span> output;</div><div class="line">}</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> All of that could of course also be done for second and even higher order derivatives. So it is now clear that with the above representation the <code>ADNumberType</code> is carrying around some extra data that represents the various derivatives of differentiable functions with respect to the original (sensitive) independent variables. It should therefore be noted that there is computational overhead associated with using them (as we compute extra functions when doing derivative computations) as well as memory overhead in storing these results. So the prescribed number of levels of differential operations should ideally be kept to a minimum to limit computational cost. We could, for instance, have computed the first derivatives ourself and then have used the <a class="el" href="classDifferentiation_1_1AD_1_1VectorFunction.html">Differentiation::AD::VectorFunction</a> helper class to determine the gradient of the collection of dependent functions, which would be the second derivatives of the original scalar function. It is also worth noting that because the chain rule is indiscriminately applied and we only see the beginning and end-points of the calculation <code>{x,y}</code> \(\rightarrow\) <code>f(x,y)</code>, we will only ever be able to query the total derivatives of <code>f</code>; the partial derivatives (<code>a.derivatives[0]</code> and <code>a.derivatives[1]</code> in the above example) are intermediate values and are hidden from us.</p>
<p>Okay, since we now at least have some idea as to exactly what <code>f_ad</code> represents and what is encoded within it, let's put all of that to some actual use. To gain access to those hidden derivative results, we register the final result with the helper class. After this point, we can no longer change the value of <code>f_ad</code> and have those changes reflected in the results returned by the helper class.</p>
<div class="fragment"><div class="line">ad_helper.register_dependent_variable(f_ad);</div></div><!-- fragment --><p>The next step is to extract the derivatives (specifically, the function gradient and Hessian). To do so we first create some temporary data structures (with the result type <code>double</code>) to store the derivatives (noting that all derivatives are returned at once, and not individually)...</p>
<div class="fragment"><div class="line">Vector&lt;double&gt;     Df(ad_helper.n_dependent_variables());</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2f(ad_helper.n_dependent_variables(),</div><div class="line">                       ad_helper.n_independent_variables());</div></div><!-- fragment --><p>... and we then request that the helper class compute these derivatives, and the function value itself. And that's it. We have everything that we were aiming to get.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_f = ad_helper.compute_value();</div><div class="line">ad_helper.compute_gradient(Df);</div><div class="line">ad_helper.compute_hessian(D2f);</div></div><!-- fragment --><p>We can convince ourselves that the AD framework is correct by comparing it to the analytical solution. (Or, if you're like the author, you'll be doing the opposite and will rather verify that your implementation of the analytical solution is correct!)</p>
<div class="fragment"><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y)</div><div class="line"></div><div class="line">- computed_f) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                           std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                           <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                           std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                           std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                           <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div></div><!-- fragment --><p>Because we know the ordering of the independent variables, we know which component of the gradient relates to which derivative...</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx = Df[0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy = Df[1];</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y)</div><div class="line"></div><div class="line">- computed_df_dx) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y)</div><div class="line"></div><div class="line">- computed_df_dy) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div></div><!-- fragment --><p>... and similar for the Hessian.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx = D2f[0][0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy = D2f[0][1];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx = D2f[1][0];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy = D2f[1][1];</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y)</div><div class="line"></div><div class="line">- computed_d2f_dx_dx) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y)</div><div class="line"></div><div class="line">- computed_d2f_dx_dy) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y)</div><div class="line"></div><div class="line">- computed_d2f_dy_dx) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y)</div><div class="line"></div><div class="line">- computed_d2f_dy_dy) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">  }</div></div><!-- fragment --><p>That's pretty great. There wasn't too much work involved in computing second-order derivatives of this trigonometric function.</p>
<p><a class="anchor" id="Handcalculatedderivativesoftheanalyticalsolution"></a> </p><h4>Hand-calculated derivatives of the analytical solution</h4>
<p>Since we now know how much "implementation effort" it takes to have the AD framework compute those derivatives for us, let's compare that to the same computed by hand and implemented in several stand-alone functions.</p>
<p>Here are the two first derivatives of \(f(x,y) = \cos\left(\frac{y}{x}\right)\) : \(\frac{df(x,y)}{dx} = \frac{y}{x^2} \sin\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(x != 0.0, <a class="code" href="group__Exceptions.html#ga2e959da7bfd82df428770c0339c377ba">ExcDivideByZero</a>());</div><div class="line">  <span class="keywordflow">return</span> y <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / (x x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{df(x,y)}{dx} = -\frac{1}{x} \sin\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span></div><div class="line"></div><div class="line">-<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / x;</div><div class="line">  }</div></div><!-- fragment --><p>And here are the four second derivatives of \(f(x,y)\) : \(\frac{d^{2}f(x,y)}{dx^{2}} = -\frac{y}{x^4} (2x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\)</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span></div><div class="line"></div><div class="line">-y (2 x std::sin(y / x) + y std::cos(y / x)) /</div><div class="line">           (x x x x);</div><div class="line">  }</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx dy} = \frac{1}{x^3} (x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (x std::sin(y / x) + y std::cos(y / x)) / (x x x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy dx} = \frac{1}{x^3} (x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\) (as expected, on the basis of <a href="https://en.wikipedia.org/wiki/Symmetry_of_second_derivatives">Schwarz's theorem</a>)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (x std::sin(y / x) + y std::cos(y / x)) / (x x x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy^{2}} = -\frac{1}{x^2} \cos\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span></div><div class="line"></div><div class="line">-(<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) / (x x);</div><div class="line">  }</div></div><!-- fragment --><p>Hmm... there's a lot of places in the above where we could have introduced an error in the above, especially when it comes to applying the chain rule. Although they're no silver bullet, at the very least these AD frameworks can serve as a verification tool to make sure that we haven't made any errors (either by calculation or by implementation) that would negatively affect our results.</p>
<p>The point of this example of course is that we might have chosen a relatively simple function \(f(x,y)\) for which we can hand-verify that the derivatives the AD framework computed is correct. But the AD framework didn't care that the function was simple: It could have been a much much more convoluted expression, or could have depended on more than two variables, and it would still have been able to compute the derivatives</p>
<ul>
<li>the only difference would have been thatwe* wouldn't have been able to come up with the derivatives any more to verify correctness of the AD framework.</li>
</ul>
<p><a class="anchor" id="Computingderivativesusingsymbolicdifferentiation"></a> </p><h4>Computing derivatives using symbolic differentiation</h4>
<p>We'll now repeat the same exercise using symbolic differentiation. The term "symbolic differentiation" is a little bit misleading because differentiation is just one tool that the Computer Algebra System (CAS) (i.e., the symbolic framework) provides. Nevertheless, in the context of finite element modeling and applications it is the most common use of a CAS and will therefore be the one that we'll focus on. Once more, we'll supply the argument values <code>x</code> and <code>y</code> with which to evaluate our function \(f(x,y) = \cos\left(\frac{y}{x}\right)\) and its derivatives, and a tolerance with which to test the correctness of the returned results.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">run_and_verify_sd(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">{</div></div><!-- fragment --><p>The first step that we need to take is to form the symbolic variables that represent the function arguments that we wish to differentiate with respect to. Again, these will be the independent variables for our problem and as such are, in some sense, primitive variables that have no dependencies on any other variable. We create these types of (independent) variables by initializing a symbolic type <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>, which is a wrapper to a set of classes used by the symbolic framework, with a unique identifier. On this occasion it makes sense that this identifier, a <code>std::string</code>, be simply <code>"x"</code> for the \(x\) argument, and likewise <code>"y"</code> for the \(y\) argument to the dependent function. Like before, we'll suffix symbolic variable names with <code>sd</code> so that we can clearly see which variables are symbolic (as opposed to numeric) in nature.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> x_sd(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> y_sd(<span class="stringliteral">&quot;y&quot;</span>);</div></div><!-- fragment --><p>Using the templated function that computes \(f(x,y)\) , we can pass these independent variables as arguments to the function. The returned result will be another symbolic type that represents the sequence of operations used to compute \(\cos\left(\frac{y}{x}\right)\) .</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_sd = f(x_sd, y_sd);</div></div><!-- fragment --><p>At this point it is legitimate to print out the expression <code>f_sd</code>, and if we did so </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;f(x,y) = &quot;</span> &lt;&lt; f_sd &lt;&lt; std::endl;</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> we would see <code>f(x,y) = cos(y/x)</code> printed to the console. You might notice that we've constructed our symbolic function <code>f_sd</code> with no context as to how we might want to use it: In contrast to the AD approach shown above, what we were returned from calling <code>f(x_sd, y_sd)</code> is not the evaluation of the function <code>f</code> at some specific point, but is in fact a symbolic representation of the evaluation at a generic, as yet undetermined, point. This is one of the key points that makes symbolic frameworks (the CAS) different from automatic differentiation frameworks. Each of the variables <code>x_sd</code> and <code>y_sd</code>, and even the composite dependent function <code>f_sd</code>, are in some sense respectively "placeholders" for numerical values and a composition of operations. In fact, the individual components that are used to compose the function are also placeholders. The sequence of operations are encoded into in a tree-like data structure (conceptually similar to an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>). Once we form these data structures we can defer any operations that we might want to do with them until some later time. Each of these placeholders represents something, but we have the opportunity to define or redefine what they represent at any convenient point in time. So for this particular problem it makes sense that we somehow want to associate "x" and "y" withsome* numerical value (with type yet to be determined), but we could conceptually (and if it made sense) assign the ratio "y/x" a value instead of the variables "x" and "y" individually. We could also associate with "x" or "y" some other symbolic function <code>g(a,b)</code>. Any of these operations involves manipulating the recorded tree of operations, and substituting the salient nodes on the tree (and that nodes' subtree) with something else. The key word here is "substitution", and indeed there are many functions in the <a class="el" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a> namespace that have this word in their names. This capability makes the framework entirely generic. In the context of finite element simulations, the types of operations that we would typically perform with our symbolic types are function composition, differentiation, substitution (partial or complete), and evaluation (i.e., conversion of the symbolic type to its numerical counterpart). But should you need it, a CAS is often capable of more than just this: It could be forming anti-derivatives (integrals) of functions, perform simplifications on the expressions that form a function (e.g., replace \((\sin a)^2 + (\cos a)^2\) by \(1\) ; or, more simply: if the function did an operation like <code>1+2</code>, a CAS could replace it by <code>3</code>), and so forth: Theexpression* that a variable represents is obtained from how the function \(f\) is implemented, but a CAS can do with it whatever its functionality happens to be. Specifically, to compute the symbolic representation of the first derivatives of the dependent function with respect to its individual independent variables, we use the <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">Differentiation::SD::Expression::differentiate()</a> function with the independent variable given as its argument. Each call will cause the CAS to go through the tree of operations that compose <code>f_sd</code> and differentiate each node of the expression tree with respect to the given symbolic argument.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dx_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dy_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div></div><!-- fragment --><p>To compute the symbolic representation of the second derivatives, we simply differentiate the first derivatives with respect to the independent variables. So to compute a higher order derivative, we first need to compute the lower order derivative. (As the return type of the call to <code><a class="el" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">differentiate()</a></code> is an expression, we could in principal execute double differentiation directly from the scalar by chaining two calls together. But this is unnecessary in this particular case, since we have the intermediate results at hand.)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dx_sd =</div><div class="line">  df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dy_sd =</div><div class="line">  df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dx_sd =</div><div class="line">  df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dy_sd =</div><div class="line">  df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div></div><!-- fragment --><p>Printing the expressions for the first and second derivatives, as computed by the CAS, using the statements </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;df_dx_sd: &quot;</span> &lt;&lt; df_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;df_dy_sd: &quot;</span> &lt;&lt; df_dy_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dx_dx_sd: &quot;</span> &lt;&lt; d2f_dx_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dx_dy_sd: &quot;</span> &lt;&lt; d2f_dx_dy_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dy_dx_sd: &quot;</span> &lt;&lt; d2f_dy_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dy_dy_sd: &quot;</span> &lt;&lt; d2f_dy_dy_sd &lt;&lt; std::endl;</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> renders the following output: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line">df_dx_sd: y*sin(y/x)/x**2</div><div class="line">df_dy_sd:</div><div class="line"></div><div class="line">-sin(y/x)/x</div><div class="line">d2f_dx_dx_sd:</div><div class="line"></div><div class="line">-y**2*cos(y/x)/x**4</div><div class="line"></div><div class="line">- 2*y*sin(y/x)/x**3</div><div class="line">d2f_dx_dy_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3</div><div class="line">d2f_dy_dx_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3</div><div class="line">d2f_dy_dy_sd:</div><div class="line"></div><div class="line">-cos(y/x)/x**2</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> This compares favorably to the analytical expressions for these derivatives that were presented earlier.</p>
<p>Now that we have formed the symbolic expressions for the function and its derivatives, we want to evaluate them for the numeric values for the main function arguments <code>x</code> and <code>y</code>. To accomplish this, we construct asubstitution map*, which maps the symbolic values to their numerical counterparts.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> substitution_map =</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::pair&lt;Differentiation::SD::Expression, double&gt;{x_sd, x},</div><div class="line">    std::pair&lt;Differentiation::SD::Expression, double&gt;{y_sd, y});</div></div><!-- fragment --><p>The last step in the process is to convert all symbolic variables and operations into numerical values, and produce the numerical result of this operation. To do this we combine the substitution map with the symbolic variable in the step we have already mentioned above: "substitution". Once we pass this substitution map to the CAS, it will substitute each instance of the symbolic variable (or, more generally, sub-expression) with its numerical counterpart and then propagate these results up the operation tree, simplifying each node on the tree if possible. If the tree is reduced to a single value (i.e., we have substituted all of the independent variables with their numerical counterpart) then the evaluation is complete. Due to the strongly-typed nature of C++, we need to instruct the CAS to convert its representation of the result into an intrinsic data type (in this case a <code>double</code>). This is the "evaluation" step, and through the template type we define the return type of this process. Conveniently, these two steps can be done at once if we are certain that we've performed a full substitution.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_f =</div><div class="line">      f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y)</div><div class="line"></div><div class="line">- computed_f) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                           std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                           <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                           std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                           std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                           <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div></div><!-- fragment --><p>We can do the same for the first derivatives...</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx =</div><div class="line">      df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy =</div><div class="line">      df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y)</div><div class="line"></div><div class="line">- computed_df_dx) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y)</div><div class="line"></div><div class="line">- computed_df_dy) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div></div><!-- fragment --><p>... and the second derivatives. Notice that we can reuse the same substitution map for each of these operations because we wish to evaluate all of these functions for the same values of <code>x</code> and <code>y</code>. Modifying the values in the substitution map renders the result of same symbolic expression evaluated with different values being assigned to the independent variables. We could also happily have each variable represent a real value in one pass, and a complex value in the next.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx =</div><div class="line">      d2f_dx_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy =</div><div class="line">      d2f_dx_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx =</div><div class="line">      d2f_dy_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy =</div><div class="line">      d2f_dy_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y)</div><div class="line"></div><div class="line">- computed_d2f_dx_dx) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y)</div><div class="line"></div><div class="line">- computed_d2f_dx_dy) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y)</div><div class="line"></div><div class="line">- computed_d2f_dy_dx) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y)</div><div class="line"></div><div class="line">- computed_d2f_dy_dy) &lt; tol,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                  std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                  <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="TheSimpleExamplerunfunction"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SimpleExample::run()</a> function</h4>
<p>The function used to drive these initial examples is straightforward. We'll arbitrarily choose some values at which to evaluate the function (although knowing that <code>x = 0</code> is not permissible), and then pass these values to the functions that use the AD and SD frameworks.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = 1.23;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = 0.91;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using automatic differentiation...&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    run_and_verify_ad(x, y);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using symbolic differentiation.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    run_and_verify_sd(x, y);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace SimpleExample</span></div></div><!-- fragment --><p><a class="anchor" id="AmorecomplexexampleUsingautomaticandsymbolicdifferentiationtocomputederivativesatcontinuumpoints"></a> </p><h3>A more complex example: Using automatic and symbolic differentiation to compute derivatives at continuum points</h3>
<p>Now that we've introduced the principles behind automatic and symbolic differentiation, we'll put them into action by formulating two coupled magneto-mechanical constitutive laws: one that is rate-independent, and another that exhibits rate-dependent behavior. As you will recall from the introduction, the material constitutive laws we will consider are far more complicated than the simple example above. This is not just because of the form of the function \(\psi_{0}\) that we will consider, but in particular because \(\psi_{0}\) doesn't just depend on two scalar variables, but instead on a whole bunch oftensors*, each with several components. In some cases, these aresymmetric* tensors, for which only a subset of components is in fact independent, and one has to think about what it actually means to compute a derivative such as \(\frac{\partial\psi_{0}}{\partial \mathbf{C}}\) where \(\mathbf C\) is a symmetric tensor. How all of this will work will, hopefully, become clear below. It will also become clear that doing this by hand is going to be, at the very best,exceedingly* tedious* and, at worst, riddled with hard-to-find bugs.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>CoupledConstitutiveLaws</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Constitutiveparameters"></a> </p><h4>Constitutive parameters</h4>
<p>We start with a description of the various material parameters that appear in the description of the energy function \(\psi_{0}\) . The ConstitutiveParameters class is used to hold these values. Values for all parameters (both constitutive and rheological) are taken from <b>[Pelteret2018a]</b> , and are given values that produce a constitutive response that is broadly representative of a real, laboratory-made magneto-active polymer, though the specific values used here are of no consequence to the purpose of this program of course. The first four constitutive parameters respectively represent</p>
<ul>
<li>the elastic shear modulus \(\mu_{e}\) ,</li>
<li>the elastic shear modulus at magnetic saturation \(\mu_{e}^{\infty}\) ,</li>
<li>the saturation magnetic field strength for the elastic shear modulus \(h_{e}^{\text{sat}}\) , and</li>
<li>the Poisson ratio \(\nu\) .</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>ConstitutiveParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConstitutiveParameters();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mu_e       = 30.0e3;</div><div class="line">  <span class="keywordtype">double</span> mu_e_inf   = 250.0e3;</div><div class="line">  <span class="keywordtype">double</span> mu_e_h_sat = 212.2e3;</div><div class="line">  <span class="keywordtype">double</span> nu_e       = 0.49;</div></div><!-- fragment --><p>The next four, which only pertain to the rate-dependent material, are parameters for</p>
<ul>
<li>the viscoelastic shear modulus \(\mu_{v}\) ,</li>
<li>the viscoelastic shear modulus at magnetic saturation \(\mu_{v}^{\infty}\) ,</li>
<li>the saturation magnetic field strength for the viscoelastic shear modulus \(h_{v}^{\text{sat}}\) , and</li>
<li>the characteristic relaxation time \(\tau\) .</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mu_v       = 20.0e3;</div><div class="line"><span class="keywordtype">double</span> mu_v_inf   = 35.0e3;</div><div class="line"><span class="keywordtype">double</span> mu_v_h_sat = 92.84e3;</div><div class="line"><span class="keywordtype">double</span> tau_v      = 0.6;</div></div><!-- fragment --><p>The last parameter is the relative magnetic permeability \(\mu_{r}\) .</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> mu_r = 6.0;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">};</div></div><!-- fragment --><p>The parameters are initialized through the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> framework, which is discussed in detail in <a class="el" href="step_60.html">step-60</a> .</p>
<div class="fragment"><div class="line">ConstitutiveParameters::ConstitutiveParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Constitutive Parameters/&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Elastic shear modulus&quot;</span>, mu_e);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Elastic shear modulus at magnetic saturation&quot;</span>, mu_e_inf);</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Saturation magnetic field strength for elastic shear modulus&quot;</span>,</div><div class="line">    mu_e_h_sat);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Poisson ratio&quot;</span>, nu_e);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus&quot;</span>, mu_v);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus at magnetic saturation&quot;</span>,</div><div class="line">                mu_v_inf);</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Saturation magnetic field strength for viscoelastic shear modulus&quot;</span>,</div><div class="line">    mu_v_h_sat);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Characteristic relaxation time&quot;</span>, tau_v);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Relative magnetic permeability&quot;</span>, mu_r);</div><div class="line"></div><div class="line">  parse_parameters_call_back.connect([&amp;]() { initialized = <span class="keyword">true</span>; });</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutivelawsBaseclass"></a> </p><h4>Constitutive laws: Base class</h4>
<p>Since we'll be formulating two constitutive laws for the same class of materials, it makes sense to define a base class that ensures a unified interface to them. The class declaration starts with the constructor that will accept the set of constitutive parameters that, in conjunction with the material law itself, dictate the material response.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coupled_Magnetomechanical_Constitutive_Law_Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div></div><!-- fragment --><p>Instead of computing and returning the kinetic variables or their linearization at will, we'll calculate and store these values within a single method. These cached results will then be returned upon request. We'll defer the precise explanation as to why we'd want to do this to a later stage. What is important for now is to see that this function accepts all of the field variables, namely the magnetic field vector \(\boldsymbol{\mathbb{H}}\) and right Cauchy-Green deformation tensor \(\mathbf{C}\) , as well as the time discretizer. These, in addition to the <code>constitutive_parameters</code>, are all the fundamental quantities that are required to compute the material response.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) = 0;</div></div><!-- fragment --><p>The next few functions provide the interface to probe the material response due subject to the applied deformation and magnetic loading. Since the class of materials can be expressed in terms of a free energy \(\psi_{0}\) , we can compute that...</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>... as well as the two kinetic quantities:</p>
<ul>
<li>the magnetic induction vector \(\boldsymbol{\mathbb{B}}\) , and</li>
<li>the total Piola-Kirchhoff stress tensor \(\mathbf{S}^{\text{tot}}\)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>... and the linearization of the kinetic quantities, which are:</p>
<ul>
<li>the magnetostatic tangent tensor \(\mathbb{D}\) ,</li>
<li>the total referential magnetoelastic coupling tensor \(\mathfrak{P}^{\text{tot}}\) , and</li>
<li>the total referential elastic tangent tensor \(\mathcal{H}^{\text{tot}}\) .</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>We'll also define a method that provides a mechanism for this class instance to do any additional tasks before moving on to the next timestep. Again, the reason for doing this will become clear a little later.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep()</div><div class="line">{}</div></div><!-- fragment --><p>In the <code>protected</code> part of the class, we store a reference to an instance of the constitutive parameters that govern the material response. For convenience, we also define some functions that return various constitutive parameters (both explicitly defined, as well as calculated). The parameters related to the elastic response of the material are, in order:</p>
<ul>
<li>the elastic shear modulus,</li>
<li>the elastic shear modulus at saturation magnetic field,</li>
<li>the saturation magnetic field strength for the elastic shear modulus,</li>
<li>the Poisson ratio,</li>
<li>the Lam&eacute; parameter, and</li>
<li>the bulk modulus.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_nu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_lambda_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_kappa_e() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The parameters related to the elastic response of the material are, in order:</p>
<ul>
<li>the viscoelastic shear modulus,</li>
<li>the viscoelastic shear modulus at magnetic saturation,</li>
<li>the saturation magnetic field strength for the viscoelastic shear modulus, and</li>
<li>the characteristic relaxation time.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_mu_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_mu_v_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_mu_v_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_tau_v() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The parameters related to the magnetic response of the material are, in order:</p>
<ul>
<li>the relative magnetic permeability, and</li>
<li>the magnetic permeability constant \(\mu_{0}\) (not really a material constant, but rather a universal constant that we'll group here for simplicity). We'll also implement a function that returns the timestep size from the time discretizion.</li>
</ul>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> get_mu_r() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> get_mu_0() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span>           get_delta_t(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>In the following, let us start by implementing the several relatively trivial member functions of the class just defined:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::</div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">    : constitutive_parameters(constitutive_parameters)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(get_kappa_e() &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.mu_e;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.mu_e_inf;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.mu_e_h_sat;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_nu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.nu_e;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_lambda_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 2.0 get_mu_e() get_nu_e() / (1.0</div><div class="line"></div><div class="line">- 2.0 get_nu_e());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_kappa_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (2.0 get_mu_e() (1.0 + get_nu_e())) /</div><div class="line">           (3.0 (1.0</div><div class="line"></div><div class="line">- 2.0 get_nu_e()));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.mu_v;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.mu_v_inf;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.mu_v_h_sat;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_tau_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.tau_v;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_r()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> constitutive_parameters.mu_r;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  constexpr <span class="keywordtype">double</span></div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_0()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 4.0 numbers::PI 1e-7;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_delta_t(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> time.<a class="code" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">get_previous_step_size</a>();</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="Magnetoelasticconstitutivelawusingautomaticdifferentiation"></a> </p><h4>Magnetoelastic constitutive law (using automatic differentiation)</h4>
<p>We'll begin by considering a non-dissipative material, namely one that is governed by a magneto-hyperelastic constitutive law that exhibits stiffening when immersed in a magnetic field. As described in the introduction, the stored energy density function for such a material might be given by </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) . \]
</p>
<p> Now on to the class that implements this behavior. Since we expect that this class fully describes a single material, we'll mark it as "final" so that the inheritance tree terminated here. At the top of the class, we define the helper type that we will use in the AD computations for our scalar energy density function. Note that we expect it to return values of type <code>double</code>. We also have to specify the number of spatial dimensions, <code>dim</code>, so that the link between vector, tensor and symmetric tensor fields and the number of components that they contain may be established. The concrete <code>ADTypeCode</code> used for the ADHelper class will be provided as a template argument at the point where this class is actually used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><span class="keyword">class </span>Magnetoelastic_Constitutive_Law_AD final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> ADHelper =</div><div class="line">    <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line">  <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoelastic_Constitutive_Law_AD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div></div><!-- fragment --><p>Since the public interface to the base class is pure-<code>virtual</code>, here we'll declare that this class will override all of these base class methods.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>In the <code>private</code> part of the class, we need to define some extractors that will help us set independent variables and later get the computed values related to the dependent variables. If this class were to be used in the context of a finite element problem, then each of these extractors is (most likely) related to the gradient of a component of the solution field (in this case, displacement and magnetic scalar potential). As you can probably infer by now, here "C" denotes the right Cauchy-Green tensor and "H" denotes the magnetic field vector.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>             H_components;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor&lt;2&gt;</a> C_components;</div></div><!-- fragment --><p>This is an instance of the automatic differentiation helper that we'll set up to do all of the differential calculations related to the constitutive law...</p>
<div class="fragment"><div class="line">ADHelper ad_helper;</div></div><!-- fragment --><p>... and the following three member variables will store the output from the <code>ad_helper</code>. The <code>ad_helper</code> returns the derivatives with respect to all field variables at once, so we'll retain the full gradient vector and Hessian matrix. From that, we'll extract the individual entries that we're actually interested in.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span>             psi;</div><div class="line">  Vector&lt;double&gt;     Dpsi;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2psi;</div><div class="line">};</div></div><!-- fragment --><p>When setting up the field component extractors, it is completely arbitrary as to how they are ordered. But it is important that the extractors do not have overlapping indices. The total number of components of these extractors defines the number of independent variables that the <code>ad_helper</code> needs to track, and with respect to which we'll be taking derivatives. The resulting data structures <code>Dpsi</code> and <code>D2psi</code> must also be sized accordingly. Once the <code>ad_helper</code> is configured (its input argument being the total number of components of \(\mathbf{C}\) and \(\boldsymbol{\mathbb{H}}\) ), we can directly interrogate it as to how many independent variables it uses.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::</div><div class="line">  Magnetoelastic_Constitutive_Law_AD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , H_components(0)</div><div class="line">  , C_components(<a class="code" href="classTensor.html">Tensor</a>&lt;1, dim&gt;::n_independent_components)</div><div class="line">  , ad_helper(<a class="code" href="classTensor.html">Tensor</a>&lt;1, dim&gt;::n_independent_components +</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt;::n_independent_components)</div><div class="line">  , psi(0.0)</div><div class="line">  , Dpsi(ad_helper.n_independent_variables())</div><div class="line">  , D2psi(ad_helper.n_independent_variables(),</div><div class="line">          ad_helper.n_independent_variables())</div><div class="line">{}</div></div><!-- fragment --><p>As stated before, due to the way that the automatic differentiation libraries work, the <code>ad_helper</code> will always returns the derivatives of the energy density function with respect to all field variables simultaneously. For this reason, it does not make sense to compute the derivatives in the functions <code>get_B()</code>, <code>get_S()</code>, etc. because we'd be doing a lot of extra computations that are then simply discarded. So, the best way to deal with that is to have a single function call that does all of the calculations up-front, and then we extract the stored data as its needed. That's what we'll do in the <code>update_internal_data()</code> method. As the material is rate-independent, we can ignore the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C) &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Since we reuse the <code>ad_helper</code> data structure at each time step, we need to clear it of all stale information before use.</p>
<div class="fragment"><div class="line">ad_helper.reset();</div></div><!-- fragment --><p>The next step is to set the values for all field components. These define the "point" around which we'll be computing the function gradients and their linearization. The extractors that we created before provide the association between the fields and the registry within the <code>ad_helper</code> </p>
<ul>
<li>they'll be used repeatedly to ensure that we have the correct interpretation of which variable corresponds to which component of <code>H</code> or <code>C</code>.</li>
</ul>
<div class="fragment"><div class="line">ad_helper.register_independent_variable(H, H_components);</div><div class="line">ad_helper.register_independent_variable(C, C_components);</div></div><!-- fragment --><p>Now that we've done the initial setup, we can retrieve the AD counterparts of our fields. These are truly the independent variables for the energy function, and are "sensitive" to the calculations that are performed with them. Notice that the AD number are treated as a special number type, and can be used in many templated classes (in this example, as the scalar type for the <a class="el" href="classTensor.html">Tensor</a> and <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, ADNumberType&gt;</a> H_ad =</div><div class="line">  ad_helper.get_sensitive_variables(H_components);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_ad =</div><div class="line">  ad_helper.get_sensitive_variables(C_components);</div></div><!-- fragment --><p>We can also use them in many functions that are templated on the scalar type. So, for these intermediate values that we require, we can perform tensor operations and some mathematical functions. The resulting type will also be an automatically differentiable number, which encodes the operations performed in these functions.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType det_F_ad = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C_ad));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_inv_ad = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C_ad);</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F_ad &gt; ADNumberType(0.0),</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>Next we'll compute the scaling function that will cause the shear modulus to change (increase) under the influence of a magnetic field...</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> ADNumberType f_mu_e_ad =</div><div class="line">      1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e()</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">              <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 H_ad H_ad) /</div><div class="line">                        (this-&gt;get_mu_e_h_sat() this-&gt;get_mu_e_h_sat()));</div></div><!-- fragment --><p>... and then we can define the material stored energy density function. We'll see later that this example is sufficiently complex to warrant the use of AD to, at the very least, verify an unassisted implementation.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> ADNumberType psi_ad =</div><div class="line">      0.5 this-&gt;get_mu_e() f_mu_e_ad</div><div class="line">        (<a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C_ad)</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">- 2.0 <a class="code" href="namespacestd.html">std</a>::log(det_F_ad))</div><div class="line">      + this-&gt;get_lambda_e() <a class="code" href="namespacestd.html">std</a>::log(det_F_ad) <a class="code" href="namespacestd.html">std</a>::log(det_F_ad)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- 0.5 this-&gt;get_mu_0() this-&gt;get_mu_r() det_F_ad</div><div class="line">          (H_ad C_inv_ad H_ad);</div></div><!-- fragment --><p>The stored energy density function is, in fact, the dependent variable for this problem, so as a final step in the "configuration" phase, we register its definition with the <code>ad_helper</code>.</p>
<div class="fragment"><div class="line">ad_helper.register_dependent_variable(psi_ad);</div></div><!-- fragment --><p>Finally, we can retrieve the resulting value of the stored energy density function, as well as its gradient and Hessian with respect to the input fields, and cache them.</p>
<div class="fragment"><div class="line">  psi = ad_helper.compute_value();</div><div class="line">  ad_helper.compute_gradient(Dpsi);</div><div class="line">  ad_helper.compute_hessian(D2psi);</div><div class="line">}</div></div><!-- fragment --><p>The following few functions then allow for querying the so-stored value of \(\psi_{0}\) , and to extract the desired components of the gradient vector and Hessian matrix. We again make use of the extractors to express which parts of the total gradient vector and Hessian matrix we wish to retrieve. They only return the derivatives of the energy function, so for our definitions of the kinetic variables and their linearization a few more manipulations are required to form the desired result.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">  <span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> psi;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dpsi_dH =</div><div class="line">      ad_helper.extract_gradient_component(Dpsi, H_components);</div><div class="line">    <span class="keywordflow">return</span></div><div class="line"></div><div class="line">-dpsi_dH;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dpsi_dC =</div><div class="line">      ad_helper.extract_gradient_component(Dpsi, C_components);</div><div class="line">    <span class="keywordflow">return</span> 2.0 dpsi_dC;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> dpsi_dH_dH =</div><div class="line">      ad_helper.extract_hessian_component(D2psi, H_components, H_components);</div><div class="line">    <span class="keywordflow">return</span></div><div class="line"></div><div class="line">-<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(dpsi_dH_dH);</div><div class="line">  }</div></div><!-- fragment --><p>Note that for coupled terms the order of the extractor arguments is especially important, as it dictates the order in which the directional derivatives are taken. So, if we'd reversed the order of the extractors in the call to <code>extract_hessian_component()</code> then we'd actually have been retrieving part of \(\left[ \mathfrak{P}^{\text{tot}} \right]^{T}\) .</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a></div><div class="line">  Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> dpsi_dC_dH =</div><div class="line">      ad_helper.extract_hessian_component(D2psi, C_components, H_components);</div><div class="line">    <span class="keywordflow">return</span></div><div class="line"></div><div class="line">-2.0 dpsi_dC_dH;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">  Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dpsi_dC_dC =</div><div class="line">      ad_helper.extract_hessian_component(D2psi, C_components, C_components);</div><div class="line">    <span class="keywordflow">return</span> 4.0 dpsi_dC_dC;</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="Magnetoviscoelasticconstitutivelawusingsymbolicalgebraanddifferentiation"></a> </p><h4>Magneto-viscoelastic constitutive law (using symbolic algebra and differentiation)</h4>
<p>The second material law that we'll consider will be one that represents a magneto-viscoelastic material with a single dissipative mechanism. We'll consider the free energy density function for such a material to be defined as</p>
<p class="formulaDsp">
\begin{align*} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \\ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \\ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \end{align*}
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right), \]
</p>
<p> in conjunction with the evolution law for the internal viscous variable </p><p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p> that was discretized using a first-order backward difference approximation. Again, let us see how this is implemented in a concrete class. Instead of the AD framework used in the previous class, we will now utilize the SD approach. To support this, the class constructor accepts not only the <code>constitutive_parameters</code>, but also two additional variables that will be used to initialize a <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a>. We'll give more context to this later.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law_SD final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags);</div></div><!-- fragment --><p>Like for the automatic differentiation helper, the <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> will return a collection of results all at once. So, in order to do that just once, we'll utilize a similar approach to before and do all of the expensive calculations within the <code>update_internal_data()</code> function, and cache the results for layer extraction.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>Since we're dealing with a rate dependent material, we'll have to update the history variable at the appropriate time. That will be the purpose of this function.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div></div><!-- fragment --><p>In the <code>private</code> part of the class, we will want to keep track of the internal viscous deformation, so the following two (real-valued, non-symbolic) member variables respectively hold</p>
<ul>
<li>the value of internal variable time step (and, if embedded within a nonlinear solver framework, Newton step), and</li>
<li>the value of internal variable at the previous timestep. (We've labeled these variables "Q" so that they're easy to identify; in a sea of calculations it is not necessarily easy to distinguish <code>Cv</code> or <code>C_v</code> from <code>C</code>.)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div></div><!-- fragment --><p>As we'll be using symbolic types, we'll need to define some symbolic variables to use with the framework. (They are all suffixed with "SD" to make it easy to distinguish the symbolic types or expressions from real-valued types or scalars.) This can be done once up front (potentially even as <code>static</code> variables) to minimize the overhead associated with creating these variables. For the ultimate in generic programming, we can even describe the constitutive parameters symbolically,potentially* allowing a single class instance to be reused with different inputs for these values too. These are the symbolic scalars that represent the elastic, viscous, and magnetic material parameters (defined mostly in the same order as they appear in the <code>ConstitutiveParameters</code> class). We also store a symbolic expression, <code>delta_t_sd</code>, that represents the time step size):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_inf_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_h_sat_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> lambda_e_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_inf_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_h_sat_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> tau_v_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> delta_t_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_r_sd;</div></div><!-- fragment --><p>Next we define some tensorial symbolic variables that represent the independent field variables, upon which the energy density function is parameterized:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          H_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_sd;</div></div><!-- fragment --><p>And similarly we have the symbolic representation of the internal viscous variables (both its current value and its value at the previous timestep):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t1_sd;</div></div><!-- fragment --><p>We should also store the definitions of the dependent expressions: Although we'll only compute them once, we require them to retrieve data from the <code>optimizer</code> that is declared below. Furthermore, when serializing a material class like this one (not done as a part of this tutorial) we'd either need to serialize these expressions as well or we'd need to reconstruct them upon reloading.</p>
<div class="fragment"><div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>                          psi_sd;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          B_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> S_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> BB_sd;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim, Differentiation::SD::Expression&gt;</a>          PP_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim, Differentiation::SD::Expression&gt;</a> HH_sd;</div></div><!-- fragment --><p>The next variable is then the optimizer that is used to evaluate the dependent functions. More specifically, it provides the possibility to accelerate the evaluation of the symbolic dependent expressions. This is a vital tool, because the native evaluation of lengthy expressions (using no method of acceleration, but rather direct evaluation directly of the symbolic expressions) can be very slow. The <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> class provides a mechanism by which to transform the symbolic expression tree into another code path that, for example, shares intermediate results between the various dependent expressions (meaning that these intermediate values only get calculated once per evaluation) and/or compiling the code using a just-in-time compiler (thereby retrieving near-native performance for the evaluation step). Performing this code transformation is very computationally expensive, so we store the optimizer so that it is done just once per class instance. This also further motivates the decision to make the constitutive parameters themselves symbolic. We could then reuse a single instance of this <code>optimizer</code> across several materials (with the same energy function, of course) and potentially multiple continuum points (if embedded within a finite element simulation). As specified by the template parameter, the numerical result will be of type <code>double</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer&lt;double&gt;</a> optimizer;</div></div><!-- fragment --><p>During the evaluation phase, we must map the symbolic variables to their real-valued counterparts. The next method will provide this functionality. The final method of this class will configure the <code>optimizer</code>.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> initialize_optimizer();</div><div class="line">};</div></div><!-- fragment --><p>As the resting deformation state is one at which the material is considered to be completely relaxed, the internal viscous variables are initialized with the identity tensor, i.e. \(\mathbf{C}_{v} = \mathbf{I}\) . The various symbolic variables representing the constitutive parameters, time step size, and field and internal variables all get a unique identifier. The optimizer is passed the two parameters that declare which optimization (acceleration) technique should be applied, as well as which additional steps should be taken by the CAS to help improve performance during evaluation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::</div><div class="line">  Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , mu_e_sd(<span class="stringliteral">&quot;mu_e&quot;</span>)</div><div class="line">  , mu_e_inf_sd(<span class="stringliteral">&quot;mu_e_inf&quot;</span>)</div><div class="line">  , mu_e_h_sat_sd(<span class="stringliteral">&quot;mu_e_h_sat&quot;</span>)</div><div class="line">  , lambda_e_sd(<span class="stringliteral">&quot;lambda_e&quot;</span>)</div><div class="line">  , mu_v_sd(<span class="stringliteral">&quot;mu_v&quot;</span>)</div><div class="line">  , mu_v_inf_sd(<span class="stringliteral">&quot;mu_v_inf&quot;</span>)</div><div class="line">  , mu_v_h_sat_sd(<span class="stringliteral">&quot;mu_v_h_sat&quot;</span>)</div><div class="line">  , tau_v_sd(<span class="stringliteral">&quot;tau_v&quot;</span>)</div><div class="line">  , delta_t_sd(<span class="stringliteral">&quot;delta_t&quot;</span>)</div><div class="line">  , mu_r_sd(<span class="stringliteral">&quot;mu_r&quot;</span>)</div><div class="line">  , H_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#acf16bdf4d5a0b48dd84496e379742426">make_vector_of_symbols</a>&lt;dim&gt;(<span class="stringliteral">&quot;H&quot;</span>))</div><div class="line">  , C_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;C&quot;</span>))</div><div class="line">  , Q_t_sd(</div><div class="line">      <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t&quot;</span>))</div><div class="line">  , Q_t1_sd(</div><div class="line">      <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t1&quot;</span>))</div><div class="line">  , optimizer(optimizer_type, optimization_flags)</div><div class="line">{</div><div class="line">  initialize_optimizer();</div><div class="line">}</div></div><!-- fragment --><p>The substitution map simply pairs all of the following data together:</p>
<ul>
<li>the constitutive parameters (with values retrieved from the base class),</li>
<li>the time step size (with its value retrieved from the time discretizer),</li>
<li>the field values (with their values being prescribed by an external function that is calling into this <code>Magnetoviscoelastic_Constitutive_Law_SD</code> instance), and</li>
<li>the current and previous internal viscous deformation (with their values stored within this class instance).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::make_substitution_map</a>(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::make_pair(mu_e_sd, this-&gt;get_mu_e()),</div><div class="line">    std::make_pair(mu_e_inf_sd, this-&gt;get_mu_e_inf()),</div><div class="line">    std::make_pair(mu_e_h_sat_sd, this-&gt;get_mu_e_h_sat()),</div><div class="line">    std::make_pair(lambda_e_sd, this-&gt;get_lambda_e()),</div><div class="line">    std::make_pair(mu_v_sd, this-&gt;get_mu_v()),</div><div class="line">    std::make_pair(mu_v_inf_sd, this-&gt;get_mu_v_inf()),</div><div class="line">    std::make_pair(mu_v_h_sat_sd, this-&gt;get_mu_v_h_sat()),</div><div class="line">    std::make_pair(tau_v_sd, this-&gt;get_tau_v()),</div><div class="line">    std::make_pair(delta_t_sd, delta_t),</div><div class="line">    std::make_pair(mu_r_sd, this-&gt;get_mu_r()),</div><div class="line">    std::make_pair(H_sd, H),</div><div class="line">    std::make_pair(C_sd, C),</div><div class="line">    std::make_pair(Q_t_sd, Q_t),</div><div class="line">    std::make_pair(Q_t1_sd, Q_t1));</div><div class="line">}</div></div><!-- fragment --><p>Due to the "natural" use of the symbolic expressions, much of the procedure to configure the <code>optimizer</code> looks very similar to that which is used to construct the automatic differentiation helper. Nevertheless, we'll detail these steps again to highlight the differences that underlie the two frameworks. The function starts with expressions that symbolically encode the determinant of the deformation gradient (as expressed in terms of the right Cauchy-Green deformation tensor, our primary field variable), as well as the inverse of \(\mathbf{C}\) itself:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::initialize_optimizer()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> det_F_sd =</div><div class="line">    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C_sd));</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_inv_sd =</div><div class="line">    <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C_sd);</div></div><!-- fragment --><p>Next is the symbolic representation of the saturation function for the elastic part of the free energy density function, followed by the magnetoelastic contribution to the free energy density function. This all has the same structure as we'd seen previously.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_e_sd =</div><div class="line">      1.0 +</div><div class="line">      (mu_e_inf_sd / mu_e_sd</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 H_sd H_sd) / (mu_e_h_sat_sd mu_e_h_sat_sd));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_ME_sd =</div><div class="line">      0.5 mu_e_sd f_mu_e_sd</div><div class="line">        (<a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C_sd)</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">- 2.0 std::log(det_F_sd)) +</div><div class="line">      lambda_e_sd <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd) <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd)</div><div class="line"></div><div class="line">-</div><div class="line">      0.5 this-&gt;get_mu_0() mu_r_sd det_F_sd (H_sd C_inv_sd H_sd);</div></div><!-- fragment --><p>In addition, we define the magneto-viscoelastic contribution to the free energy density function. The first component required to implement this is a scaling function that will cause the viscous shear modulus to change (increase) under the influence of a magnetic field (see <b>[Pelteret2018a]</b> , equation 29). Thereafter we can compute the dissipative component of the energy density function; its expression is stated in <b>[Pelteret2018a]</b> (equation 28), which is a straight-forward extension of an energy density function formulated in <b>[Linder2011a]</b> (equation 46).</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_v_sd =</div><div class="line">      1.0 +</div><div class="line">      (mu_v_inf_sd / mu_v_sd</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 H_sd H_sd) / (mu_v_h_sat_sd mu_v_h_sat_sd));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_MVE_sd =</div><div class="line">      0.5 mu_v_sd f_mu_v_sd</div><div class="line">      (Q_t_sd (std::pow(det_F_sd,</div><div class="line"></div><div class="line">-2.0 / dim) C_sd)</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">-</div><div class="line">       std::log(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t_sd)));</div></div><!-- fragment --><p>From these building blocks, we can then define the material's total free energy density function:</p>
<div class="fragment"><div class="line">psi_sd = psi_ME_sd + psi_MVE_sd;</div></div><!-- fragment --><p>As it stands, to the CAS the variable <code>Q_t_sd</code> appears to be independent of <code>C_sd</code>. Our tensorial symbolic expression <code>Q_t_sd</code> just has an identifier associated with it, and there is nothing that links it to the other tensorial symbolic expression <code>C_sd</code>. So any derivatives taken with respect to <code>C_sd</code> will ignore this inherent dependence which, as we can see from the evolution law, is in fact \(\mathbf{C}_{v} = \mathbf{C}_{v} \left( \mathbf{C}, t \right)\) . This means that deriving any function \(f = f(\mathbf{C}, \mathbf{Q})\) with respect to \(\mathbf{C}\) will return partial derivatives \(\frac{\partial f(\mathbf{C}, \mathbf{Q})}{\partial \mathbf{C}} \Big\vert_{\mathbf{Q}}\) as opposed to the total derivative \(\frac{d f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{d \mathbf{C}} = \frac{\partial f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{\partial \mathbf{C}} \Big\vert_{\mathbf{Q}} + \frac{\partial f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{\partial \mathbf{Q}} \Big\vert_{\mathbf{C}} : \frac{d \mathbf{Q}(\mathbf{C}))}{d \mathbf{C}}\) . By contrast, with the current AD libraries the total derivative would always be returned. This implies that the computed kinetic variables would be incorrect for this class of material model, making AD the incorrect tool from which to derive (at the continuum point level) the constitutive law for this dissipative material from an energy density function. It is this specific level of control that characterizes a defining difference difference between the SD and AD frameworks. In a few lines we'll be manipulating the expression for the internal variable <code>Q_t_sd</code> such that it produces the correct linearization.</p>
<p>But, first, we'll compute the symbolic expressions for the kinetic variables, i.e., the magnetic induction vector and the Piola-Kirchhoff stress tensor. The code that performs the differentiation quite closely mimics the definition stated in the theory.</p>
<div class="fragment"><div class="line">    B_sd =</div><div class="line"></div><div class="line">-<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, H_sd);</div><div class="line">    S_sd = 2.0 <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, C_sd);</div></div><!-- fragment --><p>Since the next step is to linearize the above, it is the appropriate time to inform the CAS of the explicit dependency of <code>Q_t_sd</code> on <code>C_sd</code>, i.e., state that \(\mathbf{C}_{v} = \mathbf{C}_{v} \left( \mathbf{C}, t \right)\) . This means that all future differential operations made with respect to <code>C_sd</code> will take into account this dependence (i.e., compute total derivatives). In other words, we will transform some expression such that their intrinsic parameterization changes from \(f(\mathbf{C}, \mathbf{Q})\) to \(f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))\) . To do this, we consider the time-discrete evolution law. From that, we have the explicit expression for the internal variable in terms of its history as well as the primary field variable. That is what it described in this expression:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a></div><div class="line">  Q_t_sd_explicit =</div><div class="line">    (1.0 / (1.0 + delta_t_sd / tau_v_sd))</div><div class="line">    (Q_t1_sd +</div><div class="line">     (delta_t_sd / tau_v_sd <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, 2.0 / dim) C_inv_sd));</div></div><!-- fragment --><p>Next we produce an intermediate substitution map, which will take every instance of <code>Q_t_sd</code> (our identifier) found in an expression and replace it with the full expression held in <code>Q_t_sd_explicit</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">  substitution_map_explicit = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::make_pair(Q_t_sd, Q_t_sd_explicit));</div></div><!-- fragment --><p>We can the perform this substitution on the two kinetic variables and immediately differentiate the result that appears after that substitution with the field variables. (If you'd like, this could be split up into two steps with the intermediate results stored in a temporary variable.) Again, if you overlook the "complexity" generated by the substitution, these calls that linearize the kinetic variables and produce the three tangent tensors quite closely resembles what's stated in the theory.</p>
<div class="fragment"><div class="line">    BB_sd = <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(B_sd, substitution_map_explicit),</div><div class="line">      H_sd));</div><div class="line">    PP_sd =</div><div class="line"></div><div class="line">-<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit), H_sd);</div><div class="line">    HH_sd =</div><div class="line">      2.0</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit),</div><div class="line">        C_sd);</div></div><!-- fragment --><p>Now we need to tell the <code>optimizer</code> what entries we need to provide numerical values for in order for it to successfully perform its calculations. These essentially act as the input arguments to all dependent functions that the <code>optimizer</code> must evaluate. They are, collectively, the independent variables for the problem, the history variables, the time step sie and the constitutive parameters (since we've not hard encoded them in the energy density function). So what we really want is to provide it a collection of symbols, which one could accomplish in this way: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line">optimizer.register_symbols(<a class="code" href="namespaceDifferentiation_1_1SD.html#a8349584858c74f233cc2ca0151eecfad">Differentiation::SD::make_symbol_map</a>(</div><div class="line">mu_e_sd, mu_e_inf_sd, mu_e_h_sat_sd, lambda_e_sd,</div><div class="line">mu_v_sd, mu_v_inf_sd, mu_v_h_sat_sd, tau_v_sd,</div><div class="line">delta_t_sd, mu_r_sd,</div><div class="line">H_sd, C_sd,</div><div class="line">Q_t_sd, Q_t1_sd));</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> But this is all actually already encoded as the keys of the substitution map. Doing the above would also mean that we need to manage the symbols in two places (here and when constructing the substitution map), which is annoying and a potential source of error if this material class is modified or extended. Since we're not interested in the values at this point, it is alright if the substitution map is filled with invalid data for the values associated with each key entry. So we'll simply create a fake substitution map, and extract the symbols from that. Note that any substitution map passed to the <code>optimizer</code> will have to, at the very least, contain entries for these symbols.</p>
<div class="fragment"><div class="line">optimizer.register_symbols(</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD_1_1Utilities.html#a373adeda1cf11d824bb41a679d061a3d">Differentiation::SD::Utilities::extract_symbols</a>(</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>({}, {}, 0)));</div></div><!-- fragment --><p>We then inform the optimizer of what values we want calculated, which in our situation encompasses all of the dependent variables (namely the energy density function and its various derivatives).</p>
<div class="fragment"><div class="line">optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);</div></div><!-- fragment --><p>The last step is to finalize the optimizer. With this call it will determine an equivalent code path that will evaluate all of the dependent functions at once, but with less computational cost than when evaluating the symbolic expression directly. Note: This is an expensive call, so we want execute it as few times as possible. We've done it in the constructor of our class, which achieves the goal of being called only once per class instance.</p>
<div class="fragment"><div class="line">  optimizer.optimize();</div><div class="line">}</div></div><!-- fragment --><p>Since the configuration of the <code>optimizer</code> was done up front, there's very little to do each time we want to compute kinetic variables or their linearization (derivatives).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">{</div></div><!-- fragment --><p>To update the internal history variable, we first need to compute a few fundamental quantities, which we've seen before. We can also ask the time discretizer for the time step size that was used to iterate from the previous time step to the current one.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C);</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>Now we can update the (real valued) internal viscous deformation tensor, as per the definition given by the evolution law in conjunction with the chosen time discretization scheme.</p>
<div class="fragment"><div class="line">Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v()))</div><div class="line">      (Q_t1 + (delta_t / this-&gt;get_tau_v()) std::pow(det_F, 2.0 / dim)</div><div class="line">                C_inv);</div></div><!-- fragment --><p>Next we pass the optimizer the numeric values that we wish the independent variables, time step size and (implicit to this call), the constitutive parameters to represent.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> substitution_map = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(C, H, delta_t);</div></div><!-- fragment --><p>When making this next call, the call path used to (numerically) evaluate the dependent functions is quicker than dictionary substitution.</p>
<div class="fragment"><div class="line">  optimizer.substitute(substitution_map);</div><div class="line">}</div></div><!-- fragment --><p>Having called <code>update_internal_data()</code>, it is then valid to extract data from the optimizer. When doing the evaluation, we need the exact symbolic expressions of the data to extracted from the optimizer. The implication of this is that we needed to store the symbolic expressions of all dependent variables for the lifetime of the optimizer (naturally, the same is implied for the input variables).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(psi_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(B_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(S_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(BB_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(PP_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(HH_sd);</div><div class="line">}</div></div><!-- fragment --><p>When moving forward in time, the "current" state of the internal variable instantaneously defines the state at the "previous" timestep. As such, we record value of history variable for use as the "past value" at the next time step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_end_of_timestep()</div><div class="line">{</div><div class="line">  Q_t1 = Q_t;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AmorecomplexexamplecontinuedParametersandhandderivedmaterialclasses"></a> </p><h3>A more complex example (continued): Parameters and hand-derived material classes</h3>
<p>Now that we've seen how the AD and SD frameworks can make light(er) work of defining these constitutive laws, we'll implement the equivalent classes by hand for the purpose of verification and to do some preliminary benchmarking of the frameworks versus a native implementation. At the expense of the author's sanity, what is documented below (hopefully accurately) are the full definitions for the kinetic variables and their tangents, as well as some intermediate computations. Since the structure and design of the constitutive law classes has been outlined earlier, we'll gloss over it and simply delineate between the various stages of calculations in the <code>update_internal_data()</code> method definition. It should be easy enough to link the derivative calculations (with their moderately expressive variable names) to their documented definitions that appear in the class descriptions. We will, however, take the opportunity to present two different paradigms for implementing constitutive law classes. The second will provide more flexibility than the first (thereby making it more easily extensible, in the author's opinion) at the expense of some performance.</p>
<p><a class="anchor" id="Magnetoelasticconstitutivelawhandderived"></a> </p><h4>Magnetoelastic constitutive law (hand-derived)</h4>
<p>From the stored energy that, as mentioned earlier, is defined as </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) , \\ \text{det}(\mathbf{F}) = \sqrt{\text{det}(\mathbf{C})} \]
</p>
<p> for this magnetoelastic material, the first derivatives that correspond to the magnetic induction vector and total Piola-Kirchhoff stress tensor are </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{d \psi_{0}}{d \boldsymbol{\mathbb{H}}} = - \frac{1}{2} \mu_{e} \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] \frac{d f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p class="formulaDsp">
\begin{align} \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} &amp;= \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} - 2 \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \right] + 4 \lambda_{e} \ln \left(\text{det}(\mathbf{F}) \right) \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} - \mu_{0} \mu_{r} \left[ \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} + \text{det}(\mathbf{F}) \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} \right] \\ &amp;= \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{I} - \mathbf{C}^{-1} \right] + 2 \lambda_{e} \ln \left(\text{det}(\mathbf{F}) \right) \mathbf{C}^{-1} - \mu_{0} \mu_{r} \left[ \frac{1}{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \mathbf{C}^{-1} - \text{det}(\mathbf{F}) \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{d f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} = \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \text{sech}^{2} \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \left[ \frac{4} {\left(h_{e}^{\text{sat}}\right)^{2}} \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} = \mathbf{I} \quad \text{(the second-order identity tensor)} \]
</p>
 <p class="formulaDsp">
\[ \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} = \frac{1}{2} \text{det}(\mathbf{F}) \mathbf{C}^{-1} \]
</p>
 <p class="formulaDsp">
\[ \frac{d C^{-1}_{ab}}{d C_{cd}} = - \text{sym} \left( C^{-1}_{ac} C^{-1}_{bd} \right) = -\frac{1}{2} \left[ C^{-1}_{ac} C^{-1}_{bd} + C^{-1}_{ad} C^{-1}_{bc} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} = - \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> The use of the symmetry operator \(\text{sym} \left( \bullet \right)\) in the one derivation above helps to ensure that the resulting rank-4 tensor, which holds minor symmetries due to the symmetry of \(\mathbf{C}\) , still maps rank-2 symmetric tensors to rank-2 symmetric tensors. See the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class documentation and the introduction to <a class="el" href="step_44.html">step-44</a> and for further explanation as to what symmetry means in the context of fourth-order tensors. The linearization of each of the kinematic variables with respect to their arguments are </p><p class="formulaDsp">
\[ \mathbb{D} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} = - \frac{1}{2} \mu_{e} \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] \frac{d^{2} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \mathbf{C}^{-1} \]
</p>
<p class="formulaDsp">
\begin{align} \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} &amp;= - \mu_{e} \left[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} - 2 \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \right] \otimes \frac{d f_{\mu_{e} \left( \boldsymbol{\mathbb{H}} \right)}}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \left[ \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \otimes \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \boldsymbol{\mathbb{H}}} \right] + \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} \\ &amp;= - \mu_{e} \left[ \mathbf{I} - \mathbf{C}^{-1} \right] \otimes \frac{d f_{\mu_{e} \left( \boldsymbol{\mathbb{H}} \right)}}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \left[ \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] + \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C} \otimes \mathbf{C} \boldsymbol{\mathbb{H}}} \end{align}
</p>
<p class="formulaDsp">
\begin{align} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} &amp;= 2 \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] + 4 \lambda_{e} \left[ \mathbf{C}^{-1} \otimes \left[ \frac{1}{\text{det}(\mathbf{F})} \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} \right] + \ln \left(\text{det}(\mathbf{F}) \right) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;- \mu_{0} \mu_{r} \left[ \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \mathbf{C}^{-1} \otimes \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{0} \mu_{r} \left[ \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \otimes \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} - \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} \right] \\ &amp;= 2 \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] + 4 \lambda_{e} \left[ \frac{1}{2} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \ln \left(\text{det}(\mathbf{F}) \right) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;- \mu_{0} \mu_{r} \left[ - \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] + \frac{1}{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{0} \mu_{r} \left[ \frac{1}{2} \text{det}(\mathbf{F}) \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \otimes \mathbf{C}^{-1} - \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{d^{2} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} = -2 \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \text{sech}^{2} \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \left[ \frac{4} {\left(h_{e}^{\text{sat}}\right)^{2}} \mathbf{I} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \boldsymbol{\mathbb{H}}} = 2 \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \]
</p>
 <p class="formulaDsp">
\[ \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} \Rightarrow \frac{d^{2} \left[ \mathbb{H}_{e} C^{-1}_{ef} \mathbb{H}_{f} \right]}{d C_{ab} d \mathbb{H}_{c}} = - C^{-1}_{ac} C^{-1}_{be} \mathbb{H}_{e} - C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{bc} \]
</p>
<p class="formulaDsp">
\begin{align} \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} &amp;= -\frac{d \left[\left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]\right]}{d \mathbf{C}} \\ \Rightarrow \frac{d^{2} \left[ \mathbb{H}_{e} C^{-1}_{ef} \mathbb{H}_{f} \right]}{d C_{ab} d C_{cd}} &amp;= \text{sym} \left( C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{cf} \mathbb{H}_{f} C^{-1}_{bd} + C^{-1}_{ce} \mathbb{H}_{e} C^{-1}_{bf} \mathbb{H}_{f} C^{-1}_{ad} \right) \\ &amp;= \frac{1}{2} \left[ C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{cf} \mathbb{H}_{f} C^{-1}_{bd} + C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{df} \mathbb{H}_{f} C^{-1}_{bc} + C^{-1}_{ce} \mathbb{H}_{e} C^{-1}_{bf} \mathbb{H}_{f} C^{-1}_{ad} + C^{-1}_{be} \mathbb{H}_{e} C^{-1}_{df} \mathbb{H}_{f} C^{-1}_{ac} \right] \end{align}
</p>
<p>Well, that escalated quickly</p>
<ul>
<li>although the the definition of \(\psi_{0}\) and \(f_{\mu_e}\) might have given some hints that the calculating the kinetic fields and their linearization would take some effort, it is likely that there's a little more complexity to the final definitions that perhaps initially thought. Knowing what we now do, it's probably fair to say that we really do not want to compute first and second derivatives of these functions with respect to their arguments</li>
<li>regardless of well we did in calculus classes, or how good a programmer we may be. In the class method definition where these are ultimately implemented, we've composed these calculations slightly differently. Some intermediate steps are also retained to give another perspective of how to systematically compute the derivatives. Additionally, some calculations are decomposed less or further to reuse some of the intermediate values and, hopefully, aid the reader to follow the derivative operations.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoelastic_Constitutive_Law final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoelastic_Constitutive_Law(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span>                  psi;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoelastic_Constitutive_Law&lt;dim&gt;::Magnetoelastic_Constitutive_Law(</div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , psi(0.0)</div><div class="line">{}</div></div><!-- fragment --><p>For this class's update method, we'll simply precompute a collection of intermediate values (for function evaluations, derivative calculations, and the like) and "manually" arrange them in the order that's required to maximize their reuse. This means that we have to manage this ourselves, and decide what values must be compute before others, all while keeping some semblance of order or structure in the code itself. It's effective, but perhaps a little tedious. It also doesn't do too much to help future extension of the class, because all of these values remain local to this single method. Interestingly, this basic technique of precomputing intermediate expressions that are used in more than one place has a name: <a href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">common subexpression elimination (CSE)</a>. It is a strategy used by Computer Algebra Systems to reduce the computational expense when they are tasked with evaluating similar expressions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C));</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C);</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>The saturation function for the magneto-elastic energy.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> two_h_dot_h_div_h_sat_squ =</div><div class="line">      (2.0 H H) / (this-&gt;get_mu_e_h_sat() this-&gt;get_mu_e_h_sat());</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(two_h_dot_h_div_h_sat_squ);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e =</div><div class="line">      1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e()</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">              tanh_two_h_dot_h_div_h_sat_squ;</div></div><!-- fragment --><p>The first derivative of the saturation function, noting that \(\frac{d \tanh(x)}{dx} = \text{sech}^{2}(x)\) .</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> dtanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">      <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(two_h_dot_h_div_h_sat_squ), 2.0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dtwo_h_dot_h_div_h_sat_squ_dH =</div><div class="line">      2.0 2.0 / (this-&gt;get_mu_e_h_sat() this-&gt;get_mu_e_h_sat()) H;</div><div class="line"></div><div class="line">    const <a class="code" href="classTensor.html">Tensor</a>&lt;1, dim&gt; df_mu_e_dH =</div><div class="line">      (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e()</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">      (dtanh_two_h_dot_h_div_h_sat_squ dtwo_h_dot_h_div_h_sat_squ_dH);</div></div><!-- fragment --><p>The second derivative of saturation function, noting that \(\frac{d \text{sech}^{2}(x)}{dx} = -2 \tanh(x) \text{sech}^{2}(x)\) .</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> d2tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-2.0 tanh_two_h_dot_h_div_h_sat_squ dtanh_two_h_dot_h_div_h_sat_squ;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2two_h_dot_h_div_h_sat_squ_dH_dH =</div><div class="line">      2.0 2.0 / (this-&gt;get_mu_e_h_sat() this-&gt;get_mu_e_h_sat())</div><div class="line">      <a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I;</div><div class="line"></div><div class="line">    const <a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim&gt; d2f_mu_e_dH_dH =</div><div class="line">      (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e()</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">      (d2tanh_two_h_dot_h_div_h_sat_squ</div><div class="line">         <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dtwo_h_dot_h_div_h_sat_squ_dH,</div><div class="line">                                  dtwo_h_dot_h_div_h_sat_squ_dH)) +</div><div class="line">       dtanh_two_h_dot_h_div_h_sat_squ d2two_h_dot_h_div_h_sat_squ_dH_dH);</div></div><!-- fragment --><p>Some intermediate quantities attained directly from the field / kinematic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         log_det_F         = <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         tr_C              = <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H       = C_inv H;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         H_dot_C_inv_dot_H = H C_inv_dot_H;</div></div><!-- fragment --><p>First derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d_tr_C_dC =</div><div class="line">      <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> ddet_F_dC     = 0.5 det_F C_inv;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dlog_det_F_dC = 0.5 C_inv;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dH_dot_C_inv_dot_H_dH = 2.0 C_inv_dot_H;</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dC_inv_dC;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">            dC_inv_dC[A][B][C][D]</div><div class="line"></div><div class="line">-=</div><div class="line">              0.5 (C_inv[A][C] C_inv[B][D]</div><div class="line">                     + C_inv[A][D] C_inv[B][C]);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dH_dot_C_inv_dot_H_dC =</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H));</div></div><!-- fragment --><p>Second derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2log_det_F_dC_dC = 0.5 dC_inv_dC;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2det_F_dC_dC =</div><div class="line">      0.5 (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv, ddet_F_dC) + det_F dC_inv_dC);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2H_dot_C_inv_dot_H_dH_dH = 2.0 C_inv;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">          d2H_dot_C_inv_dot_H_dC_dH[A][B][C]</div><div class="line"></div><div class="line">-=</div><div class="line">            C_inv[A][C] C_inv_dot_H[B] +</div><div class="line">            C_inv_dot_H[A] C_inv[B][C];</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">            d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">              0.5 (C_inv_dot_H[A] C_inv_dot_H[C] C_inv[B][D] +</div><div class="line">                     C_inv_dot_H[A] C_inv_dot_H[D] C_inv[B][C] +</div><div class="line">                     C_inv_dot_H[B] C_inv_dot_H[C] C_inv[A][D] +</div><div class="line">                     C_inv_dot_H[B] C_inv_dot_H[D] C_inv[A][C]);</div></div><!-- fragment --><p>The stored energy density function.</p>
<div class="fragment"><div class="line">    psi =</div><div class="line">      (0.5 this-&gt;get_mu_e() f_mu_e)</div><div class="line">        (tr_C</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">- 2.0 <a class="code" href="namespacestd.html">std</a>::log(det_F)) +</div><div class="line">      this-&gt;get_lambda_e() (<a class="code" href="namespacestd.html">std</a>::log(det_F) <a class="code" href="namespacestd.html">std</a>::log(det_F))</div><div class="line"></div><div class="line">-</div><div class="line">      (0.5 this-&gt;get_mu_0() this-&gt;get_mu_r()) det_F (H C_inv H);</div></div><!-- fragment --><p>The kinetic quantities.</p>
<div class="fragment"><div class="line">    B =</div><div class="line"></div><div class="line">-(0.5 this-&gt;get_mu_e() (tr_C</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">- 2.0 log_det_F))</div><div class="line">          df_mu_e_dH</div><div class="line">        + 0.5 this-&gt;get_mu_0() this-&gt;get_mu_r() det_F</div><div class="line">            dH_dot_C_inv_dot_H_dH;</div><div class="line"></div><div class="line">    S = 2.0 (0.5 this-&gt;get_mu_e() f_mu_e)</div><div class="line">          (d_tr_C_dC</div><div class="line"></div><div class="line">- 2.0 dlog_det_F_dC)</div><div class="line">        + 2.0 this-&gt;get_lambda_e() (2.0 log_det_F dlog_det_F_dC)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- 2.0 (0.5 this-&gt;get_mu_0() this-&gt;get_mu_r())</div><div class="line">            (H_dot_C_inv_dot_H ddet_F_dC</div><div class="line">             + det_F dH_dot_C_inv_dot_H_dC);</div></div><!-- fragment --><p>The linearization of the kinetic quantities.</p>
<div class="fragment"><div class="line">    BB =</div><div class="line"></div><div class="line">-(0.5 this-&gt;get_mu_e() (tr_C</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">- 2.0 log_det_F))</div><div class="line">           d2f_mu_e_dH_dH</div><div class="line">         + 0.5 this-&gt;get_mu_0() this-&gt;get_mu_r() det_F</div><div class="line">             d2H_dot_C_inv_dot_H_dH_dH;</div><div class="line"></div><div class="line">    PP =</div><div class="line"></div><div class="line">-2.0 (0.5 this-&gt;get_mu_e())</div><div class="line">           <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor</a>&lt;2, dim&gt;(d_tr_C_dC</div><div class="line"></div><div class="line">- 2.0 dlog_det_F_dC),</div><div class="line">                         df_mu_e_dH)</div><div class="line">         +</div><div class="line">         2.0 (0.5 this-&gt;get_mu_0() this-&gt;get_mu_r())</div><div class="line">           (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Tensor&lt;2, dim&gt;(ddet_F_dC), dH_dot_C_inv_dot_H_dH)</div><div class="line">            + det_F d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line"></div><div class="line">    HH =</div><div class="line">      4.0 (0.5 this-&gt;get_mu_e() f_mu_e) (-2.0 d2log_det_F_dC_dC)</div><div class="line">      + 4.0 this-&gt;get_lambda_e()</div><div class="line">          (2.0 <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)</div><div class="line">           + 2.0 log_det_F d2log_det_F_dC_dC)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- 4.0 (0.5 this-&gt;get_mu_0() this-&gt;get_mu_r())</div><div class="line">          (H_dot_C_inv_dot_H d2det_F_dC_dC</div><div class="line">           + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)</div><div class="line">           + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)</div><div class="line">           + det_F d2H_dot_C_inv_dot_H_dC_dC);</div><div class="line">  }</div><div class="line"></div><div class="line">  template &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> psi;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> B;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> S;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> BB;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> PP;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> HH;</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="Magnetoviscoelasticconstitutivelawhandderived"></a> </p><h4>Magneto-viscoelastic constitutive law (hand-derived)</h4>
<p>As mentioned before, the free energy density function for the magneto-viscoelastic material with one dissipative mechanism that we'll be considering is defined as </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \]
</p>
 <p class="formulaDsp">
\[ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\[ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p> and the evolution law </p><p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \left( \mathbf{C} \right) = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v} \right] \]
</p>
<p> that itself is parameterized in terms of \(\mathbf{C}\) . By design, the magnetoelastic part of the energy \(\psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) is identical to that of the magnetoelastic material presented earlier. So, for the derivatives of the various contributions stemming from this part of the energy, please refer to the previous section. We'll continue to highlight the specific contributions from those terms by superscripting the salient terms with \(ME\) , while contributions from the magneto-viscoelastic component are superscripted with \(MVE\) . Furthermore, the magnetic saturation function \(f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right)\) for the damping term has the identical form as that of the elastic term (i.e., \(f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right)\) ), and so the structure of its derivatives are identical to that seen before; the only change is for the three constitutive parameters that are now associated with the viscous shear modulus \(\mu_{v}\) rather than the elastic shear modulus \(\mu_{e}\) . For this magneto-viscoelastic material, the first derivatives that correspond to the magnetic induction vector and total Piola-Kirchhoff stress tensor are </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \Big\vert_{\mathbf{C}, \mathbf{C}_{v}} \equiv \boldsymbol{\mathbb{B}}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \boldsymbol{\mathbb{B}}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} - \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \Big\vert_{\mathbf{C}_{v}, \boldsymbol{\mathbb{H}}} \equiv \mathbf{S}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathbf{S}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} + 2 \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \]
</p>
<p> with the viscous contributions being </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \Big\vert_{\mathbf{C}, \mathbf{C}_{v}} = - \frac{1}{2} \mu_{v} \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \frac{\partial f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \Big\vert_{\mathbf{C}_{v}, \boldsymbol{\mathbb{H}}} = \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \right] \]
</p>
<p> and with </p><p class="formulaDsp">
\[ \frac{\partial f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \equiv \frac{d f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} . \]
</p>
<p> The time-discretized evolution law, </p><p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} \left( \mathbf{C} \right) = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p> will also dictate how the linearization of the internal variable with respect to the field variables is composed. Observe that in order to attain thecorrect* expressions for the magnetic induction vector and total Piola-Kirchhoff stress tensor for this dissipative material, we must adhere strictly to the outcome of applying the Coleman-Noll procedure: we must takepartial derivatives* of the free energy density function with respect to the field variables. (For our non-dissipative magnetoelastic material, taking either partial or total derivatives would have had the same result, so there was no need to draw your attention to this before.) The crucial part of the operation is to freeze the internal variable \(\mathbf{C}_{v}^{(t)} \left( \mathbf{C} \right)\) while computing the derivatives of \(\psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v} \left( \mathbf{C} \right), \boldsymbol{\mathbb{H}} \right)\) with respect to \(\mathbf{C}\)</p>
<ul>
<li>the dependence of \(\mathbf{C}_{v}^{(t)}\) on \(\mathbf{C}\) is not to be taken into account. When deciding whether to use AD or SD to perform this task the choice is clear</li>
<li>only the symbolic framework provides a mechanism to do this; as was mentioned before, AD can only return total derivatives so it is unsuitable for the task. To wrap things up, we'll present the material tangents for this rate-dependent coupled material. The linearization of both kinetic variables with respect to their arguments are <p class="formulaDsp">
\[ \mathbb{D} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} \equiv \mathbb{D}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathbb{D}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}^{ME}}{d \boldsymbol{\mathbb{H}}} + \frac{d \boldsymbol{\mathbb{B}}^{MVE}}{d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} \equiv \mathfrak{P}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathfrak{P}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}, ME}}{d \boldsymbol{\mathbb{H}}} - \frac{d \mathbf{S}^{\text{tot}, MVE}}{d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} \equiv \mathcal{H}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathcal{H}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}, ME}}{d \mathbf{C}} + 2 \frac{d \mathbf{S}^{\text{tot}, MVE}}{d \mathbf{C}} \]
</p>
 where the tangents for the viscous contributions are <p class="formulaDsp">
\[ \mathbb{D}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{1}{2} \mu_{v} \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \frac{\partial^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathfrak{P}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \mu_{v} \left[ \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \right] \otimes \frac{d f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} \]
</p>
</li>
</ul>
<p class="formulaDsp">
\begin{align} \mathcal{H}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] \otimes \left[ \mathbf{C}_{v} + \mathbf{C} : \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ \frac{1}{d^{2}} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ -\frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \otimes \mathbf{C}^{-1} + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{\partial^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \equiv \frac{d^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \]
</p>
<p> and, from the evolution law, </p><p class="formulaDsp">
\[ \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \equiv \frac{d \mathbf{C}_{v}^{(t)}}{d \mathbf{C}} = \frac{\frac{\Delta t}{\tau_{v}} }{1 + \frac{\Delta t}{\tau_{v}}} \left[ \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{\frac{2}{d}} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \left[\text{det}\left(\mathbf{F}\right)\right]^{\frac{2}{d}} \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] . \]
</p>
<p> Notice that just the last term of \(\mathcal{H}^{\text{tot}, MVE}\) contains the tangent of the internal variable. The linearization of this particular evolution law is linear. For an example of a nonlinear evolution law, for which this linearization must be solved for in an iterative manner, see <b>[Koprowski]</b> -Theiss2011a.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoviscoelastic_Constitutive_Law(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>                  psi;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div></div><!-- fragment --><p>A data structure that is used to store all intermediate calculations. We'll see shortly precisely how this can be leveraged to make the part of the code where we actually perform calculations clean and easy (well, at least easier) to follow and maintain. But for now, we can say that it will allow us to move the parts of the code where we compute the derivatives of intermediate quantities away from where they are used.</p>
<div class="fragment"><div class="line"><span class="keyword">mutable</span> <a class="code" href="classGeneralDataStorage.html">GeneralDataStorage</a> cache;</div></div><!-- fragment --><p>The next two functions are used to update the state of the field and internal variables, and will be called before we perform any detailed calculations.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_primary_variables(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> update_internal_variable(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time);</div></div><!-- fragment --><p>The remainder of the class interface is dedicated to methods that are used to compute the components required to calculate the free energy density function, and all of its derivatives:</p>
<p>The kinematic, or field, variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C() <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_f_mu(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the first derivative of saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_df_mu_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the second derivative of saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_d2f_mu_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Intermediate quantities attained directly from the field / kinematic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C_inv() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_log_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_trace_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_H_dot_C_inv_dot_H() <span class="keyword">const</span>;</div></div><!-- fragment --><p>First derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_dC_inv_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d_tr_C_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_ddet_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dlog_det_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dC() <span class="keyword">const</span>;</div></div><!-- fragment --><p>Derivative of internal variable with respect to field variables. Notice that we only need this one derivative of the internal variable, as this variable is only differentiated as part of the linearization of the kinetic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">get_dQ_t_dC(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Second derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2log_det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dH_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dC() <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::Magnetoviscoelastic_Constitutive_Law(<span class="keyword">const</span> ConstitutiveParameters</div><div class="line">                                               &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , psi(0.0)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">{</div></div><!-- fragment --><p>Record the applied deformation state as well as the magnetic load. Thereafter, update internal (viscous) variable based on new deformation state.</p>
<div class="fragment"><div class="line">set_primary_variables(C, H);</div><div class="line">update_internal_variable(time);</div></div><!-- fragment --><p>Get the values for the elastic and viscous saturation function based on the current magnetic field...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e = get_f_mu(this-&gt;get_mu_e(),</div><div class="line">                               this-&gt;get_mu_e_inf(),</div><div class="line">                               this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_v = get_f_mu(this-&gt;get_mu_v(),</div><div class="line">                               this-&gt;get_mu_v_inf(),</div><div class="line">                               this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>... as well as their first derivatives...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH = get_df_mu_dH(this-&gt;get_mu_e(),</div><div class="line">                                               this-&gt;get_mu_e_inf(),</div><div class="line">                                               this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_v_dH = get_df_mu_dH(this-&gt;get_mu_v(),</div><div class="line">                                               this-&gt;get_mu_v_inf(),</div><div class="line">                                               this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>... and their second derivatives.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">  get_d2f_mu_dH_dH(this-&gt;get_mu_e(),</div><div class="line">                   this-&gt;get_mu_e_inf(),</div><div class="line">                   this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_v_dH_dH =</div><div class="line">  get_d2f_mu_dH_dH(this-&gt;get_mu_v(),</div><div class="line">                   this-&gt;get_mu_v_inf(),</div><div class="line">                   this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>Intermediate quantities. Note that, since we're fetching these values from a cache that has a lifetime that outlasts this function call, we can alias the result rather than copying the value from the cache.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;                 det_F = get_det_F();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;log_det_F         = get_log_det_F();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;tr_C              = get_trace_C();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();</div></div><!-- fragment --><p>First derivatives of intermediate values, as well as the that of the internal variable with respect to the right Cauchy-Green deformation tensor.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d_tr_C_dC     = get_d_tr_C_dC();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;ddet_F_dC     = get_ddet_F_dC();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dlog_det_F_dC = get_dlog_det_F_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;dQ_t_dC = get_dQ_t_dC(time);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dC =</div><div class="line">  get_dH_dot_C_inv_dot_H_dC();</div></div><!-- fragment --><p>Second derivatives of intermediate values.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2log_det_F_dC_dC =</div><div class="line">  get_d2log_det_F_dC_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2det_F_dC_dC = get_d2det_F_dC_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dH_dH =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dH_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dH =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dC_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dC =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dC_dC();</div></div><!-- fragment --><p>Since the definitions of the linearizations become particularly lengthy, we'll decompose the free energy density function into three additive components:</p>
<ul>
<li>the "Neo-Hookean"-like term,</li>
<li>the rate-dependent term, and</li>
<li>the term that resembles that of the energy stored in the magnetic field. To remain consistent, each of these contributions will be individually added to the variables that we want to compute in that same order. So, first of all this is the energy density function itself:</li>
</ul>
<div class="fragment"><div class="line">    psi = (0.5 this-&gt;get_mu_e() f_mu_e)</div><div class="line">            (tr_C</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">- 2.0 <a class="code" href="namespacestd.html">std</a>::log(det_F)) +</div><div class="line">          this-&gt;get_lambda_e() (<a class="code" href="namespacestd.html">std</a>::log(det_F) <a class="code" href="namespacestd.html">std</a>::log(det_F));</div><div class="line">    psi += (0.5 this-&gt;get_mu_v() f_mu_v)</div><div class="line">           (Q_t (<a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim) C)</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">-</div><div class="line">            <a class="code" href="namespacestd.html">std</a>::log(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t)));</div><div class="line">    psi</div><div class="line"></div><div class="line">-=</div><div class="line">      (0.5 this-&gt;get_mu_0() this-&gt;get_mu_r()) det_F (H C_inv H);</div></div><!-- fragment --><p>... followed by the magnetic induction vector and Piola-Kirchhoff stress:</p>
<div class="fragment"><div class="line">    B =</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-(0.5 this-&gt;get_mu_e() (tr_C</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">- 2.0 log_det_F)) df_mu_e_dH;</div><div class="line">    B</div><div class="line"></div><div class="line">-= (0.5 this-&gt;get_mu_v())</div><div class="line">         (Q_t (std::pow(det_F,</div><div class="line"></div><div class="line">-2.0 / dim) C)</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">-</div><div class="line">          <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t)))</div><div class="line">         df_mu_v_dH;</div><div class="line">    B += 0.5 this-&gt;get_mu_0() this-&gt;get_mu_r() det_F</div><div class="line">         dH_dot_C_inv_dot_H_dH;</div><div class="line"></div><div class="line">    S = 2.0 (0.5 this-&gt;get_mu_e() f_mu_e)</div><div class="line">          (d_tr_C_dC</div><div class="line"></div><div class="line">- 2.0 dlog_det_F_dC)</div><div class="line">        + 2.0 this-&gt;get_lambda_e() (2.0 log_det_F dlog_det_F_dC);</div><div class="line">    S += 2.0 (0.5 this-&gt;get_mu_v() f_mu_v)</div><div class="line">         ((Q_t C)</div><div class="line">            ((-2.0 / dim) <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim</div><div class="line"></div><div class="line">- 1.0) ddet_F_dC) +</div><div class="line">          <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim) Q_t);                <span class="comment">// dC/dC = II</span></div><div class="line">    S</div><div class="line"></div><div class="line">-= 2.0 (0.5 this-&gt;get_mu_0() this-&gt;get_mu_r())</div><div class="line">         (H_dot_C_inv_dot_H ddet_F_dC</div><div class="line">          + det_F dH_dot_C_inv_dot_H_dC);</div></div><!-- fragment --><p>... and lastly the tangents due to the linearization of the kinetic variables.</p>
<div class="fragment"><div class="line">    BB =</div><div class="line"></div><div class="line">-(0.5 this-&gt;get_mu_e() (tr_C</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">- 2.0 log_det_F))</div><div class="line">         d2f_mu_e_dH_dH;</div><div class="line">    BB</div><div class="line"></div><div class="line">-= (0.5 this-&gt;get_mu_v())</div><div class="line">          (Q_t (std::pow(det_F,</div><div class="line"></div><div class="line">-2.0 / dim) C)</div><div class="line"></div><div class="line">- dim</div><div class="line"></div><div class="line">-</div><div class="line">           <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t)))</div><div class="line">          d2f_mu_v_dH_dH;</div><div class="line">    BB += 0.5 this-&gt;get_mu_0() this-&gt;get_mu_r() det_F</div><div class="line">          d2H_dot_C_inv_dot_H_dH_dH;</div><div class="line"></div><div class="line">    PP =</div><div class="line"></div><div class="line">-2.0 (0.5 this-&gt;get_mu_e())</div><div class="line">         <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor</a>&lt;2, dim&gt;(d_tr_C_dC</div><div class="line"></div><div class="line">- 2.0 dlog_det_F_dC),</div><div class="line">                       df_mu_e_dH);</div><div class="line">    PP</div><div class="line"></div><div class="line">-= 2.0 (0.5 this-&gt;get_mu_v())</div><div class="line">          <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Tensor&lt;2, dim&gt;((Q_t C)</div><div class="line">                                         ((-2.0 / dim)</div><div class="line">                                          <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">                                          ddet_F_dC) +</div><div class="line">                                       <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim) Q_t),</div><div class="line">                        df_mu_v_dH);</div><div class="line">    PP += 2.0 (0.5 this-&gt;get_mu_0() this-&gt;get_mu_r())</div><div class="line">          (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Tensor&lt;2, dim&gt;(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +</div><div class="line">           det_F d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line"></div><div class="line">    HH =</div><div class="line">      4.0 (0.5 this-&gt;get_mu_e() f_mu_e) (-2.0 d2log_det_F_dC_dC)</div><div class="line">      + 4.0 this-&gt;get_lambda_e()</div><div class="line">          (2.0 <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)</div><div class="line">           + 2.0 log_det_F d2log_det_F_dC_dC);</div><div class="line">    HH += 4.0 (0.5 this-&gt;get_mu_v() f_mu_v)</div><div class="line">          (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>((-2.0 / dim) <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">                           ddet_F_dC,</div><div class="line">                         C dQ_t_dC + Q_t) +</div><div class="line">           (Q_t C)</div><div class="line">             (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC,</div><div class="line">                            (-2.0 / dim) (-2.0 / dim</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">                              <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim</div><div class="line"></div><div class="line">- 2.0) ddet_F_dC) +</div><div class="line">              ((-2.0 / dim) <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">               d2det_F_dC_dC)) +</div><div class="line">           <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Q_t,</div><div class="line">                         (-2.0 / dim) <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">                           ddet_F_dC) +</div><div class="line">           <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F,</div><div class="line"></div><div class="line">-2.0 / dim) dQ_t_dC);</div><div class="line">    HH</div><div class="line"></div><div class="line">-= 4.0 (0.5 this-&gt;get_mu_0() this-&gt;get_mu_r())</div><div class="line">          (H_dot_C_inv_dot_H d2det_F_dC_dC</div><div class="line">           + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)</div><div class="line">           + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)</div><div class="line">           + det_F d2H_dot_C_inv_dot_H_dC_dC);</div></div><!-- fragment --><p>Now that we're done using all of those temporary variables stored in our cache, we can clear it out to free up some memory.</p>
<div class="fragment"><div class="line">  cache.reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> psi;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> B;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> S;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> BB;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> PP;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> HH;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_end_of_timestep()</div><div class="line">{</div><div class="line">  Q_t1 = Q_t;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_variable(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">  Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v()))</div><div class="line">        (Q_t1 + (delta_t / this-&gt;get_tau_v())</div><div class="line">                  std::pow(get_det_F(), 2.0 / dim) get_C_inv());</div><div class="line">}</div></div><!-- fragment --><p>The next few functions implement the generalized formulation for the saturation function, as well as its various derivatives.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_two_h_dot_h_div_h_sat_squ(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;H = get_H();</div><div class="line">  <span class="keywordflow">return</span> (2.0 H H) / (mu_h_sat mu_h_sat);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));</div><div class="line">}</div></div><!-- fragment --><p>A scaling function that will cause the shear modulus to change (increase) under the influence of a magnetic field.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_f_mu(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1.0 +</div><div class="line">           (mu_inf / mu</div><div class="line"></div><div class="line">- 1.0) get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">  }</div></div><!-- fragment --><p>First derivative of scaling function</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">    dim&gt;::get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),</div><div class="line">                    2.0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">    dim&gt;::get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 2.0 2.0 / (mu_h_sat mu_h_sat) get_H();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_df_mu_dH(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (mu_inf / mu</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">           (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat)</div><div class="line">            get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">    dim&gt;::get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span></div><div class="line"></div><div class="line">-2.0 get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat)</div><div class="line">           get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">    dim&gt;::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 2.0 2.0 / (mu_h_sat mu_h_sat)</div><div class="line">           <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2f_mu_dH_dH(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (mu_inf / mu</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">           (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat)</div><div class="line">              <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(</div><div class="line">                <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),</div><div class="line">                              get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +</div><div class="line">            get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat)</div><div class="line">              get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));</div><div class="line">  }</div></div><!-- fragment --><p>For the cached calculation approach that we've adopted for this material class, the root of all calculations are the field variables, and the immutable ancillary data such as the constitutive parameters and time step size. As such, we need to enter them into the cache in a different manner to the other variables, since they are inputs that are prescribed from outside the class itself. This function simply adds them to the cache directly from the input arguments, checking that there is no equivalent data there in the first place (we expect to call the <code>update_internal_data()</code> method only once per time step, or Newton iteration).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::set_primary_variables(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>Set value for \(\boldsymbol{\mathbb{H}}\) .</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string name_H(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_H),</div><div class="line">       <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">         <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">cache.add_unique_copy(name_H, H);</div></div><!-- fragment --><p>Set value for \(\mathbf{C}\) .</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string name_C(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_C),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">           <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">  cache.add_unique_copy(name_C, C);</div><div class="line">}</div></div><!-- fragment --><p>After that, we can fetch them from the cache at any point in time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div></div><!-- fragment --><p>With the primary variables guaranteed to be in the cache when we need them, we can not compute all intermediate values (either directly, or indirectly) from them. If the cache does not already store the value that we're looking for, then we quickly calculate it, store it in the cache and return the value just stored in the cache. That way we can return it as a reference and avoid copying the object. The same goes for any values that a compound function might depend on. Said another way, if there is a dependency chain of calculations that come before the one that we're currently interested in doing, then we're guaranteed to resolve the dependencies before we proceed with using any of those values. Although there is a cost to fetching data from the cache, the "resolved dependency" concept might be sufficiently convenient to make it worth looking past the extra cost. If these material laws are embedded within a finite element framework, then the added cost might not even be noticeable.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;det_F&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(get_C()));</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                    <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line">        cache.add_unique_copy(name, det_F);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        cache.add_unique_copy(name, <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(get_C()));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_log_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;log(det_F)&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, std::log(get_det_F()));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_trace_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;trace(C)&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(get_C()));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv_dot_H&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, get_C_inv() get_H());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H_dot_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H_dot_C_inv_dot_H&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, get_H() get_C_inv_dot_H());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dQ_t_dC(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dQ_t_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>  delta_t = this-&gt;get_delta_t(time);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;det_F   = get_det_F();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dQ_t_dC =</div><div class="line">          (1.0 / (1.0 + delta_t / this-&gt;get_tau_v()))</div><div class="line">          (delta_t / this-&gt;get_tau_v())</div><div class="line">          ((2.0 / dim) <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim</div><div class="line"></div><div class="line">- 1.0)</div><div class="line">             <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">           <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(det_F, 2.0 / dim) get_dC_inv_dC());</div><div class="line"></div><div class="line">        cache.add_unique_copy(name, dQ_t_dC);</div><div class="line">      }</div><div class="line"></div><div class="line">    return cache.template get_object_with_name&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;4, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  const SymmetricTensor&lt;4, dim&gt; &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dC_inv_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dC_inv_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line">        <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>        dC_inv_dC;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">                dC_inv_dC[A][B][C][D]</div><div class="line"></div><div class="line">-=</div><div class="line">                  0.5 (C_inv[A][C] C_inv[B][D]</div><div class="line">                         + C_inv[A][D] C_inv[B][C]);</div><div class="line"></div><div class="line">        cache.add_unique_copy(name, dC_inv_dC);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d_tr_C_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d_tr_C_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name,</div><div class="line">                            <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_ddet_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;ddet_F_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, 0.5 get_det_F() get_C_inv());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dlog_det_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dlog_det_F_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, 0.5 get_C_inv());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dH&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, 2.0 get_C_inv_dot_H());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">        cache.add_unique_copy(</div><div class="line">          name,</div><div class="line"></div><div class="line">-<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H)));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2log_det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2log_det_F_dC_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, 0.5 get_dC_inv_dC());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2det_F_dC_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name,</div><div class="line">                            0.5</div><div class="line">                              (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">                               get_det_F() get_dC_inv_dC()));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dH_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">    const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dH_dH&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      cache.add_unique_copy(name, 2.0 get_C_inv());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">    const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dH&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">              d2H_dot_C_inv_dot_H_dC_dH[A][B][C]</div><div class="line"></div><div class="line">-=</div><div class="line">                C_inv[A][C] C_inv_dot_H[B] +</div><div class="line">                C_inv_dot_H[A] C_inv[B][C];</div><div class="line"></div><div class="line">        cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;3, dim&gt;&gt;(name);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">  Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dC()<span class="keyword"></span></div><div class="line"><span class="keyword">    const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dC&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">        <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">                d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">                  0.5 (C_inv_dot_H[A] C_inv_dot_H[C] C_inv[B][D] +</div><div class="line">                         C_inv_dot_H[A] C_inv_dot_H[D] C_inv[B][C] +</div><div class="line">                         C_inv_dot_H[B] C_inv_dot_H[C] C_inv[A][D] +</div><div class="line">                         C_inv_dot_H[B] C_inv_dot_H[D] C_inv[A][C]);</div><div class="line"></div><div class="line">        cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="Rheologicalexperimentparameters"></a> </p><h4>Rheological experiment parameters</h4>
<p>The <code>RheologicalExperimentParameters</code> class is used to drive the numerical experiments that are to be conducted on the coupled materials that we've implemented constitutive laws for.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RheologicalExperimentParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RheologicalExperimentParameters();</div></div><!-- fragment --><p>These are dimensions of the rheological specimen that is to be simulated. They, effectively, define the measurement point for our virtual experiment.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sample_radius = 0.01;</div><div class="line"><span class="keywordtype">double</span> sample_height = 0.001;</div></div><!-- fragment --><p>The three steady-state loading parameters are respectively</p>
<ul>
<li>the axial stretch,</li>
<li>the shear strain amplitude, and</li>
<li>the axial magnetic field strength.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> lambda_2 = 0.95;</div><div class="line"><span class="keywordtype">double</span> gamma_12 = 0.05;</div><div class="line"><span class="keywordtype">double</span> H_2      = 60.0e3;</div></div><!-- fragment --><p>Moreover, the parameters for the time-dependent rheological loading conditions are</p>
<ul>
<li>the loading cycle frequency,</li>
<li>the number of load cycles, and</li>
<li>the number of discrete timesteps per cycle.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>       frequency         = 1.0 / (2.0 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles          = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps_per_cycle = 2500;</div></div><!-- fragment --><p>We also declare some self-explanatory parameters related to output data generated for the experiments conducted with rate-dependent and rate-independent materials.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span>        output_data_to_file = <span class="keyword">true</span>;</div><div class="line">std::string output_filename_rd =</div><div class="line">  <span class="stringliteral">&quot;experimental_results-rate_dependent.csv&quot;</span>;</div><div class="line">std::string output_filename_ri =</div><div class="line">  <span class="stringliteral">&quot;experimental_results-rate_independent.csv&quot;</span>;</div></div><!-- fragment --><p>The next few functions compute time-related parameters for the experiment...</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> start_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> end_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> delta_t() <span class="keyword">const</span>;</div></div><!-- fragment --><p>... while the following two prescribe the mechanical and magnetic loading at any given time...</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> get_H(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>... and this last one outputs the status of the experiment to the console.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">bool</span> print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  RheologicalExperimentParameters::RheologicalExperimentParameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Rheological Experiment/&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_radius);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_height);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Axial stretch&quot;</span>, lambda_2);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Shear strain amplitude&quot;</span>, gamma_12);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Axial magnetic field strength&quot;</span>, H_2);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Frequency&quot;</span>, frequency);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Number of loading cycles&quot;</span>, n_cycles);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Discretisation for each cycle&quot;</span>, n_steps_per_cycle);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output experimental results to file&quot;</span>, output_data_to_file);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output file name (rate dependent constitutive law)&quot;</span>,</div><div class="line">                  output_filename_rd);</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Output file name (rate independent constitutive law)&quot;</span>,</div><div class="line">                  output_filename_ri);</div><div class="line"></div><div class="line">    parse_parameters_call_back.connect([&amp;]()</div><div class="line"></div><div class="line">-&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> RheologicalExperimentParameters::start_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> RheologicalExperimentParameters::end_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> n_cycles / frequency;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> RheologicalExperimentParameters::delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (end_time()</div><div class="line"></div><div class="line">- start_time()) / (n_steps_per_cycle n_cycles);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span></div><div class="line">  RheologicalExperimentParameters::print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (step_number % (n_cycles n_steps_per_cycle / 100)) == 0;</div><div class="line">  }</div></div><!-- fragment --><p>The applied magnetic field is always aligned with the axis of rotation of the rheometer's rotor.</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> RheologicalExperimentParameters::get_H(<span class="keyword">const</span> <span class="keywordtype">double</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>({0.0, 0.0, H_2});</div><div class="line">}</div></div><!-- fragment --><p>The applied deformation (gradient) is computed based on the geometry of the rheometer and the sample, the sampling point, and the experimental parameters. From the displacement profile documented in the introduction, the deformation gradient may be expressed in Cartesian coordinates as </p><p class="formulaDsp">
\[ \mathbf{F} = \begin{bmatrix} \frac{\cos\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\frac{\sin\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\tau R \sqrt{\lambda_{3}} \sin\left(\Theta + \alpha\right) \\ \frac{\sin\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; \frac{\cos\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\tau R \sqrt{\lambda_{3}} \cos\left(\Theta + \alpha\right) \\ 0 &amp; 0 &amp; \lambda_{3} \end{bmatrix} \]
</p>
<div class="fragment"><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> RheologicalExperimentParameters::get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((sample_radius &gt; 0.0 &amp;&amp; sample_height &gt; 0.0),</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical sample dimensions&quot;</span>));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(lambda_2 &gt; 0.0,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical applied axial stretch&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> sqrt_lambda_2     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(lambda_2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_max =</div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(std::tan(gamma_12) sample_height /</div><div class="line">                sample_radius); <span class="comment">// Small strain approximation</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> A       = sample_radius alpha_max;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> w       = 2.0 numbers::PI frequency; <span class="comment">// in rad /s</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> gamma_t = A <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(w time);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tau_t =</div><div class="line">      gamma_t /</div><div class="line">      (sample_radius sample_height); <span class="comment">// Torsion angle per unit length</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_t = tau_t lambda_2 sample_height;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">    F[0][0] = inv_sqrt_lambda_2 <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">    F[0][1] =</div><div class="line"></div><div class="line">-inv_sqrt_lambda_2 <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">    F[0][2] =</div><div class="line"></div><div class="line">-tau_t sample_radius sqrt_lambda_2 <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">    F[1][0] = inv_sqrt_lambda_2 <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">    F[1][1] = inv_sqrt_lambda_2 <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">    F[1][2] = tau_t sample_radius sqrt_lambda_2 <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">    F[2][0] = 0.0;</div><div class="line">    F[2][1] = 0.0;</div><div class="line">    F[2][2] = lambda_2;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((F[0][0] &gt; 0) &amp;&amp; (F[1][1] &gt; 0) &amp;&amp; (F[2][2] &gt; 0),</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical deformation gradient component.&quot;</span>));</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(F)</div><div class="line"></div><div class="line">- 1.0) &lt; 1e-6,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian is not equal to unity.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="RheologicalexperimentParallelplaterotationalrheometer"></a> </p><h4>Rheological experiment: Parallel plate rotational rheometer</h4>
<p>This is the function that will drive the numerical experiments.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> run_rheological_experiment(</div><div class="line">  <span class="keyword">const</span> RheologicalExperimentParameters &amp;experimental_parameters,</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    &amp;material_hand_calculated,</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    &amp;               material_assisted_computation,</div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> &amp;     timer,</div><div class="line">  <span class="keyword">const</span> std::string filename)</div><div class="line">{</div></div><!-- fragment --><p>We can take the hand-implemented constitutive law and compare the results that we attain with it to those that we get using AD or SD. In this way, we can verify that they produce identical results (which indicates that either both implementations have a high probability of being correct, or that they're incorrect with identical flaws being present in both). Either way, it is a decent sanity check for the fully self-implemented variants and can certainly be used as a debugging strategy when differences between the results are detected).</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> check_material_class_results =</div><div class="line">      [](</div><div class="line">        <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;to_verify,</div><div class="line">        <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;blessed,</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-6) {</div><div class="line">        (void)to_verify;</div><div class="line">        (void)blessed;</div><div class="line">        (void)tol;</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(std::abs(blessed.get_psi()</div><div class="line"></div><div class="line">- to_verify.get_psi()) &lt; tol,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for psi. Error: &quot;</span> +</div><div class="line">                          <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(std::abs(</div><div class="line">                            blessed.get_psi()</div><div class="line"></div><div class="line">- to_verify.get_psi()))));</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_B()</div><div class="line"></div><div class="line">- to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for B. Error: &quot;</span> +</div><div class="line">                          <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                            (blessed.get_B()</div><div class="line"></div><div class="line">- to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_S()</div><div class="line"></div><div class="line">- to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for S. Error: &quot;</span> +</div><div class="line">                          <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                            (blessed.get_S()</div><div class="line"></div><div class="line">- to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_DD()</div><div class="line"></div><div class="line">- to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for BB. Error: &quot;</span> +</div><div class="line">                          <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                            (blessed.get_DD()</div><div class="line"></div><div class="line">- to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_PP()</div><div class="line"></div><div class="line">- to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for PP. Error: &quot;</span> +</div><div class="line">                          <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                            (blessed.get_PP()</div><div class="line"></div><div class="line">- to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_HH()</div><div class="line"></div><div class="line">- to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for HH. Error: &quot;</span> +</div><div class="line">                          <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                            (blessed.get_HH()</div><div class="line"></div><div class="line">- to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">      };</div></div><!-- fragment --><p>We'll be outputting the constitutive response of the material to file for post-processing, so here we declare a <code>stream</code> that will act as a buffer for this output. We'll use a simple CSV format for the outputted results.</p>
<div class="fragment"><div class="line">std::ostringstream stream;</div><div class="line">stream</div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\n&quot;</span>;</div></div><!-- fragment --><p>Using the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> class, we iterate through each timestep using a fixed time step size.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(experimental_parameters.start_time(),</div><div class="line">                       experimental_parameters.end_time() +</div><div class="line">                         experimental_parameters.delta_t(),</div><div class="line">                       experimental_parameters.delta_t());</div><div class="line">     time.is_at_end() == <span class="keyword">false</span>;</div><div class="line">     time.advance_time())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (experimental_parameters.print_status(time.get_step_number()))</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep = &quot;</span> &lt;&lt; time.get_step_number()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; @ time = &quot;</span> &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;s.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>We fetch and compute the loading to be applied to the material at this time step...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> H =</div><div class="line">  experimental_parameters.get_H(time.get_current_time());</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F =</div><div class="line">  experimental_parameters.get_F(time.get_current_time());</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C =</div><div class="line">  <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">Physics::Elasticity::Kinematics::C</a>(F);</div></div><!-- fragment --><p>... then we update the state of the materials...</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Hand calculated&quot;</span>);</div><div class="line">  material_hand_calculated.update_internal_data(C, H, time);</div><div class="line">  material_hand_calculated.update_end_of_timestep();</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assisted computation&quot;</span>);</div><div class="line">  material_assisted_computation.update_internal_data(C, H, time);</div><div class="line">  material_assisted_computation.update_end_of_timestep();</div><div class="line">}</div></div><!-- fragment --><p>... and test for discrepancies between the two.</p>
<div class="fragment"><div class="line">check_material_class_results(material_hand_calculated,</div><div class="line">                             material_assisted_computation);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">  {</div></div><!-- fragment --><p>The next thing that we will do is collect some results to post-process. All quantities are in the "current configuration" (rather than the "reference
 configuration", in which all quantities computed by the constitutive laws are framed).</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> h =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Covariant.html#ad438f09c3045e448805f62b27c2f8d29">Physics::Transformations::Covariant::push_forward</a>(H, F);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> b =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">          material_hand_calculated.get_B(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> sigma =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">          material_hand_calculated.get_S(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">      stream &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; h[2] &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; b[2]</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; F[1][2] 100.0 &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; sigma[1][2] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, we output the strain-stress and magnetic loading history to file.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">    {</div><div class="line">      std::ofstream output(filename);</div><div class="line">      output &lt;&lt; stream.str();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheCoupledConstitutiveLawsrunfunction"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">CoupledConstitutiveLaws::run()</a> function</h4>
<p>The purpose of this driver function is to read in all of the parameters from file and, based off of that, create a representative instance of each constitutive law and invoke the function that conducts a rheological experiment with it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters          constitutive_parameters;</div><div class="line">  <span class="keyword">const</span> RheologicalExperimentParameters experimental_parameters;</div><div class="line"></div><div class="line">  std::string parameter_file;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    parameter_file = argv[1];</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line">  <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div></div><!-- fragment --><p>We start the actual work by configuring and running the experiment using our rate-independent constitutive law. The automatically differentiable number type is hard-coded here, but with some clever templating it is possible to select which framework to use at run time (e.g., as selected through the parameter file). We'll simultaneously perform the experiments with the counterpary material law that was fully implemented by hand, and check what it computes against our assisted implementation.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                    <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                    <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">  std::cout</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;Coupled magnetoelastic constitutive law using automatic differentiation.&quot;</span></div><div class="line">    &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"></div><div class="line">  Magnetoelastic_Constitutive_Law&lt;dim&gt; material(constitutive_parameters);</div><div class="line">  Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt; material_ad(</div><div class="line">    constitutive_parameters);</div><div class="line"></div><div class="line">  run_rheological_experiment(experimental_parameters,</div><div class="line">                             material,</div><div class="line">                             material_ad,</div><div class="line">                             timer,</div><div class="line">                             experimental_parameters.output_filename_ri);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Next we do the same for the rate-dependent constitutive law. The highest performance option is selected as default if SymEngine is set up to use the LLVM just-in-time compiler which (in conjunction with some aggressive compilation flags) produces the fastest code evaluation path of all of the available option. As a fall-back, the so called "lambda" optimizer (which only requires a C++11 compliant compiler) will be selected. At the same time, we'll ask the CAS to perform common subexpression elimination to minimize the number of intermediate calculations used during evaluation. We'll record how long it takes to execute the "initialization" step inside the constructor for the SD implementation, as this is where the abovementioned transformations occur.</p>
<div class="fragment"><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                        <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                        <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">      std::cout</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Coupled magneto-viscoelastic constitutive law using symbolic differentiation.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_SYMENGINE_WITH_LLVM</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Using LLVM optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">      constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba7c7d2b9e8389cc541dc5a615e05bcf1e">Differentiation::SD::OptimizerType::llvm</a>;</div><div class="line">      constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a1ad0cce13bc606ad6742e9841ccdfe15">Differentiation::SD::OptimizationFlags::optimize_all</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Using lambda optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">      constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">Differentiation::SD::OptimizerType::lambda</a>;</div><div class="line">      constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a3df84265620315a025367510c90d0474">Differentiation::SD::OptimizationFlags::optimize_cse</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">      Magnetoviscoelastic_Constitutive_Law&lt;dim&gt; material(</div><div class="line">        constitutive_parameters);</div><div class="line"></div><div class="line">      timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Initialize symbolic CL&quot;</span>);</div><div class="line">      Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt; material_sd(</div><div class="line">        constitutive_parameters, optimizer_type, optimization_flags);</div><div class="line">      timer.<a class="code" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a>();</div><div class="line"></div><div class="line">      run_rheological_experiment(experimental_parameters,</div><div class="line">                                 material,</div><div class="line">                                 material_sd,</div><div class="line">                                 timer,</div><div class="line">                                 experimental_parameters.output_filename_rd);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace CoupledConstitutiveLaws</span></div><div class="line"></div><div class="line">} <span class="comment">// namespace Step71</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The main function only calls the driver functions for the two sets of examples that are to be executed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line"><a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::SimpleExample::run</a>();</div><div class="line"><a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::CoupledConstitutiveLaws::run</a>(argc, argv);</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Introductoryexample"></a></p><h3>Introductory example</h3>
<p>The first exploratory example produces the following output. It is verified thatall three implementations produce identical results. </p><div class="fragment"><div class="line">&gt; ./step-71</div><div class="line">Simple example <span class="keyword">using</span> automatic differentiation...</div><div class="line">... all calculations are correct!</div><div class="line">Simple example <span class="keyword">using</span> symbolic differentiation.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --><p><a class="anchor" id="Constitutivemodelling"></a></p><h3>Constitutive modelling</h3>
<p>To help summarize the results from the virtual experiment itself, below are somegraphs showing the shear stress, plotted against the shear strain, at a selectlocation within the material sample. The plots show the stress-strain curves underthree different magnetic loads, and for the last cycle of the (mechanical)loading profile, when the rate-dependent material reaches a repeatable("steady-state") response. These types of graphs are often referred to as<a href="https://en.wikipedia.org/wiki/Lissajous_curve">Lissajous plots</a>. The areaof the ellipse that the curve takes for viscoelastic materials provides somemeasure of how much energy is dissipated by the material, and its ellipticityindicates the phase shift of the viscous response with respect to the elasticresponse. </p><table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.lissajous_plot-me.png" width="400"/>
</div>
 <p>Lissajous plot for the magneto-elastic material. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.lissajous_plot-mve.png" width="400"/>
</div>
 <p>Lissajous plot for the magneto-viscoelastic material. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>It is not surprising to see that the magneto-elastic material response has an unloadingcurve that matches the loading curve</p>
<ul>
<li>the material is non-dissipative after all.But here it's clearly noticeable how the gradient of the curve increases as theapplied magnetic field increases. The tangent at any point along this curve isrelated to the instantaneous shear modulus and, due to the way that the energydensity function was defined, we expect that the shear modulus increases as themagnetic field strength increases.We observe much the same behavior for the magneto-viscoelastic material. The majoraxis of the ellipse traced by the loading-unloading curve has a slope that increasesas a greater magnetic load is applied. At the same time, the more energy isdissipated by the material. As for the code output, this is what is printed to the console for the partpertaining to the rheological experiment conducted with the magnetoelasticmaterial: <div class="fragment"><div class="line">Coupled magnetoelastic constitutive law <span class="keyword">using</span> automatic differentiation.</div><div class="line">Timestep = 0 @ time = 0s.</div><div class="line">Timestep = 125 @ time = 0.314159s.</div><div class="line">Timestep = 250 @ time = 0.628318s.</div><div class="line">Timestep = 375 @ time = 0.942477s.</div><div class="line">...</div><div class="line">Timestep = 12250 @ time = 30.7876s.</div><div class="line">Timestep = 12375 @ time = 31.1018s.</div><div class="line">Timestep = 12500 @ time = 31.4159s.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --></li>
</ul>
<p>And this portion of the output pertains to the experiment performed with themagneto-viscoelastic material: </p><div class="fragment"><div class="line">Coupled magneto-viscoelastic constitutive law <span class="keyword">using</span> symbolic differentiation.</div><div class="line">Using LLVM optimizer.</div><div class="line">Timestep = 0 @ time = 0s.</div><div class="line">Timestep = 125 @ time = 0.314159s.</div><div class="line">Timestep = 250 @ time = 0.628318s.</div><div class="line">Timestep = 375 @ time = 0.942477s.</div><div class="line">...</div><div class="line">Timestep = 12250 @ time = 30.7876s.</div><div class="line">Timestep = 12375 @ time = 31.1018s.</div><div class="line">Timestep = 12500 @ time = 31.4159s.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --><p>The timer output is also emitted to the console, so we can compare time takento perform the hand- and assisted- calculations and get some idea of the overheadof using the AD and SD frameworks.Here are the timings taken from the magnetoelastic experiment usingthe AD framework, based on the Sacado component of the Trilinos library: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |       3.2s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |      3.02s |        95% |</div><div class="line">| Hand calculated                 |     12501 |    0.0464s |       1.5% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> With respect to the computations performed using automatic differentiation(as a reminder, this is with two levels of differentiation using the Sacadolibrary in conjunction with dynamic forward auto-differentiable types), weobserve that the assisted computations takes about \(65 \times\) longer tocompute the desired quantities. This does seem like quite a lot of overheadbut, as mentioned in the introduction, it's entirely subjective andcircumstance-dependent as to whether or not this is acceptable or not:Do you value computer time more than human time for doing thenecessary hand-computations of derivatives, verify their correctness,implement them, and verify the correctness of the implementation? Ifyou develop a research code that will only be run for a relativelysmall number of experiments, you might value your own time more. Ifyou develop a production code that will be run over and over on10,000-core clusters for hours, your considerations might be different.In any case, the one nice featureof the AD approach is the "drop in" capability when functions and classes aretemplated on the scalar type. This means that minimal effort is required tostart working with it. In contrast, the timings for magneto-viscoelastic material as implemented usingjust-in-time (JIT) compiled symbolic algebra indicate that, at some non-negligible cost duringinitialization, the calculations themselves are a lot more efficiently executed: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.34s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |     0.376s |        28% |</div><div class="line">| Hand calculated                 |     12501 |     0.368s |        27% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.466s |        35% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> Since the initialization phase need, most likely, only be executed once perthread, this initial expensive phase can be offset by the repeated use of asingle <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> instance. Even though themagneto-viscoelastic constitutive law has more terms to calculate when comparedto its magnetoelastic counterpart, it still is a whole order of magnitude fasterto execute the computations of the kinetic variables and tangents. And when comparedto the hand computed variant that uses the caching scheme, the calculation timeis nearly equal. So although using the symbolic framework requires a paradigmshift in terms of how one implements and manipulates the symbolic expressions,it can offer good performance and flexibility that the AD frameworks lack. On the point of data caching, the added cost of value caching for themagneto-viscoelastic material implementation is, in fact, about a \(6\times\) increase in the time spent in <code>update_internal_data()</code> when compared to theimplementation using intermediate values for the numerical experiments conductedwith this material. Here's a sample output of the timing comparison extracted forthe "hand calculated" variant when the caching data structure is removed: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.01s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |     0.361s |        36% |</div><div class="line">| Hand calculated                 |     12501 |    0.0562s |       5.6% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.469s |        47% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>With some minor adjustment we can quite easily test the different optimizationschemes for the batch optimizer. So let's compare the computational expenseassociated with the <code>LLVM</code> batch optimizer setting versus the alternatives.Below are the timings reported for the <code>lambda</code> optimization method (retainingthe use of CSE): </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      3.87s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |      3.12s |        81% |</div><div class="line">| Hand calculated                 |     12501 |     0.394s |        10% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.209s |       5.4% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> The primary observation here is that an order of magnitude greater time is spentin the "Assisted computation" section when compared to the <code>LLVM</code> approach. Last of all we'll test how <code>dictionary</code> substitution, in conjunction with CSE,performs. Dictionary substitution simply does all of the evaluation within thenative CAS framework itself, with no transformation of the underlying datastructures taking place. Only the use of CSE, which caches intermediate results,will provide any "acceleration" in this instance. With that in mind, here arethe results from this selection: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |  1.54e+03s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |  1.54e+03s |     1e+02% |</div><div class="line">| Hand calculated                 |     12501 |     0.563s |         0% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.184s |         0% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> Needless to say, compared to the other two methods, these results took quitesome time to produce... The <code>dictionary</code> substitutionmethod is perhaps only really viable for simple expressions or when the numberof calls is sufficiently small. <a class="anchor" id="SowhichframeworkshouldIuse"></a></p><h1>So, which framework should I use?</h1>
<p>Perhaps you've been convinced that these tools have some merit, and can beof immediate help or use to you. The obvious question now is which one touse. Focusing specifically at a continuum point level, where you would beusing these frameworks to compute derivatives of a constitutive law inparticular, we can say the following:</p>
<ul>
<li>Automatic differentiation probably provides the simplest entry point into the world of assisted differentiation.</li>
<li>Given a sufficiently generic implementation of a constitutive framework, AD can often be used as a drop-in replacement for the intrinsic scalar types and the helper classes can then be leveraged to compute first (and possibly higher order) derivatives with minimal effort.</li>
<li>As a qualification to the above point, being a "drop-in replacement" does not mean that you must not be contentious of what the algorithms that these numbers are being passed through are doing. It is possible to inadvertently perform an operation that would, upon differentiating, return an incorrect result. So this is definitely something that one should be aware of. A concrete example: When computing the eigenvalues of a tensor, if the tensor is diagonal then a short-cut to the result is simply to return the diagonal entries directly (as extracted from the input tensor). This is completely correct in terms of computing the eigenvalues themselves, but not going through the algorithm that would otherwise compute the eigenvalues for a non-diagonal tensor has had an unintended side-effect, namely that the eigenvalues appear (to the AD framework) to be completely decoupled from one another and their cross-sensitivities are not encoded in the returned result. Upon differentiating, many entries of the derivative tensor will be missing. To fix this issue, one has to ensure that the standard eigenvalue solving algorithm is used so that the sensitivities of the returned eigenvalues with respect to one another are encoded in the result.</li>
<li>Computations involving AD number types may be expensive. The expense increases (sometimes quite considerably) as the order of the differential operations increases. This may be mitigated by computational complexity of surrounding operations (such as a linear solve, for example), but is ultimately problem specific.</li>
<li>AD is restricted to the case where only total derivatives are required. If a differential operation requires a partial derivative with respect to an independent variable then it is not appropriate to use it.</li>
<li>Each AD library has its own quirks (sad to say but, in the author's experience, true), so it may take some trial and error to find the appropriate library and choice of AD number to suit your purposes. The reason for these "quirks" often boils down to the overall philosophy behind the library (data structures, the use of template meta-programming, etc.) as well as the mathematical implementation of the derivative computations (for example, manipulations of results using logarithmic functions to change basis might restrict the domain for the input values</li>
<li>details all hidden from the user, of course). Furthermore, one library might be able to compute the desired results quicker than another, so some initial exploration might be beneficial in that regard.</li>
<li>Symbolic differentiation (well, the use of a CAS in general) provides the most flexible framework with which to perform assisted computations.</li>
<li>The SD framework can do everything that the AD frameworks can, with the additional benefit of having low-level control over when certain manipulations and operations are performed.</li>
<li>Acceleration of expression evaluation is possible, potentially leading to near-native performance of the SD framework compared to some hand implementations (this comparison being dependent on the overall program design, of course) at the expense of the initial optimization call.</li>
<li>Clever use of the <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> could minimize the expense of the costly call that optimizes the dependent expressions. The possibility to serialize the <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> that often (but not always) this expensive call can be done once and then reused in a later simulation.</li>
<li>If two or more material laws differ by only their material parameters, for instance, then a single batch optimizer can be shared between them as long as those material parameters are considered to be symbolic. The implication of this is that you can "differentiate once, evaluate in many contexts".</li>
<li>The SD framework may partially be used as a "drop-in replacement" for scalar types, but one (at the very least) has to add some more framework around it to perform the value substitution step, converting symbolic types to their numerical counterparts.</li>
<li>It may not be possible to use SD numbers within some specialized algorithms. For example, if an algorithm has an exit point or code branch based off of some concrete, numerical value that the (symbolic) input argument should take, then obviously this isn't going to work. One either has to reimplement the algorithm specifically for SD number types (somewhat inconvenient, but frequently possible as conditionals are supported by the <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> class), or one must use a creative means around this specific issue (e.g., introduce a symbolic expression that represents the result returned by this algorithm, perhaps declaring it to be a <a href="https://dealii.org/developer/doxygen/deal.II/namespaceDifferentiation_1_1SD.html#a876041f6048705c7a8ad0855cdb1bd7a">symbolic function</a> if that makes sense within the context in which it is to be used. This can later be substituted by its numerical values, and if declared a symbolic function then its deferred derivatives may also be incorporated into the calculations as substituted results.).</li>
<li>The biggest drawback to using SD is that using it requires a paradigm shift, and that one has to frame most problems differently in order to take the most advantage of it. (Careful consideration of how the data structures are used and reused is also essential to get it to work effectively.) This may mean that one needs to play around with it a bit and build up an understanding of what the sequence of typical operations is and what specifically each step does in terms of manipulating the underlying data. If one has the time and inclination to do so, then the benefits of using this tool may be substantial. <a class="anchor" id="Possibilitiesforextension"></a><h1>Possibilities for extension</h1>
</li>
</ul>
<p>There are a few logical ways in which this program could be extended:</p>
<ul>
<li>Perhaps the most obvious extension would be to implement and test other constitutive models. This could still be within the realm of coupled magneto-mechanical problems, perhaps considering alternatives to the "Neo-Hookean"-type elastic part of the energy functions, changing the constitutive law for the dissipative energy (and its associated evolution law), or including magnetic hysteretic effects or damage models for the composite polymer that these material seek to model.</li>
<li>Of course, the implemented models could be modified or completely replaced with models that are focused on other aspects of physics, such as electro-active polymers, biomechanical materials, elastoplastic media, etc.</li>
<li>Implement a different time-discretization scheme for the viscoelastic evolution law.</li>
<li>Instead of deriving everything directly from an energy density function, use the <a class="el" href="classDifferentiation_1_1AD_1_1VectorFunction.html">Differentiation::AD::VectorFunction</a> to directly linearize the kinetic quantities. This would mean that only a once-differentiable auto-differentiable number type would be required, and would certainly improve the performance greatly. Such an approach would also offer the opportunity for dissipative materials, such as the magneto-viscoelastic one consider here, to be implemented in conjunction with AD. This is because the linearization invokes the total derivative of the dependent variables with respect to the field variables, which is exactly what the AD frameworks can provide.</li>
<li>Investigate using other auto-differentiable number types and frameworks (such as ADOL-C). Since each AD library has its own implementation, the choice of which to use could result in performance increases and, in the most unfortunate cases, more stable computations. It can at least be said that for the AD libraries that deal.II supports, the accuracy of results should be largely unaffected by this decision.</li>
<li>Embed one of these constitutive laws within a finite element simulation. With less effort, one could think about re-writing nonlinear problemsolvers such as the one implemented in <a class="el" href="step_15.html">step-15</a> using AD or SDapproaches to compute the Newton matrix. Indeed, this is done in <a class="el" href="step_72.html">step-72</a> .</li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Jean-Paul Pelteret, 2021</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="general__data__storage_8h.html">deal.II/algorithms/general_data_storage.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numbers_8h.html">deal.II/base/numbers.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="symmetric__tensor_8h.html">deal.II/base/symmetric_tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transformations_8h.html">deal.II/physics/transformations.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinematics_8h.html">deal.II/physics/elasticity/kinematics.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="standard__tensors_8h.html">deal.II/physics/elasticity/standard_tensors.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sd_8h.html">deal.II/differentiation/sd.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step71</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SimpleExample</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumberType&gt;</div><div class="line">    <a class="code" href="classNumberType.html">NumberType</a> f(<span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    run_and_verify_ad(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">    {</div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     dim = 1;</div><div class="line">      constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line">      <span class="keyword">using</span> ADHelper =</div><div class="line">        <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = 2;</div><div class="line"></div><div class="line">      ADHelper ad_helper(n_independent_variables);</div><div class="line">      <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">      ad_helper.register_independent_variables({x, y});</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; independent_variables_ad =</div><div class="line">        ad_helper.get_sensitive_variables();</div><div class="line">      <span class="keyword">const</span> ADNumberType &amp;x_ad = independent_variables_ad[0];</div><div class="line">      <span class="keyword">const</span> ADNumberType &amp;y_ad = independent_variables_ad[1];</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType f_ad = f(x_ad, y_ad);</div><div class="line"></div><div class="line"></div><div class="line">      ad_helper.register_dependent_variable(f_ad);</div><div class="line"></div><div class="line">      Vector&lt;double&gt;     Df(ad_helper.n_dependent_variables());</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2f(ad_helper.n_dependent_variables(),</div><div class="line">                             ad_helper.n_independent_variables());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_f = ad_helper.compute_value();</div><div class="line">      ad_helper.compute_gradient(Df);</div><div class="line">      ad_helper.compute_hessian(D2f);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                             std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx = Df[0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy = Df[1];</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx = D2f[0][0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy = D2f[0][1];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx = D2f[1][0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy = D2f[1][1];</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(x != 0.0, <a class="code" href="group__Exceptions.html#ga2e959da7bfd82df428770c0339c377ba">ExcDivideByZero</a>());</div><div class="line">      <span class="keywordflow">return</span> y * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / (x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / x;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -y * (2 * x * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) + y * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) /</div><div class="line">             (x * x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -(<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) / (x * x);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    run_and_verify_sd(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> x_sd(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> y_sd(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_sd = f(x_sd, y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dx_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dy_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dx_sd =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dy_sd =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dx_sd =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dy_sd =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> substitution_map =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">          std::pair&lt;Differentiation::SD::Expression, double&gt;{x_sd, x},</div><div class="line">          std::pair&lt;Differentiation::SD::Expression, double&gt;{y_sd, y});</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_f =</div><div class="line">        f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                             std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx =</div><div class="line">        d2f_dx_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy =</div><div class="line">        d2f_dx_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx =</div><div class="line">        d2f_dy_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy =</div><div class="line">        d2f_dy_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> x = 1.23;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> y = 0.91;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using automatic differentiation...&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      run_and_verify_ad(x, y);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using symbolic differentiation.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      run_and_verify_sd(x, y);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace SimpleExample</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>CoupledConstitutiveLaws</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">class </span>ConstitutiveParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ConstitutiveParameters();</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_e       = 30.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_e_inf   = 250.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_e_h_sat = 212.2e3;</div><div class="line">      <span class="keywordtype">double</span> nu_e       = 0.49;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_v       = 20.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_v_inf   = 35.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_v_h_sat = 92.84e3;</div><div class="line">      <span class="keywordtype">double</span> tau_v      = 0.6;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_r = 6.0;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    ConstitutiveParameters::ConstitutiveParameters()</div><div class="line">      : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Constitutive Parameters/&quot;</span>)</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Elastic shear modulus&quot;</span>, mu_e);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Elastic shear modulus at magnetic saturation&quot;</span>, mu_e_inf);</div><div class="line">      add_parameter(</div><div class="line">        <span class="stringliteral">&quot;Saturation magnetic field strength for elastic shear modulus&quot;</span>,</div><div class="line">        mu_e_h_sat);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Poisson ratio&quot;</span>, nu_e);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus&quot;</span>, mu_v);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus at magnetic saturation&quot;</span>,</div><div class="line">                    mu_v_inf);</div><div class="line">      add_parameter(</div><div class="line">        <span class="stringliteral">&quot;Saturation magnetic field strength for viscoelastic shear modulus&quot;</span>,</div><div class="line">        mu_v_h_sat);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Characteristic relaxation time&quot;</span>, tau_v);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Relative magnetic permeability&quot;</span>, mu_r);</div><div class="line"></div><div class="line">      parse_parameters_call_back.connect([&amp;]() { initialized = <span class="keyword">true</span>; });</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Coupled_Magnetomechanical_Constitutive_Law_Base</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep()</div><div class="line">      {}</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_nu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_lambda_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_kappa_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_tau_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_r() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">double</span> get_mu_0() <span class="keyword">const</span>;</div><div class="line">      <span class="keywordtype">double</span>           get_delta_t(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : constitutive_parameters(constitutive_parameters)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(get_kappa_e() &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e_inf;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e_h_sat;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_nu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.nu_e;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_lambda_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_kappa_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (2.0 * get_mu_e() * (1.0 + get_nu_e())) /</div><div class="line">             (3.0 * (1.0 - 2.0 * get_nu_e()));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v_inf;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v_h_sat;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_tau_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.tau_v;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_r()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_r;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_0()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 4.0 * numbers::PI * 1e-7;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_delta_t(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> time.<a class="code" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">get_previous_step_size</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoelastic_Constitutive_Law_AD final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> ADHelper =</div><div class="line">        <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line">      <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoelastic_Constitutive_Law_AD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>             H_components;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor&lt;2&gt;</a> C_components;</div><div class="line"></div><div class="line">      ADHelper ad_helper;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>             psi;</div><div class="line">      Vector&lt;double&gt;     Dpsi;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2psi;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::</div><div class="line">      Magnetoelastic_Constitutive_Law_AD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , H_components(0)</div><div class="line">      , C_components(Tensor&lt;1, dim&gt;::n_independent_components)</div><div class="line">      , ad_helper(Tensor&lt;1, dim&gt;::n_independent_components +</div><div class="line">                  SymmetricTensor&lt;2, dim&gt;::n_independent_components)</div><div class="line">      , psi(0.0)</div><div class="line">      , Dpsi(ad_helper.n_independent_variables())</div><div class="line">      , D2psi(ad_helper.n_independent_variables(),</div><div class="line">              ad_helper.n_independent_variables())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C) &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      ad_helper.reset();</div><div class="line"></div><div class="line">      ad_helper.register_independent_variable(H, H_components);</div><div class="line">      ad_helper.register_independent_variable(C, C_components);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, ADNumberType&gt;</a> H_ad =</div><div class="line">        ad_helper.get_sensitive_variables(H_components);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_ad =</div><div class="line">        ad_helper.get_sensitive_variables(C_components);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType det_F_ad = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C_ad));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_inv_ad = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C_ad);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F_ad &gt; ADNumberType(0.0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType f_mu_e_ad =</div><div class="line">        1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">                <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_ad * H_ad) /</div><div class="line">                          (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType psi_ad =</div><div class="line">        0.5 * this-&gt;get_mu_e() * f_mu_e_ad *</div><div class="line">          (<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C_ad) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad))                 </div><div class="line">        + this-&gt;get_lambda_e() * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) </div><div class="line">        - 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F_ad *</div><div class="line">            (H_ad * C_inv_ad * H_ad); </div><div class="line"></div><div class="line">      ad_helper.register_dependent_variable(psi_ad);</div><div class="line"></div><div class="line">      psi = ad_helper.compute_value();</div><div class="line">      ad_helper.compute_gradient(Dpsi);</div><div class="line">      ad_helper.compute_hessian(D2psi);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dpsi_dH =</div><div class="line">        ad_helper.extract_gradient_component(Dpsi, H_components);</div><div class="line">      <span class="keywordflow">return</span> -dpsi_dH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dpsi_dC =</div><div class="line">        ad_helper.extract_gradient_component(Dpsi, C_components);</div><div class="line">      <span class="keywordflow">return</span> 2.0 * dpsi_dC;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> dpsi_dH_dH =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, H_components, H_components);</div><div class="line">      <span class="keywordflow">return</span> -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(dpsi_dH_dH);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> dpsi_dC_dH =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, C_components, H_components);</div><div class="line">      <span class="keywordflow">return</span> -2.0 * dpsi_dC_dH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dpsi_dC_dC =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, C_components, C_components);</div><div class="line">      <span class="keywordflow">return</span> 4.0 * dpsi_dC_dC;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law_SD final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_inf_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_h_sat_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> lambda_e_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_inf_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_h_sat_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> tau_v_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> delta_t_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_r_sd;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          H_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_sd;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t1_sd;</div><div class="line"></div><div class="line">      <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>                          psi_sd;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          B_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> S_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> BB_sd;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim, Differentiation::SD::Expression&gt;</a>          PP_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim, Differentiation::SD::Expression&gt;</a> HH_sd;</div><div class="line"></div><div class="line">      <a class="code" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer&lt;double&gt;</a> optimizer;</div><div class="line"></div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> initialize_optimizer();</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::</div><div class="line">      Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , mu_e_sd(<span class="stringliteral">&quot;mu_e&quot;</span>)</div><div class="line">      , mu_e_inf_sd(<span class="stringliteral">&quot;mu_e_inf&quot;</span>)</div><div class="line">      , mu_e_h_sat_sd(<span class="stringliteral">&quot;mu_e_h_sat&quot;</span>)</div><div class="line">      , lambda_e_sd(<span class="stringliteral">&quot;lambda_e&quot;</span>)</div><div class="line">      , mu_v_sd(<span class="stringliteral">&quot;mu_v&quot;</span>)</div><div class="line">      , mu_v_inf_sd(<span class="stringliteral">&quot;mu_v_inf&quot;</span>)</div><div class="line">      , mu_v_h_sat_sd(<span class="stringliteral">&quot;mu_v_h_sat&quot;</span>)</div><div class="line">      , tau_v_sd(<span class="stringliteral">&quot;tau_v&quot;</span>)</div><div class="line">      , delta_t_sd(<span class="stringliteral">&quot;delta_t&quot;</span>)</div><div class="line">      , mu_r_sd(<span class="stringliteral">&quot;mu_r&quot;</span>)</div><div class="line">      , H_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#acf16bdf4d5a0b48dd84496e379742426">make_vector_of_symbols</a>&lt;dim&gt;(<span class="stringliteral">&quot;H&quot;</span>))</div><div class="line">      , C_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;C&quot;</span>))</div><div class="line">      , Q_t_sd(</div><div class="line">          <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t&quot;</span>))</div><div class="line">      , Q_t1_sd(</div><div class="line">          <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t1&quot;</span>))</div><div class="line">      , optimizer(optimizer_type, optimization_flags)</div><div class="line">    {</div><div class="line">      initialize_optimizer();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::make_substitution_map</a>(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">        std::make_pair(mu_e_sd, this-&gt;get_mu_e()),</div><div class="line">        std::make_pair(mu_e_inf_sd, this-&gt;get_mu_e_inf()),</div><div class="line">        std::make_pair(mu_e_h_sat_sd, this-&gt;get_mu_e_h_sat()),</div><div class="line">        std::make_pair(lambda_e_sd, this-&gt;get_lambda_e()),</div><div class="line">        std::make_pair(mu_v_sd, this-&gt;get_mu_v()),</div><div class="line">        std::make_pair(mu_v_inf_sd, this-&gt;get_mu_v_inf()),</div><div class="line">        std::make_pair(mu_v_h_sat_sd, this-&gt;get_mu_v_h_sat()),</div><div class="line">        std::make_pair(tau_v_sd, this-&gt;get_tau_v()),</div><div class="line">        std::make_pair(delta_t_sd, delta_t),</div><div class="line">        std::make_pair(mu_r_sd, this-&gt;get_mu_r()),</div><div class="line">        std::make_pair(H_sd, H),</div><div class="line">        std::make_pair(C_sd, C),</div><div class="line">        std::make_pair(Q_t_sd, Q_t),</div><div class="line">        std::make_pair(Q_t1_sd, Q_t1));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::initialize_optimizer()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> det_F_sd =</div><div class="line">        <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C_sd));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_inv_sd =</div><div class="line">        <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_e_sd =</div><div class="line">        1.0 +</div><div class="line">        (mu_e_inf_sd / mu_e_sd - 1.0) *</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_ME_sd =</div><div class="line">        0.5 * mu_e_sd * f_mu_e_sd *</div><div class="line">          (<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C_sd) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd)) +</div><div class="line">        lambda_e_sd * std::log(det_F_sd) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd) -</div><div class="line">        0.5 * this-&gt;get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_v_sd =</div><div class="line">        1.0 +</div><div class="line">        (mu_v_inf_sd / mu_v_sd - 1.0) *</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_MVE_sd =</div><div class="line">        0.5 * mu_v_sd * f_mu_v_sd *</div><div class="line">        (Q_t_sd * (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, -2.0 / dim) * C_sd) - dim -</div><div class="line">         std::log(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t_sd)));</div><div class="line"></div><div class="line">      psi_sd = psi_ME_sd + psi_MVE_sd;</div><div class="line"></div><div class="line"></div><div class="line">      B_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, H_sd);</div><div class="line">      S_sd = 2.0 * <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, C_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a></div><div class="line">        Q_t_sd_explicit =</div><div class="line">          (1.0 / (1.0 + delta_t_sd / tau_v_sd)) *</div><div class="line">          (Q_t1_sd +</div><div class="line">           (delta_t_sd / tau_v_sd * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, 2.0 / dim) * C_inv_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">        substitution_map_explicit = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">          std::make_pair(Q_t_sd, Q_t_sd_explicit));</div><div class="line"></div><div class="line">      BB_sd = <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(B_sd, substitution_map_explicit),</div><div class="line">        H_sd));</div><div class="line">      PP_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit), H_sd);</div><div class="line">      HH_sd =</div><div class="line">        2.0 *</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit),</div><div class="line">          C_sd);</div><div class="line"></div><div class="line">      optimizer.register_symbols(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD_1_1Utilities.html#a373adeda1cf11d824bb41a679d061a3d">Differentiation::SD::Utilities::extract_symbols</a>(</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>({}, {}, 0)));</div><div class="line"></div><div class="line">      optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);</div><div class="line"></div><div class="line">      optimizer.optimize();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (Q_t1 + (delta_t / this-&gt;get_tau_v()) * std::pow(det_F, 2.0 / dim) *</div><div class="line">                      C_inv);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> substitution_map = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(C, H, delta_t);</div><div class="line"></div><div class="line">      optimizer.substitute(substitution_map);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(psi_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(B_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(S_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(BB_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(PP_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(HH_sd);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_end_of_timestep()</div><div class="line">    {</div><div class="line">      Q_t1 = Q_t;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoelastic_Constitutive_Law final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoelastic_Constitutive_Law(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keywordtype">double</span>                  psi;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoelastic_Constitutive_Law&lt;dim&gt;::Magnetoelastic_Constitutive_Law(</div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , psi(0.0)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> two_h_dot_h_div_h_sat_squ =</div><div class="line">        (2.0 * H * H) / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(two_h_dot_h_div_h_sat_squ);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e =</div><div class="line">        1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">                tanh_two_h_dot_h_div_h_sat_squ;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dtanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(two_h_dot_h_div_h_sat_squ), 2.0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dtwo_h_dot_h_div_h_sat_squ_dH =</div><div class="line">        2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) * H;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH =</div><div class="line">        (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">        (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> d2tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2two_h_dot_h_div_h_sat_squ_dH_dH =</div><div class="line">        2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) *</div><div class="line">        <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">        (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">        (d2tanh_two_h_dot_h_div_h_sat_squ *</div><div class="line">           <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dtwo_h_dot_h_div_h_sat_squ_dH,</div><div class="line">                                    dtwo_h_dot_h_div_h_sat_squ_dH)) +</div><div class="line">         dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         log_det_F         = <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         tr_C              = <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H       = C_inv * H;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         H_dot_C_inv_dot_H = H * C_inv_dot_H;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d_tr_C_dC =</div><div class="line">        <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> ddet_F_dC     = 0.5 * det_F * C_inv;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dlog_det_F_dC = 0.5 * C_inv;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dC_inv_dC;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              dC_inv_dC[A][B][C][D] -=               </div><div class="line">                0.5 * (C_inv[A][C] * C_inv[B][D]     </div><div class="line">                       + C_inv[A][D] * C_inv[B][C]); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dH_dot_C_inv_dot_H_dC =</div><div class="line">        -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2det_F_dC_dC =</div><div class="line">        0.5 * (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv, ddet_F_dC) + det_F * dC_inv_dC);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=</div><div class="line">              C_inv[A][C] * C_inv_dot_H[B] + </div><div class="line">              C_inv_dot_H[A] * C_inv[B][C];  </div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">                0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                       C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);</div><div class="line"></div><div class="line">      psi =</div><div class="line">        (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">          (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">        this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F)) -</div><div class="line">        (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div><div class="line"></div><div class="line">      B = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">            df_mu_e_dH </div><div class="line">          + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">              dH_dot_C_inv_dot_H_dH; </div><div class="line"></div><div class="line">      S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                        </div><div class="line">            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              </div><div class="line">          + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) </div><div class="line">          - 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *            </div><div class="line">              (H_dot_C_inv_dot_H * ddet_F_dC                               </div><div class="line">               + det_F * dH_dot_C_inv_dot_H_dC);                           </div><div class="line"></div><div class="line">      BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * </div><div class="line">             d2f_mu_e_dH_dH                                             </div><div class="line">           + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">               d2H_dot_C_inv_dot_H_dH_dH; </div><div class="line"></div><div class="line">      PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *                                  </div><div class="line">             <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   </div><div class="line">                           df_mu_e_dH)                                        </div><div class="line">           +                                                                  </div><div class="line">           2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">             (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) </div><div class="line">              + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           </div><div class="line"></div><div class="line">      HH =</div><div class="line">        4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">        + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">            (2.0 * <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">             + 2.0 * log_det_F * d2log_det_F_dC_dC)                          </div><div class="line">        - 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">            (H_dot_C_inv_dot_H * d2det_F_dC_dC                               </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               </div><div class="line">             + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> B;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> S;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> BB;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> PP;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> HH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoviscoelastic_Constitutive_Law(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>                  psi;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classGeneralDataStorage.html">GeneralDataStorage</a> cache;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> set_primary_variables(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                 <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> update_internal_variable(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_f_mu(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">      get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_df_mu_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_d2f_mu_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C_inv() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_log_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_trace_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_H_dot_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_dC_inv_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d_tr_C_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_ddet_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dlog_det_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">      get_dQ_t_dC(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2log_det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dH_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dC() <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::Magnetoviscoelastic_Constitutive_Law(<span class="keyword">const</span> ConstitutiveParameters</div><div class="line">                                                   &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , psi(0.0)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">    {</div><div class="line">      set_primary_variables(C, H);</div><div class="line">      update_internal_variable(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e = get_f_mu(this-&gt;get_mu_e(),</div><div class="line">                                     this-&gt;get_mu_e_inf(),</div><div class="line">                                     this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_v = get_f_mu(this-&gt;get_mu_v(),</div><div class="line">                                     this-&gt;get_mu_v_inf(),</div><div class="line">                                     this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH = get_df_mu_dH(this-&gt;get_mu_e(),</div><div class="line">                                                     this-&gt;get_mu_e_inf(),</div><div class="line">                                                     this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_v_dH = get_df_mu_dH(this-&gt;get_mu_v(),</div><div class="line">                                                     this-&gt;get_mu_v_inf(),</div><div class="line">                                                     this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">        get_d2f_mu_dH_dH(this-&gt;get_mu_e(),</div><div class="line">                         this-&gt;get_mu_e_inf(),</div><div class="line">                         this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_v_dH_dH =</div><div class="line">        get_d2f_mu_dH_dH(this-&gt;get_mu_v(),</div><div class="line">                         this-&gt;get_mu_v_inf(),</div><div class="line">                         this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;                 det_F = get_det_F();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;log_det_F         = get_log_det_F();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;tr_C              = get_trace_C();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d_tr_C_dC     = get_d_tr_C_dC();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;ddet_F_dC     = get_ddet_F_dC();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dlog_det_F_dC = get_dlog_det_F_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;dQ_t_dC = get_dQ_t_dC(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dC =</div><div class="line">        get_dH_dot_C_inv_dot_H_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2log_det_F_dC_dC =</div><div class="line">        get_d2log_det_F_dC_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2det_F_dC_dC = get_d2det_F_dC_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dH_dH =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dH_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dH =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dC_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dC =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dC_dC();</div><div class="line"></div><div class="line">      psi = (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">              (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">            this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F));</div><div class="line">      psi += (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">             (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">              <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t)));</div><div class="line">      psi -=</div><div class="line">        (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div><div class="line"></div><div class="line">      B =</div><div class="line">        -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;</div><div class="line">      B -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">           (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t))) *</div><div class="line">           df_mu_v_dH;</div><div class="line">      B += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">           dH_dot_C_inv_dot_H_dH;</div><div class="line"></div><div class="line">      S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                         </div><div class="line">            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               </div><div class="line">          + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); </div><div class="line">      S += 2.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">           ((Q_t * C) *</div><div class="line">              ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) +</div><div class="line">            std::pow(det_F, -2.0 / dim) * Q_t);                <span class="comment">// dC/dC = II</span></div><div class="line">      S -= 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">           (H_dot_C_inv_dot_H * ddet_F_dC                      </div><div class="line">            + det_F * dH_dot_C_inv_dot_H_dC);                  </div><div class="line"></div><div class="line">      BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">           d2f_mu_e_dH_dH;</div><div class="line">      BB -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">            (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">             <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t))) *</div><div class="line">            d2f_mu_v_dH_dH;</div><div class="line">      BB += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">            d2H_dot_C_inv_dot_H_dH_dH;</div><div class="line"></div><div class="line">      PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *</div><div class="line">           <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),</div><div class="line">                         df_mu_e_dH);</div><div class="line">      PP -= 2.0 * (0.5 * this-&gt;get_mu_v()) *</div><div class="line">            <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>((Q_t * C) *</div><div class="line">                                           ((-2.0 / dim) *</div><div class="line">                                            std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                                            ddet_F_dC) +</div><div class="line">                                         std::pow(det_F, -2.0 / dim) * Q_t),</div><div class="line">                          df_mu_v_dH);</div><div class="line">      PP += 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *</div><div class="line">            (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +</div><div class="line">             det_F * d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line"></div><div class="line">      HH =</div><div class="line">        4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">        + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">            (2.0 * <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">             + 2.0 * log_det_F * d2log_det_F_dC_dC);                         </div><div class="line">      HH += 4.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">            (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                             ddet_F_dC,</div><div class="line">                           C * dQ_t_dC + Q_t) +</div><div class="line">             (Q_t * <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>) *</div><div class="line">               (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC,</div><div class="line">                              (-2.0 / dim) * (-2.0 / dim - 1.0) *</div><div class="line">                                std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +</div><div class="line">                ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                 d2det_F_dC_dC)) +</div><div class="line">             <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Q_t,</div><div class="line">                           (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                             ddet_F_dC) +</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, -2.0 / dim) * dQ_t_dC);</div><div class="line">      HH -= 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">            (H_dot_C_inv_dot_H * d2det_F_dC_dC                  </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  </div><div class="line">             + det_F * d2H_dot_C_inv_dot_H_dC_dC);              </div><div class="line"></div><div class="line"></div><div class="line">      cache.reset();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> B;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> S;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> BB;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> PP;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> HH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_end_of_timestep()</div><div class="line">    {</div><div class="line">      Q_t1 = Q_t;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_variable(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">      Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (Q_t1 + (delta_t / this-&gt;get_tau_v()) *</div><div class="line">                      std::pow(get_det_F(), 2.0 / dim) * get_C_inv());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_two_h_dot_h_div_h_sat_squ(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;H = get_H();</div><div class="line">      <span class="keywordflow">return</span> (2.0 * H * H) / (mu_h_sat * mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_f_mu(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 1.0 +</div><div class="line">             (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),</div><div class="line">                      2.0);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_df_mu_dH(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">             (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">              get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">             get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *</div><div class="line">             <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2f_mu_dH_dH(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">             (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">                <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(</div><div class="line">                  <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),</div><div class="line">                                get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +</div><div class="line">              get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">                get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::set_primary_variables(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name_H(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_H),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">               <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">      cache.add_unique_copy(name_H, H);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string name_C(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_C),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">               <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">      cache.add_unique_copy(name_C, C);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;det_F&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(get_C()));</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line">          cache.add_unique_copy(name, det_F);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          cache.add_unique_copy(name, <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(get_C()));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_log_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;log(det_F)&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, std::log(get_det_F()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_trace_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;trace(C)&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(get_C()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv_dot_H&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, get_C_inv() * get_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H_dot_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H_dot_C_inv_dot_H&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dQ_t_dC(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dQ_t_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>  delta_t = this-&gt;get_delta_t(time);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;det_F   = get_det_F();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dQ_t_dC =</div><div class="line">            (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (delta_t / this-&gt;get_tau_v()) *</div><div class="line">            ((2.0 / dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim - 1.0) *</div><div class="line">               <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim) * get_dC_inv_dC());</div><div class="line"></div><div class="line">          cache.add_unique_copy(name, dQ_t_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dC_inv_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dC_inv_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line">          <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>        dC_inv_dC;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">                  dC_inv_dC[A][B][C][D] -=               </div><div class="line">                    0.5 * (C_inv[A][C] * C_inv[B][D]     </div><div class="line">                           + C_inv[A][D] * C_inv[B][C]); </div><div class="line"></div><div class="line">          cache.add_unique_copy(name, dC_inv_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d_tr_C_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d_tr_C_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name,</div><div class="line">                              <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_ddet_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;ddet_F_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dlog_det_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dlog_det_F_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          cache.add_unique_copy(</div><div class="line">            name, -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H)));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2log_det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2log_det_F_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2det_F_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name,</div><div class="line">                              0.5 *</div><div class="line">                                (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">                                 get_det_F() * get_dC_inv_dC()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dH_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dH_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 2.0 * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=</div><div class="line">                  C_inv[A][C] * C_inv_dot_H[B] + </div><div class="line">                  C_inv_dot_H[A] * C_inv[B][C];  </div><div class="line"></div><div class="line">          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;3, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dC()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">          <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">                  d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">                    0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                           C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                           C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +</div><div class="line">                           C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);</div><div class="line"></div><div class="line">          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">class </span>RheologicalExperimentParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RheologicalExperimentParameters();</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> sample_radius = 0.01;</div><div class="line">      <span class="keywordtype">double</span> sample_height = 0.001;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> lambda_2 = 0.95;</div><div class="line">      <span class="keywordtype">double</span> gamma_12 = 0.05;</div><div class="line">      <span class="keywordtype">double</span> H_2      = 60.0e3;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>       frequency         = 1.0 / (2.0 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles          = 5;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps_per_cycle = 2500;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span>        output_data_to_file = <span class="keyword">true</span>;</div><div class="line">      std::string output_filename_rd =</div><div class="line">        <span class="stringliteral">&quot;experimental_results-rate_dependent.csv&quot;</span>;</div><div class="line">      std::string output_filename_ri =</div><div class="line">        <span class="stringliteral">&quot;experimental_results-rate_independent.csv&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> start_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> end_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> delta_t() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> get_H(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    RheologicalExperimentParameters::RheologicalExperimentParameters()</div><div class="line">      : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Rheological Experiment/&quot;</span>)</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_radius);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_height);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Axial stretch&quot;</span>, lambda_2);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Shear strain amplitude&quot;</span>, gamma_12);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Axial magnetic field strength&quot;</span>, H_2);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Frequency&quot;</span>, frequency);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Number of loading cycles&quot;</span>, n_cycles);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Discretisation for each cycle&quot;</span>, n_steps_per_cycle);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output experimental results to file&quot;</span>, output_data_to_file);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output file name (rate dependent constitutive law)&quot;</span>,</div><div class="line">                    output_filename_rd);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output file name (rate independent constitutive law)&quot;</span>,</div><div class="line">                    output_filename_ri);</div><div class="line"></div><div class="line">      parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::start_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.0;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::end_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> n_cycles / frequency;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    RheologicalExperimentParameters::print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> RheologicalExperimentParameters::get_H(<span class="keyword">const</span> <span class="keywordtype">double</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>({0.0, 0.0, H_2});</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> RheologicalExperimentParameters::get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((sample_radius &gt; 0.0 &amp;&amp; sample_height &gt; 0.0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical sample dimensions&quot;</span>));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(lambda_2 &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical applied axial stretch&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> sqrt_lambda_2     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(lambda_2);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_max =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(std::tan(gamma_12) * sample_height /</div><div class="line">                  sample_radius); <span class="comment">// Small strain approximation</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> A       = sample_radius * alpha_max;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> w       = 2.0 * numbers::PI * frequency; <span class="comment">// in rad /s</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma_t = A * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(w * time);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tau_t =</div><div class="line">        gamma_t /</div><div class="line">        (sample_radius * sample_height); <span class="comment">// Torsion angle per unit length</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_t = tau_t * lambda_2 * sample_height;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">      F[0][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[0][1] = -inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[1][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[1][1] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[2][0] = 0.0;</div><div class="line">      F[2][1] = 0.0;</div><div class="line">      F[2][2] = lambda_2;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((F[0][0] &gt; 0) &amp;&amp; (F[1][1] &gt; 0) &amp;&amp; (F[2][2] &gt; 0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical deformation gradient component.&quot;</span>));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(F) - 1.0) &lt; 1e-6,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian is not equal to unity.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> run_rheological_experiment(</div><div class="line">      <span class="keyword">const</span> RheologicalExperimentParameters &amp;experimental_parameters,</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">        &amp;material_hand_calculated,</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">        &amp;               material_assisted_computation,</div><div class="line">      <a class="code" href="classTimerOutput.html">TimerOutput</a> &amp;     timer,</div><div class="line">      <span class="keyword">const</span> std::string filename)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> check_material_class_results =</div><div class="line">        [](</div><div class="line">          <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;to_verify,</div><div class="line">          <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;blessed,</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-6) {</div><div class="line">          (void)to_verify;</div><div class="line">          (void)blessed;</div><div class="line">          (void)tol;</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(std::abs(blessed.get_psi() - to_verify.get_psi()) &lt; tol,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for psi. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(std::abs(</div><div class="line">                              blessed.get_psi() - to_verify.get_psi()))));</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for B. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for S. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for BB. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for PP. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for HH. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">        };</div><div class="line"></div><div class="line">      std::ostringstream stream;</div><div class="line">      stream</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\n&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(experimental_parameters.start_time(),</div><div class="line">                             experimental_parameters.end_time() +</div><div class="line">                               experimental_parameters.delta_t(),</div><div class="line">                             experimental_parameters.delta_t());</div><div class="line">           time.is_at_end() == <span class="keyword">false</span>;</div><div class="line">           time.advance_time())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (experimental_parameters.print_status(time.get_step_number()))</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep = &quot;</span> &lt;&lt; time.get_step_number()</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; @ time = &quot;</span> &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;s.&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> H =</div><div class="line">            experimental_parameters.get_H(time.get_current_time());</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F =</div><div class="line">            experimental_parameters.get_F(time.get_current_time());</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C =</div><div class="line">            <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">Physics::Elasticity::Kinematics::C</a>(F);</div><div class="line"></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Hand calculated&quot;</span>);</div><div class="line">            material_hand_calculated.update_internal_data(C, H, time);</div><div class="line">            material_hand_calculated.update_end_of_timestep();</div><div class="line">          }</div><div class="line"></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assisted computation&quot;</span>);</div><div class="line">            material_assisted_computation.update_internal_data(C, H, time);</div><div class="line">            material_assisted_computation.update_end_of_timestep();</div><div class="line">          }</div><div class="line"></div><div class="line">          check_material_class_results(material_hand_calculated,</div><div class="line">                                       material_assisted_computation);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> h =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Covariant.html#ad438f09c3045e448805f62b27c2f8d29">Physics::Transformations::Covariant::push_forward</a>(H, F);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> b =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">                  material_hand_calculated.get_B(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> sigma =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">                  material_hand_calculated.get_S(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">              stream &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; h[2] &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; b[2]</div><div class="line">                     &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; F[1][2] * 100.0 &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; sigma[1][2] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">        {</div><div class="line">          std::ofstream output(filename);</div><div class="line">          output &lt;&lt; stream.str();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters          constitutive_parameters;</div><div class="line">      <span class="keyword">const</span> RheologicalExperimentParameters experimental_parameters;</div><div class="line"></div><div class="line">      std::string parameter_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        parameter_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">        std::cout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Coupled magnetoelastic constitutive law using automatic differentiation.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"></div><div class="line">        Magnetoelastic_Constitutive_Law&lt;dim&gt; material(constitutive_parameters);</div><div class="line">        Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt; material_ad(</div><div class="line">          constitutive_parameters);</div><div class="line"></div><div class="line">        run_rheological_experiment(experimental_parameters,</div><div class="line">                                   material,</div><div class="line">                                   material_ad,</div><div class="line">                                   timer,</div><div class="line">                                   experimental_parameters.output_filename_ri);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">        std::cout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Coupled magneto-viscoelastic constitutive law using symbolic differentiation.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_SYMENGINE_WITH_LLVM</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using LLVM optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba7c7d2b9e8389cc541dc5a615e05bcf1e">Differentiation::SD::OptimizerType::llvm</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a1ad0cce13bc606ad6742e9841ccdfe15">Differentiation::SD::OptimizationFlags::optimize_all</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using lambda optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">Differentiation::SD::OptimizerType::lambda</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a3df84265620315a025367510c90d0474">Differentiation::SD::OptimizationFlags::optimize_cse</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        Magnetoviscoelastic_Constitutive_Law&lt;dim&gt; material(</div><div class="line">          constitutive_parameters);</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Initialize symbolic CL&quot;</span>);</div><div class="line">        Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt; material_sd(</div><div class="line">          constitutive_parameters, optimizer_type, optimization_flags);</div><div class="line">        timer.<a class="code" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a>();</div><div class="line"></div><div class="line">        run_rheological_experiment(experimental_parameters,</div><div class="line">                                   material,</div><div class="line">                                   material_sd,</div><div class="line">                                   timer,</div><div class="line">                                   experimental_parameters.output_filename_rd);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace CoupledConstitutiveLaws</span></div><div class="line"></div><div class="line">} <span class="comment">// namespace Step71</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::SimpleExample::run</a>();</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::CoupledConstitutiveLaws::run</a>(argc, argv);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#AmotivationWhywouldIusethesetools">A motivation: Why would I use these tools?</a>
        <li><a href="#Theoryformagnetomechanicalmaterials">Theory for magneto-mechanical materials</a>
      <ul>
        <li><a href="#Thermodynamicprinciples">Thermodynamic principles</a>
        <li><a href="#Constitutivelaws">Constitutive laws</a>
      <ul>
        <li><a href="#Magnetoelasticconstitutivelaw">Magnetoelastic constitutive law</a>
        <li><a href="#Magnetoviscoelasticconstitutivelaw">Magneto-viscoelastic constitutive law</a>
      </ul>
      </ul>
        <li><a href="#Rheologicalexperiment">Rheological experiment</a>
        <li><a href="#Suggestedliterature">Suggested literature</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#AnintroductoryexampleThefundamentalsofautomaticandsymbolicdifferentiation">An introductory example: The fundamentals of automatic and symbolic differentiation</a>
      <ul>
        <li><a href="#Ananalyticalfunction">An analytical function</a>
        <li><a href="#Computingderivativesusingautomaticdifferentiation">Computing derivatives using automatic differentiation</a>
        <li><a href="#Handcalculatedderivativesoftheanalyticalsolution">Hand-calculated derivatives of the analytical solution</a>
        <li><a href="#Computingderivativesusingsymbolicdifferentiation">Computing derivatives using symbolic differentiation</a>
        <li><a href="#TheSimpleExamplerunfunction">The SimpleExample::run() function</a>
      </ul>
        <li><a href="#AmorecomplexexampleUsingautomaticandsymbolicdifferentiationtocomputederivativesatcontinuumpoints">A more complex example: Using automatic and symbolic differentiation to compute derivatives at continuum points</a>
      <ul>
        <li><a href="#Constitutiveparameters">Constitutive parameters</a>
        <li><a href="#ConstitutivelawsBaseclass">Constitutive laws: Base class</a>
        <li><a href="#Magnetoelasticconstitutivelawusingautomaticdifferentiation">Magnetoelastic constitutive law (using automatic differentiation)</a>
        <li><a href="#Magnetoviscoelasticconstitutivelawusingsymbolicalgebraanddifferentiation">Magneto-viscoelastic constitutive law (using symbolic algebra and differentiation)</a>
      </ul>
        <li><a href="#AmorecomplexexamplecontinuedParametersandhandderivedmaterialclasses">A more complex example (continued): Parameters and hand-derived material classes</a>
      <ul>
        <li><a href="#Magnetoelasticconstitutivelawhandderived">Magnetoelastic constitutive law (hand-derived)</a>
        <li><a href="#Magnetoviscoelasticconstitutivelawhandderived">Magneto-viscoelastic constitutive law (hand-derived)</a>
        <li><a href="#Rheologicalexperimentparameters">Rheological experiment parameters</a>
        <li><a href="#RheologicalexperimentParallelplaterotationalrheometer">Rheological experiment: Parallel plate rotational rheometer</a>
        <li><a href="#TheCoupledConstitutiveLawsrunfunction">The CoupledConstitutiveLaws::run() function</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Introductoryexample">Introductory example</a>
        <li><a href="#Constitutivemodelling">Constitutive modelling</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-71/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Jean-Paul Pelteret. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>本教程的目的很简单，就是介绍<a href="https://en.wikipedia.org/wiki/Automatic_differentiation">自动</a>和<a href="https://en.wikipedia.org/wiki/Computer_algebra">符号微分</a>（分别缩写为AD和SD）的基本原理。人们可以在源代码中描述一个函数 \(\mathbf f(\mathbf x)\) ，并自动获得导数 \(\nabla \mathbf f(\mathbf x)\) （"Jacobian"）、 \(\nabla^2 \mathbf f(\mathbf x)\) （"Hessian"）等的表示方法，而无需编写额外的代码行。这样做对解决非线性或优化问题很有帮助，因为人们希望在代码中只描述非线性方程或目标函数，而不必同时提供它们的导数（这对解决非线性问题的牛顿方法或寻找最小化器是必要的）。</p>
<p>由于AD和SD工具在某种程度上独立于有限元和边界值问题，本教程将与你之前可能读过的其他教程不同。它将特别关注这些框架是如何工作的，以及它们背后的原理和思想，并放弃在有限元模拟的直接背景下看待它们。</p>
<p>事实上，我们将研究两组不同的问题，它们的复杂程度大不相同，但当框架正确时，有足够的相似性，同样的AD和SD框架可以被利用。通过这些例子，我们的目的是建立起对使用AD和SD工具所需步骤的理解，以及它们之间的区别，并希望能找出它们可以立即用于改进或简化现有代码的地方。</p>
<p>你想知道什么是AD和SD，这是可信的，首先。好吧，这个问题很容易回答，但如果没有上下文，就没有很好的洞察力。因此，我们不打算在这个介绍中涉及这个问题，而是将其推迟到第一个介绍性的例子中，在这个例子的展开过程中，我们将列出关键点。作为补充，我们应该提到，这两个框架的核心理论在 <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> 模块中都有广泛的讨论，所以在此不需要重复。</p>
<p>由于我们必须挑选*个足够有趣的课题来研究，并确定AD和SD在哪里可以有效地使用，所以在教程的后半部分实现的主要问题是对一个耦合的构成法进行建模，特别是一个磁活性材料（具有滞后效应）。作为一种介绍的手段，在介绍的后面将介绍该类材料的一些基础理论。自然，这不是一个广泛受众感兴趣的领域（甚至不是一类材料）。因此，作者希望在前面表示，这个理论和任何后续的推导都不能被认为是本教程的重点。相反，请牢记从相对无害的构成法则描述中产生的问题的复杂性，以及我们可能（在边界值问题的背景下）需要从中推导出什么。我们将在一个有代表性的连续体点的水平上用这些构成法则进行一些计算（所以，仍然是在连续体力学的领域），并将产生一些基准结果，我们可以围绕这些结果对计算性能的主题进行最后讨论。</p>
<p>一旦我们有了可以建立进一步概念的基础，我们将看到如何在有限元（而不是连续体）水平上特别利用AD：这是在步骤-72和步骤-33中涉及的一个主题。但在此之前，让我们花点时间思考一下为什么我们可能要考虑使用这些工具，以及它们可能给你带来什么好处。</p>
<p><a class="anchor" id="AmotivationWhywouldIusethesetools"></a></p><h3>A motivation: Why would I use these tools?</h3>
<p>使用AD或SD的主要驱动力通常是，有一些情况需要进行区分，而且这样做有足够的挑战性，使得使用外部工具来执行该特定任务的前景具有吸引力。对AD或SD最有用的情况进行广泛分类，包括（但可能不限于）以下情况。</p>
<ul>
<li><b>Rapid prototyping:</b>对于一类新的问题，你试图快速实现一个解决方案，并希望去除一些复杂的细节（在数学以及代码本身的组织结构方面）。你可能愿意证明任何额外的计算成本是合理的，这将被重组你的代码或修改问题中引入一些复杂的非线性的部分的敏捷性所抵消，只需最小的努力。</li>
<li><b>Complex problems:</b>很可能有些问题恰好有一个非线性，对线性化或手工制定有极大的挑战。 让一个在大多数情况下稳健、可靠和准确的工具来为你解决这个挑战，可能会减轻实现某些问题的痛苦。这方面的例子包括第15步，我们解决的非线性PDE的导数并不难推导，但足够繁琐，以至于人们在手工操作时必须注意，而且实现牛顿步骤的相应有限元公式所需的时间不仅仅是实现双线性形式一般所需的几行；第33步（我们实际使用AD）是一个更极端的例子。</li>
<li><b>Verification:</b> 对于表现出非线性响应的材料和模拟，准确而非近似的材料切线（机械工程师对材料定律的导数使用的术语）可能是收敛和发散行为之间的区别，特别是在高外部（或耦合）载荷下。 随着问题复杂性的增加，引入细微的（或者，也许不是那么细微的）错误的机会也在增加，这些错误会产生可预见的负面结果。 此外，通过验证实现是完全正确的，也有很多好处。例如，某些类别的问题已知会表现出不稳定性，因此，当你在非线性求解器（例如牛顿方法）中开始失去二次收敛时，那么这对研究者来说可能不是一个巨大的惊喜。然而，很难（如果不是不可能）区分以下两种收敛行为：一种是你接近不稳定的解时产生的收敛行为，另一种是你在材料或有限元线性化中出现了错误，并因此开始偏离最佳收敛路径。例如，拥有一种验证构成法线性化实现的正确性的方法，也许是你用来捕捉这种错误的唯一有意义的方法，假设你没有其他人来检查你的代码。 值得庆幸的是，通过一些战术性的编程，可以很直接地将代码结构化以便重复使用，这样你就可以在生产代码中使用相同的类，并直接在例如单元测试框架中验证它们。</li>
</ul>
<p>这个教程程序将有两个部分。一部分，我们只是用一组简单的例子来介绍deal.II中自动和符号微分支持的基本思想；另一部分，我们将其应用于一个现实的但更复杂的案例。对于这后半部分，下一节将提供一些关于磁性机械材料的背景&ndash;如果你想了解的只是AD和SD的实际情况，你可以跳过这一节，但如果你对如何将AD和SD应用于具体的情况感兴趣，你可能想读完这一节。</p>
<p><a class="anchor" id="Theoryformagnetomechanicalmaterials"></a></p><h3>Theory for magneto-mechanical materials</h3>
<p><a class="anchor" id="Thermodynamicprinciples"></a></p><h4>Thermodynamic principles</h4>
<p>作为介绍我们将用来为磁活性聚合物建模的磁-机械耦合材料法的前奏，我们将首先对这些构成法则必须认同的突出的热力学进行非常简洁的总结。这里总结的理论基础，由Truesdell和Toupin <b>[Truesdell1960a]</b> 以及Coleman和Noll <b>[Coleman1963a]</b> 详细描述，并遵循Holzapfel <b>[Holzapfel2007a]</b> 所提出的逻辑。</p>
<p>从热力学第一定律出发，并遵循一些技术假设，可以证明动能加内能率与外部来源提供给系统的功率之间的平衡是由以下关系给出的，即左边是一个（任意）体积 \(V\) 的能量变化率，右边是作用于该体积的力的总和。</p>
<p class="formulaDsp">
\[ D_{t} \int\limits_{V} \left[ \frac{1}{2} \rho_{0} \mathbf{v} \cdot \mathbf{v} + U^{*}_{0} \right] dV = \int\limits_{V} \left[ \rho_{0} \mathbf{v} \cdot \mathbf{a} + \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - D_{t} M^{*}_{0} - \nabla_{0} \cdot \mathbf{Q} + R_{0} \right] dV . \]
</p>
<p>这里 \(D_{t}\) 代表总的时间导数， \(\rho_{0}\) 是在拉格朗日参考框架下测量的材料密度， \(\mathbf{v}\) 是材料速度， \(\mathbf{a}\) 是其加速度， \(U^{*}_{0}\) 是每单位参考体积的内能， \(\mathbf{P}^{\text{tot}}\) 是总皮拉应力张量， \(\dot{\mathbf{F}}\) 是变形梯度张量的时间速率， \(\boldsymbol{\mathbb{H}}\) 和 \(\boldsymbol{\mathbb{B}}\) 分别是磁场向量和磁感应（或磁通密度）向量， \(\mathbb{E}\) 和 \(\mathbb{D}\) 是电场向量和电位移向量， \(\mathbf{Q}\) 和 \(R_{0}\) 代表参考热通向量和热源。材料微分算子 \(\nabla_{0} (\bullet) \dealcoloneq \frac{d(\bullet)}{d\mathbf{X}}\) ，其中 \(\mathbf{X}\) 是材料位置向量。通过一些条款的重排，引用积分体积 \(V\) 的任意性，总的内部能量密度率 \(\dot{E}_{0}\) 可以被确定为</p>
<p class="formulaDsp">
\[ \dot{E}_{0} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \nabla_{0} \cdot \mathbf{Q} + R_{0} . \]
</p>
<p>总的内能不仅包括由于机械变形（第一项）、热通量和热源（第四项和第五项）而产生的贡献，还包括由于储存在磁场和电场本身的内在能量（分别为第二项和第三项）。</p>
<p>热力学第二定律，也被称为熵不平等原则，告诉我们某些热力学过程是不可逆的。在考虑了总熵和熵输入的速度后，可以得出克劳修斯-杜姆不等式。在局部形式下（以及在物质配置中），其内容为</p>
<p class="formulaDsp">
\[ \theta \dot{\eta}_{0} - R_{0} + \nabla_{0} \cdot \mathbf{Q} - \frac{1}{\theta} \nabla_{0} \theta \cdot \mathbf{Q} \geq 0 . \]
</p>
<p>量 \(\theta\) 是绝对温度， \(\eta_{0}\) 代表每单位参考体积的熵值。</p>
<p>用它来代替热力学第一定律结果中的 \(R_{0} - \nabla_{0} \cdot \mathbf{Q}\) ，我们现在有了这样的关系</p>
<p class="formulaDsp">
\[ \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} + \theta \dot{\eta}_{0} - \dot{E}_{0} - \frac{1}{\theta} \nabla_{0} \theta \cdot \mathbf{Q} \geq 0 . \]
</p>
<p>傅里叶定律告诉我们，热量从高温区域流向低温区域，根据这一定律，最后一项总是正的，可以忽略不计。这使得局部耗散的不等式变成了</p>
<p class="formulaDsp">
\[ \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \left[ \dot{E}_{0} - \theta \dot{\eta}_{0} \right] \geq 0 . \]
</p>
<p>据推测 <b>[Holzapfel2007a]</b> ，Legendre变换</p>
<p class="formulaDsp">
\[ \psi^{*}_{0} = \psi^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}}, \mathbb{D}, \theta \right) = E_{0} - \theta \eta_{0} , \]
</p>
<p>从中我们可以定义具有所述参数化的自由能密度函数 \(\psi^{*}_{0}\) ，它存在并且有效。取此方程的材料速率并将其代入局部耗散不等式，结果是通用表达式</p>
<p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} + \mathbb{E} \cdot \dot{\mathbb{D}} - \dot{\theta} \eta_{0} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}}, \mathbb{D}, \theta \right) \geq 0 . \]
</p>
<p>在等温条件的假设下，并且电场不会以一种被认为是不可忽视的方式激发材料，那么这个耗散不等式就会简化为</p>
<p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \boldsymbol{\mathbb{B}} \right) \geq 0 . \]
</p>
<p><a class="anchor" id="Constitutivelaws"></a></p><h4>Constitutive laws</h4>
<p>当考虑到表现出机械耗散行为的材料时，可以证明这可以通过用代表内部变量的额外参数增加材料自由能密度函数的方式在耗散不等式中得到体现 <b>[Holzapfel1996a]</b> 。因此，我们把它写成</p>
<p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{P}^{\text{tot}} : \dot{\mathbf{F}} + \boldsymbol{\mathbb{H}} \cdot \dot{\boldsymbol{\mathbb{B}}} - \dot{\psi}^{*}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{B}} \right) \geq 0 . \]
</p>
<p>其中 \(\mathbf{F}_{v}^{i} = \mathbf{F}_{v}^{i} \left( t \right)\) 代表与第i个机械耗散（粘性）机制相关的内部变量（其作用类似于变形梯度的测量）。从它的参数化可以推断出，这些内部参数中的每一个都被认为是在时间中演变的。目前，自由能密度函数 \(\psi^{*}_{0}\) 是以磁感应 \(\boldsymbol{\mathbb{B}}\) 为参数的。这是自然的参数化，是所考虑的平衡法的结果。如果这样一类材料被纳入到有限元模型中，将确定需要采用某种磁问题的表述，即磁矢量势表述。这有它自己的一套挑战，所以在可能的情况下，更简单的磁标量势表述可能是首选。在这种情况下，磁性问题需要在磁场方面进行参数化 \(\boldsymbol{\mathbb{H}}\) 。为了进行这种重新参数化，我们执行最后的Legendre变换</p>
<p class="formulaDsp">
\[ \tilde{\psi}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) = \psi^{*}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{B}} \right) - \boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{B}} . \]
</p>
<p>同时，我们可以利用材料框架无所谓的原则，以便用对称的变形措施来表达能量密度函数。</p>
<p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) = \tilde{\psi}_{0} \left( \mathbf{F}, \mathbf{F}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) . \]
</p>
<p>这两个转换的结果（撇开相当多的明确和隐藏的细节）使减少耗散不等式的最终表达式为</p>
<p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \mathbf{S}^{\text{tot}} : \frac{1}{2} \dot{\mathbf{C}} - \boldsymbol{\mathbb{B}} \cdot \dot{\boldsymbol{\mathbb{H}}} - \dot{\psi}_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \geq 0 . \]
</p>
<p>注意右侧第二项的符号变化，以及时间导数向磁感应矢量的转移）。应力量 \(\mathbf{S}^{\text{tot}}\) 被称为总Piola-Kirchhoff应力张量，其能量共轭物 \(\mathbf{C} = \mathbf{F}^{T} \cdot \mathbf{F}\) 是右Cauchy-Green变形张量， \(\mathbf{C}_{v}^{i} = \mathbf{C}_{v}^{i} \left( t \right)\) 是与<code>i</code>th机械耗散（粘性）机制相关的重新参数化内部变量。</p>
<p>对能量密度函数的材料速率进行扩展，并对各种项进行重排，得出的表达式是</p>
<p class="formulaDsp">
\[ \mathcal{D}_{\text{int}} = \left[ \mathbf{S}^{\text{tot}} - 2 \frac{\partial \psi_{0}}{\partial \mathbf{C}} \right] : \frac{1}{2} \dot{\mathbf{C}} - \sum\limits_{i}\left[ 2 \frac{\partial \psi_{0}}{\partial \mathbf{C}_{v}^{i}} \right] : \frac{1}{2} \dot{\mathbf{C}}_{v}^{i} + \left[ - \boldsymbol{\mathbb{B}} - \frac{\partial \psi_{0}}{\partial \boldsymbol{\mathbb{H}}} \right] \cdot \dot{\boldsymbol{\mathbb{H}}} \geq 0 . \]
</p>
<p>在这一点上，值得注意的是<a href="https://en.wikipedia.org/wiki/Partial_derivative">偏导数</a> \(\partial \left( \bullet \right)\) 的使用。这是一个重要的细节，对于本教程中的某个设计选择是很重要的。简单提醒一下这意味着什么，一个多变量函数的偏导返回该函数相对于其中一个变量的导数，而其他变量保持不变。</p>
<p class="formulaDsp">
\[ \frac{\partial f\left(x, y\right)}{\partial x} = \frac{d f\left(x, y\right)}{d x} \Big\vert_{y} . \]
</p>
<p>更具体到耗散不等式所编码的内容（用非常普遍的自由能密度函数 \(\psi_{0}\) ，其参数化尚待正式确定），如果输入变量之一是另一个变量的函数，它也被保持不变，链式规则不再传播，而计算总导数将意味着明智地使用链式规则。通过比较以下两个语句可以更好地理解这一点。</p>
<p class="formulaDsp">
\begin{align*} \frac{\partial f\left(x, y\left(x\right)\right)}{\partial x} &amp;= \frac{d f\left(x, y\left(x\right)\right)}{d x} \Big\vert_{y} \\ \frac{d f\left(x, y\left(x\right)\right)}{d x} &amp;= \frac{d f\left(x, y\left(x\right)\right)}{d x} \Big\vert_{y} + \frac{d f\left(x, y\left(x\right)\right)}{d y} \Big\vert_{x} \frac{d y\left(x\right)}{x} . \end{align*}
</p>
<p>回到问题的热力学，我们接下来利用数量的任意性 \(\dot{\mathbf{C}}\) 和 \(\dot{\boldsymbol{\mathbb{H}}}\) ，通过应用科尔曼-诺尔程序 <b>[Coleman1963a]</b> ， <b>[Coleman1967a]</b> 。这导致了对动力学共轭量的识别</p>
<p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}} = \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} , \\ \boldsymbol{\mathbb{B}} = \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} . \]
</p>
<p>(再次注意，在这个广义的设置中，使用偏导数来定义应力和磁感应)。从耗散功率中剩下的条款（即那些与机械耗散机制有关的条款）来看，如果假定它们是相互独立的，那么，对于每个机制<code>i</code>。</p>
<p class="formulaDsp">
\[ \frac{\partial \psi_{0}}{\partial \mathbf{C}_{v}^{i}} : \dot{\mathbf{C}}_{v}^{i} \leq 0 . \]
</p>
<p>这一约束必须通过适当选择自由能函数以及仔细考虑内部变量的演化规律来满足。</p>
<p>在构成模型中没有耗散机制的情况下（例如，如果要建模的材料是磁超弹性的），那么自由能密度函数 \(\psi_{0} = \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) 减少到存储能量密度函数，总应力和磁感应可以被简化</p>
<p class="formulaDsp">
\begin{align*} \mathbf{S}^{\text{tot}} = \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;\dealcoloneq 2 \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} , \\ \boldsymbol{\mathbb{B}} = \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;\dealcoloneq - \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} , \end{align*}
</p>
<p>其中算子 \(d\) 表示总导数操作。</p>
<p>为了完整起见，应力张量和磁感应的线性化在四阶总参考弹性张量 \(\mathcal{H}^{\text{tot}} \) 、二阶磁静力张量 \(\mathbb{D}\) 和三阶总参考磁弹性耦合张量 \(\mathfrak{P}^{\text{tot}}\) 中得到体现。无论 \(\mathbf{S}^{\text{tot}}\) 和 \(\boldsymbol{\mathbb{B}}\) 的参数化如何，这些量都可以通过以下方式计算出来</p>
<p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} &amp;= 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} , \\ \mathbb{D} &amp;= \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} &amp;= - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} , \\ \left[ \mathfrak{P}^{\text{tot}} \right]^{T} &amp;= 2 \frac{d \boldsymbol{\mathbb{B}}}{d \mathbf{C}} . \end{align*}
</p>
<p>对于速率依赖性材料的情况，这扩展为</p>
<p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= 4 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C} \otimes d \mathbf{C}} , \\ \mathbb{D} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= -\frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \mathbf{C}} , \\ \left[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right) \right]^{T} &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}^{i}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} , \end{align*}
</p>
<p>而对于与速率无关的材料，其线性化为</p>
<p class="formulaDsp">
\begin{align*} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= 4 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C} \otimes d \mathbf{C}} , \\ \mathbb{D} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= -\frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} , \\ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \mathbf{C}} , \\ \left[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \right]^{T} &amp;= - 2 \frac{d^{2} \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} . \end{align*}
</p>
<p>它们之间的微妙区别是在计算第一个导数时应用了偏导。我们稍后会看到这对这个具体应用中AD与SD的选择有什么影响。现在，我们将简单介绍在本教程中实现的两种具体材料。</p>
<p><a class="anchor" id="Magnetoelasticconstitutivelaw"></a></p><h5>Magnetoelastic constitutive law</h5>
<p>我们要考虑的第一种材料是受磁超弹性构成法支配的材料。这种材料对变形和浸泡在磁场中都有反应，但没有表现出时间或历史相关的行为（如通过粘性阻尼或磁滞的耗散，等等）。这种材料的*存储能量密度函数*只以（当前）场变量为参数，而不是它们的时间导数或过去的值。</p>
<p>我们将选择能量密度函数，它既能捕捉到由于变形和磁化而储存在材料中的能量，也能捕捉到储存在磁场本身的能量，它是</p>
<p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p>与</p>
<p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p>其中变量 \(d = \text{tr}(\mathbf{I})\) （ \(\mathbf{I}\) 是秩-2身份张量）代表空间维度， \(\mathbf{F}\) 是变形梯度张量。为了给 \(\psi_{0}\) 的各个组成部分提供一些简单的背景，前两个项与（超弹性）Neohookean材料的储能密度函数非常相似。这里使用的东西与Neohookean材料的唯一区别是弹性剪切模量被磁场敏感的饱和函数 \(f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)\) 缩放（见 <b>[Pelteret2018a]</b> ，公式29）。这个函数实际上将导致材料在强磁场的存在下变硬。由于它受一个sigmoid型函数的支配，剪切模量将渐进地收敛于指定的饱和剪切模量。还可以证明， \(\psi_{0}\) 中的最后一项是磁场的储能密度函数（从第一原理中得出），由相对渗透率常数缩放。这个定义共同意味着材料是线性磁化的，也就是说，磁化矢量和磁场矢量是对齐的。(这在以电流形式陈述的磁能中当然不明显，但当磁感应和磁化从 \(\psi_{0}\) 中导出，并且所有磁场都以 <em> 的电流配置 </em> 表示时，这种关联性就变得很清楚了)。至于磁感应、应力张量和各种材料切线的具体内容，我们将把这些内容推迟到教程正文中介绍，在那里定义了构成法的完整、无辅助的实施。</p>
<p><a class="anchor" id="Magnetoviscoelasticconstitutivelaw"></a></p><h5>Magneto-viscoelastic constitutive law</h5>
<p>我们将制定的第二个材料是一个具有单一耗散机制<code>i</code>的磁-粘弹性材料。我们将考虑的*自由能量密度函数*被定义为</p>
<p class="formulaDsp">
\begin{align*} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \\ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \\ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \end{align*}
</p>
<p>与</p>
<p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p>和进化法</p>
<p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \left( \mathbf{C} \right) = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v} \right] \]
</p>
<p>为内部粘性变量。我们已经选择了能量的磁弹性部分 \(\psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) 来匹配我们探索的第一个材料模型，所以这部分不需要进一步解释。至于粘性部分 \(\psi_{0}^{MVE}\) ，自由能的这一部分（与粘性变形张量的演化规律一起）取自 <b>[Linder2011a]</b> （由 <b>[Pelteret2018a]</b> 中描述的粘性饱和函数进行额外缩放）。它是在一个热力学上一致的框架中得出的，其核心是在微观层面上模拟聚合物链的运动。</p>
<p>要超越这一点，我们还需要考虑进化规律的时间离散化。选择隐式一阶逆向差分方案，那么</p>
<p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \approx \frac{\mathbf{C}_{v}^{(t)} - \mathbf{C}_{v}^{(t-1)}}{\Delta t} = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v}^{(t)} \right] \]
</p>
<p>其中上标 \((t)\) 表示该数量是在当前时间步长中提取的， \((t-1)\) 表示在前一时间步长中提取的数量（即历史变量）。时间段大小 \(\Delta t\) 是当前时间与上一时间段的差。将这些条款重新排列，使当前时间的所有内部变量量都在方程的左侧，我们可以得到</p>
<p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p>匹配 <b>[Linder2011a]</b> 公式54。</p>
<p><a class="anchor" id="Rheologicalexperiment"></a></p><h3>Rheological experiment</h3>
<p>现在我们已经展示了所有这些关于热力学和磁力学理论以及构成模型的公式，让我们概述一下这个程序将对所有这些做什么。我们希望对我们制定的材料定律做一些*有意义的事情，因此将它们置于一些机械和磁载荷条件下是有意义的，这些条件在某种程度上代表了在应用或实验室环境中可能发现的一些条件。实现这一目标的方法之一是将这些构成法则嵌入到有限元模型中，以模拟一个设备。不过，在这个例子中，我们将保持简单（毕竟我们关注的是自动和符号微分概念），并将找到一种简明的方法，使用加载条件的分析表达式忠实地复制工业标准的流变学实验。</p>
<p>我们将重现的流变学实验，它理想化了一个用于表征磁活性聚合物的实验室实验，详见 <b>[Pelteret2018a]</b> （以及 <b>[Pelteret2019a]</b> ，其中与真实世界的实验一起记录）。下面的图片提供了对问题设置的直观描述。</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.parallel_plate-geometry.png" height="300"/>
</div>
 <p>The basic functional geometry of the parallel-plate rotational rheometer. The smooth rotor (blue) applies a torque to an experimental sample (red) of radius \(r\) and height \(H\) while an axially aligned magnetic field generated by a a magneto-rheological device. Although the time-dependent deformation profile of the may be varied, one common experiment would be to subject the material to a harmonic torsional deformation of constant amplitude and frequency \(\omega\). </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.parallel_plate-kinematics.png" height="300"/>
</div>
 <p>Schematic of the kinematics of the problem, assuming no preloading or compression of the sample. A point \(\mathbf{P}\) located at azimuth \(\Theta\) is displaced to location \(\mathbf{p}\) at azimuth \(\theta = \Theta + \alpha\). </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>假设正在测试的是不可压缩的介质，并且通过样品厚度的变形曲线是线性的，那么在样品内某个测量点 \(\mathbf{X}\) 的位移，用径向坐标表示，就是</p>
<p class="formulaDsp">
\begin{align*} r(\mathbf{X}) &amp;= \frac{R(X_{1}, X_{2})}{\sqrt{\lambda_{3}}} , \\ \theta(\mathbf{X}) &amp; = \Theta(X_{1}, X_{2}) + \underbrace{\tau(t) \lambda_{3} X_{3}}_{\alpha(X_{3}, t)} , \\ z(\mathbf{X}) &amp;= \lambda_{3} X_{3} \end{align*}
</p>
<p>其中 \(R(X_{1}, X_{2})\) 和 \(\Theta(X_{1}, X_{2})\) 是半径在</p>
<p>&ndash; 的角度， \(\lambda_{3}\) 是（恒定的）轴向变形， \(\tau(t) = \frac{A}{RH} \sin\left(\omega t\right)\) 是每单位长度的随时间变化的扭转角，将使用固定振幅的正弦波重复振荡 \(A\) 来规定。磁场是轴向排列的，即在 \(X_{3}\) 方向。</p>
<p>这总结了我们在流变样品内任何一点上全面描述理想化载荷所需的一切。我们将以这样的方式设置问题，即我们在这个样品中 "挑选 "一个有代表性的点，并使其在恒定的轴向变形（默认为压缩载荷）和恒定的、轴向施加的磁场中受到谐波剪切变形。我们将记录该点的应力和磁感应强度，并将数据输出到文件中进行后处理。尽管对这个特定的问题来说没有必要，我们也将计算切线。尽管它们没有直接用于这个特定的工作，但这些二阶导数是在有限元模型中嵌入构成法所需要的（这项工作的一个可能的扩展）。因此，我们将利用这个机会，用辅助微分框架来检查我们的手工计算是否正确。</p>
<p><a class="anchor" id="Suggestedliterature"></a></p><h3>Suggested literature</h3>
<p>除了已经提到的 <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> 模块外，以下是一些更详细讨论的参考资料</p>
<ul>
<li>磁力学，以及自动分化框架的某些方面。 <b>[Pao1978a]</b> , <b>[Pelteret2019a]</b> , 和</li>
<li><p class="startli">使用AD和/或SD实现有限元框架的自动化： <b>[Logg2012a]</b> , <b>[Korelc2016a]</b> 。</p>
<p class="startli"><br />
</p>
<p class="startli"><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p class="startli">We start by including all the necessary deal.II header files and some C++ related ones. This first header will give us access to a data structure that will allow us to store arbitrary data within it.</p>
</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="general__data__storage_8h.html">deal.II/algorithms/general_data_storage.h</a>&gt;</span></div></div><!-- fragment --><p>Next come some core classes, including one that provides an implementation for time-stepping.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numbers_8h.html">deal.II/base/numbers.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="symmetric__tensor_8h.html">deal.II/base/symmetric_tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div></div><!-- fragment --><p>Then some headers that define some useful coordinate transformations and kinematic relationships that are often found in nonlinear elasticity.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transformations_8h.html">deal.II/physics/transformations.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinematics_8h.html">deal.II/physics/elasticity/kinematics.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="standard__tensors_8h.html">deal.II/physics/elasticity/standard_tensors.h</a>&gt;</span></div></div><!-- fragment --><p>The following two headers provide all of the functionality that we need to perform automatic differentiation, and use the symbolic computer algebra system that deal.II can utilize. The headers of all automatic differentiation and symbolic differentiation wrapper classes, and any ancillary data structures that are required, are all collected inside these unifying headers.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sd_8h.html">deal.II/differentiation/sd.h</a>&gt;</span></div></div><!-- fragment --><p>Including this header allows us the capability to write output to a file stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>As per usual, the entire tutorial program is defined within its own unique namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step71</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="AnintroductoryexampleThefundamentalsofautomaticandsymbolicdifferentiation"></a> </p><h3>An introductory example: The fundamentals of automatic and symbolic differentiation</h3>
<p>Automatic and symbolic differentiation have some magical and mystical qualities. Although their use in a project can be beneficial for a multitude of reasons, the barrier to understanding how to use these frameworks or how they can be leveraged may exceed the patience of the developer that is trying to (reliably) integrate them into their work.</p>
<p>Although it is the wish of the author to successfully illustrate how these tools can be integrated into workflows for finite element modelling, it might be best to first take a step back and start right from the basics. So to start off with, we'll first have a look at differentiating a "simple" mathematical function using both frameworks, so that the fundamental operations (both their sequence and function) can be firmly established and understood with minimal complication. In the second part of this tutorial we will put these fundamentals into practice and build on them further.</p>
<p>Accompanying the description of the algorithmic steps to use the frameworks will be a simplified view as to what they <em>might</em> be doing in the background. This description will be very much one designed to aid understanding, and the reader is encouraged to view the <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> module documentation for a far more formal description into how these tools actually work.</p>
<p><a class="anchor" id="Ananalyticalfunction"></a> </p><h4>An analytical function</h4>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SimpleExample</div><div class="line">{</div></div><!-- fragment --><p>In order to convince the reader that these tools are indeed useful in practice, let us choose a function for which it is not too difficult to compute the analytical derivatives by hand. It's just sufficiently complicated to make you think about whether or not you truly want to go through with this exercise, and might also make you question whether you are completely sure that your calculations and implementation for its derivatives are correct. The point, of course, is that differentiation of functions is in a sense relatively formulaic and should be something computers are good at &ndash; if we could build on existing software that understands the rules, we wouldn't have to bother with doing it ourselves.</p>
<p>We choose the two variable trigonometric function \(f(x,y) = \cos\left(\frac{y}{x}\right)\) for this purpose. Notice that this function is templated on the number type. This is done because we can often (but not always) use special auto-differentiable and symbolic types as drop-in replacements for real or complex valued types, and these will then perform some elementary calculations, such as evaluate a function value along with its derivatives. We will exploit that property and make sure that we need only define our function once, and then it can be re-used in whichever context we wish to perform differential operations on it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumberType&gt;</div><div class="line"><a class="code" href="classNumberType.html">NumberType</a> f(<span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x);</div><div class="line">}</div></div><!-- fragment --><p>Rather than revealing this function's derivatives immediately, we'll forward declare functions that return them and defer their definition to later. As implied by the function names, they respectively return the derivatives \(\frac{df(x,y)}{dx}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{df(x,y)}{dy}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx^{2}}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx dy}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy dx}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p>and, lastly, \(\frac{d^{2}f(x,y)}{dy^{2}}\):</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div></div><!-- fragment --><p><a class="anchor" id="Computingderivativesusingautomaticdifferentiation"></a> </p><h4>Computing derivatives using automatic differentiation</h4>
<p>To begin, we'll use AD as the tool to automatically compute derivatives for us. We will evaluate the function with the arguments <code>x</code> and <code>y</code>, and expect the resulting value and all of the derivatives to match to within the given tolerance.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">run_and_verify_ad(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">{</div></div><!-- fragment --><p>Our function \(f(x,y)\) is a scalar-valued function, with arguments that represent the typical input variables that one comes across in algebraic calculations or tensor calculus. For this reason, the <a class="el" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction</a> class is the appropriate wrapper class to use to do the computations that we require. (As a point of comparison, if the function arguments represented finite element cell degrees-of-freedom, we'd want to treat them differently.) The spatial dimension of the problem is irrelevant since we have no vector- or tensor-valued arguments to accommodate, so the <code>dim</code> template argument is arbitrarily assigned a value of 1. The second template argument stipulates which AD framework will be used (deal.II has support for several external AD frameworks), and what the underlying number type provided by this framework is to be used. This number type influences the maximum order of the differential operation, and the underlying algorithms that are used to compute them. Given its template nature, this choice is a compile-time decision because many (but not all) of the AD libraries exploit compile-time meta-programming to implement these special number types in an efficient manner. The third template parameter states what the result type is; in our case, we're working with <code>double</code>s.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     dim = 1;</div><div class="line">constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"><span class="keyword">using</span> ADHelper =</div><div class="line">  <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div></div><!-- fragment --><p>It is necessary that we pre-register with our <code>ADHelper</code> class how many arguments (what we will call "independent variables") the function \(f(x,y)\) has. Those arguments are <code>x</code> and <code>y</code>, so obviously there are two of them.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = 2;</div></div><!-- fragment --><p>We now have sufficient information to create and initialize an instance of the helper class. We can also get the concrete number type that will be used in all subsequent calculations. This is useful, because we can write everything from here on by referencing this type, and if we ever want to change the framework used, or number type (e.g., if we need more differential operations) then we need only adjust the <code>ADTypeCode</code> template parameter.</p>
<div class="fragment"><div class="line">ADHelper ad_helper(n_independent_variables);</div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div></div><!-- fragment --><p>The next step is to register the numerical values of the independent variables with the helper class. This is done because the function and its derivatives will be evaluated for exactly these arguments. Since we register them in the order <code>{x,y}</code>, the variable <code>x</code> will be assigned component number <code>0</code>, and <code>y</code> will be component <code>1</code> &ndash; a detail that will be used in the next few lines.</p>
<div class="fragment"><div class="line">ad_helper.register_independent_variables({x, y});</div></div><!-- fragment --><p>We now ask for the helper class to give to us the independent variables with their auto-differentiable representation. These are termed "sensitive variables", because from this point on any operations that we do with the components <code>independent_variables_ad</code> are tracked and recorded by the AD framework, and will be considered when we ask for the derivatives of something that they're used to compute. What the helper returns is a <code>vector</code> of auto-differentiable numbers, but we can be sure that the zeroth element represents <code>x</code> and the first element <code>y</code>. Just to make completely sure that there's no ambiguity of what number type these variables are, we suffix all of the auto-differentiable variables with <code>ad</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; independent_variables_ad =</div><div class="line">  ad_helper.get_sensitive_variables();</div><div class="line"><span class="keyword">const</span> ADNumberType &amp;x_ad = independent_variables_ad[0];</div><div class="line"><span class="keyword">const</span> ADNumberType &amp;y_ad = independent_variables_ad[1];</div></div><!-- fragment --><p>We can immediately pass in our sensitive representation of the independent variables to our templated function that computes \(f(x,y)\). This also returns an auto-differentiable number.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType f_ad = f(x_ad, y_ad);</div></div><!-- fragment --><p>So now the natural question to ask is what we have actually just computed by passing these special <code>x_ad</code> and <code>y_ad</code> variables to the function <code>f</code>, instead of the original <code>double</code> variables <code>x</code> and <code>y</code>? In other words, how is all of this related to the computation of the derivatives that we were wanting to determine? Or, more concisely: What is so special about this returned <code>ADNumberType</code> object that gives it the ability to magically return derivatives?</p>
<p>In essence, how this <em>could</em> be done is the following: This special number can be viewed as a data structure that stores the function value, and the prescribed number of derivatives. For a once-differentiable number expecting two arguments, it might look like this:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="keyword">struct </span>ADNumberType</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> value;          <span class="comment">// The value of the object</span></div><div class="line">  <span class="keywordtype">double</span> derivatives[2]; <span class="comment">// Array of derivatives of the object with</span></div><div class="line">                         <span class="comment">// respect to x and y</span></div><div class="line">};</div></div><!-- fragment --> </div><p>For our independent variable <code>x_ad</code>, the starting value of <code>x_ad.value</code> would simply be its assigned value (i.e., the real value of that this variable represents). The derivative <code>x_ad.derivatives[0]</code> would be initialized to <code>1</code>, since <code>x</code> is the zeroth independent variable and \(\frac{d(x)}{dx} = 1\). The derivative <code>x.derivatives[1]</code> would be initialized to zero, since the first independent variable is <code>y</code> and \(\frac{d(x)}{dy} = 0\).</p>
<p>For the function derivatives to be meaningful, we must assume that not only is this function differentiable in an analytical sense, but that it is also differentiable at the evaluation point <code>x,y</code>. We can exploit both of these assumptions: when we use this number type in mathematical operations, the AD framework <em>could</em> overload the operations (e.g., <code>operator+()</code>, <code>operator*()</code> as well as <code>sin()</code>, <code>exp()</code>, etc.) such that the returned result has the expected value. At the same time, it would then compute the derivatives through the knowledge of exactly what function is being overloaded and rigorous application of the chain-rule. So, the <code>sin()</code> function (with its argument <code>a</code> itself being a function of the independent variables <code>x</code> and <code>y</code>) <em>might</em> be defined as follows:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">ADNumberType <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(<span class="keyword">const</span> ADNumberType &amp;a)</div><div class="line">{</div><div class="line">  ADNumberType output;</div><div class="line">     </div><div class="line"></div><div class="line">  <span class="comment">// For the input argument &quot;a&quot;, &quot;a.value&quot; is simply its value.</span></div><div class="line">  output.value = <a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(a.value);</div><div class="line">     </div><div class="line"></div><div class="line">  <span class="comment">// We know that the derivative of sin(a) is cos(a), but we need</span></div><div class="line">  <span class="comment">// to also consider the chain rule and that the input argument</span></div><div class="line">  <span class="comment">// `a` is also differentiable with respect to the original</span></div><div class="line">  <span class="comment">// independent variables `x` and `y`. So `a.derivatives[0]`</span></div><div class="line">  <span class="comment">// and `a.derivatives[1]` respectively represent the partial</span></div><div class="line">  <span class="comment">// derivatives of `a` with respect to its inputs `x` and `y`.</span></div><div class="line">  output.derivatives[0] = <a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(a.value)*a.derivatives[0];</div><div class="line">  output.derivatives[1] = <a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(a.value)*a.derivatives[1];</div><div class="line">     </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> output;</div><div class="line">}</div></div><!-- fragment --> </div><p>All of that could of course also be done for second and even higher order derivatives.</p>
<p>So it is now clear that with the above representation the <code>ADNumberType</code> is carrying around some extra data that represents the various derivatives of differentiable functions with respect to the original (sensitive) independent variables. It should therefore be noted that there is computational overhead associated with using them (as we compute extra functions when doing derivative computations) as well as memory overhead in storing these results. So the prescribed number of levels of differential operations should ideally be kept to a minimum to limit computational cost. We could, for instance, have computed the first derivatives ourself and then have used the <a class="el" href="classDifferentiation_1_1AD_1_1VectorFunction.html">Differentiation::AD::VectorFunction</a> helper class to determine the gradient of the collection of dependent functions, which would be the second derivatives of the original scalar function.</p>
<p>It is also worth noting that because the chain rule is indiscriminately applied and we only see the beginning and end-points of the calculation <code>{x,y}</code> \(\rightarrow\) <code>f(x,y)</code>, we will only ever be able to query the total derivatives of <code>f</code>; the partial derivatives (<code>a.derivatives[0]</code> and <code>a.derivatives[1]</code> in the above example) are intermediate values and are hidden from us.</p>
<p>Okay, since we now at least have some idea as to exactly what <code>f_ad</code> represents and what is encoded within it, let's put all of that to some actual use. To gain access to those hidden derivative results, we register the final result with the helper class. After this point, we can no longer change the value of <code>f_ad</code> and have those changes reflected in the results returned by the helper class.</p>
<div class="fragment"><div class="line">ad_helper.register_dependent_variable(f_ad);</div></div><!-- fragment --><p>The next step is to extract the derivatives (specifically, the function gradient and Hessian). To do so we first create some temporary data structures (with the result type <code>double</code>) to store the derivatives (noting that all derivatives are returned at once, and not individually)...</p>
<div class="fragment"><div class="line">Vector&lt;double&gt;     Df(ad_helper.n_dependent_variables());</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2f(ad_helper.n_dependent_variables(),</div><div class="line">                       ad_helper.n_independent_variables());</div></div><!-- fragment --><p>... and we then request that the helper class compute these derivatives, and the function value itself. And that's it. We have everything that we were aiming to get.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_f = ad_helper.compute_value();</div><div class="line">ad_helper.compute_gradient(Df);</div><div class="line">ad_helper.compute_hessian(D2f);</div></div><!-- fragment --><p>We can convince ourselves that the AD framework is correct by comparing it to the analytical solution. (Or, if you're like the author, you'll be doing the opposite and will rather verify that your implementation of the analytical solution is correct!)</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                       std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                       std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                       std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div></div><!-- fragment --><p>Because we know the ordering of the independent variables, we know which component of the gradient relates to which derivative...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx = Df[0];</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy = Df[1];</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div></div><!-- fragment --><p>... and similar for the Hessian.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx = D2f[0][0];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy = D2f[0][1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx = D2f[1][0];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy = D2f[1][1];</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">}</div></div><!-- fragment --><p>That's pretty great. There wasn't too much work involved in computing second-order derivatives of this trigonometric function.</p>
<p><a class="anchor" id="Handcalculatedderivativesoftheanalyticalsolution"></a> </p><h4>Hand-calculated derivatives of the analytical solution</h4>
<p>Since we now know how much "implementation effort" it takes to have the AD framework compute those derivatives for us, let's compare that to the same computed by hand and implemented in several stand-alone functions.</p>
<p>Here are the two first derivatives of \(f(x,y) = \cos\left(\frac{y}{x}\right)\):</p>
<p>\(\frac{df(x,y)}{dx} = \frac{y}{x^2} \sin\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(x != 0.0, <a class="code" href="group__Exceptions.html#ga2e959da7bfd82df428770c0339c377ba">ExcDivideByZero</a>());</div><div class="line">  <span class="keywordflow">return</span> y * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / (x * x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{df(x,y)}{dx} = -\frac{1}{x} \sin\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / x;</div><div class="line">}</div></div><!-- fragment --><p>And here are the four second derivatives of \(f(x,y)\):</p>
<p>\(\frac{d^{2}f(x,y)}{dx^{2}} = -\frac{y}{x^4} (2x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> -y * (2 * x * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) + y * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) /</div><div class="line">         (x * x * x * x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dx dy} = \frac{1}{x^3} (x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy dx} = \frac{1}{x^3} (x \sin\left(\frac{y}{x}\right) + y \cos\left(\frac{y}{x}\right))\) (as expected, on the basis of <a href="https://en.wikipedia.org/wiki/Symmetry_of_second_derivatives">Schwarz's theorem</a>)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">}</div></div><!-- fragment --><p>\(\frac{d^{2}f(x,y)}{dy^{2}} = -\frac{1}{x^2} \cos\left(\frac{y}{x}\right)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> -(<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) / (x * x);</div><div class="line">}</div></div><!-- fragment --><p>Hmm... there's a lot of places in the above where we could have introduced an error in the above, especially when it comes to applying the chain rule. Although they're no silver bullet, at the very least these AD frameworks can serve as a verification tool to make sure that we haven't made any errors (either by calculation or by implementation) that would negatively affect our results.</p>
<p>The point of this example of course is that we might have chosen a relatively simple function \(f(x,y)\) for which we can hand-verify that the derivatives the AD framework computed is correct. But the AD framework didn't care that the function was simple: It could have been a much much more convoluted expression, or could have depended on more than two variables, and it would still have been able to compute the derivatives &ndash; the only difference would have been that <em>we</em> wouldn't have been able to come up with the derivatives any more to verify correctness of the AD framework.</p>
<p><a class="anchor" id="Computingderivativesusingsymbolicdifferentiation"></a> </p><h4>Computing derivatives using symbolic differentiation</h4>
<p>We'll now repeat the same exercise using symbolic differentiation. The term "symbolic differentiation" is a little bit misleading because differentiation is just one tool that the Computer Algebra System (CAS) (i.e., the symbolic framework) provides. Nevertheless, in the context of finite element modeling and applications it is the most common use of a CAS and will therefore be the one that we'll focus on. Once more, we'll supply the argument values <code>x</code> and <code>y</code> with which to evaluate our function \(f(x,y) = \cos\left(\frac{y}{x}\right)\) and its derivatives, and a tolerance with which to test the correctness of the returned results.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">run_and_verify_sd(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">{</div></div><!-- fragment --><p>The first step that we need to take is to form the symbolic variables that represent the function arguments that we wish to differentiate with respect to. Again, these will be the independent variables for our problem and as such are, in some sense, primitive variables that have no dependencies on any other variable. We create these types of (independent) variables by initializing a symbolic type <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>, which is a wrapper to a set of classes used by the symbolic framework, with a unique identifier. On this occasion it makes sense that this identifier, a <code>std::string</code>, be simply <code>"x"</code> for the \(x\) argument, and likewise <code>"y"</code> for the \(y\) argument to the dependent function. Like before, we'll suffix symbolic variable names with <code>sd</code> so that we can clearly see which variables are symbolic (as opposed to numeric) in nature.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> x_sd(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> y_sd(<span class="stringliteral">&quot;y&quot;</span>);</div></div><!-- fragment --><p>Using the templated function that computes \(f(x,y)\), we can pass these independent variables as arguments to the function. The returned result will be another symbolic type that represents the sequence of operations used to compute \(\cos\left(\frac{y}{x}\right)\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_sd = f(x_sd, y_sd);</div></div><!-- fragment --><p>At this point it is legitimate to print out the expression <code>f_sd</code>, and if we did so </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;f(x,y) = &quot;</span> &lt;&lt; f_sd &lt;&lt; std::endl;</div></div><!-- fragment --> </div><p> we would see <code>f(x,y) = cos(y/x)</code> printed to the console.</p>
<p>You might notice that we've constructed our symbolic function <code>f_sd</code> with no context as to how we might want to use it: In contrast to the AD approach shown above, what we were returned from calling <code>f(x_sd, y_sd)</code> is not the evaluation of the function <code>f</code> at some specific point, but is in fact a symbolic representation of the evaluation at a generic, as yet undetermined, point. This is one of the key points that makes symbolic frameworks (the CAS) different from automatic differentiation frameworks. Each of the variables <code>x_sd</code> and <code>y_sd</code>, and even the composite dependent function <code>f_sd</code>, are in some sense respectively "placeholders" for numerical values and a composition of operations. In fact, the individual components that are used to compose the function are also placeholders. The sequence of operations are encoded into in a tree-like data structure (conceptually similar to an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>).</p>
<p>Once we form these data structures we can defer any operations that we might want to do with them until some later time. Each of these placeholders represents something, but we have the opportunity to define or redefine what they represent at any convenient point in time. So for this particular problem it makes sense that we somehow want to associate "x" and "y" with <em>some</em> numerical value (with type yet to be determined), but we could conceptually (and if it made sense) assign the ratio "y/x" a value instead of the variables "x" and "y" individually. We could also associate with "x" or "y" some other symbolic function <code>g(a,b)</code>. Any of these operations involves manipulating the recorded tree of operations, and substituting the salient nodes on the tree (and that nodes' subtree) with something else. The key word here is "substitution", and indeed there are many functions in the <a class="el" href="namespaceDifferentiation_1_1SD.html">Differentiation::SD</a> namespace that have this word in their names.</p>
<p>This capability makes the framework entirely generic. In the context of finite element simulations, the types of operations that we would typically perform with our symbolic types are function composition, differentiation, substitution (partial or complete), and evaluation (i.e., conversion of the symbolic type to its numerical counterpart). But should you need it, a CAS is often capable of more than just this: It could be forming anti-derivatives (integrals) of functions, perform simplifications on the expressions that form a function (e.g., replace \((\sin a)^2 + (\cos a)^2\) by \(1\); or, more simply: if the function did an operation like <code>1+2</code>, a CAS could replace it by <code>3</code>), and so forth: The <em>expression</em> that a variable represents is obtained from how the function \(f\) is implemented, but a CAS can do with it whatever its functionality happens to be.</p>
<p>Specifically, to compute the symbolic representation of the first derivatives of the dependent function with respect to its individual independent variables, we use the <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">Differentiation::SD::Expression::differentiate()</a> function with the independent variable given as its argument. Each call will cause the CAS to go through the tree of operations that compose <code>f_sd</code> and differentiate each node of the expression tree with respect to the given symbolic argument.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dx_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dy_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div></div><!-- fragment --><p>To compute the symbolic representation of the second derivatives, we simply differentiate the first derivatives with respect to the independent variables. So to compute a higher order derivative, we first need to compute the lower order derivative. (As the return type of the call to <code><a class="el" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">differentiate()</a></code> is an expression, we could in principal execute double differentiation directly from the scalar by chaining two calls together. But this is unnecessary in this particular case, since we have the intermediate results at hand.)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dx_sd =</div><div class="line">  df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dy_sd =</div><div class="line">  df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dx_sd =</div><div class="line">  df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dy_sd =</div><div class="line">  df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div></div><!-- fragment --><p>Printing the expressions for the first and second derivatives, as computed by the CAS, using the statements </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;df_dx_sd: &quot;</span> &lt;&lt; df_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;df_dy_sd: &quot;</span> &lt;&lt; df_dy_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dx_dx_sd: &quot;</span> &lt;&lt; d2f_dx_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dx_dy_sd: &quot;</span> &lt;&lt; d2f_dx_dy_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dy_dx_sd: &quot;</span> &lt;&lt; d2f_dy_dx_sd &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;d2f_dy_dy_sd: &quot;</span> &lt;&lt; d2f_dy_dy_sd &lt;&lt; std::endl;</div></div><!-- fragment --> </div><p> renders the following output: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">df_dx_sd: y*sin(y/x)/x**2</div><div class="line">df_dy_sd: -sin(y/x)/x</div><div class="line">d2f_dx_dx_sd: -y**2*cos(y/x)/x**4 - 2*y*sin(y/x)/x**3</div><div class="line">d2f_dx_dy_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3</div><div class="line">d2f_dy_dx_sd: sin(y/x)/x**2 + y*cos(y/x)/x**3</div><div class="line">d2f_dy_dy_sd: -cos(y/x)/x**2</div></div><!-- fragment --> </div><p> This compares favorably to the analytical expressions for these derivatives that were presented earlier.</p>
<p>Now that we have formed the symbolic expressions for the function and its derivatives, we want to evaluate them for the numeric values for the main function arguments <code>x</code> and <code>y</code>. To accomplish this, we construct a <em>substitution map</em>, which maps the symbolic values to their numerical counterparts.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> substitution_map =</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::pair&lt;Differentiation::SD::Expression, double&gt;{x_sd, x},</div><div class="line">    std::pair&lt;Differentiation::SD::Expression, double&gt;{y_sd, y});</div></div><!-- fragment --><p>The last step in the process is to convert all symbolic variables and operations into numerical values, and produce the numerical result of this operation. To do this we combine the substitution map with the symbolic variable in the step we have already mentioned above: "substitution".</p>
<p>Once we pass this substitution map to the CAS, it will substitute each instance of the symbolic variable (or, more generally, sub-expression) with its numerical counterpart and then propagate these results up the operation tree, simplifying each node on the tree if possible. If the tree is reduced to a single value (i.e., we have substituted all of the independent variables with their numerical counterpart) then the evaluation is complete.</p>
<p>Due to the strongly-typed nature of C++, we need to instruct the CAS to convert its representation of the result into an intrinsic data type (in this case a <code>double</code>). This is the "evaluation" step, and through the template type we define the return type of this process. Conveniently, these two steps can be done at once if we are certain that we've performed a full substitution.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_f =</div><div class="line">  f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                       std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                       std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                       std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div></div><!-- fragment --><p>We can do the same for the first derivatives...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx =</div><div class="line">  df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy =</div><div class="line">  df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">              std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">              <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div></div><!-- fragment --><p>... and the second derivatives. Notice that we can reuse the same substitution map for each of these operations because we wish to evaluate all of these functions for the same values of <code>x</code> and <code>y</code>. Modifying the values in the substitution map renders the result of same symbolic expression evaluated with different values being assigned to the independent variables. We could also happily have each variable represent a real value in one pass, and a complex value in the next.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx =</div><div class="line">    d2f_dx_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy =</div><div class="line">    d2f_dx_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx =</div><div class="line">    d2f_dy_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy =</div><div class="line">    d2f_dy_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheSimpleExamplerunfunction"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SimpleExample::run()</a> function</h4>
<p>The function used to drive these initial examples is straightforward. We'll arbitrarily choose some values at which to evaluate the function (although knowing that <code>x = 0</code> is not permissible), and then pass these values to the functions that use the AD and SD frameworks.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x = 1.23;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> y = 0.91;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using automatic differentiation...&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    run_and_verify_ad(x, y);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using symbolic differentiation.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    run_and_verify_sd(x, y);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace SimpleExample</span></div></div><!-- fragment --><p><a class="anchor" id="AmorecomplexexampleUsingautomaticandsymbolicdifferentiationtocomputederivativesatcontinuumpoints"></a> </p><h3>A more complex example: Using automatic and symbolic differentiation to compute derivatives at continuum points</h3>
<p>Now that we've introduced the principles behind automatic and symbolic differentiation, we'll put them into action by formulating two coupled magneto-mechanical constitutive laws: one that is rate-independent, and another that exhibits rate-dependent behavior.</p>
<p>As you will recall from the introduction, the material constitutive laws we will consider are far more complicated than the simple example above. This is not just because of the form of the function \(\psi_{0}\) that we will consider, but in particular because \(\psi_{0}\) doesn't just depend on two scalar variables, but instead on a whole bunch of <em>tensors</em>, each with several components. In some cases, these are <em>symmetric</em> tensors, for which only a subset of components is in fact independent, and one has to think about what it actually means to compute a derivative such as \(\frac{\partial\psi_{0}}{\partial \mathbf{C}}\) where \(\mathbf C\) is a symmetric tensor. How all of this will work will, hopefully, become clear below. It will also become clear that doing this by hand is going to be, at the very best, <em>exceedingly</em> <em>tedious</em> and, at worst, riddled with hard-to-find bugs.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>CoupledConstitutiveLaws</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Constitutiveparameters"></a> </p><h4>Constitutive parameters</h4>
<p>We start with a description of the various material parameters that appear in the description of the energy function \(\psi_{0}\).</p>
<p>The ConstitutiveParameters class is used to hold these values. Values for all parameters (both constitutive and rheological) are taken from <b>[Pelteret2018a]</b>, and are given values that produce a constitutive response that is broadly representative of a real, laboratory-made magneto-active polymer, though the specific values used here are of no consequence to the purpose of this program of course.</p>
<p>The first four constitutive parameters respectively represent</p><ul>
<li>the elastic shear modulus \(\mu_{e}\),</li>
<li>the elastic shear modulus at magnetic saturation \(\mu_{e}^{\infty}\),</li>
<li>the saturation magnetic field strength for the elastic shear modulus \(h_{e}^{\text{sat}}\), and</li>
<li>the Poisson ratio \(\nu\).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">class </span>ConstitutiveParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConstitutiveParameters();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mu_e       = 30.0e3;</div><div class="line">  <span class="keywordtype">double</span> mu_e_inf   = 250.0e3;</div><div class="line">  <span class="keywordtype">double</span> mu_e_h_sat = 212.2e3;</div><div class="line">  <span class="keywordtype">double</span> nu_e       = 0.49;</div></div><!-- fragment --><p>The next four, which only pertain to the rate-dependent material, are parameters for</p><ul>
<li>the viscoelastic shear modulus \(\mu_{v}\),</li>
<li>the viscoelastic shear modulus at magnetic saturation \(\mu_{v}^{\infty}\),</li>
<li>the saturation magnetic field strength for the viscoelastic shear modulus \(h_{v}^{\text{sat}}\), and</li>
<li>the characteristic relaxation time \(\tau\).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mu_v       = 20.0e3;</div><div class="line"><span class="keywordtype">double</span> mu_v_inf   = 35.0e3;</div><div class="line"><span class="keywordtype">double</span> mu_v_h_sat = 92.84e3;</div><div class="line"><span class="keywordtype">double</span> tau_v      = 0.6;</div></div><!-- fragment --><p>The last parameter is the relative magnetic permeability \(\mu_{r}\).</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> mu_r = 6.0;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">};</div></div><!-- fragment --><p>The parameters are initialized through the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> framework, which is discussed in detail in <a class="el" href="step_60.html">step-60</a>.</p>
<div class="fragment"><div class="line">ConstitutiveParameters::ConstitutiveParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Constitutive Parameters/&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Elastic shear modulus&quot;</span>, mu_e);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Elastic shear modulus at magnetic saturation&quot;</span>, mu_e_inf);</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Saturation magnetic field strength for elastic shear modulus&quot;</span>,</div><div class="line">    mu_e_h_sat);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Poisson ratio&quot;</span>, nu_e);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus&quot;</span>, mu_v);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus at magnetic saturation&quot;</span>,</div><div class="line">                mu_v_inf);</div><div class="line">  add_parameter(</div><div class="line">    <span class="stringliteral">&quot;Saturation magnetic field strength for viscoelastic shear modulus&quot;</span>,</div><div class="line">    mu_v_h_sat);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Characteristic relaxation time&quot;</span>, tau_v);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Relative magnetic permeability&quot;</span>, mu_r);</div><div class="line"></div><div class="line">  parse_parameters_call_back.connect([&amp;]() { initialized = <span class="keyword">true</span>; });</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutivelawsBaseclass"></a> </p><h4>Constitutive laws: Base class</h4>
<p>Since we'll be formulating two constitutive laws for the same class of materials, it makes sense to define a base class that ensures a unified interface to them.</p>
<p>The class declaration starts with the constructor that will accept the set of constitutive parameters that, in conjunction with the material law itself, dictate the material response.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coupled_Magnetomechanical_Constitutive_Law_Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div></div><!-- fragment --><p>Instead of computing and returning the kinetic variables or their linearization at will, we'll calculate and store these values within a single method. These cached results will then be returned upon request. We'll defer the precise explanation as to why we'd want to do this to a later stage. What is important for now is to see that this function accepts all of the field variables, namely the magnetic field vector \(\boldsymbol{\mathbb{H}}\) and right Cauchy-Green deformation tensor \(\mathbf{C}\), as well as the time discretizer. These, in addition to the <code>constitutive_parameters</code>, are all the fundamental quantities that are required to compute the material response.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) = 0;</div></div><!-- fragment --><p>The next few functions provide the interface to probe the material response due subject to the applied deformation and magnetic loading.</p>
<p>Since the class of materials can be expressed in terms of a free energy \(\psi_{0}\), we can compute that...</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>... as well as the two kinetic quantities:</p><ul>
<li>the magnetic induction vector \(\boldsymbol{\mathbb{B}}\), and</li>
<li>the total Piola-Kirchhoff stress tensor \(\mathbf{S}^{\text{tot}}\)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>... and the linearization of the kinetic quantities, which are:</p><ul>
<li>the magnetostatic tangent tensor \(\mathbb{D}\),</li>
<li>the total referential magnetoelastic coupling tensor \(\mathfrak{P}^{\text{tot}}\), and</li>
<li>the total referential elastic tangent tensor \(\mathcal{H}^{\text{tot}}\).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>We'll also define a method that provides a mechanism for this class instance to do any additional tasks before moving on to the next timestep. Again, the reason for doing this will become clear a little later.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep()</div><div class="line">{}</div></div><!-- fragment --><p>In the <code>protected</code> part of the class, we store a reference to an instance of the constitutive parameters that govern the material response. For convenience, we also define some functions that return various constitutive parameters (both explicitly defined, as well as calculated).</p>
<p>The parameters related to the elastic response of the material are, in order:</p><ul>
<li>the elastic shear modulus,</li>
<li>the elastic shear modulus at saturation magnetic field,</li>
<li>the saturation magnetic field strength for the elastic shear modulus,</li>
<li>the Poisson ratio,</li>
<li>the Lam&eacute; parameter, and</li>
<li>the bulk modulus.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_mu_e_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_nu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_lambda_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_kappa_e() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The parameters related to the elastic response of the material are, in order:</p><ul>
<li>the viscoelastic shear modulus,</li>
<li>the viscoelastic shear modulus at magnetic saturation,</li>
<li>the saturation magnetic field strength for the viscoelastic shear modulus, and</li>
<li>the characteristic relaxation time.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_mu_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_mu_v_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_mu_v_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_tau_v() <span class="keyword">const</span>;</div></div><!-- fragment --><p>The parameters related to the magnetic response of the material are, in order:</p><ul>
<li>the relative magnetic permeability, and</li>
<li>the magnetic permeability constant \(\mu_{0}\) (not really a material constant, but rather a universal constant that we'll group here for simplicity).</li>
</ul>
<p>We'll also implement a function that returns the timestep size from the time discretizion.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> get_mu_r() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> get_mu_0() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span>           get_delta_t(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>In the following, let us start by implementing the several relatively trivial member functions of the class just defined:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">  : constitutive_parameters(constitutive_parameters)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(get_kappa_e() &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_e;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_e_inf;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_e_h_sat;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_nu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.nu_e;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_lambda_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_kappa_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (2.0 * get_mu_e() * (1.0 + get_nu_e())) /</div><div class="line">         (3.0 * (1.0 - 2.0 * get_nu_e()));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_v;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_v_inf;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_v_h_sat;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_tau_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.tau_v;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_r()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> constitutive_parameters.mu_r;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">constexpr <span class="keywordtype">double</span></div><div class="line">Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_0()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 4.0 * numbers::PI * 1e-7;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_delta_t(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> time.<a class="code" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">get_previous_step_size</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Magnetoelasticconstitutivelawusingautomaticdifferentiation"></a> </p><h4>Magnetoelastic constitutive law (using automatic differentiation)</h4>
<p>We'll begin by considering a non-dissipative material, namely one that is governed by a magneto-hyperelastic constitutive law that exhibits stiffening when immersed in a magnetic field. As described in the introduction, the stored energy density function for such a material might be given by </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) . \]
</p>
<p>Now on to the class that implements this behavior. Since we expect that this class fully describes a single material, we'll mark it as "final" so that the inheritance tree terminated here. At the top of the class, we define the helper type that we will use in the AD computations for our scalar energy density function. Note that we expect it to return values of type <code>double</code>. We also have to specify the number of spatial dimensions, <code>dim</code>, so that the link between vector, tensor and symmetric tensor fields and the number of components that they contain may be established. The concrete <code>ADTypeCode</code> used for the ADHelper class will be provided as a template argument at the point where this class is actually used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><span class="keyword">class </span>Magnetoelastic_Constitutive_Law_AD final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> ADHelper =</div><div class="line">    <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line">  <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoelastic_Constitutive_Law_AD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div></div><!-- fragment --><p>Since the public interface to the base class is pure-<code>virtual</code>, here we'll declare that this class will override all of these base class methods.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>In the <code>private</code> part of the class, we need to define some extractors that will help us set independent variables and later get the computed values related to the dependent variables. If this class were to be used in the context of a finite element problem, then each of these extractors is (most likely) related to the gradient of a component of the solution field (in this case, displacement and magnetic scalar potential). As you can probably infer by now, here "C" denotes the right Cauchy-Green tensor and "H" denotes the magnetic field vector.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>             H_components;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor&lt;2&gt;</a> C_components;</div></div><!-- fragment --><p>This is an instance of the automatic differentiation helper that we'll set up to do all of the differential calculations related to the constitutive law...</p>
<div class="fragment"><div class="line">ADHelper ad_helper;</div></div><!-- fragment --><p>... and the following three member variables will store the output from the <code>ad_helper</code>. The <code>ad_helper</code> returns the derivatives with respect to all field variables at once, so we'll retain the full gradient vector and Hessian matrix. From that, we'll extract the individual entries that we're actually interested in.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span>             psi;</div><div class="line">  Vector&lt;double&gt;     Dpsi;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2psi;</div><div class="line">};</div></div><!-- fragment --><p>When setting up the field component extractors, it is completely arbitrary as to how they are ordered. But it is important that the extractors do not have overlapping indices. The total number of components of these extractors defines the number of independent variables that the <code>ad_helper</code> needs to track, and with respect to which we'll be taking derivatives. The resulting data structures <code>Dpsi</code> and <code>D2psi</code> must also be sized accordingly. Once the <code>ad_helper</code> is configured (its input argument being the total number of components of \(\mathbf{C}\) and \(\boldsymbol{\mathbb{H}}\)), we can directly interrogate it as to how many independent variables it uses.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::</div><div class="line">  Magnetoelastic_Constitutive_Law_AD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , H_components(0)</div><div class="line">  , C_components(Tensor&lt;1, dim&gt;::n_independent_components)</div><div class="line">  , ad_helper(Tensor&lt;1, dim&gt;::n_independent_components +</div><div class="line">              SymmetricTensor&lt;2, dim&gt;::n_independent_components)</div><div class="line">  , psi(0.0)</div><div class="line">  , Dpsi(ad_helper.n_independent_variables())</div><div class="line">  , D2psi(ad_helper.n_independent_variables(),</div><div class="line">          ad_helper.n_independent_variables())</div><div class="line">{}</div></div><!-- fragment --><p>As stated before, due to the way that the automatic differentiation libraries work, the <code>ad_helper</code> will always returns the derivatives of the energy density function with respect to all field variables simultaneously. For this reason, it does not make sense to compute the derivatives in the functions <code>get_B()</code>, <code>get_S()</code>, etc. because we'd be doing a lot of extra computations that are then simply discarded. So, the best way to deal with that is to have a single function call that does all of the calculations up-front, and then we extract the stored data as its needed. That's what we'll do in the <code>update_internal_data()</code> method. As the material is rate-independent, we can ignore the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> argument.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C) &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div></div><!-- fragment --><p>Since we reuse the <code>ad_helper</code> data structure at each time step, we need to clear it of all stale information before use.</p>
<div class="fragment"><div class="line">ad_helper.reset();</div></div><!-- fragment --><p>The next step is to set the values for all field components. These define the "point" around which we'll be computing the function gradients and their linearization. The extractors that we created before provide the association between the fields and the registry within the <code>ad_helper</code> &ndash; they'll be used repeatedly to ensure that we have the correct interpretation of which variable corresponds to which component of <code>H</code> or <code>C</code>.</p>
<div class="fragment"><div class="line">ad_helper.register_independent_variable(H, H_components);</div><div class="line">ad_helper.register_independent_variable(C, C_components);</div></div><!-- fragment --><p>Now that we've done the initial setup, we can retrieve the AD counterparts of our fields. These are truly the independent variables for the energy function, and are "sensitive" to the calculations that are performed with them. Notice that the AD number are treated as a special number type, and can be used in many templated classes (in this example, as the scalar type for the <a class="el" href="classTensor.html">Tensor</a> and <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, ADNumberType&gt;</a> H_ad =</div><div class="line">  ad_helper.get_sensitive_variables(H_components);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_ad =</div><div class="line">  ad_helper.get_sensitive_variables(C_components);</div></div><!-- fragment --><p>We can also use them in many functions that are templated on the scalar type. So, for these intermediate values that we require, we can perform tensor operations and some mathematical functions. The resulting type will also be an automatically differentiable number, which encodes the operations performed in these functions.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType det_F_ad = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C_ad));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_inv_ad = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C_ad);</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F_ad &gt; ADNumberType(0.0),</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>Next we'll compute the scaling function that will cause the shear modulus to change (increase) under the influence of a magnetic field...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType f_mu_e_ad =</div><div class="line">  1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_ad * H_ad) /</div><div class="line">                    (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()));</div></div><!-- fragment --><p>... and then we can define the material stored energy density function. We'll see later that this example is sufficiently complex to warrant the use of AD to, at the very least, verify an unassisted implementation.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ADNumberType psi_ad =</div><div class="line">  0.5 * this-&gt;get_mu_e() * f_mu_e_ad *</div><div class="line">    (<a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C_ad) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad))                 </div><div class="line">  + this-&gt;get_lambda_e() * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) </div><div class="line">  - 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F_ad *</div><div class="line">      (H_ad * C_inv_ad * H_ad); </div></div><!-- fragment --><p>The stored energy density function is, in fact, the dependent variable for this problem, so as a final step in the "configuration" phase, we register its definition with the <code>ad_helper</code>.</p>
<div class="fragment"><div class="line">ad_helper.register_dependent_variable(psi_ad);</div></div><!-- fragment --><p>Finally, we can retrieve the resulting value of the stored energy density function, as well as its gradient and Hessian with respect to the input fields, and cache them.</p>
<div class="fragment"><div class="line">  psi = ad_helper.compute_value();</div><div class="line">  ad_helper.compute_gradient(Dpsi);</div><div class="line">  ad_helper.compute_hessian(D2psi);</div><div class="line">}</div></div><!-- fragment --><p>The following few functions then allow for querying the so-stored value of \(\psi_{0}\), and to extract the desired components of the gradient vector and Hessian matrix. We again make use of the extractors to express which parts of the total gradient vector and Hessian matrix we wish to retrieve. They only return the derivatives of the energy function, so for our definitions of the kinetic variables and their linearization a few more manipulations are required to form the desired result.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> psi;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dpsi_dH =</div><div class="line">    ad_helper.extract_gradient_component(Dpsi, H_components);</div><div class="line">  <span class="keywordflow">return</span> -dpsi_dH;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dpsi_dC =</div><div class="line">    ad_helper.extract_gradient_component(Dpsi, C_components);</div><div class="line">  <span class="keywordflow">return</span> 2.0 * dpsi_dC;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> dpsi_dH_dH =</div><div class="line">    ad_helper.extract_hessian_component(D2psi, H_components, H_components);</div><div class="line">  <span class="keywordflow">return</span> -<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(dpsi_dH_dH);</div><div class="line">}</div></div><!-- fragment --><p>Note that for coupled terms the order of the extractor arguments is especially important, as it dictates the order in which the directional derivatives are taken. So, if we'd reversed the order of the extractors in the call to <code>extract_hessian_component()</code> then we'd actually have been retrieving part of \(\left[ \mathfrak{P}^{\text{tot}} \right]^{T}\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> dpsi_dC_dH =</div><div class="line">    ad_helper.extract_hessian_component(D2psi, C_components, H_components);</div><div class="line">  <span class="keywordflow">return</span> -2.0 * dpsi_dC_dH;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dpsi_dC_dC =</div><div class="line">    ad_helper.extract_hessian_component(D2psi, C_components, C_components);</div><div class="line">  <span class="keywordflow">return</span> 4.0 * dpsi_dC_dC;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Magnetoviscoelasticconstitutivelawusingsymbolicalgebraanddifferentiation"></a> </p><h4>Magneto-viscoelastic constitutive law (using symbolic algebra and differentiation)</h4>
<p>The second material law that we'll consider will be one that represents a magneto-viscoelastic material with a single dissipative mechanism. We'll consider the free energy density function for such a material to be defined as </p><p class="formulaDsp">
\begin{align*} \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \\ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \\ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \end{align*}
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right), \]
</p>
<p> in conjunction with the evolution law for the internal viscous variable </p><p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p> that was discretized using a first-order backward difference approximation.</p>
<p>Again, let us see how this is implemented in a concrete class. Instead of the AD framework used in the previous class, we will now utilize the SD approach. To support this, the class constructor accepts not only the <code>constitutive_parameters</code>, but also two additional variables that will be used to initialize a <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a>. We'll give more context to this later.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law_SD final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags);</div></div><!-- fragment --><p>Like for the automatic differentiation helper, the <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> will return a collection of results all at once. So, in order to do that just once, we'll utilize a similar approach to before and do all of the expensive calculations within the <code>update_internal_data()</code> function, and cache the results for layer extraction.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>Since we're dealing with a rate dependent material, we'll have to update the history variable at the appropriate time. That will be the purpose of this function.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div></div><!-- fragment --><p>In the <code>private</code> part of the class, we will want to keep track of the internal viscous deformation, so the following two (real-valued, non-symbolic) member variables respectively hold</p><ul>
<li>the value of internal variable time step (and, if embedded within a nonlinear solver framework, Newton step), and</li>
<li>the value of internal variable at the previous timestep.</li>
</ul>
<p>(We've labeled these variables "Q" so that they're easy to identify; in a sea of calculations it is not necessarily easy to distinguish <code>Cv</code> or <code>C_v</code> from <code>C</code>.)</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div></div><!-- fragment --><p>As we'll be using symbolic types, we'll need to define some symbolic variables to use with the framework. (They are all suffixed with "SD" to make it easy to distinguish the symbolic types or expressions from real-valued types or scalars.) This can be done once up front (potentially even as <code>static</code> variables) to minimize the overhead associated with creating these variables. For the ultimate in generic programming, we can even describe the constitutive parameters symbolically, <em>potentially</em> allowing a single class instance to be reused with different inputs for these values too.</p>
<p>These are the symbolic scalars that represent the elastic, viscous, and magnetic material parameters (defined mostly in the same order as they appear in the <code>ConstitutiveParameters</code> class). We also store a symbolic expression, <code>delta_t_sd</code>, that represents the time step size):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_inf_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_h_sat_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> lambda_e_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_inf_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_h_sat_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> tau_v_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> delta_t_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_r_sd;</div></div><!-- fragment --><p>Next we define some tensorial symbolic variables that represent the independent field variables, upon which the energy density function is parameterized:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          H_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_sd;</div></div><!-- fragment --><p>And similarly we have the symbolic representation of the internal viscous variables (both its current value and its value at the previous timestep):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t_sd;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t1_sd;</div></div><!-- fragment --><p>We should also store the definitions of the dependent expressions: Although we'll only compute them once, we require them to retrieve data from the <code>optimizer</code> that is declared below. Furthermore, when serializing a material class like this one (not done as a part of this tutorial) we'd either need to serialize these expressions as well or we'd need to reconstruct them upon reloading.</p>
<div class="fragment"><div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>                          psi_sd;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          B_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> S_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> BB_sd;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim, Differentiation::SD::Expression&gt;</a>          PP_sd;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim, Differentiation::SD::Expression&gt;</a> HH_sd;</div></div><!-- fragment --><p>The next variable is then the optimizer that is used to evaluate the dependent functions. More specifically, it provides the possibility to accelerate the evaluation of the symbolic dependent expressions. This is a vital tool, because the native evaluation of lengthy expressions (using no method of acceleration, but rather direct evaluation directly of the symbolic expressions) can be very slow. The <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> class provides a mechanism by which to transform the symbolic expression tree into another code path that, for example, shares intermediate results between the various dependent expressions (meaning that these intermediate values only get calculated once per evaluation) and/or compiling the code using a just-in-time compiler (thereby retrieving near-native performance for the evaluation step).</p>
<p>Performing this code transformation is very computationally expensive, so we store the optimizer so that it is done just once per class instance. This also further motivates the decision to make the constitutive parameters themselves symbolic. We could then reuse a single instance of this <code>optimizer</code> across several materials (with the same energy function, of course) and potentially multiple continuum points (if embedded within a finite element simulation).</p>
<p>As specified by the template parameter, the numerical result will be of type <code>double</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer&lt;double&gt;</a> optimizer;</div></div><!-- fragment --><p>During the evaluation phase, we must map the symbolic variables to their real-valued counterparts. The next method will provide this functionality.</p>
<p>The final method of this class will configure the <code>optimizer</code>.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> initialize_optimizer();</div><div class="line">};</div></div><!-- fragment --><p>As the resting deformation state is one at which the material is considered to be completely relaxed, the internal viscous variables are initialized with the identity tensor, i.e. \(\mathbf{C}_{v} = \mathbf{I}\). The various symbolic variables representing the constitutive parameters, time step size, and field and internal variables all get a unique identifier. The optimizer is passed the two parameters that declare which optimization (acceleration) technique should be applied, as well as which additional steps should be taken by the CAS to help improve performance during evaluation.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::</div><div class="line">  Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , mu_e_sd(<span class="stringliteral">&quot;mu_e&quot;</span>)</div><div class="line">  , mu_e_inf_sd(<span class="stringliteral">&quot;mu_e_inf&quot;</span>)</div><div class="line">  , mu_e_h_sat_sd(<span class="stringliteral">&quot;mu_e_h_sat&quot;</span>)</div><div class="line">  , lambda_e_sd(<span class="stringliteral">&quot;lambda_e&quot;</span>)</div><div class="line">  , mu_v_sd(<span class="stringliteral">&quot;mu_v&quot;</span>)</div><div class="line">  , mu_v_inf_sd(<span class="stringliteral">&quot;mu_v_inf&quot;</span>)</div><div class="line">  , mu_v_h_sat_sd(<span class="stringliteral">&quot;mu_v_h_sat&quot;</span>)</div><div class="line">  , tau_v_sd(<span class="stringliteral">&quot;tau_v&quot;</span>)</div><div class="line">  , delta_t_sd(<span class="stringliteral">&quot;delta_t&quot;</span>)</div><div class="line">  , mu_r_sd(<span class="stringliteral">&quot;mu_r&quot;</span>)</div><div class="line">  , H_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#acf16bdf4d5a0b48dd84496e379742426">make_vector_of_symbols</a>&lt;dim&gt;(<span class="stringliteral">&quot;H&quot;</span>))</div><div class="line">  , C_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;C&quot;</span>))</div><div class="line">  , Q_t_sd(</div><div class="line">      <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t&quot;</span>))</div><div class="line">  , Q_t1_sd(</div><div class="line">      <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t1&quot;</span>))</div><div class="line">  , optimizer(optimizer_type, optimization_flags)</div><div class="line">{</div><div class="line">  initialize_optimizer();</div><div class="line">}</div></div><!-- fragment --><p>The substitution map simply pairs all of the following data together:</p><ul>
<li>the constitutive parameters (with values retrieved from the base class),</li>
<li>the time step size (with its value retrieved from the time discretizer),</li>
<li>the field values (with their values being prescribed by an external function that is calling into this <code>Magnetoviscoelastic_Constitutive_Law_SD</code> instance), and</li>
<li>the current and previous internal viscous deformation (with their values stored within this class instance).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::make_substitution_map</a>(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::make_pair(mu_e_sd, this-&gt;get_mu_e()),</div><div class="line">    std::make_pair(mu_e_inf_sd, this-&gt;get_mu_e_inf()),</div><div class="line">    std::make_pair(mu_e_h_sat_sd, this-&gt;get_mu_e_h_sat()),</div><div class="line">    std::make_pair(lambda_e_sd, this-&gt;get_lambda_e()),</div><div class="line">    std::make_pair(mu_v_sd, this-&gt;get_mu_v()),</div><div class="line">    std::make_pair(mu_v_inf_sd, this-&gt;get_mu_v_inf()),</div><div class="line">    std::make_pair(mu_v_h_sat_sd, this-&gt;get_mu_v_h_sat()),</div><div class="line">    std::make_pair(tau_v_sd, this-&gt;get_tau_v()),</div><div class="line">    std::make_pair(delta_t_sd, delta_t),</div><div class="line">    std::make_pair(mu_r_sd, this-&gt;get_mu_r()),</div><div class="line">    std::make_pair(H_sd, H),</div><div class="line">    std::make_pair(C_sd, C),</div><div class="line">    std::make_pair(Q_t_sd, Q_t),</div><div class="line">    std::make_pair(Q_t1_sd, Q_t1));</div><div class="line">}</div></div><!-- fragment --><p>Due to the "natural" use of the symbolic expressions, much of the procedure to configure the <code>optimizer</code> looks very similar to that which is used to construct the automatic differentiation helper. Nevertheless, we'll detail these steps again to highlight the differences that underlie the two frameworks.</p>
<p>The function starts with expressions that symbolically encode the determinant of the deformation gradient (as expressed in terms of the right Cauchy-Green deformation tensor, our primary field variable), as well as the inverse of \(\mathbf{C}\) itself:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::initialize_optimizer()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> det_F_sd =</div><div class="line">    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C_sd));</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_inv_sd =</div><div class="line">    <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C_sd);</div></div><!-- fragment --><p>Next is the symbolic representation of the saturation function for the elastic part of the free energy density function, followed by the magnetoelastic contribution to the free energy density function. This all has the same structure as we'd seen previously.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_e_sd =</div><div class="line">  1.0 +</div><div class="line">  (mu_e_inf_sd / mu_e_sd - 1.0) *</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_ME_sd =</div><div class="line">  0.5 * mu_e_sd * f_mu_e_sd *</div><div class="line">    (<a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C_sd) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd)) +</div><div class="line">  lambda_e_sd * std::log(det_F_sd) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd) -</div><div class="line">  0.5 * this-&gt;get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);</div></div><!-- fragment --><p>In addition, we define the magneto-viscoelastic contribution to the free energy density function. The first component required to implement this is a scaling function that will cause the viscous shear modulus to change (increase) under the influence of a magnetic field (see <b>[Pelteret2018a]</b>, equation 29). Thereafter we can compute the dissipative component of the energy density function; its expression is stated in <b>[Pelteret2018a]</b> (equation 28), which is a straight-forward extension of an energy density function formulated in <b>[Linder2011a]</b> (equation 46).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_v_sd =</div><div class="line">  1.0 +</div><div class="line">  (mu_v_inf_sd / mu_v_sd - 1.0) *</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_MVE_sd =</div><div class="line">  0.5 * mu_v_sd * f_mu_v_sd *</div><div class="line">  (Q_t_sd * (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, -2.0 / dim) * C_sd) - dim -</div><div class="line">   std::log(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t_sd)));</div></div><!-- fragment --><p>From these building blocks, we can then define the material's total free energy density function:</p>
<div class="fragment"><div class="line">psi_sd = psi_ME_sd + psi_MVE_sd;</div></div><!-- fragment --><p>As it stands, to the CAS the variable <code>Q_t_sd</code> appears to be independent of <code>C_sd</code>. Our tensorial symbolic expression <code>Q_t_sd</code> just has an identifier associated with it, and there is nothing that links it to the other tensorial symbolic expression <code>C_sd</code>. So any derivatives taken with respect to <code>C_sd</code> will ignore this inherent dependence which, as we can see from the evolution law, is in fact \(\mathbf{C}_{v} = \mathbf{C}_{v} \left( \mathbf{C}, t \right)\). This means that deriving any function \(f = f(\mathbf{C}, \mathbf{Q})\) with respect to \(\mathbf{C}\) will return partial derivatives \(\frac{\partial f(\mathbf{C}, \mathbf{Q})}{\partial \mathbf{C}} \Big\vert_{\mathbf{Q}}\) as opposed to the total derivative \(\frac{d f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{d \mathbf{C}} = \frac{\partial f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{\partial \mathbf{C}} \Big\vert_{\mathbf{Q}} + \frac{\partial f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))}{\partial \mathbf{Q}} \Big\vert_{\mathbf{C}} : \frac{d \mathbf{Q}(\mathbf{C}))}{d \mathbf{C}}\).</p>
<p>By contrast, with the current AD libraries the total derivative would always be returned. This implies that the computed kinetic variables would be incorrect for this class of material model, making AD the incorrect tool from which to derive (at the continuum point level) the constitutive law for this dissipative material from an energy density function.</p>
<p>It is this specific level of control that characterizes a defining difference difference between the SD and AD frameworks. In a few lines we'll be manipulating the expression for the internal variable <code>Q_t_sd</code> such that it produces the correct linearization.</p>
<p>But, first, we'll compute the symbolic expressions for the kinetic variables, i.e., the magnetic induction vector and the Piola-Kirchhoff stress tensor. The code that performs the differentiation quite closely mimics the definition stated in the theory.</p>
<div class="fragment"><div class="line">B_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, H_sd);</div><div class="line">S_sd = 2.0 * <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, C_sd);</div></div><!-- fragment --><p>Since the next step is to linearize the above, it is the appropriate time to inform the CAS of the explicit dependency of <code>Q_t_sd</code> on <code>C_sd</code>, i.e., state that \(\mathbf{C}_{v} = \mathbf{C}_{v} \left( \mathbf{C}, t \right)\). This means that all future differential operations made with respect to <code>C_sd</code> will take into account this dependence (i.e., compute total derivatives). In other words, we will transform some expression such that their intrinsic parameterization changes from \(f(\mathbf{C}, \mathbf{Q})\) to \(f(\mathbf{C}, \mathbf{Q}(\mathbf{C}))\).</p>
<p>To do this, we consider the time-discrete evolution law. From that, we have the explicit expression for the internal variable in terms of its history as well as the primary field variable. That is what it described in this expression:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a></div><div class="line">  Q_t_sd_explicit =</div><div class="line">    (1.0 / (1.0 + delta_t_sd / tau_v_sd)) *</div><div class="line">    (Q_t1_sd +</div><div class="line">     (delta_t_sd / tau_v_sd * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, 2.0 / dim) * C_inv_sd));</div></div><!-- fragment --><p>Next we produce an intermediate substitution map, which will take every instance of <code>Q_t_sd</code> (our identifier) found in an expression and replace it with the full expression held in <code>Q_t_sd_explicit</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">  substitution_map_explicit = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">    std::make_pair(Q_t_sd, Q_t_sd_explicit));</div></div><!-- fragment --><p>We can the perform this substitution on the two kinetic variables and immediately differentiate the result that appears after that substitution with the field variables. (If you'd like, this could be split up into two steps with the intermediate results stored in a temporary variable.) Again, if you overlook the "complexity" generated by the substitution, these calls that linearize the kinetic variables and produce the three tangent tensors quite closely resembles what's stated in the theory.</p>
<div class="fragment"><div class="line">BB_sd = <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(B_sd, substitution_map_explicit),</div><div class="line">  H_sd));</div><div class="line">PP_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit), H_sd);</div><div class="line">HH_sd =</div><div class="line">  2.0 *</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit),</div><div class="line">    C_sd);</div></div><!-- fragment --><p>Now we need to tell the <code>optimizer</code> what entries we need to provide numerical values for in order for it to successfully perform its calculations. These essentially act as the input arguments to all dependent functions that the <code>optimizer</code> must evaluate. They are, collectively, the independent variables for the problem, the history variables, the time step sie and the constitutive parameters (since we've not hard encoded them in the energy density function).</p>
<p>So what we really want is to provide it a collection of symbols, which one could accomplish in this way: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">optimizer.register_symbols(<a class="code" href="namespaceDifferentiation_1_1SD.html#a8349584858c74f233cc2ca0151eecfad">Differentiation::SD::make_symbol_map</a>(</div><div class="line">  mu_e_sd, mu_e_inf_sd, mu_e_h_sat_sd, lambda_e_sd,</div><div class="line">  mu_v_sd, mu_v_inf_sd, mu_v_h_sat_sd, tau_v_sd,</div><div class="line">  delta_t_sd, mu_r_sd,</div><div class="line">  H_sd, C_sd,</div><div class="line">  Q_t_sd, Q_t1_sd));</div></div><!-- fragment --> </div><p> But this is all actually already encoded as the keys of the substitution map. Doing the above would also mean that we need to manage the symbols in two places (here and when constructing the substitution map), which is annoying and a potential source of error if this material class is modified or extended. Since we're not interested in the values at this point, it is alright if the substitution map is filled with invalid data for the values associated with each key entry. So we'll simply create a fake substitution map, and extract the symbols from that. Note that any substitution map passed to the <code>optimizer</code> will have to, at the very least, contain entries for these symbols.</p>
<div class="fragment"><div class="line">optimizer.register_symbols(</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD_1_1Utilities.html#a373adeda1cf11d824bb41a679d061a3d">Differentiation::SD::Utilities::extract_symbols</a>(</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>({}, {}, 0)));</div></div><!-- fragment --><p>We then inform the optimizer of what values we want calculated, which in our situation encompasses all of the dependent variables (namely the energy density function and its various derivatives).</p>
<div class="fragment"><div class="line">optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);</div></div><!-- fragment --><p>The last step is to finalize the optimizer. With this call it will determine an equivalent code path that will evaluate all of the dependent functions at once, but with less computational cost than when evaluating the symbolic expression directly. Note: This is an expensive call, so we want execute it as few times as possible. We've done it in the constructor of our class, which achieves the goal of being called only once per class instance.</p>
<div class="fragment"><div class="line">  optimizer.optimize();</div><div class="line">}</div></div><!-- fragment --><p>Since the configuration of the <code>optimizer</code> was done up front, there's very little to do each time we want to compute kinetic variables or their linearization (derivatives).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">{</div></div><!-- fragment --><p>To update the internal history variable, we first need to compute a few fundamental quantities, which we've seen before. We can also ask the time discretizer for the time step size that was used to iterate from the previous time step to the current one.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C));</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C);</div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>Now we can update the (real valued) internal viscous deformation tensor, as per the definition given by the evolution law in conjunction with the chosen time discretization scheme.</p>
<div class="fragment"><div class="line">Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">      (Q_t1 + (delta_t / this-&gt;get_tau_v()) * std::pow(det_F, 2.0 / dim) *</div><div class="line">                C_inv);</div></div><!-- fragment --><p>Next we pass the optimizer the numeric values that we wish the independent variables, time step size and (implicit to this call), the constitutive parameters to represent.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> substitution_map = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(C, H, delta_t);</div></div><!-- fragment --><p>When making this next call, the call path used to (numerically) evaluate the dependent functions is quicker than dictionary substitution.</p>
<div class="fragment"><div class="line">  optimizer.substitute(substitution_map);</div><div class="line">}</div></div><!-- fragment --><p>Having called <code>update_internal_data()</code>, it is then valid to extract data from the optimizer. When doing the evaluation, we need the exact symbolic expressions of the data to extracted from the optimizer. The implication of this is that we needed to store the symbolic expressions of all dependent variables for the lifetime of the optimizer (naturally, the same is implied for the input variables).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(psi_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(B_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(S_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(BB_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(PP_sd);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> optimizer.evaluate(HH_sd);</div><div class="line">}</div></div><!-- fragment --><p>When moving forward in time, the "current" state of the internal variable instantaneously defines the state at the "previous" timestep. As such, we record value of history variable for use as the "past value" at the next time step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_end_of_timestep()</div><div class="line">{</div><div class="line">  Q_t1 = Q_t;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AmorecomplexexamplecontinuedParametersandhandderivedmaterialclasses"></a> </p><h3>A more complex example (continued): Parameters and hand-derived material classes</h3>
<p>Now that we've seen how the AD and SD frameworks can make light(er) work of defining these constitutive laws, we'll implement the equivalent classes by hand for the purpose of verification and to do some preliminary benchmarking of the frameworks versus a native implementation.</p>
<p>At the expense of the author's sanity, what is documented below (hopefully accurately) are the full definitions for the kinetic variables and their tangents, as well as some intermediate computations. Since the structure and design of the constitutive law classes has been outlined earlier, we'll gloss over it and simply delineate between the various stages of calculations in the <code>update_internal_data()</code> method definition. It should be easy enough to link the derivative calculations (with their moderately expressive variable names) to their documented definitions that appear in the class descriptions. We will, however, take the opportunity to present two different paradigms for implementing constitutive law classes. The second will provide more flexibility than the first (thereby making it more easily extensible, in the author's opinion) at the expense of some performance.</p>
<p><a class="anchor" id="Magnetoelasticconstitutivelawhandderived"></a> </p><h4>Magnetoelastic constitutive law (hand-derived)</h4>
<p>From the stored energy that, as mentioned earlier, is defined as </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) , \\ \text{det}(\mathbf{F}) = \sqrt{\text{det}(\mathbf{C})} \]
</p>
<p> for this magnetoelastic material, the first derivatives that correspond to the magnetic induction vector and total Piola-Kirchhoff stress tensor are </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{d \psi_{0}}{d \boldsymbol{\mathbb{H}}} = - \frac{1}{2} \mu_{e} \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] \frac{d f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\begin{align} \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{d \psi_{0} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} &amp;= \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} - 2 \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \right] + 4 \lambda_{e} \ln \left(\text{det}(\mathbf{F}) \right) \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} - \mu_{0} \mu_{r} \left[ \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} + \text{det}(\mathbf{F}) \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} \right] \\ &amp;= \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{I} - \mathbf{C}^{-1} \right] + 2 \lambda_{e} \ln \left(\text{det}(\mathbf{F}) \right) \mathbf{C}^{-1} - \mu_{0} \mu_{r} \left[ \frac{1}{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \mathbf{C}^{-1} - \text{det}(\mathbf{F}) \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{d f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} = \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \text{sech}^{2} \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \left[ \frac{4} {\left(h_{e}^{\text{sat}}\right)^{2}} \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} = \mathbf{I} \quad \text{(the second-order identity tensor)} \]
</p>
 <p class="formulaDsp">
\[ \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} = \frac{1}{2} \text{det}(\mathbf{F}) \mathbf{C}^{-1} \]
</p>
 <p class="formulaDsp">
\[ \frac{d C^{-1}_{ab}}{d C_{cd}} = - \text{sym} \left( C^{-1}_{ac} C^{-1}_{bd} \right) = -\frac{1}{2} \left[ C^{-1}_{ac} C^{-1}_{bd} + C^{-1}_{ad} C^{-1}_{bc} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} = - \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
<p> The use of the symmetry operator \(\text{sym} \left( \bullet \right)\) in the one derivation above helps to ensure that the resulting rank-4 tensor, which holds minor symmetries due to the symmetry of \(\mathbf{C}\), still maps rank-2 symmetric tensors to rank-2 symmetric tensors. See the <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> class documentation and the introduction to <a class="el" href="step_44.html">step-44</a> and for further explanation as to what symmetry means in the context of fourth-order tensors.</p>
<p>The linearization of each of the kinematic variables with respect to their arguments are </p><p class="formulaDsp">
\[ \mathbb{D} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} = - \frac{1}{2} \mu_{e} \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] \frac{d^{2} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \mathbf{C}^{-1} \]
</p>
 <p class="formulaDsp">
\begin{align} \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} &amp;= - \mu_{e} \left[ \frac{d\,\text{tr}(\mathbf{C})}{d \mathbf{C}} - 2 \frac{1}{\text{det}(\mathbf{F})} \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \right] \otimes \frac{d f_{\mu_{e} \left( \boldsymbol{\mathbb{H}} \right)}}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \left[ \frac{d\,\text{det}(\mathbf{F})}{d \mathbf{C}} \otimes \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \boldsymbol{\mathbb{H}}} \right] + \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} \\ &amp;= - \mu_{e} \left[ \mathbf{I} - \mathbf{C}^{-1} \right] \otimes \frac{d f_{\mu_{e} \left( \boldsymbol{\mathbb{H}} \right)}}{d \boldsymbol{\mathbb{H}}} + \mu_{0} \mu_{r} \left[ \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] + \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C} \otimes \mathbf{C} \boldsymbol{\mathbb{H}}} \end{align}
</p>
 <p class="formulaDsp">
\begin{align} \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} &amp;= 2 \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] + 4 \lambda_{e} \left[ \mathbf{C}^{-1} \otimes \left[ \frac{1}{\text{det}(\mathbf{F})} \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} \right] + \ln \left(\text{det}(\mathbf{F}) \right) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;- \mu_{0} \mu_{r} \left[ \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \mathbf{C}} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \mathbf{C}^{-1} \otimes \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{0} \mu_{r} \left[ \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \otimes \frac{d \, \text{det}(\mathbf{F})}{d \mathbf{C}} - \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} \right] \\ &amp;= 2 \mu_{e} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] + 4 \lambda_{e} \left[ \frac{1}{2} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \ln \left(\text{det}(\mathbf{F}) \right) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;- \mu_{0} \mu_{r} \left[ - \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] + \frac{1}{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \text{det}(\mathbf{F}) \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{0} \mu_{r} \left[ \frac{1}{2} \text{det}(\mathbf{F}) \left[ \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \right] \otimes \mathbf{C}^{-1} - \text{det}(\mathbf{F}) \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{d^{2} f_{\mu_{e}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} = -2 \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \text{sech}^{2} \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \left[ \frac{4} {\left(h_{e}^{\text{sat}}\right)^{2}} \mathbf{I} \right] \]
</p>
 <p class="formulaDsp">
\[ \frac{d \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]}{d \boldsymbol{\mathbb{H}}} = 2 \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \]
</p>
 <p class="formulaDsp">
\[ \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \boldsymbol{\mathbb{H}}} \Rightarrow \frac{d^{2} \left[ \mathbb{H}_{e} C^{-1}_{ef} \mathbb{H}_{f} \right]}{d C_{ab} d \mathbb{H}_{c}} = - C^{-1}_{ac} C^{-1}_{be} \mathbb{H}_{e} - C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{bc} \]
</p>
 <p class="formulaDsp">
\begin{align} \frac{d^{2} \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}}\right]}{d \mathbf{C} \otimes d \mathbf{C}} &amp;= -\frac{d \left[\left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \otimes \left[ \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right]\right]}{d \mathbf{C}} \\ \Rightarrow \frac{d^{2} \left[ \mathbb{H}_{e} C^{-1}_{ef} \mathbb{H}_{f} \right]}{d C_{ab} d C_{cd}} &amp;= \text{sym} \left( C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{cf} \mathbb{H}_{f} C^{-1}_{bd} + C^{-1}_{ce} \mathbb{H}_{e} C^{-1}_{bf} \mathbb{H}_{f} C^{-1}_{ad} \right) \\ &amp;= \frac{1}{2} \left[ C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{cf} \mathbb{H}_{f} C^{-1}_{bd} + C^{-1}_{ae} \mathbb{H}_{e} C^{-1}_{df} \mathbb{H}_{f} C^{-1}_{bc} + C^{-1}_{ce} \mathbb{H}_{e} C^{-1}_{bf} \mathbb{H}_{f} C^{-1}_{ad} + C^{-1}_{be} \mathbb{H}_{e} C^{-1}_{df} \mathbb{H}_{f} C^{-1}_{ac} \right] \end{align}
</p>
<p>Well, that escalated quickly &ndash; although the the definition of \(\psi_{0}\) and \(f_{\mu_e}\) might have given some hints that the calculating the kinetic fields and their linearization would take some effort, it is likely that there's a little more complexity to the final definitions that perhaps initially thought. Knowing what we now do, it's probably fair to say that we really do not want to compute first and second derivatives of these functions with respect to their arguments &ndash; regardless of well we did in calculus classes, or how good a programmer we may be.</p>
<p>In the class method definition where these are ultimately implemented, we've composed these calculations slightly differently. Some intermediate steps are also retained to give another perspective of how to systematically compute the derivatives. Additionally, some calculations are decomposed less or further to reuse some of the intermediate values and, hopefully, aid the reader to follow the derivative operations.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoelastic_Constitutive_Law final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoelastic_Constitutive_Law(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span>                  psi;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoelastic_Constitutive_Law&lt;dim&gt;::Magnetoelastic_Constitutive_Law(</div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , psi(0.0)</div><div class="line">{}</div></div><!-- fragment --><p>For this class's update method, we'll simply precompute a collection of intermediate values (for function evaluations, derivative calculations, and the like) and "manually" arrange them in the order that's required to maximize their reuse. This means that we have to manage this ourselves, and decide what values must be compute before others, all while keeping some semblance of order or structure in the code itself. It's effective, but perhaps a little tedious. It also doesn't do too much to help future extension of the class, because all of these values remain local to this single method.</p>
<p>Interestingly, this basic technique of precomputing intermediate expressions that are used in more than one place has a name: <a href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">common subexpression elimination (CSE)</a>. It is a strategy used by Computer Algebra Systems to reduce the computational expense when they are tasked with evaluating similar expressions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(C));</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(C);</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div></div><!-- fragment --><p>The saturation function for the magneto-elastic energy.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> two_h_dot_h_div_h_sat_squ =</div><div class="line">  (2.0 * H * H) / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat());</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(two_h_dot_h_div_h_sat_squ);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e =</div><div class="line">  1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">          tanh_two_h_dot_h_div_h_sat_squ;</div></div><!-- fragment --><p>The first derivative of the saturation function, noting that \(\frac{d \tanh(x)}{dx} = \text{sech}^{2}(x)\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> dtanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(two_h_dot_h_div_h_sat_squ), 2.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dtwo_h_dot_h_div_h_sat_squ_dH =</div><div class="line">  2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) * H;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH =</div><div class="line">  (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">  (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH);</div></div><!-- fragment --><p>The second derivative of saturation function, noting that \(\frac{d \text{sech}^{2}(x)}{dx} = -2 \tanh(x) \text{sech}^{2}(x)\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> d2tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">  -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2two_h_dot_h_div_h_sat_squ_dH_dH =</div><div class="line">  2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) *</div><div class="line">  <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">  (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">  (d2tanh_two_h_dot_h_div_h_sat_squ *</div><div class="line">     <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dtwo_h_dot_h_div_h_sat_squ_dH,</div><div class="line">                              dtwo_h_dot_h_div_h_sat_squ_dH)) +</div><div class="line">   dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);</div></div><!-- fragment --><p>Some intermediate quantities attained directly from the field / kinematic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         log_det_F         = <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         tr_C              = <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(C);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H       = C_inv * H;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         H_dot_C_inv_dot_H = H * C_inv_dot_H;</div></div><!-- fragment --><p>First derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d_tr_C_dC =</div><div class="line">  <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> ddet_F_dC     = 0.5 * det_F * C_inv;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dlog_det_F_dC = 0.5 * C_inv;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dC_inv_dC;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">        dC_inv_dC[A][B][C][D] -=               </div><div class="line">          0.5 * (C_inv[A][C] * C_inv[B][D]     </div><div class="line">                 + C_inv[A][D] * C_inv[B][C]); </div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dH_dot_C_inv_dot_H_dC =</div><div class="line">  -<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H));</div></div><!-- fragment --><p>Second derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2det_F_dC_dC =</div><div class="line">  0.5 * (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv, ddet_F_dC) + det_F * dC_inv_dC);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">      d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=</div><div class="line">        C_inv[A][C] * C_inv_dot_H[B] + </div><div class="line">        C_inv_dot_H[A] * C_inv[B][C];  </div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">        d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">          0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                 C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                 C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +</div><div class="line">                 C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);</div></div><!-- fragment --><p>The stored energy density function.</p>
<div class="fragment"><div class="line">psi =</div><div class="line">  (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">    (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">  this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F)) -</div><div class="line">  (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div></div><!-- fragment --><p>The kinetic quantities.</p>
<div class="fragment"><div class="line">B = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">      df_mu_e_dH </div><div class="line">    + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">        dH_dot_C_inv_dot_H_dH; </div><div class="line"></div><div class="line">S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                        </div><div class="line">      (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              </div><div class="line">    + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) </div><div class="line">    - 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *            </div><div class="line">        (H_dot_C_inv_dot_H * ddet_F_dC                               </div><div class="line">         + det_F * dH_dot_C_inv_dot_H_dC);                           </div></div><!-- fragment --><p>The linearization of the kinetic quantities.</p>
<div class="fragment"><div class="line">  BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * </div><div class="line">         d2f_mu_e_dH_dH                                             </div><div class="line">       + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">           d2H_dot_C_inv_dot_H_dH_dH; </div><div class="line"></div><div class="line">  PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *                                  </div><div class="line">         <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   </div><div class="line">                       df_mu_e_dH)                                        </div><div class="line">       +                                                                  </div><div class="line">       2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">         (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) </div><div class="line">          + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           </div><div class="line"></div><div class="line">  HH =</div><div class="line">    4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">    + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">        (2.0 * <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">         + 2.0 * log_det_F * d2log_det_F_dC_dC)                          </div><div class="line">    - 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">        (H_dot_C_inv_dot_H * d2det_F_dC_dC                               </div><div class="line">         + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               </div><div class="line">         + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               </div><div class="line">         + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> psi;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> B;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> S;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> BB;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> PP;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> HH;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Magnetoviscoelasticconstitutivelawhandderived"></a> </p><h4>Magneto-viscoelastic constitutive law (hand-derived)</h4>
<p>As mentioned before, the free energy density function for the magneto-viscoelastic material with one dissipative mechanism that we'll be considering is defined as </p><p class="formulaDsp">
\[ \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \]
</p>
 <p class="formulaDsp">
\[ \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{e} f_{\mu_{e}^{ME}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \text{tr}(\mathbf{C}) - d - 2 \ln (\text{det}(\mathbf{F})) \right] + \lambda_{e} \ln^{2} \left(\text{det}(\mathbf{F}) \right) - \frac{1}{2} \mu_{0} \mu_{r} \text{det}(\mathbf{F}) \left[ \boldsymbol{\mathbb{H}} \cdot \mathbf{C}^{-1} \cdot \boldsymbol{\mathbb{H}} \right] \]
</p>
 <p class="formulaDsp">
\[ \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{1}{2} \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \]
</p>
<p> with </p><p class="formulaDsp">
\[ f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{e}^{\infty}}{\mu_{e}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{e}^{\text{sat}}\right)^{2}} \right) \]
</p>
 <p class="formulaDsp">
\[ f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right) = 1 + \left[ \frac{\mu_{v}^{\infty}}{\mu_{v}} - 1 \right] \tanh \left( 2 \frac{\boldsymbol{\mathbb{H}} \cdot \boldsymbol{\mathbb{H}}} {\left(h_{v}^{\text{sat}}\right)^{2}} \right) \]
</p>
<p> and the evolution law </p><p class="formulaDsp">
\[ \dot{\mathbf{C}}_{v} \left( \mathbf{C} \right) = \frac{1}{\tau} \left[ \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}\right]^{-1} - \mathbf{C}_{v} \right] \]
</p>
<p> that itself is parameterized in terms of \(\mathbf{C}\). By design, the magnetoelastic part of the energy \(\psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)\) is identical to that of the magnetoelastic material presented earlier. So, for the derivatives of the various contributions stemming from this part of the energy, please refer to the previous section. We'll continue to highlight the specific contributions from those terms by superscripting the salient terms with \(ME\), while contributions from the magneto-viscoelastic component are superscripted with \(MVE\). Furthermore, the magnetic saturation function \(f_{\mu_{v}}^{MVE} \left( \boldsymbol{\mathbb{H}} \right)\) for the damping term has the identical form as that of the elastic term (i.e., \(f_{\mu_{e}}^{ME} \left( \boldsymbol{\mathbb{H}} \right)\) ), and so the structure of its derivatives are identical to that seen before; the only change is for the three constitutive parameters that are now associated with the viscous shear modulus \(\mu_{v}\) rather than the elastic shear modulus \(\mu_{e}\).</p>
<p>For this magneto-viscoelastic material, the first derivatives that correspond to the magnetic induction vector and total Piola-Kirchhoff stress tensor are </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq - \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \Big\vert_{\mathbf{C}, \mathbf{C}_{v}} \equiv \boldsymbol{\mathbb{B}}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \boldsymbol{\mathbb{B}}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} - \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) \dealcoloneq 2 \frac{\partial \psi_{0} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \Big\vert_{\mathbf{C}_{v}, \boldsymbol{\mathbb{H}}} \equiv \mathbf{S}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathbf{S}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \psi_{0}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right)}{d \mathbf{C}} + 2 \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \]
</p>
<p> with the viscous contributions being </p><p class="formulaDsp">
\[ \boldsymbol{\mathbb{B}}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \Big\vert_{\mathbf{C}, \mathbf{C}_{v}} = - \frac{1}{2} \mu_{v} \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \frac{\partial f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathbf{S}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{\partial \psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right)}{\partial \mathbf{C}} \Big\vert_{\mathbf{C}_{v}, \boldsymbol{\mathbb{H}}} = \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \right] \]
</p>
<p> and with </p><p class="formulaDsp">
\[ \frac{\partial f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}}} \equiv \frac{d f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} . \]
</p>
<p> The time-discretized evolution law, </p><p class="formulaDsp">
\[ \mathbf{C}_{v}^{(t)} \left( \mathbf{C} \right) = \frac{1}{1 + \frac{\Delta t}{\tau_{v}}} \left[ \mathbf{C}_{v}^{(t-1)} + \frac{\Delta t}{\tau_{v}} \left[\left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right]^{-1} \right] \]
</p>
<p> will also dictate how the linearization of the internal variable with respect to the field variables is composed.</p>
<p>Observe that in order to attain the <em>correct</em> expressions for the magnetic induction vector and total Piola-Kirchhoff stress tensor for this dissipative material, we must adhere strictly to the outcome of applying the Coleman-Noll procedure: we must take <em>partial derivatives</em> of the free energy density function with respect to the field variables. (For our non-dissipative magnetoelastic material, taking either partial or total derivatives would have had the same result, so there was no need to draw your attention to this before.) The crucial part of the operation is to freeze the internal variable \(\mathbf{C}_{v}^{(t)} \left( \mathbf{C} \right)\) while computing the derivatives of \(\psi_{0}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v} \left( \mathbf{C} \right), \boldsymbol{\mathbb{H}} \right)\) with respect to \(\mathbf{C}\) &ndash; the dependence of \(\mathbf{C}_{v}^{(t)}\) on \(\mathbf{C}\) is not to be taken into account. When deciding whether to use AD or SD to perform this task the choice is clear &ndash; only the symbolic framework provides a mechanism to do this; as was mentioned before, AD can only return total derivatives so it is unsuitable for the task.</p>
<p>To wrap things up, we'll present the material tangents for this rate-dependent coupled material. The linearization of both kinetic variables with respect to their arguments are </p><p class="formulaDsp">
\[ \mathbb{D} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}}{d \boldsymbol{\mathbb{H}}} \equiv \mathbb{D}^{ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathbb{D}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = \frac{d \boldsymbol{\mathbb{B}}^{ME}}{d \boldsymbol{\mathbb{H}}} + \frac{d \boldsymbol{\mathbb{B}}^{MVE}}{d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathfrak{P}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}}}{d \boldsymbol{\mathbb{H}}} \equiv \mathfrak{P}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathfrak{P}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{d \mathbf{S}^{\text{tot}, ME}}{d \boldsymbol{\mathbb{H}}} - \frac{d \mathbf{S}^{\text{tot}, MVE}}{d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathcal{H}^{\text{tot}} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}}}{d \mathbf{C}} \equiv \mathcal{H}^{\text{tot}, ME} \left( \mathbf{C}, \boldsymbol{\mathbb{H}} \right) + \mathcal{H}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = 2 \frac{d \mathbf{S}^{\text{tot}, ME}}{d \mathbf{C}} + 2 \frac{d \mathbf{S}^{\text{tot}, MVE}}{d \mathbf{C}} \]
</p>
<p> where the tangents for the viscous contributions are </p><p class="formulaDsp">
\[ \mathbb{D}^{MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \frac{1}{2} \mu_{v} \left[ \mathbf{C}_{v} : \left[ \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C} \right] - d - \ln\left( \text{det}\left(\mathbf{C}_{v}\right) \right) \right] \frac{\partial^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\[ \mathfrak{P}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) = - \mu_{v} \left[ \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \right] \otimes \frac{d f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}}} \]
</p>
 <p class="formulaDsp">
\begin{align} \mathcal{H}^{\text{tot}, MVE} \left( \mathbf{C}, \mathbf{C}_{v}, \boldsymbol{\mathbb{H}} \right) &amp;= 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \right] \otimes \left[ \mathbf{C}_{v} + \mathbf{C} : \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ \mathbf{C}_{v} : \mathbf{C} \right] \left[ \frac{1}{d^{2}} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} - \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] \\ &amp;+ 2 \mu_{v} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right) \left[ -\frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \mathbf{C}_{v} \otimes \mathbf{C}^{-1} + \left[\text{det}\left(\mathbf{F}\right)\right]^{-\frac{2}{d}} \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \right] \end{align}
</p>
<p> with </p><p class="formulaDsp">
\[ \frac{\partial^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{\partial \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \equiv \frac{d^{2} f_{\mu_{v}^{MVE}} \left( \boldsymbol{\mathbb{H}} \right)}{d \boldsymbol{\mathbb{H}} \otimes d \boldsymbol{\mathbb{H}}} \]
</p>
<p> and, from the evolution law, </p><p class="formulaDsp">
\[ \frac{d \mathbf{C}_{v}}{d \mathbf{C}} \equiv \frac{d \mathbf{C}_{v}^{(t)}}{d \mathbf{C}} = \frac{\frac{\Delta t}{\tau_{v}} }{1 + \frac{\Delta t}{\tau_{v}}} \left[ \frac{1}{d} \left[\text{det}\left(\mathbf{F}\right)\right]^{\frac{2}{d}} \mathbf{C}^{-1} \otimes \mathbf{C}^{-1} + \left[\text{det}\left(\mathbf{F}\right)\right]^{\frac{2}{d}} \frac{d \mathbf{C}^{-1}}{d \mathbf{C}} \right] . \]
</p>
<p> Notice that just the last term of \(\mathcal{H}^{\text{tot}, MVE}\) contains the tangent of the internal variable. The linearization of this particular evolution law is linear. For an example of a nonlinear evolution law, for which this linearization must be solved for in an iterative manner, see <b>[Koprowski-Theiss2011a]</b>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law final</div><div class="line">  : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Magnetoviscoelastic_Constitutive_Law(</div><div class="line">    <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>                  psi;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div></div><!-- fragment --><p>A data structure that is used to store all intermediate calculations. We'll see shortly precisely how this can be leveraged to make the part of the code where we actually perform calculations clean and easy (well, at least easier) to follow and maintain. But for now, we can say that it will allow us to move the parts of the code where we compute the derivatives of intermediate quantities away from where they are used.</p>
<div class="fragment"><div class="line"><span class="keyword">mutable</span> <a class="code" href="classGeneralDataStorage.html">GeneralDataStorage</a> cache;</div></div><!-- fragment --><p>The next two functions are used to update the state of the field and internal variables, and will be called before we perform any detailed calculations.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_primary_variables(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> update_internal_variable(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time);</div></div><!-- fragment --><p>The remainder of the class interface is dedicated to methods that are used to compute the components required to calculate the free energy density function, and all of its derivatives:</p>
<p>The kinematic, or field, variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C() <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> get_f_mu(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the first derivative of saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_df_mu_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>A generalized formulation for the second derivative of saturation function, with the required constitutive parameters passed as arguments to each function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_d2f_mu_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Intermediate quantities attained directly from the field / kinematic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C_inv() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_log_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_trace_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_H_dot_C_inv_dot_H() <span class="keyword">const</span>;</div></div><!-- fragment --><p>First derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_dC_inv_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d_tr_C_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_ddet_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dlog_det_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dC() <span class="keyword">const</span>;</div></div><!-- fragment --><p>Derivative of internal variable with respect to field variables. Notice that we only need this one derivative of the internal variable, as this variable is only differentiated as part of the linearization of the kinetic variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">get_dQ_t_dC(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Second derivatives of the intermediate quantities.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2log_det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dH_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dC() <span class="keyword">const</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::Magnetoviscoelastic_Constitutive_Law(<span class="keyword">const</span> ConstitutiveParameters</div><div class="line">                                               &amp;constitutive_parameters)</div><div class="line">  : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">      constitutive_parameters)</div><div class="line">  , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">  , psi(0.0)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">{</div></div><!-- fragment --><p>Record the applied deformation state as well as the magnetic load. Thereafter, update internal (viscous) variable based on new deformation state.</p>
<div class="fragment"><div class="line">set_primary_variables(C, H);</div><div class="line">update_internal_variable(time);</div></div><!-- fragment --><p>Get the values for the elastic and viscous saturation function based on the current magnetic field...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e = get_f_mu(this-&gt;get_mu_e(),</div><div class="line">                               this-&gt;get_mu_e_inf(),</div><div class="line">                               this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_v = get_f_mu(this-&gt;get_mu_v(),</div><div class="line">                               this-&gt;get_mu_v_inf(),</div><div class="line">                               this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>... as well as their first derivatives...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH = get_df_mu_dH(this-&gt;get_mu_e(),</div><div class="line">                                               this-&gt;get_mu_e_inf(),</div><div class="line">                                               this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_v_dH = get_df_mu_dH(this-&gt;get_mu_v(),</div><div class="line">                                               this-&gt;get_mu_v_inf(),</div><div class="line">                                               this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>... and their second derivatives.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">  get_d2f_mu_dH_dH(this-&gt;get_mu_e(),</div><div class="line">                   this-&gt;get_mu_e_inf(),</div><div class="line">                   this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_v_dH_dH =</div><div class="line">  get_d2f_mu_dH_dH(this-&gt;get_mu_v(),</div><div class="line">                   this-&gt;get_mu_v_inf(),</div><div class="line">                   this-&gt;get_mu_v_h_sat());</div></div><!-- fragment --><p>Intermediate quantities. Note that, since we're fetching these values from a cache that has a lifetime that outlasts this function call, we can alias the result rather than copying the value from the cache.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;                 det_F = get_det_F();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;log_det_F         = get_log_det_F();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;tr_C              = get_trace_C();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();</div></div><!-- fragment --><p>First derivatives of intermediate values, as well as the that of the internal variable with respect to the right Cauchy-Green deformation tensor.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d_tr_C_dC     = get_d_tr_C_dC();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;ddet_F_dC     = get_ddet_F_dC();</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dlog_det_F_dC = get_dlog_det_F_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;dQ_t_dC = get_dQ_t_dC(time);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dC =</div><div class="line">  get_dH_dot_C_inv_dot_H_dC();</div></div><!-- fragment --><p>Second derivatives of intermediate values.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2log_det_F_dC_dC =</div><div class="line">  get_d2log_det_F_dC_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2det_F_dC_dC = get_d2det_F_dC_dC();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dH_dH =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dH_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dH =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dC_dH();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dC =</div><div class="line">  get_d2H_dot_C_inv_dot_H_dC_dC();</div></div><!-- fragment --><p>Since the definitions of the linearizations become particularly lengthy, we'll decompose the free energy density function into three additive components:</p><ul>
<li>the "Neo-Hookean"-like term,</li>
<li>the rate-dependent term, and</li>
<li>the term that resembles that of the energy stored in the magnetic field.</li>
</ul>
<p>To remain consistent, each of these contributions will be individually added to the variables that we want to compute in that same order.</p>
<p>So, first of all this is the energy density function itself:</p>
<div class="fragment"><div class="line">psi = (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">        (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">      this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F));</div><div class="line">psi += (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">       (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">        <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t)));</div><div class="line">psi -=</div><div class="line">  (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div></div><!-- fragment --><p>... followed by the magnetic induction vector and Piola-Kirchhoff stress:</p>
<div class="fragment"><div class="line">B =</div><div class="line">  -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;</div><div class="line">B -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">     (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">      <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t))) *</div><div class="line">     df_mu_v_dH;</div><div class="line">B += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">     dH_dot_C_inv_dot_H_dH;</div><div class="line"></div><div class="line">S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                         </div><div class="line">      (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               </div><div class="line">    + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); </div><div class="line">S += 2.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">     ((Q_t * C) *</div><div class="line">        ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) +</div><div class="line">      std::pow(det_F, -2.0 / dim) * Q_t);                <span class="comment">// dC/dC = II</span></div><div class="line">S -= 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">     (H_dot_C_inv_dot_H * ddet_F_dC                      </div><div class="line">      + det_F * dH_dot_C_inv_dot_H_dC);                  </div></div><!-- fragment --><p>... and lastly the tangents due to the linearization of the kinetic variables.</p>
<div class="fragment"><div class="line">BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">     d2f_mu_e_dH_dH;</div><div class="line">BB -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">      (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">       <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(Q_t))) *</div><div class="line">      d2f_mu_v_dH_dH;</div><div class="line">BB += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">      d2H_dot_C_inv_dot_H_dH_dH;</div><div class="line"></div><div class="line">PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *</div><div class="line">     <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),</div><div class="line">                   df_mu_e_dH);</div><div class="line">PP -= 2.0 * (0.5 * this-&gt;get_mu_v()) *</div><div class="line">      <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>((Q_t * C) *</div><div class="line">                                     ((-2.0 / dim) *</div><div class="line">                                      std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                                      ddet_F_dC) +</div><div class="line">                                   std::pow(det_F, -2.0 / dim) * Q_t),</div><div class="line">                    df_mu_v_dH);</div><div class="line">PP += 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *</div><div class="line">      (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +</div><div class="line">       det_F * d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line"></div><div class="line">HH =</div><div class="line">  4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">  + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">      (2.0 * <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">       + 2.0 * log_det_F * d2log_det_F_dC_dC);                         </div><div class="line">HH += 4.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">      (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                       ddet_F_dC,</div><div class="line">                     C * dQ_t_dC + Q_t) +</div><div class="line">       (Q_t * <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>) *</div><div class="line">         (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC,</div><div class="line">                        (-2.0 / dim) * (-2.0 / dim - 1.0) *</div><div class="line">                          std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +</div><div class="line">          ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">           d2det_F_dC_dC)) +</div><div class="line">       <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Q_t,</div><div class="line">                     (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                       ddet_F_dC) +</div><div class="line">       <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, -2.0 / dim) * dQ_t_dC);</div><div class="line">HH -= 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">      (H_dot_C_inv_dot_H * d2det_F_dC_dC                  </div><div class="line">       + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  </div><div class="line">       + <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  </div><div class="line">       + det_F * d2H_dot_C_inv_dot_H_dC_dC);              </div></div><!-- fragment --><p>Now that we're done using all of those temporary variables stored in our cache, we can clear it out to free up some memory.</p>
<div class="fragment"><div class="line">  cache.reset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> psi;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> B;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> S;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> BB;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> PP;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> HH;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_end_of_timestep()</div><div class="line">{</div><div class="line">  Q_t1 = Q_t;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_variable(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">  Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">        (Q_t1 + (delta_t / this-&gt;get_tau_v()) *</div><div class="line">                  std::pow(get_det_F(), 2.0 / dim) * get_C_inv());</div><div class="line">}</div></div><!-- fragment --><p>The next few functions implement the generalized formulation for the saturation function, as well as its various derivatives.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_two_h_dot_h_div_h_sat_squ(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;H = get_H();</div><div class="line">  <span class="keywordflow">return</span> (2.0 * H * H) / (mu_h_sat * mu_h_sat);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));</div><div class="line">}</div></div><!-- fragment --><p>A scaling function that will cause the shear modulus to change (increase) under the influence of a magnetic field.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_f_mu(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1.0 +</div><div class="line">         (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">}</div></div><!-- fragment --><p>First derivative of scaling function</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),</div><div class="line">                  2.0);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_df_mu_dH(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">         (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">          get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">         get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">  dim&gt;::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *</div><div class="line">         <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2f_mu_dH_dH(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">         (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">            <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(</div><div class="line">              <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),</div><div class="line">                            get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +</div><div class="line">          get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">            get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));</div><div class="line">}</div></div><!-- fragment --><p>For the cached calculation approach that we've adopted for this material class, the root of all calculations are the field variables, and the immutable ancillary data such as the constitutive parameters and time step size. As such, we need to enter them into the cache in a different manner to the other variables, since they are inputs that are prescribed from outside the class itself. This function simply adds them to the cache directly from the input arguments, checking that there is no equivalent data there in the first place (we expect to call the <code>update_internal_data()</code> method only once per time step, or Newton iteration).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::set_primary_variables(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>Set value for \(\boldsymbol{\mathbb{H}}\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string name_H(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_H),</div><div class="line">       <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">         <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">cache.add_unique_copy(name_H, H);</div></div><!-- fragment --><p>Set value for \(\mathbf{C}\).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string name_C(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_C),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">           <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">  cache.add_unique_copy(name_C, C);</div><div class="line">}</div></div><!-- fragment --><p>After that, we can fetch them from the cache at any point in time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div></div><!-- fragment --><p>With the primary variables guaranteed to be in the cache when we need them, we can not compute all intermediate values (either directly, or indirectly) from them.</p>
<p>If the cache does not already store the value that we're looking for, then we quickly calculate it, store it in the cache and return the value just stored in the cache. That way we can return it as a reference and avoid copying the object. The same goes for any values that a compound function might depend on. Said another way, if there is a dependency chain of calculations that come before the one that we're currently interested in doing, then we're guaranteed to resolve the dependencies before we proceed with using any of those values. Although there is a cost to fetching data from the cache, the "resolved dependency" concept might be sufficiently convenient to make it worth looking past the extra cost. If these material laws are embedded within a finite element framework, then the added cost might not even be noticeable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;det_F&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(get_C()));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line">      cache.add_unique_copy(name, det_F);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      cache.add_unique_copy(name, <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(get_C()));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_log_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;log(det_F)&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, std::log(get_det_F()));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_trace_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;trace(C)&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(get_C()));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv_dot_H&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, get_C_inv() * get_H());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H_dot_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H_dot_C_inv_dot_H&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dQ_t_dC(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dQ_t_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>  delta_t = this-&gt;get_delta_t(time);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;det_F   = get_det_F();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dQ_t_dC =</div><div class="line">        (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">        (delta_t / this-&gt;get_tau_v()) *</div><div class="line">        ((2.0 / dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim - 1.0) *</div><div class="line">           <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">         <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim) * get_dC_inv_dC());</div><div class="line"></div><div class="line">      cache.add_unique_copy(name, dQ_t_dC);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dC_inv_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dC_inv_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>        dC_inv_dC;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              dC_inv_dC[A][B][C][D] -=               </div><div class="line">                0.5 * (C_inv[A][C] * C_inv[B][D]     </div><div class="line">                       + C_inv[A][D] * C_inv[B][C]); </div><div class="line"></div><div class="line">      cache.add_unique_copy(name, dC_inv_dC);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d_tr_C_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d_tr_C_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name,</div><div class="line">                          <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_ddet_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;ddet_F_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dlog_det_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dlog_det_F_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 0.5 * get_C_inv());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dH()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dH&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">      cache.add_unique_copy(</div><div class="line">        name, -<a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H)));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2log_det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2log_det_F_dC_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2det_F_dC_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name,</div><div class="line">                          0.5 *</div><div class="line">                            (<a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">                             get_det_F() * get_dC_inv_dC()));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dH_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dH_dH&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    cache.add_unique_copy(name, 2.0 * get_C_inv());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dH&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=</div><div class="line">              C_inv[A][C] * C_inv_dot_H[B] + </div><div class="line">              C_inv_dot_H[A] * C_inv[B][C];  </div><div class="line"></div><div class="line">      cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;3, dim&gt;&gt;(name);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dC()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dC&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">                0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                       C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);</div><div class="line"></div><div class="line">      cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Rheologicalexperimentparameters"></a> </p><h4>Rheological experiment parameters</h4>
<p>The <code>RheologicalExperimentParameters</code> class is used to drive the numerical experiments that are to be conducted on the coupled materials that we've implemented constitutive laws for.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RheologicalExperimentParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RheologicalExperimentParameters();</div></div><!-- fragment --><p>These are dimensions of the rheological specimen that is to be simulated. They, effectively, define the measurement point for our virtual experiment.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sample_radius = 0.01;</div><div class="line"><span class="keywordtype">double</span> sample_height = 0.001;</div></div><!-- fragment --><p>The three steady-state loading parameters are respectively</p><ul>
<li>the axial stretch,</li>
<li>the shear strain amplitude, and</li>
<li>the axial magnetic field strength.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> lambda_2 = 0.95;</div><div class="line"><span class="keywordtype">double</span> gamma_12 = 0.05;</div><div class="line"><span class="keywordtype">double</span> H_2      = 60.0e3;</div></div><!-- fragment --><p>Moreover, the parameters for the time-dependent rheological loading conditions are</p><ul>
<li>the loading cycle frequency,</li>
<li>the number of load cycles, and</li>
<li>the number of discrete timesteps per cycle.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>       frequency         = 1.0 / (2.0 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles          = 5;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps_per_cycle = 2500;</div></div><!-- fragment --><p>We also declare some self-explanatory parameters related to output data generated for the experiments conducted with rate-dependent and rate-independent materials.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span>        output_data_to_file = <span class="keyword">true</span>;</div><div class="line">std::string output_filename_rd =</div><div class="line">  <span class="stringliteral">&quot;experimental_results-rate_dependent.csv&quot;</span>;</div><div class="line">std::string output_filename_ri =</div><div class="line">  <span class="stringliteral">&quot;experimental_results-rate_independent.csv&quot;</span>;</div></div><!-- fragment --><p>The next few functions compute time-related parameters for the experiment...</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> start_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> end_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> delta_t() <span class="keyword">const</span>;</div></div><!-- fragment --><p>... while the following two prescribe the mechanical and magnetic loading at any given time...</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> get_H(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div></div><!-- fragment --><p>... and this last one outputs the status of the experiment to the console.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">bool</span> print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">RheologicalExperimentParameters::RheologicalExperimentParameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Rheological Experiment/&quot;</span>)</div><div class="line">{</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_radius);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_height);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Axial stretch&quot;</span>, lambda_2);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Shear strain amplitude&quot;</span>, gamma_12);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Axial magnetic field strength&quot;</span>, H_2);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Frequency&quot;</span>, frequency);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Number of loading cycles&quot;</span>, n_cycles);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Discretisation for each cycle&quot;</span>, n_steps_per_cycle);</div><div class="line"></div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output experimental results to file&quot;</span>, output_data_to_file);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output file name (rate dependent constitutive law)&quot;</span>,</div><div class="line">                output_filename_rd);</div><div class="line">  add_parameter(<span class="stringliteral">&quot;Output file name (rate independent constitutive law)&quot;</span>,</div><div class="line">                output_filename_ri);</div><div class="line"></div><div class="line">  parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> RheologicalExperimentParameters::start_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0.0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> RheologicalExperimentParameters::end_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> n_cycles / frequency;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> RheologicalExperimentParameters::delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">bool</span></div><div class="line">RheologicalExperimentParameters::print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;</div><div class="line">}</div></div><!-- fragment --><p>The applied magnetic field is always aligned with the axis of rotation of the rheometer's rotor.</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> RheologicalExperimentParameters::get_H(<span class="keyword">const</span> <span class="keywordtype">double</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>({0.0, 0.0, H_2});</div><div class="line">}</div></div><!-- fragment --><p>The applied deformation (gradient) is computed based on the geometry of the rheometer and the sample, the sampling point, and the experimental parameters. From the displacement profile documented in the introduction, the deformation gradient may be expressed in Cartesian coordinates as </p><p class="formulaDsp">
\[ \mathbf{F} = \begin{bmatrix} \frac{\cos\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\frac{\sin\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\tau R \sqrt{\lambda_{3}} \sin\left(\Theta + \alpha\right) \\ \frac{\sin\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; \frac{\cos\left(\alpha\right)}{\sqrt{\lambda_{3}}} &amp; -\tau R \sqrt{\lambda_{3}} \cos\left(\Theta + \alpha\right) \\ 0 &amp; 0 &amp; \lambda_{3} \end{bmatrix} \]
</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> RheologicalExperimentParameters::get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((sample_radius &gt; 0.0 &amp;&amp; sample_height &gt; 0.0),</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical sample dimensions&quot;</span>));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(lambda_2 &gt; 0.0,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical applied axial stretch&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> sqrt_lambda_2     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(lambda_2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_max =</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(std::tan(gamma_12) * sample_height /</div><div class="line">              sample_radius); <span class="comment">// Small strain approximation</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> A       = sample_radius * alpha_max;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> w       = 2.0 * numbers::PI * frequency; <span class="comment">// in rad /s</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> gamma_t = A * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(w * time);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tau_t =</div><div class="line">    gamma_t /</div><div class="line">    (sample_radius * sample_height); <span class="comment">// Torsion angle per unit length</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_t = tau_t * lambda_2 * sample_height;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">  F[0][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">  F[0][1] = -inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">  F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">  F[1][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">  F[1][1] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">  F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">  F[2][0] = 0.0;</div><div class="line">  F[2][1] = 0.0;</div><div class="line">  F[2][2] = lambda_2;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((F[0][0] &gt; 0) &amp;&amp; (F[1][1] &gt; 0) &amp;&amp; (F[2][2] &gt; 0),</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical deformation gradient component.&quot;</span>));</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(<a class="code" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a>(F) - 1.0) &lt; 1e-6,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian is not equal to unity.&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="RheologicalexperimentParallelplaterotationalrheometer"></a> </p><h4>Rheological experiment: Parallel plate rotational rheometer</h4>
<p>This is the function that will drive the numerical experiments.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> run_rheological_experiment(</div><div class="line">  <span class="keyword">const</span> RheologicalExperimentParameters &amp;experimental_parameters,</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    &amp;material_hand_calculated,</div><div class="line">  Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    &amp;               material_assisted_computation,</div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> &amp;     timer,</div><div class="line">  <span class="keyword">const</span> std::string filename)</div><div class="line">{</div></div><!-- fragment --><p>We can take the hand-implemented constitutive law and compare the results that we attain with it to those that we get using AD or SD. In this way, we can verify that they produce identical results (which indicates that either both implementations have a high probability of being correct, or that they're incorrect with identical flaws being present in both). Either way, it is a decent sanity check for the fully self-implemented variants and can certainly be used as a debugging strategy when differences between the results are detected).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> check_material_class_results =</div><div class="line">  [](</div><div class="line">    <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;to_verify,</div><div class="line">    <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;blessed,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-6) {</div><div class="line">    (void)to_verify;</div><div class="line">    (void)blessed;</div><div class="line">    (void)tol;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(std::abs(blessed.get_psi() - to_verify.get_psi()) &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for psi. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(std::abs(</div><div class="line">                        blessed.get_psi() - to_verify.get_psi()))));</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for B. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for S. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for BB. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for PP. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; tol,</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for HH. Error: &quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                        (blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">  };</div></div><!-- fragment --><p>We'll be outputting the constitutive response of the material to file for post-processing, so here we declare a <code>stream</code> that will act as a buffer for this output. We'll use a simple CSV format for the outputted results.</p>
<div class="fragment"><div class="line">std::ostringstream stream;</div><div class="line">stream</div><div class="line">  &lt;&lt; <span class="stringliteral">&quot;Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\n&quot;</span>;</div></div><!-- fragment --><p>Using the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> class, we iterate through each timestep using a fixed time step size.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(experimental_parameters.start_time(),</div><div class="line">                       experimental_parameters.end_time() +</div><div class="line">                         experimental_parameters.delta_t(),</div><div class="line">                       experimental_parameters.delta_t());</div><div class="line">     time.is_at_end() == <span class="keyword">false</span>;</div><div class="line">     time.advance_time())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (experimental_parameters.print_status(time.get_step_number()))</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep = &quot;</span> &lt;&lt; time.get_step_number()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; @ time = &quot;</span> &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;s.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>We fetch and compute the loading to be applied to the material at this time step...</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> H =</div><div class="line">  experimental_parameters.get_H(time.get_current_time());</div><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F =</div><div class="line">  experimental_parameters.get_F(time.get_current_time());</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C =</div><div class="line">  <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">Physics::Elasticity::Kinematics::C</a>(F);</div></div><!-- fragment --><p>... then we update the state of the materials...</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Hand calculated&quot;</span>);</div><div class="line">  material_hand_calculated.update_internal_data(C, H, time);</div><div class="line">  material_hand_calculated.update_end_of_timestep();</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assisted computation&quot;</span>);</div><div class="line">  material_assisted_computation.update_internal_data(C, H, time);</div><div class="line">  material_assisted_computation.update_end_of_timestep();</div><div class="line">}</div></div><!-- fragment --><p>... and test for discrepancies between the two.</p>
<div class="fragment"><div class="line">check_material_class_results(material_hand_calculated,</div><div class="line">                             material_assisted_computation);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">  {</div></div><!-- fragment --><p>The next thing that we will do is collect some results to post-process. All quantities are in the "current configuration" (rather than the "reference configuration", in which all quantities computed by the constitutive laws are framed).</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> h =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Covariant.html#ad438f09c3045e448805f62b27c2f8d29">Physics::Transformations::Covariant::push_forward</a>(H, F);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> b =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">          material_hand_calculated.get_B(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> sigma =</div><div class="line">        <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">          material_hand_calculated.get_S(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">      stream &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; h[2] &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; b[2]</div><div class="line">             &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; F[1][2] * 100.0 &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; sigma[1][2] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, we output the strain-stress and magnetic loading history to file.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">    {</div><div class="line">      std::ofstream output(filename);</div><div class="line">      output &lt;&lt; stream.str();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheCoupledConstitutiveLawsrunfunction"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">CoupledConstitutiveLaws::run()</a> function</h4>
<p>The purpose of this driver function is to read in all of the parameters from file and, based off of that, create a representative instance of each constitutive law and invoke the function that conducts a rheological experiment with it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ConstitutiveParameters          constitutive_parameters;</div><div class="line">  <span class="keyword">const</span> RheologicalExperimentParameters experimental_parameters;</div><div class="line"></div><div class="line">  std::string parameter_file;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">    parameter_file = argv[1];</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line">  <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div></div><!-- fragment --><p>We start the actual work by configuring and running the experiment using our rate-independent constitutive law. The automatically differentiable number type is hard-coded here, but with some clever templating it is possible to select which framework to use at run time (e.g., as selected through the parameter file). We'll simultaneously perform the experiments with the counterpary material law that was fully implemented by hand, and check what it computes against our assisted implementation.</p>
<div class="fragment"><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                    <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                    <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">  std::cout</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;Coupled magnetoelastic constitutive law using automatic differentiation.&quot;</span></div><div class="line">    &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"></div><div class="line">  Magnetoelastic_Constitutive_Law&lt;dim&gt; material(constitutive_parameters);</div><div class="line">  Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt; material_ad(</div><div class="line">    constitutive_parameters);</div><div class="line"></div><div class="line">  run_rheological_experiment(experimental_parameters,</div><div class="line">                             material,</div><div class="line">                             material_ad,</div><div class="line">                             timer,</div><div class="line">                             experimental_parameters.output_filename_ri);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Next we do the same for the rate-dependent constitutive law. The highest performance option is selected as default if SymEngine is set up to use the LLVM just-in-time compiler which (in conjunction with some aggressive compilation flags) produces the fastest code evaluation path of all of the available option. As a fall-back, the so called "lambda" optimizer (which only requires a C++11 compliant compiler) will be selected. At the same time, we'll ask the CAS to perform common subexpression elimination to minimize the number of intermediate calculations used during evaluation. We'll record how long it takes to execute the "initialization" step inside the constructor for the SD implementation, as this is where the abovementioned transformations occur.</p>
<div class="fragment"><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">        std::cout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Coupled magneto-viscoelastic constitutive law using symbolic differentiation.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_SYMENGINE_WITH_LLVM</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using LLVM optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba7c7d2b9e8389cc541dc5a615e05bcf1e">Differentiation::SD::OptimizerType::llvm</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a1ad0cce13bc606ad6742e9841ccdfe15">Differentiation::SD::OptimizationFlags::optimize_all</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using lambda optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">Differentiation::SD::OptimizerType::lambda</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a3df84265620315a025367510c90d0474">Differentiation::SD::OptimizationFlags::optimize_cse</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        Magnetoviscoelastic_Constitutive_Law&lt;dim&gt; material(</div><div class="line">          constitutive_parameters);</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Initialize symbolic CL&quot;</span>);</div><div class="line">        Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt; material_sd(</div><div class="line">          constitutive_parameters, optimizer_type, optimization_flags);</div><div class="line">        timer.<a class="code" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a>();</div><div class="line"></div><div class="line">        run_rheological_experiment(experimental_parameters,</div><div class="line">                                   material,</div><div class="line">                                   material_sd,</div><div class="line">                                   timer,</div><div class="line">                                   experimental_parameters.output_filename_rd);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace CoupledConstitutiveLaws</span></div><div class="line"></div><div class="line">} <span class="comment">// namespace Step71</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The main function only calls the driver functions for the two sets of examples that are to be executed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::SimpleExample::run</a>();</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::CoupledConstitutiveLaws::run</a>(argc, argv);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-71/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Introductoryexample"></a></p><h3>Introductory example</h3>
<p>第一个探索性的例子产生了以下输出。经核实，这三种实现方式产生的结果是相同的。</p>
<div class="fragment"><div class="line">&gt; ./step-71</div><div class="line">Simple example <span class="keyword">using</span> automatic differentiation...</div><div class="line">... all calculations are correct!</div><div class="line">Simple example <span class="keyword">using</span> symbolic differentiation.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --><p><a class="anchor" id="Constitutivemodelling"></a></p><h3>Constitutive modelling</h3>
<p>为了帮助总结虚拟实验本身的结果，下面是一些图表，显示了材料样品内选定位置的剪切应力，与剪切应变的关系。这些图表显示了在三种不同的磁载荷下的应力-应变曲线，以及（机械）载荷曲线的最后一个周期，当速率依赖型材料达到可重复（"稳态"）响应时。这些类型的图表通常被称为<a href="https://en.wikipedia.org/wiki/Lissajous_curve">Lissajous plots</a>。粘弹性材料的曲线所呈现的椭圆面积提供了某种衡量材料耗散能量多少的方法，其椭圆度表明粘性反应相对于弹性反应的相位变化。</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.lissajous_plot-me.png" width="400"/>
</div>
 <p>Lissajous plot for the magneto-elastic material. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-71.lissajous_plot-mve.png" width="400"/>
</div>
 <p>Lissajous plot for the magneto-viscoelastic material. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p>看到磁弹性材料的反应有一个与加载曲线相匹配的卸载曲线并不奇怪&ndash;毕竟该材料是非耗散性的。但在这里可以清楚地注意到，随着施加磁场的增加，曲线的梯度是如何增加的。沿着这条曲线任何一点的切线都与瞬时剪切模量有关，由于能量密度函数的定义方式，我们预计剪切模量会随着磁场强度的增加而增加。我们观察到磁-粘弹性材料的行为大致相同。由加载-卸载曲线追踪的椭圆的主轴有一个斜率，随着施加更大的磁载荷而增加。同时，材料耗散的能量也越多。</p>
<p>至于代码输出，这是打印到控制台的与磁弹性材料进行的流变学实验有关的部分的内容。</p>
<div class="fragment"><div class="line">Coupled magnetoelastic constitutive law <span class="keyword">using</span> automatic differentiation.</div><div class="line">Timestep = 0 @ time = 0s.</div><div class="line">Timestep = 125 @ time = 0.314159s.</div><div class="line">Timestep = 250 @ time = 0.628318s.</div><div class="line">Timestep = 375 @ time = 0.942477s.</div><div class="line">...</div><div class="line">Timestep = 12250 @ time = 30.7876s.</div><div class="line">Timestep = 12375 @ time = 31.1018s.</div><div class="line">Timestep = 12500 @ time = 31.4159s.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --><p>而这部分输出与用磁涡流材料进行的实验有关。</p>
<div class="fragment"><div class="line">Coupled magneto-viscoelastic constitutive law <span class="keyword">using</span> symbolic differentiation.</div><div class="line">Using LLVM optimizer.</div><div class="line">Timestep = 0 @ time = 0s.</div><div class="line">Timestep = 125 @ time = 0.314159s.</div><div class="line">Timestep = 250 @ time = 0.628318s.</div><div class="line">Timestep = 375 @ time = 0.942477s.</div><div class="line">...</div><div class="line">Timestep = 12250 @ time = 30.7876s.</div><div class="line">Timestep = 12375 @ time = 31.1018s.</div><div class="line">Timestep = 12500 @ time = 31.4159s.</div><div class="line">... all calculations are correct!</div></div><!-- fragment --><p>计时器的输出也被发射到控制台，因此我们可以比较进行手工计算和辅助计算所需的时间，并对使用AD和SD框架的开销有一些了解。下面是使用AD框架的磁弹性实验的时间，基于Trilinos库的Sacado组件。</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |       3.2s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |      3.02s |        95% |</div><div class="line">| Hand calculated                 |     12501 |    0.0464s |       1.5% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>关于使用自动微分进行的计算（作为提醒，这是使用Sacado库结合动态前向自动微分类型进行的两级微分），我们观察到辅助计算需要大约 \(65 \times\) 的时间来计算所需的数量。这看起来确实是一个相当大的开销，但是，正如介绍中提到的，这是否可以接受，完全是主观的，取决于环境的。在对导数进行必要的手工计算、验证其正确性、实现它们以及验证实现的正确性方面，你是否更看重计算机时间而不是人的时间？如果你开发的研究代码只在相对较少的实验中运行，你可能更看重自己的时间。如果你开发的是一个将在万核集群上反复运行数小时的生产代码，你的考虑可能就不同了。在任何情况下，AD方法的一个很好的特点是，当函数和类在标量类型上被模板化时，有 "滴入 "能力。这意味着开始使用它需要付出最小的努力。</p>
<p>相比之下，使用准时制（JIT）编译的符号代数实现的磁涡弹材料的时间表明，在初始化过程中付出一些不可忽视的代价，计算本身的执行效率要高得多。</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.34s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |     0.376s |        28% |</div><div class="line">| Hand calculated                 |     12501 |     0.368s |        27% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.466s |        35% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>由于初始化阶段很可能只需要在每个线程中执行一次，这个初始的昂贵阶段可以通过重复使用一个 <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> 实例来抵消。尽管与磁弹性构成法相比，磁弹性构成法有更多的条款需要计算，但它在执行动能变量和切线的计算方面仍然快了一个数量级。而与使用缓存方案的手工计算变量相比，计算时间几乎相等。因此，尽管使用符号框架需要在如何实现和操作符号表达方面进行范式转变，但它可以提供AD框架所缺乏的良好性能和灵活性。</p>
<p>在数据缓存这一点上，事实上，在用这种材料进行的数值实验中，与使用中间值的实现相比，磁涡流材料实现的数值缓存所增加的成本大约是 \(6\times\) ，在<code>update_internal_data()</code>中花费的时间增加。下面是删除缓存数据结构时为 "手工计算 "变体提取的时间比较样本输出。</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.01s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |     0.361s |        36% |</div><div class="line">| Hand calculated                 |     12501 |    0.0562s |       5.6% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.469s |        47% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>通过一些小的调整，我们可以很容易地测试批量优化器的不同优化方案。因此，让我们比较一下与 "LLVM "批处理优化器设置相关的计算费用和其他方案。下面是 "lambda "优化方法的时间报告（保留了CSE的使用）。</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      3.87s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |      3.12s |        81% |</div><div class="line">| Hand calculated                 |     12501 |     0.394s |        10% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.209s |       5.4% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>这里的主要观察结果是，与 "LLVM "方法相比，在 "辅助计算 "部分花费的时间要多一个数量级。</p>
<p>最后，我们将测试 "字典 "替换与CSE的结合情况。字典替换只是在本地CAS框架内进行了所有的评估，没有对底层数据结构进行任何转换。在这种情况下，只有使用缓存中间结果的CSE才能提供任何 "加速"。考虑到这一点，下面是这个选择的结果。</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |  1.54e+03s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assisted computation            |     12501 |  1.54e+03s |     1e+02% |</div><div class="line">| Hand calculated                 |     12501 |     0.563s |         0% |</div><div class="line">| Initialize symbolic CL          |         1 |     0.184s |         0% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>不用说，与其他两种方法相比，这些结果花了相当多的时间来产生......字典 "替换方法也许只适用于简单的表达式，或者当调用的数量足够少的时候。</p>
<p><a class="anchor" id="SowhichframeworkshouldIuse"></a></p><h1>So, which framework should I use?</h1>
<p>也许你已经相信这些工具有一些优点，并能对你有直接的帮助或用途。现在明显的问题是要使用哪一个。特别是在连续点水平上，你将使用这些框架来计算构成法的导数，我们可以说以下几点。</p>
<ul>
<li>自动区分可能提供了进入辅助区分世界的最简单的切入点。</li>
<li>考虑到一个构成框架的足够通用的实现，AD通常可以被用作内在标量类型的替代品，然后可以利用辅助类来计算一阶（以及可能的高阶）导数，只需付出最小的努力。</li>
<li>作为对上述观点的限定，"直接替换 "并不意味着你必须对这些数字所通过的算法不持争议态度。有可能在不经意间进行的操作，在进行区分时，会返回一个错误的结果。 所以这绝对是一个人应该注意的事情。 一个具体的例子。当计算一个张量的特征值时，如果该张量是对角线的，那么得到结果的捷径就是直接返回对角线条目（从输入张量中提取的）。就计算特征值本身而言，这是完全正确的，但是不通过算法来计算非对角线张量的特征值会产生意想不到的副作用，即特征值看起来（对AD框架而言）是完全相互脱钩的，它们的交叉敏感度没有被编码在返回的结果中。在进行微分时，导数张量的许多条目将被丢失。为了解决这个问题，我们必须确保使用标准的特征值求解算法，这样返回的特征值对彼此的敏感性就会在结果中得到编码。</li>
<li>涉及AD数字类型的计算可能很昂贵。随着微分运算顺序的增加，费用也会增加（有时相当可观）。这可能会被周围操作的计算复杂性所缓解（例如线性求解），但最终还是要看具体问题。</li>
<li>AD被限制在只需要总导数的情况下。如果一个微分运算需要相对于自变量的偏导，那么使用它是不合适的。</li>
<li>每个AD库都有自己的怪癖（说起来很悲哀，但根据作者的经验，是真的），所以可能需要一些试验和错误来找到合适的库和选择AD号来满足你的目的。这些 "怪癖 "的原因往往归结于库背后的整体理念（数据结构、模板元编程的使用等）以及导数计算的数学实现（例如，使用对数函数改变基础的结果操作可能会限制输入值的域&ndash;当然，细节都是对用户隐藏的）。 此外，一个库可能比另一个库能更快地计算出所需的结果，所以在这方面进行一些初步探索可能是有益的。</li>
<li>符号微分（好吧，一般来说，使用CAS）提供了最灵活的框架，可以进行辅助计算。</li>
<li>SD框架可以做AD框架能做的所有事情，还有一个好处是可以对何时进行某些操纵和操作进行低层次控制。</li>
<li>加速表达式的评估是可能的，与一些手工实现相比，有可能导致SD框架接近原生的性能（当然，这种比较取决于整个程序设计），但代价是初始优化调用。</li>
<li>巧妙地使用 <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> 可以将优化依赖表达式的昂贵调用的费用降到最低。 对 <a class="el" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer</a> 进行序列化的可能性，往往（但不总是）这种昂贵的调用可以做一次，然后在以后的模拟中重复使用。</li>
<li>例如，如果两个或更多的材料法只因其材料参数而不同，那么只要这些材料参数被认为是象征性的，就可以在它们之间共享一个批次优化器。这意味着你可以 "区分一次，在许多情况下评估"。</li>
<li>SD框架可以部分地被用作标量类型的 "直接替换"，但人们（至少）必须在它周围增加一些框架来执行值替换步骤，将符号类型转换为它们的数字对应物。</li>
<li>在一些专门的算法中可能无法使用SD数字。 例如，如果一个算法的退出点或代码分支是基于（符号）输入参数应该采取的一些具体的数值，那么显然这是不可能的。我们要么重新实现专门针对SD数字类型的算法（有点不方便，但经常是可能的，因为 <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> 类支持条件反射），要么必须使用创造性的手段来解决这个具体问题（例如，引入一个符号表达式来表示这个算法返回的结果，如果在要使用它的环境中是有意义的，也许可以将它声明为一个[符号函数]（https://dealii.org/developer/doxygen/deal.II/namespaceDifferentiation_1_1SD.html::a876041f6048705c7a8ad0855cdb1bd7a）。这以后可以用它的数值来替代，如果宣布为符号函数，那么它的递延导数也可以作为替代的结果纳入计算中。)</li>
<li>使用SD的最大缺点是，使用它需要一个范式的转变，人们必须以不同的方式来构建大多数问题，以便充分利用它。仔细考虑如何使用和重用数据结构也是让它有效工作的关键）。这可能意味着，人们需要对它进行一番玩耍，并建立起对典型操作顺序的理解，以及每一步在操作基础数据方面的具体作用。如果人们有时间和意愿这样做，那么使用这个工具的好处可能是巨大的。</li>
</ul>
<p><a class="anchor" id="Possibilitiesforextension"></a></p><h1>Possibilities for extension</h1>
<p>有几个合乎逻辑的方法可以扩展这个计划。</p>
<ul>
<li>也许最明显的扩展是实施和测试其他构成模型。 这可能仍然属于磁-机械耦合问题的范畴，也许可以考虑替代能量函数的 "Neo-Hookean "型弹性部分，改变耗散能量的构成法则（及其相关的演化法则），或者包括磁滞效应或这些材料试图模拟的复合聚合物的损坏模型。</li>
<li>当然，所实现的模型可以被修改或完全替换为专注于物理学其他方面的模型，如电活性聚合物、生物力学材料、弹塑性介质等。</li>
<li>对粘弹性演化法实施不同的时间微调方案。</li>
<li>与其直接从能量密度函数推导出一切，不如使用 <a class="el" href="classDifferentiation_1_1AD_1_1VectorFunction.html">Differentiation::AD::VectorFunction</a> 直接线性化动力学量。 这将意味着只需要一个可微分的自动微分的数字类型，并且肯定会大大改善性能。 这种方法也为耗散材料提供了机会，比如这里考虑的磁涡弹材料，可以与AD结合起来实现。这是因为线性化调用了因变量相对于场变量的总导数，这正是AD框架所能提供的。</li>
<li>调查使用其他可自动微分的数字类型和框架（如ADOL-C）。由于每个AD库都有自己的实现，选择使用哪个库可能会导致性能的提高，在最不幸的情况下，计算也会更加稳定。至少可以说，对于deal.II支持的AD库，结果的准确性应该基本不受这个决定的影响。</li>
<li>在有限元模拟中嵌入这些构成法则中的一个。</li>
</ul>
<p>如果不费吹灰之力，人们可以考虑重新编写非线性问题求解器，比如在步骤15中实现的使用AD或SD方法来计算牛顿矩阵的求解器。事实上，这在第72步中已经完成。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Jean-Paul Pelteret, 2021</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="general__data__storage_8h.html">deal.II/algorithms/general_data_storage.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numbers_8h.html">deal.II/base/numbers.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="symmetric__tensor_8h.html">deal.II/base/symmetric_tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="transformations_8h.html">deal.II/physics/transformations.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinematics_8h.html">deal.II/physics/elasticity/kinematics.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="standard__tensors_8h.html">deal.II/physics/elasticity/standard_tensors.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sd_8h.html">deal.II/differentiation/sd.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step71</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SimpleExample</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumberType&gt;</div><div class="line">    <a class="code" href="classNumberType.html">NumberType</a> f(<span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;x, <span class="keyword">const</span> <a class="code" href="classNumberType.html">NumberType</a> &amp;y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    run_and_verify_ad(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">    {</div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     dim = 1;</div><div class="line">      constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line">      <span class="keyword">using</span> ADHelper =</div><div class="line">        <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = 2;</div><div class="line"></div><div class="line">      ADHelper ad_helper(n_independent_variables);</div><div class="line">      <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">      ad_helper.register_independent_variables({x, y});</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; independent_variables_ad =</div><div class="line">        ad_helper.get_sensitive_variables();</div><div class="line">      <span class="keyword">const</span> ADNumberType &amp;x_ad = independent_variables_ad[0];</div><div class="line">      <span class="keyword">const</span> ADNumberType &amp;y_ad = independent_variables_ad[1];</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType f_ad = f(x_ad, y_ad);</div><div class="line"></div><div class="line"></div><div class="line">      ad_helper.register_dependent_variable(f_ad);</div><div class="line"></div><div class="line">      Vector&lt;double&gt;     Df(ad_helper.n_dependent_variables());</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2f(ad_helper.n_dependent_variables(),</div><div class="line">                             ad_helper.n_independent_variables());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_f = ad_helper.compute_value();</div><div class="line">      ad_helper.compute_gradient(Df);</div><div class="line">      ad_helper.compute_hessian(D2f);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                             std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx = Df[0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy = Df[1];</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx = D2f[0][0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy = D2f[0][1];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx = D2f[1][0];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy = D2f[1][1];</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(x != 0.0, <a class="code" href="group__Exceptions.html#ga2e959da7bfd82df428770c0339c377ba">ExcDivideByZero</a>());</div><div class="line">      <span class="keywordflow">return</span> y * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / (x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> df_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) / x;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -y * (2 * x * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(y / x) + y * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) /</div><div class="line">             (x * x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dx_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dx(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> (x * std::sin(y / x) + y * std::cos(y / x)) / (x * x * x);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> d2f_dy_dy(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> -(<a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(y / x)) / (x * x);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    run_and_verify_sd(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y, <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-12)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> x_sd(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> y_sd(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_sd = f(x_sd, y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dx_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> df_dy_sd = f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dx_sd =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dx_dy_sd =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dx_sd =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(x_sd);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> d2f_dy_dy_sd =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a>(y_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a> substitution_map =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">          std::pair&lt;Differentiation::SD::Expression, double&gt;{x_sd, x},</div><div class="line">          std::pair&lt;Differentiation::SD::Expression, double&gt;{y_sd, y});</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_f =</div><div class="line">        f_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(f(x, y) - computed_f) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Incorrect value computed for f. &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(f(x, y)) +</div><div class="line">                             std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                             std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                             <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_f)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dx =</div><div class="line">        df_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_df_dy =</div><div class="line">        df_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dx(x, y) - computed_df_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(df_dy(x, y) - computed_df_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for df/dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(df_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by AD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_df_dy)));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dx =</div><div class="line">        d2f_dx_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dx_dy =</div><div class="line">        d2f_dx_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dx =</div><div class="line">        d2f_dy_dx_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> computed_d2f_dy_dy =</div><div class="line">        d2f_dy_dy_sd.<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a>&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dx(x, y) - computed_d2f_dx_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dx_dy(x, y) - computed_d2f_dx_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dx_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dx_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dx_dy)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dx(x, y) - computed_d2f_dy_dx) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dx. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dx(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dx)));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(d2f_dy_dy(x, y) - computed_d2f_dy_dy) &lt; tol,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    std::string(<span class="stringliteral">&quot;Incorrect value computed for d2f/dy_dy. &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Hand-calculated value: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(d2f_dy_dy(x, y)) + std::string(<span class="stringliteral">&quot; ; &quot;</span>) +</div><div class="line">                    std::string(<span class="stringliteral">&quot;Value computed by SD: &quot;</span>) +</div><div class="line">                    <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(computed_d2f_dy_dy)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> x = 1.23;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> y = 0.91;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using automatic differentiation...&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      run_and_verify_ad(x, y);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Simple example using symbolic differentiation.&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      run_and_verify_sd(x, y);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace SimpleExample</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>CoupledConstitutiveLaws</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">class </span>ConstitutiveParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ConstitutiveParameters();</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_e       = 30.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_e_inf   = 250.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_e_h_sat = 212.2e3;</div><div class="line">      <span class="keywordtype">double</span> nu_e       = 0.49;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_v       = 20.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_v_inf   = 35.0e3;</div><div class="line">      <span class="keywordtype">double</span> mu_v_h_sat = 92.84e3;</div><div class="line">      <span class="keywordtype">double</span> tau_v      = 0.6;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> mu_r = 6.0;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    ConstitutiveParameters::ConstitutiveParameters()</div><div class="line">      : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Constitutive Parameters/&quot;</span>)</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Elastic shear modulus&quot;</span>, mu_e);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Elastic shear modulus at magnetic saturation&quot;</span>, mu_e_inf);</div><div class="line">      add_parameter(</div><div class="line">        <span class="stringliteral">&quot;Saturation magnetic field strength for elastic shear modulus&quot;</span>,</div><div class="line">        mu_e_h_sat);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Poisson ratio&quot;</span>, nu_e);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus&quot;</span>, mu_v);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Viscoelastic shear modulus at magnetic saturation&quot;</span>,</div><div class="line">                    mu_v_inf);</div><div class="line">      add_parameter(</div><div class="line">        <span class="stringliteral">&quot;Saturation magnetic field strength for viscoelastic shear modulus&quot;</span>,</div><div class="line">        mu_v_h_sat);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Characteristic relaxation time&quot;</span>, tau_v);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Relative magnetic permeability&quot;</span>, mu_r);</div><div class="line"></div><div class="line">      parse_parameters_call_back.connect([&amp;]() { initialized = <span class="keyword">true</span>; });</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Coupled_Magnetomechanical_Constitutive_Law_Base</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep()</div><div class="line">      {}</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_e_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_nu_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_lambda_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_kappa_e() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v_inf() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_v_h_sat() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_tau_v() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_mu_r() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">double</span> get_mu_0() <span class="keyword">const</span>;</div><div class="line">      <span class="keywordtype">double</span>           get_delta_t(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : constitutive_parameters(constitutive_parameters)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(get_kappa_e() &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e_inf;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_e_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_e_h_sat;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_nu_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.nu_e;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_lambda_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * get_mu_e() * get_nu_e() / (1.0 - 2.0 * get_nu_e());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_kappa_e()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (2.0 * get_mu_e() * (1.0 + get_nu_e())) /</div><div class="line">             (3.0 * (1.0 - 2.0 * get_nu_e()));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_inf()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v_inf;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_v_h_sat()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_v_h_sat;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_tau_v()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.tau_v;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_r()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> constitutive_parameters.mu_r;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    constexpr <span class="keywordtype">double</span></div><div class="line">    Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_mu_0()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 4.0 * numbers::PI * 1e-7;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;::get_delta_t(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> time.<a class="code" href="classDiscreteTime.html#a9bd02740b86e63bd84e29d39fce495dd">get_previous_step_size</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoelastic_Constitutive_Law_AD final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> ADHelper =</div><div class="line">        <a class="code" href="classDifferentiation_1_1AD_1_1ScalarFunction.html">Differentiation::AD::ScalarFunction&lt;dim, ADTypeCode, double&gt;</a>;</div><div class="line">      <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoelastic_Constitutive_Law_AD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>             H_components;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor&lt;2&gt;</a> C_components;</div><div class="line"></div><div class="line">      ADHelper ad_helper;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>             psi;</div><div class="line">      Vector&lt;double&gt;     Dpsi;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> D2psi;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::</div><div class="line">      Magnetoelastic_Constitutive_Law_AD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , H_components(0)</div><div class="line">      , C_components(Tensor&lt;1, dim&gt;::n_independent_components)</div><div class="line">      , ad_helper(Tensor&lt;1, dim&gt;::n_independent_components +</div><div class="line">                  SymmetricTensor&lt;2, dim&gt;::n_independent_components)</div><div class="line">      , psi(0.0)</div><div class="line">      , Dpsi(ad_helper.n_independent_variables())</div><div class="line">      , D2psi(ad_helper.n_independent_variables(),</div><div class="line">              ad_helper.n_independent_variables())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C) &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      ad_helper.reset();</div><div class="line"></div><div class="line">      ad_helper.register_independent_variable(H, H_components);</div><div class="line">      ad_helper.register_independent_variable(C, C_components);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, ADNumberType&gt;</a> H_ad =</div><div class="line">        ad_helper.get_sensitive_variables(H_components);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_ad =</div><div class="line">        ad_helper.get_sensitive_variables(C_components);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType det_F_ad = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C_ad));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, ADNumberType&gt;</a> C_inv_ad = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C_ad);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F_ad &gt; ADNumberType(0.0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType f_mu_e_ad =</div><div class="line">        1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">                <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_ad * H_ad) /</div><div class="line">                          (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ADNumberType psi_ad =</div><div class="line">        0.5 * this-&gt;get_mu_e() * f_mu_e_ad *</div><div class="line">          (<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C_ad) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad))                 </div><div class="line">        + this-&gt;get_lambda_e() * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_ad) </div><div class="line">        - 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F_ad *</div><div class="line">            (H_ad * C_inv_ad * H_ad); </div><div class="line"></div><div class="line">      ad_helper.register_dependent_variable(psi_ad);</div><div class="line"></div><div class="line">      psi = ad_helper.compute_value();</div><div class="line">      ad_helper.compute_gradient(Dpsi);</div><div class="line">      ad_helper.compute_hessian(D2psi);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dpsi_dH =</div><div class="line">        ad_helper.extract_gradient_component(Dpsi, H_components);</div><div class="line">      <span class="keywordflow">return</span> -dpsi_dH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dpsi_dC =</div><div class="line">        ad_helper.extract_gradient_component(Dpsi, C_components);</div><div class="line">      <span class="keywordflow">return</span> 2.0 * dpsi_dC;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> dpsi_dH_dH =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, H_components, H_components);</div><div class="line">      <span class="keywordflow">return</span> -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(dpsi_dH_dH);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> dpsi_dC_dH =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, C_components, H_components);</div><div class="line">      <span class="keywordflow">return</span> -2.0 * dpsi_dC_dH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, Differentiation::AD::NumberTypes ADTypeCode&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dpsi_dC_dC =</div><div class="line">        ad_helper.extract_hessian_component(D2psi, C_components, C_components);</div><div class="line">      <span class="keywordflow">return</span> 4.0 * dpsi_dC_dC;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law_SD final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_inf_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_e_h_sat_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> lambda_e_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_inf_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_v_h_sat_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> tau_v_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> delta_t_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> mu_r_sd;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          H_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_sd;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t_sd;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> Q_t1_sd;</div><div class="line"></div><div class="line">      <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a>                          psi_sd;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim, Differentiation::SD::Expression&gt;</a>          B_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> S_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> BB_sd;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim, Differentiation::SD::Expression&gt;</a>          PP_sd;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim, Differentiation::SD::Expression&gt;</a> HH_sd;</div><div class="line"></div><div class="line">      <a class="code" href="classDifferentiation_1_1SD_1_1BatchOptimizer.html">Differentiation::SD::BatchOptimizer&lt;double&gt;</a> optimizer;</div><div class="line"></div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> initialize_optimizer();</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::</div><div class="line">      Magnetoviscoelastic_Constitutive_Law_SD(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;               constitutive_parameters,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a>     optimizer_type,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , mu_e_sd(<span class="stringliteral">&quot;mu_e&quot;</span>)</div><div class="line">      , mu_e_inf_sd(<span class="stringliteral">&quot;mu_e_inf&quot;</span>)</div><div class="line">      , mu_e_h_sat_sd(<span class="stringliteral">&quot;mu_e_h_sat&quot;</span>)</div><div class="line">      , lambda_e_sd(<span class="stringliteral">&quot;lambda_e&quot;</span>)</div><div class="line">      , mu_v_sd(<span class="stringliteral">&quot;mu_v&quot;</span>)</div><div class="line">      , mu_v_inf_sd(<span class="stringliteral">&quot;mu_v_inf&quot;</span>)</div><div class="line">      , mu_v_h_sat_sd(<span class="stringliteral">&quot;mu_v_h_sat&quot;</span>)</div><div class="line">      , tau_v_sd(<span class="stringliteral">&quot;tau_v&quot;</span>)</div><div class="line">      , delta_t_sd(<span class="stringliteral">&quot;delta_t&quot;</span>)</div><div class="line">      , mu_r_sd(<span class="stringliteral">&quot;mu_r&quot;</span>)</div><div class="line">      , H_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#acf16bdf4d5a0b48dd84496e379742426">make_vector_of_symbols</a>&lt;dim&gt;(<span class="stringliteral">&quot;H&quot;</span>))</div><div class="line">      , C_sd(<a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;C&quot;</span>))</div><div class="line">      , Q_t_sd(</div><div class="line">          <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t&quot;</span>))</div><div class="line">      , Q_t1_sd(</div><div class="line">          <a class="code" href="namespaceDifferentiation.html">Differentiation</a>::SD::<a class="code" href="namespaceDifferentiation_1_1SD.html#aa97c3f1e51baf8bc4a96d563f2131e91">make_symmetric_tensor_of_symbols</a>&lt;2, dim&gt;(<span class="stringliteral">&quot;Q_t1&quot;</span>))</div><div class="line">      , optimizer(optimizer_type, optimization_flags)</div><div class="line">    {</div><div class="line">      initialize_optimizer();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">    <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::make_substitution_map</a>(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                   delta_t)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">        std::make_pair(mu_e_sd, this-&gt;get_mu_e()),</div><div class="line">        std::make_pair(mu_e_inf_sd, this-&gt;get_mu_e_inf()),</div><div class="line">        std::make_pair(mu_e_h_sat_sd, this-&gt;get_mu_e_h_sat()),</div><div class="line">        std::make_pair(lambda_e_sd, this-&gt;get_lambda_e()),</div><div class="line">        std::make_pair(mu_v_sd, this-&gt;get_mu_v()),</div><div class="line">        std::make_pair(mu_v_inf_sd, this-&gt;get_mu_v_inf()),</div><div class="line">        std::make_pair(mu_v_h_sat_sd, this-&gt;get_mu_v_h_sat()),</div><div class="line">        std::make_pair(tau_v_sd, this-&gt;get_tau_v()),</div><div class="line">        std::make_pair(delta_t_sd, delta_t),</div><div class="line">        std::make_pair(mu_r_sd, this-&gt;get_mu_r()),</div><div class="line">        std::make_pair(H_sd, H),</div><div class="line">        std::make_pair(C_sd, C),</div><div class="line">        std::make_pair(Q_t_sd, Q_t),</div><div class="line">        std::make_pair(Q_t1_sd, Q_t1));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::initialize_optimizer()</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> det_F_sd =</div><div class="line">        <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C_sd));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a> C_inv_sd =</div><div class="line">        <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_e_sd =</div><div class="line">        1.0 +</div><div class="line">        (mu_e_inf_sd / mu_e_sd - 1.0) *</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_e_h_sat_sd * mu_e_h_sat_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_ME_sd =</div><div class="line">        0.5 * mu_e_sd * f_mu_e_sd *</div><div class="line">          (<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C_sd) - dim - 2.0 * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd)) +</div><div class="line">        lambda_e_sd * std::log(det_F_sd) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F_sd) -</div><div class="line">        0.5 * this-&gt;get_mu_0() * mu_r_sd * det_F_sd * (H_sd * C_inv_sd * H_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> f_mu_v_sd =</div><div class="line">        1.0 +</div><div class="line">        (mu_v_inf_sd / mu_v_sd - 1.0) *</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>((2.0 * H_sd * H_sd) / (mu_v_h_sat_sd * mu_v_h_sat_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html">Differentiation::SD::Expression</a> psi_MVE_sd =</div><div class="line">        0.5 * mu_v_sd * f_mu_v_sd *</div><div class="line">        (Q_t_sd * (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, -2.0 / dim) * C_sd) - dim -</div><div class="line">         std::log(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t_sd)));</div><div class="line"></div><div class="line">      psi_sd = psi_ME_sd + psi_MVE_sd;</div><div class="line"></div><div class="line"></div><div class="line">      B_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, H_sd);</div><div class="line">      S_sd = 2.0 * <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(psi_sd, C_sd);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim, Differentiation::SD::Expression&gt;</a></div><div class="line">        Q_t_sd_explicit =</div><div class="line">          (1.0 / (1.0 + delta_t_sd / tau_v_sd)) *</div><div class="line">          (Q_t1_sd +</div><div class="line">           (delta_t_sd / tau_v_sd * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F_sd, 2.0 / dim) * C_inv_sd));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">Differentiation::SD::types::substitution_map</a></div><div class="line">        substitution_map_explicit = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">Differentiation::SD::make_substitution_map</a>(</div><div class="line">          std::make_pair(Q_t_sd, Q_t_sd_explicit));</div><div class="line"></div><div class="line">      BB_sd = <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(B_sd, substitution_map_explicit),</div><div class="line">        H_sd));</div><div class="line">      PP_sd = -<a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit), H_sd);</div><div class="line">      HH_sd =</div><div class="line">        2.0 *</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a5bb5de9e851544ae6b9a17170ab3f570">Differentiation::SD::differentiate</a>(</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#adee79451c8fcfef0b37efbedd461756a">Differentiation::SD::substitute</a>(S_sd, substitution_map_explicit),</div><div class="line">          C_sd);</div><div class="line"></div><div class="line">      optimizer.register_symbols(</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD_1_1Utilities.html#a373adeda1cf11d824bb41a679d061a3d">Differentiation::SD::Utilities::extract_symbols</a>(</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>({}, {}, 0)));</div><div class="line"></div><div class="line">      optimizer.register_functions(psi_sd, B_sd, S_sd, BB_sd, PP_sd, HH_sd);</div><div class="line"></div><div class="line">      optimizer.optimize();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (Q_t1 + (delta_t / this-&gt;get_tau_v()) * std::pow(det_F, 2.0 / dim) *</div><div class="line">                      C_inv);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> substitution_map = <a class="code" href="namespaceDifferentiation_1_1SD.html#aecd8502f0296caba06f86c06bc449e51">make_substitution_map</a>(C, H, delta_t);</div><div class="line"></div><div class="line">      optimizer.substitute(substitution_map);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(psi_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(B_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(S_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(BB_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(PP_sd);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> optimizer.evaluate(HH_sd);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt;::update_end_of_timestep()</div><div class="line">    {</div><div class="line">      Q_t1 = Q_t;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoelastic_Constitutive_Law final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoelastic_Constitutive_Law(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keywordtype">double</span>                  psi;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoelastic_Constitutive_Law&lt;dim&gt;::Magnetoelastic_Constitutive_Law(</div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , psi(0.0)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                  det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(C));</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C_inv = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(C);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> two_h_dot_h_div_h_sat_squ =</div><div class="line">        (2.0 * H * H) / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat());</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(two_h_dot_h_div_h_sat_squ);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e =</div><div class="line">        1.0 + (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">                tanh_two_h_dot_h_div_h_sat_squ;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dtanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(two_h_dot_h_div_h_sat_squ), 2.0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dtwo_h_dot_h_div_h_sat_squ_dH =</div><div class="line">        2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) * H;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH =</div><div class="line">        (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">        (dtanh_two_h_dot_h_div_h_sat_squ * dtwo_h_dot_h_div_h_sat_squ_dH);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> d2tanh_two_h_dot_h_div_h_sat_squ =</div><div class="line">        -2.0 * tanh_two_h_dot_h_div_h_sat_squ * dtanh_two_h_dot_h_div_h_sat_squ;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2two_h_dot_h_div_h_sat_squ_dH_dH =</div><div class="line">        2.0 * 2.0 / (this-&gt;get_mu_e_h_sat() * this-&gt;get_mu_e_h_sat()) *</div><div class="line">        <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">        (this-&gt;get_mu_e_inf() / this-&gt;get_mu_e() - 1.0) *</div><div class="line">        (d2tanh_two_h_dot_h_div_h_sat_squ *</div><div class="line">           <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dtwo_h_dot_h_div_h_sat_squ_dH,</div><div class="line">                                    dtwo_h_dot_h_div_h_sat_squ_dH)) +</div><div class="line">         dtanh_two_h_dot_h_div_h_sat_squ * d2two_h_dot_h_div_h_sat_squ_dH_dH);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         log_det_F         = <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         tr_C              = <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(C);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H       = C_inv * H;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         H_dot_C_inv_dot_H = H * C_inv_dot_H;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d_tr_C_dC =</div><div class="line">        <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> ddet_F_dC     = 0.5 * det_F * C_inv;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dlog_det_F_dC = 0.5 * C_inv;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dH_dot_C_inv_dot_H_dH = 2.0 * C_inv_dot_H;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dC_inv_dC;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              dC_inv_dC[A][B][C][D] -=               </div><div class="line">                0.5 * (C_inv[A][C] * C_inv[B][D]     </div><div class="line">                       + C_inv[A][D] * C_inv[B][C]); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> dH_dot_C_inv_dot_H_dC =</div><div class="line">        -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2log_det_F_dC_dC = 0.5 * dC_inv_dC;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2det_F_dC_dC =</div><div class="line">        0.5 * (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv, ddet_F_dC) + det_F * dC_inv_dC);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2H_dot_C_inv_dot_H_dH_dH = 2.0 * C_inv;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=</div><div class="line">              C_inv[A][C] * C_inv_dot_H[B] + </div><div class="line">              C_inv_dot_H[A] * C_inv[B][C];  </div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">              d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">                0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                       C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +</div><div class="line">                       C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);</div><div class="line"></div><div class="line">      psi =</div><div class="line">        (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">          (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">        this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F)) -</div><div class="line">        (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div><div class="line"></div><div class="line">      B = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">            df_mu_e_dH </div><div class="line">          + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">              dH_dot_C_inv_dot_H_dH; </div><div class="line"></div><div class="line">      S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                        </div><div class="line">            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                              </div><div class="line">          + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC) </div><div class="line">          - 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *            </div><div class="line">              (H_dot_C_inv_dot_H * ddet_F_dC                               </div><div class="line">               + det_F * dH_dot_C_inv_dot_H_dC);                           </div><div class="line"></div><div class="line">      BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * </div><div class="line">             d2f_mu_e_dH_dH                                             </div><div class="line">           + 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">               d2H_dot_C_inv_dot_H_dH_dH; </div><div class="line"></div><div class="line">      PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *                                  </div><div class="line">             <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),   </div><div class="line">                           df_mu_e_dH)                                        </div><div class="line">           +                                                                  </div><div class="line">           2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">             (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) </div><div class="line">              + det_F * d2H_dot_C_inv_dot_H_dC_dH);                           </div><div class="line"></div><div class="line">      HH =</div><div class="line">        4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">        + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">            (2.0 * <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">             + 2.0 * log_det_F * d2log_det_F_dC_dC)                          </div><div class="line">        - 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *                </div><div class="line">            (H_dot_C_inv_dot_H * d2det_F_dC_dC                               </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)               </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)               </div><div class="line">             + det_F * d2H_dot_C_inv_dot_H_dC_dC);                           </div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> B;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> S;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> BB;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> PP;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> Magnetoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> HH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Magnetoviscoelastic_Constitutive_Law final</div><div class="line">      : <span class="keyword">public</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Magnetoviscoelastic_Constitutive_Law(</div><div class="line">        <span class="keyword">const</span> ConstitutiveParameters &amp;constitutive_parameters);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_internal_data(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> get_psi() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_B() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_S() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_DD() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> get_PP() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_HH() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_end_of_timestep() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Q_t1;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>                  psi;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>          B;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> S;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> BB;</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a>          PP;</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> HH;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classGeneralDataStorage.html">GeneralDataStorage</a> cache;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> set_primary_variables(<span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">                                 <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> update_internal_variable(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_f_mu(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">      get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> get_df_mu_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">      get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> get_d2f_mu_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_C_inv() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_log_det_F() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_trace_C() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;get_H_dot_C_inv_dot_H() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_dC_inv_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d_tr_C_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_ddet_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dlog_det_F_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_dH_dot_C_inv_dot_H_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">      get_dQ_t_dC(<span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2log_det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2det_F_dC_dC() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dH_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dH() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;get_d2H_dot_C_inv_dot_H_dC_dC() <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::Magnetoviscoelastic_Constitutive_Law(<span class="keyword">const</span> ConstitutiveParameters</div><div class="line">                                                   &amp;constitutive_parameters)</div><div class="line">      : Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;(</div><div class="line">          constitutive_parameters)</div><div class="line">      , Q_t(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , Q_t1(<a class="code" href="namespacePhysics.html">Physics</a>::Elasticity::StandardTensors&lt;dim&gt;::I)</div><div class="line">      , psi(0.0)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_data(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;           time)</div><div class="line">    {</div><div class="line">      set_primary_variables(C, H);</div><div class="line">      update_internal_variable(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_e = get_f_mu(this-&gt;get_mu_e(),</div><div class="line">                                     this-&gt;get_mu_e_inf(),</div><div class="line">                                     this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> f_mu_v = get_f_mu(this-&gt;get_mu_v(),</div><div class="line">                                     this-&gt;get_mu_v_inf(),</div><div class="line">                                     this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_e_dH = get_df_mu_dH(this-&gt;get_mu_e(),</div><div class="line">                                                     this-&gt;get_mu_e_inf(),</div><div class="line">                                                     this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> df_mu_v_dH = get_df_mu_dH(this-&gt;get_mu_v(),</div><div class="line">                                                     this-&gt;get_mu_v_inf(),</div><div class="line">                                                     this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_e_dH_dH =</div><div class="line">        get_d2f_mu_dH_dH(this-&gt;get_mu_e(),</div><div class="line">                         this-&gt;get_mu_e_inf(),</div><div class="line">                         this-&gt;get_mu_e_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> d2f_mu_v_dH_dH =</div><div class="line">        get_d2f_mu_dH_dH(this-&gt;get_mu_v(),</div><div class="line">                         this-&gt;get_mu_v_inf(),</div><div class="line">                         this-&gt;get_mu_v_h_sat());</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;                 det_F = get_det_F();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;log_det_F         = get_log_det_F();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;tr_C              = get_trace_C();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;H_dot_C_inv_dot_H = get_H_dot_C_inv_dot_H();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d_tr_C_dC     = get_d_tr_C_dC();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;ddet_F_dC     = get_ddet_F_dC();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dlog_det_F_dC = get_dlog_det_F_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;dQ_t_dC = get_dQ_t_dC(time);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dH = get_dH_dot_C_inv_dot_H_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;dH_dot_C_inv_dot_H_dC =</div><div class="line">        get_dH_dot_C_inv_dot_H_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2log_det_F_dC_dC =</div><div class="line">        get_d2log_det_F_dC_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2det_F_dC_dC = get_d2det_F_dC_dC();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dH_dH =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dH_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dH =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dC_dH();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;d2H_dot_C_inv_dot_H_dC_dC =</div><div class="line">        get_d2H_dot_C_inv_dot_H_dC_dC();</div><div class="line"></div><div class="line">      psi = (0.5 * this-&gt;get_mu_e() * f_mu_e) *</div><div class="line">              (tr_C - dim - 2.0 * std::log(det_F)) +</div><div class="line">            this-&gt;get_lambda_e() * (<a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F) * <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(det_F));</div><div class="line">      psi += (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">             (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">              <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t)));</div><div class="line">      psi -=</div><div class="line">        (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * det_F * (H * C_inv * H);</div><div class="line"></div><div class="line">      B =</div><div class="line">        -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) * df_mu_e_dH;</div><div class="line">      B -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">           (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">            <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t))) *</div><div class="line">           df_mu_v_dH;</div><div class="line">      B += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">           dH_dot_C_inv_dot_H_dH;</div><div class="line"></div><div class="line">      S = 2.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) *                         </div><div class="line">            (d_tr_C_dC - 2.0 * dlog_det_F_dC)                               </div><div class="line">          + 2.0 * this-&gt;get_lambda_e() * (2.0 * log_det_F * dlog_det_F_dC); </div><div class="line">      S += 2.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">           ((Q_t * C) *</div><div class="line">              ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) * ddet_F_dC) +</div><div class="line">            std::pow(det_F, -2.0 / dim) * Q_t);                <span class="comment">// dC/dC = II</span></div><div class="line">      S -= 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">           (H_dot_C_inv_dot_H * ddet_F_dC                      </div><div class="line">            + det_F * dH_dot_C_inv_dot_H_dC);                  </div><div class="line"></div><div class="line">      BB = -(0.5 * this-&gt;get_mu_e() * (tr_C - dim - 2.0 * log_det_F)) *</div><div class="line">           d2f_mu_e_dH_dH;</div><div class="line">      BB -= (0.5 * this-&gt;get_mu_v()) *</div><div class="line">            (Q_t * (std::pow(det_F, -2.0 / dim) * C) - dim -</div><div class="line">             <a class="code" href="vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(Q_t))) *</div><div class="line">            d2f_mu_v_dH_dH;</div><div class="line">      BB += 0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r() * det_F *</div><div class="line">            d2H_dot_C_inv_dot_H_dH_dH;</div><div class="line"></div><div class="line">      PP = -2.0 * (0.5 * this-&gt;get_mu_e()) *</div><div class="line">           <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(d_tr_C_dC - 2.0 * dlog_det_F_dC),</div><div class="line">                         df_mu_e_dH);</div><div class="line">      PP -= 2.0 * (0.5 * this-&gt;get_mu_v()) *</div><div class="line">            <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>((Q_t * C) *</div><div class="line">                                           ((-2.0 / dim) *</div><div class="line">                                            std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                                            ddet_F_dC) +</div><div class="line">                                         std::pow(det_F, -2.0 / dim) * Q_t),</div><div class="line">                          df_mu_v_dH);</div><div class="line">      PP += 2.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) *</div><div class="line">            (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>(ddet_F_dC), dH_dot_C_inv_dot_H_dH) +</div><div class="line">             det_F * d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line"></div><div class="line">      HH =</div><div class="line">        4.0 * (0.5 * this-&gt;get_mu_e() * f_mu_e) * (-2.0 * d2log_det_F_dC_dC) </div><div class="line">        + 4.0 * this-&gt;get_lambda_e() *                                       </div><div class="line">            (2.0 * <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dlog_det_F_dC, dlog_det_F_dC)               </div><div class="line">             + 2.0 * log_det_F * d2log_det_F_dC_dC);                         </div><div class="line">      HH += 4.0 * (0.5 * this-&gt;get_mu_v() * f_mu_v) *</div><div class="line">            (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                             ddet_F_dC,</div><div class="line">                           C * dQ_t_dC + Q_t) +</div><div class="line">             (Q_t * <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>) *</div><div class="line">               (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC,</div><div class="line">                              (-2.0 / dim) * (-2.0 / dim - 1.0) *</div><div class="line">                                std::pow(det_F, -2.0 / dim - 2.0) * ddet_F_dC) +</div><div class="line">                ((-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                 d2det_F_dC_dC)) +</div><div class="line">             <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(Q_t,</div><div class="line">                           (-2.0 / dim) * std::pow(det_F, -2.0 / dim - 1.0) *</div><div class="line">                             ddet_F_dC) +</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, -2.0 / dim) * dQ_t_dC);</div><div class="line">      HH -= 4.0 * (0.5 * this-&gt;get_mu_0() * this-&gt;get_mu_r()) * </div><div class="line">            (H_dot_C_inv_dot_H * d2det_F_dC_dC                  </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(ddet_F_dC, dH_dot_C_inv_dot_H_dC)  </div><div class="line">             + <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(dH_dot_C_inv_dot_H_dC, ddet_F_dC)  </div><div class="line">             + det_F * d2H_dot_C_inv_dot_H_dC_dC);              </div><div class="line"></div><div class="line"></div><div class="line">      cache.reset();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_psi()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> psi;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_B()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> B;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_S()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> S;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_DD()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> BB;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_PP()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> PP;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_HH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> HH;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_end_of_timestep()</div><div class="line">    {</div><div class="line">      Q_t1 = Q_t;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::update_internal_variable(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> delta_t = this-&gt;get_delta_t(time);</div><div class="line"></div><div class="line">      Q_t = (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (Q_t1 + (delta_t / this-&gt;get_tau_v()) *</div><div class="line">                      std::pow(get_det_F(), 2.0 / dim) * get_C_inv());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_two_h_dot_h_div_h_sat_squ(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;H = get_H();</div><div class="line">      <span class="keywordflow">return</span> (2.0 * H * H) / (mu_h_sat * mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_f_mu(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 1.0 +</div><div class="line">             (mu_inf / mu - 1.0) * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_dtanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(1.0 / <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">std::cosh</a>(get_two_h_dot_h_div_h_sat_squ(mu_h_sat)),</div><div class="line">                      2.0);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_dtwo_h_dot_h_div_h_sat_squ_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) * get_H();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_df_mu_dH(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">             (get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">              get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_d2tanh_two_h_dot_h_div_h_sat_squ(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> -2.0 * get_tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">             get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> Magnetoviscoelastic_Constitutive_Law&lt;</div><div class="line">      dim&gt;::get_d2two_h_dot_h_div_h_sat_squ_dH_dH(<span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 2.0 * 2.0 / (mu_h_sat * mu_h_sat) *</div><div class="line">             <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a></div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2f_mu_dH_dH(</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_inf,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> mu_h_sat)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (mu_inf / mu - 1.0) *</div><div class="line">             (get_d2tanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">                <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(</div><div class="line">                  <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat),</div><div class="line">                                get_dtwo_h_dot_h_div_h_sat_squ_dH(mu_h_sat))) +</div><div class="line">              get_dtanh_two_h_dot_h_div_h_sat_squ(mu_h_sat) *</div><div class="line">                get_d2two_h_dot_h_div_h_sat_squ_dH_dH(mu_h_sat));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::set_primary_variables(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         H)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name_H(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_H),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">               <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">      cache.add_unique_copy(name_H, H);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::string name_C(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(!cache.stores_object_with_name(name_C),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">               <span class="stringliteral">&quot;The primary variable has already been added to the cache.&quot;</span>));</div><div class="line">      cache.add_unique_copy(name_C, C);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C&quot;</span>);</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache.stores_object_with_name(name),</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Primary variables must be added to the cache.&quot;</span>));</div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;det_F&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> det_F = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(get_C()));</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(det_F &gt; 0.0,</div><div class="line">                      <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian must be positive.&quot;</span>));</div><div class="line">          cache.add_unique_copy(name, det_F);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          cache.add_unique_copy(name, <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(get_C()));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_log_det_F()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;log(det_F)&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, std::log(get_det_F()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_trace_C()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;trace(C)&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(get_C()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;C_inv_dot_H&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, get_C_inv() * get_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_H_dot_C_inv_dot_H()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;H_dot_C_inv_dot_H&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, get_H() * get_C_inv_dot_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;double&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dQ_t_dC(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classDiscreteTime.html">DiscreteTime</a> &amp;time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dQ_t_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>  delta_t = this-&gt;get_delta_t(time);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;det_F   = get_det_F();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> dQ_t_dC =</div><div class="line">            (1.0 / (1.0 + delta_t / this-&gt;get_tau_v())) *</div><div class="line">            (delta_t / this-&gt;get_tau_v()) *</div><div class="line">            ((2.0 / dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim - 1.0) *</div><div class="line">               <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">             <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(det_F, 2.0 / dim) * get_dC_inv_dC());</div><div class="line"></div><div class="line">          cache.add_unique_copy(name, dQ_t_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dC_inv_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dC_inv_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv = get_C_inv();</div><div class="line">          <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a>        dC_inv_dC;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">                  dC_inv_dC[A][B][C][D] -=               </div><div class="line">                    0.5 * (C_inv[A][C] * C_inv[B][D]     </div><div class="line">                           + C_inv[A][D] * C_inv[B][C]); </div><div class="line"></div><div class="line">          cache.add_unique_copy(name, dC_inv_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d_tr_C_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d_tr_C_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name,</div><div class="line">                              <a class="code" href="classPhysics_1_1Elasticity_1_1StandardTensors.html">Physics::Elasticity::StandardTensors&lt;dim&gt;::I</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_ddet_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;ddet_F_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_det_F() * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dlog_det_F_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dlog_det_F_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dH()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 2.0 * get_C_inv_dot_H());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;1, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_dH_dot_C_inv_dot_H_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;dH_dot_C_inv_dot_H_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          cache.add_unique_copy(</div><div class="line">            name, -<a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(C_inv_dot_H, C_inv_dot_H)));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2log_det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2log_det_F_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 0.5 * get_dC_inv_dC());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2det_F_dC_dC()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2det_F_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name,</div><div class="line">                              0.5 *</div><div class="line">                                (<a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(get_C_inv(), get_ddet_F_dC()) +</div><div class="line">                                 get_det_F() * get_dC_inv_dC()));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dH_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dH_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        cache.add_unique_copy(name, 2.0 * get_C_inv());</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;2, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dH()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dH&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;3, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dH;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = 0; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                d2H_dot_C_inv_dot_H_dC_dH[A][B][C] -=</div><div class="line">                  C_inv[A][C] * C_inv_dot_H[B] + </div><div class="line">                  C_inv_dot_H[A] * C_inv[B][C];  </div><div class="line"></div><div class="line">          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dH);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;Tensor&lt;3, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;</div><div class="line">    Magnetoviscoelastic_Constitutive_Law&lt;dim&gt;::get_d2H_dot_C_inv_dot_H_dC_dC()<span class="keyword"></span></div><div class="line"><span class="keyword">      const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> std::string name(<span class="stringliteral">&quot;d2H_dot_C_inv_dot_H_dC_dC&quot;</span>);</div><div class="line">      <span class="keywordflow">if</span> (cache.stores_object_with_name(name) == <span class="keyword">false</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;         C_inv_dot_H = get_C_inv_dot_H();</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;C_inv       = get_C_inv();</div><div class="line"></div><div class="line">          <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> d2H_dot_C_inv_dot_H_dC_dC;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> A = 0; A &lt; dim; ++<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> B = A; B &lt; dim; ++B)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> C = 0; C &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> D = C; D &lt; dim; ++D)</div><div class="line">                  d2H_dot_C_inv_dot_H_dC_dC[A][B][C][D] +=</div><div class="line">                    0.5 * (C_inv_dot_H[A] * C_inv_dot_H[C] * C_inv[B][D] +</div><div class="line">                           C_inv_dot_H[A] * C_inv_dot_H[D] * C_inv[B][C] +</div><div class="line">                           C_inv_dot_H[B] * C_inv_dot_H[C] * C_inv[A][D] +</div><div class="line">                           C_inv_dot_H[B] * C_inv_dot_H[D] * C_inv[A][C]);</div><div class="line"></div><div class="line">          cache.add_unique_copy(name, d2H_dot_C_inv_dot_H_dC_dC);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> cache.template get_object_with_name&lt;SymmetricTensor&lt;4, dim&gt;&gt;(name);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">class </span>RheologicalExperimentParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RheologicalExperimentParameters();</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> sample_radius = 0.01;</div><div class="line">      <span class="keywordtype">double</span> sample_height = 0.001;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> lambda_2 = 0.95;</div><div class="line">      <span class="keywordtype">double</span> gamma_12 = 0.05;</div><div class="line">      <span class="keywordtype">double</span> H_2      = 60.0e3;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span>       frequency         = 1.0 / (2.0 * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>);</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cycles          = 5;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_steps_per_cycle = 2500;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span>        output_data_to_file = <span class="keyword">true</span>;</div><div class="line">      std::string output_filename_rd =</div><div class="line">        <span class="stringliteral">&quot;experimental_results-rate_dependent.csv&quot;</span>;</div><div class="line">      std::string output_filename_ri =</div><div class="line">        <span class="stringliteral">&quot;experimental_results-rate_independent.csv&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> start_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> end_time() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> delta_t() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> get_H(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    RheologicalExperimentParameters::RheologicalExperimentParameters()</div><div class="line">      : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Coupled Constitutive Laws/Rheological Experiment/&quot;</span>)</div><div class="line">    {</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_radius);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Experimental sample radius&quot;</span>, sample_height);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Axial stretch&quot;</span>, lambda_2);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Shear strain amplitude&quot;</span>, gamma_12);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Axial magnetic field strength&quot;</span>, H_2);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Frequency&quot;</span>, frequency);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Number of loading cycles&quot;</span>, n_cycles);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Discretisation for each cycle&quot;</span>, n_steps_per_cycle);</div><div class="line"></div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output experimental results to file&quot;</span>, output_data_to_file);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output file name (rate dependent constitutive law)&quot;</span>,</div><div class="line">                    output_filename_rd);</div><div class="line">      add_parameter(<span class="stringliteral">&quot;Output file name (rate independent constitutive law)&quot;</span>,</div><div class="line">                    output_filename_ri);</div><div class="line"></div><div class="line">      parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::start_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.0;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::end_time()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> n_cycles / frequency;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> RheologicalExperimentParameters::delta_t()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (end_time() - start_time()) / (n_steps_per_cycle * n_cycles);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span></div><div class="line">    RheologicalExperimentParameters::print_status(<span class="keyword">const</span> <span class="keywordtype">int</span> step_number)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> (step_number % (n_cycles * n_steps_per_cycle / 100)) == 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a> RheologicalExperimentParameters::get_H(<span class="keyword">const</span> <span class="keywordtype">double</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>({0.0, 0.0, H_2});</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> RheologicalExperimentParameters::get_F(<span class="keyword">const</span> <span class="keywordtype">double</span> time)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((sample_radius &gt; 0.0 &amp;&amp; sample_height &gt; 0.0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical sample dimensions&quot;</span>));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(lambda_2 &gt; 0.0,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical applied axial stretch&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> sqrt_lambda_2     = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(lambda_2);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> inv_sqrt_lambda_2 = 1.0 / sqrt_lambda_2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_max =</div><div class="line">        <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">std::atan</a>(std::tan(gamma_12) * sample_height /</div><div class="line">                  sample_radius); <span class="comment">// Small strain approximation</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> A       = sample_radius * alpha_max;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> w       = 2.0 * numbers::PI * frequency; <span class="comment">// in rad /s</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma_t = A * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(w * time);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tau_t =</div><div class="line">        gamma_t /</div><div class="line">        (sample_radius * sample_height); <span class="comment">// Torsion angle per unit length</span></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> alpha_t = tau_t * lambda_2 * sample_height;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, 3&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">      F[0][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[0][1] = -inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[0][2] = -tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[1][0] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(alpha_t);</div><div class="line">      F[1][1] = inv_sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[1][2] = tau_t * sample_radius * sqrt_lambda_2 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(alpha_t);</div><div class="line">      F[2][0] = 0.0;</div><div class="line">      F[2][1] = 0.0;</div><div class="line">      F[2][2] = lambda_2;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>((F[0][0] &gt; 0) &amp;&amp; (F[1][1] &gt; 0) &amp;&amp; (F[2][2] &gt; 0),</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Non-physical deformation gradient component.&quot;</span>));</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(std::abs(<a class="code" href="symmetric__tensor_8h.html#a31fa20712aae4f3b8ab9f62729b464d3">determinant</a>(F) - 1.0) &lt; 1e-6,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Volumetric Jacobian is not equal to unity.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> run_rheological_experiment(</div><div class="line">      <span class="keyword">const</span> RheologicalExperimentParameters &amp;experimental_parameters,</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">        &amp;material_hand_calculated,</div><div class="line">      Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt;</div><div class="line">        &amp;               material_assisted_computation,</div><div class="line">      <a class="code" href="classTimerOutput.html">TimerOutput</a> &amp;     timer,</div><div class="line">      <span class="keyword">const</span> std::string filename)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> check_material_class_results =</div><div class="line">        [](</div><div class="line">          <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;to_verify,</div><div class="line">          <span class="keyword">const</span> Coupled_Magnetomechanical_Constitutive_Law_Base&lt;dim&gt; &amp;blessed,</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> tol = 1e-6) {</div><div class="line">          (void)to_verify;</div><div class="line">          (void)blessed;</div><div class="line">          (void)tol;</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(std::abs(blessed.get_psi() - to_verify.get_psi()) &lt; tol,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for psi. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(std::abs(</div><div class="line">                              blessed.get_psi() - to_verify.get_psi()))));</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for B. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_B() - to_verify.get_B()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for S. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_S() - to_verify.get_S()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line"></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for BB. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_DD() - to_verify.get_DD()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for PP. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_PP() - to_verify.get_PP()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>() &lt; <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#ac80bc8a0dc30eb3ca526e12e0e6b6270">tol</a>,</div><div class="line">                 <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;No match for HH. Error: &quot;</span> +</div><div class="line">                            <a class="code" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string</a>(</div><div class="line">                              (blessed.get_HH() - to_verify.get_HH()).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>())));</div><div class="line">        };</div><div class="line"></div><div class="line">      std::ostringstream stream;</div><div class="line">      stream</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Time;Axial magnetic field strength [A/m];Axial magnetic induction [T];Shear strain [%];Shear stress [Pa]\n&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(experimental_parameters.start_time(),</div><div class="line">                             experimental_parameters.end_time() +</div><div class="line">                               experimental_parameters.delta_t(),</div><div class="line">                             experimental_parameters.delta_t());</div><div class="line">           time.is_at_end() == <span class="keyword">false</span>;</div><div class="line">           time.advance_time())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (experimental_parameters.print_status(time.get_step_number()))</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep = &quot;</span> &lt;&lt; time.get_step_number()</div><div class="line">                      &lt;&lt; <span class="stringliteral">&quot; @ time = &quot;</span> &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;s.&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> H =</div><div class="line">            experimental_parameters.get_H(time.get_current_time());</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> F =</div><div class="line">            experimental_parameters.get_F(time.get_current_time());</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> C =</div><div class="line">            <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">Physics::Elasticity::Kinematics::C</a>(F);</div><div class="line"></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Hand calculated&quot;</span>);</div><div class="line">            material_hand_calculated.update_internal_data(C, H, time);</div><div class="line">            material_hand_calculated.update_end_of_timestep();</div><div class="line">          }</div><div class="line"></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assisted computation&quot;</span>);</div><div class="line">            material_assisted_computation.update_internal_data(C, H, time);</div><div class="line">            material_assisted_computation.update_end_of_timestep();</div><div class="line">          }</div><div class="line"></div><div class="line">          check_material_class_results(material_hand_calculated,</div><div class="line">                                       material_assisted_computation);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> h =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Covariant.html#ad438f09c3045e448805f62b27c2f8d29">Physics::Transformations::Covariant::push_forward</a>(H, F);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> b =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">                  material_hand_calculated.get_B(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> sigma =</div><div class="line">                <a class="code" href="namespacePhysics_1_1Transformations_1_1Piola.html#acea15f84164890c8e34ace0561ff9703">Physics::Transformations::Piola::push_forward</a>(</div><div class="line">                  material_hand_calculated.get_S(), <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>);</div><div class="line">              stream &lt;&lt; time.get_current_time() &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; h[2] &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; b[2]</div><div class="line">                     &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; F[1][2] * 100.0 &lt;&lt; <span class="stringliteral">&quot;;&quot;</span> &lt;&lt; sigma[1][2] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (experimental_parameters.output_data_to_file)</div><div class="line">        {</div><div class="line">          std::ofstream output(filename);</div><div class="line">          output &lt;&lt; stream.str();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">      constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 3;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> ConstitutiveParameters          constitutive_parameters;</div><div class="line">      <span class="keyword">const</span> RheologicalExperimentParameters experimental_parameters;</div><div class="line"></div><div class="line">      std::string parameter_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        parameter_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">        std::cout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Coupled magnetoelastic constitutive law using automatic differentiation.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1c">Differentiation::AD::NumberTypes</a> ADTypeCode =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>;</div><div class="line"></div><div class="line">        Magnetoelastic_Constitutive_Law&lt;dim&gt; material(constitutive_parameters);</div><div class="line">        Magnetoelastic_Constitutive_Law_AD&lt;dim, ADTypeCode&gt; material_ad(</div><div class="line">          constitutive_parameters);</div><div class="line"></div><div class="line">        run_rheological_experiment(experimental_parameters,</div><div class="line">                                   material,</div><div class="line">                                   material_ad,</div><div class="line">                                   timer,</div><div class="line">                                   experimental_parameters.output_filename_ri);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                          <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line">        std::cout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Coupled magneto-viscoelastic constitutive law using symbolic differentiation.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef DEAL_II_SYMENGINE_WITH_LLVM</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using LLVM optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba7c7d2b9e8389cc541dc5a615e05bcf1e">Differentiation::SD::OptimizerType::llvm</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a1ad0cce13bc606ad6742e9841ccdfe15">Differentiation::SD::OptimizationFlags::optimize_all</a>;</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Using lambda optimizer.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8b">Differentiation::SD::OptimizerType</a> optimizer_type =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">Differentiation::SD::OptimizerType::lambda</a>;</div><div class="line">        constexpr <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842">Differentiation::SD::OptimizationFlags</a> optimization_flags =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#af920b6488de218dea94f25b94ad08842a3df84265620315a025367510c90d0474">Differentiation::SD::OptimizationFlags::optimize_cse</a>;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        Magnetoviscoelastic_Constitutive_Law&lt;dim&gt; material(</div><div class="line">          constitutive_parameters);</div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a>(<span class="stringliteral">&quot;Initialize symbolic CL&quot;</span>);</div><div class="line">        Magnetoviscoelastic_Constitutive_Law_SD&lt;dim&gt; material_sd(</div><div class="line">          constitutive_parameters, optimizer_type, optimization_flags);</div><div class="line">        timer.<a class="code" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a>();</div><div class="line"></div><div class="line">        run_rheological_experiment(experimental_parameters,</div><div class="line">                                   material,</div><div class="line">                                   material_sd,</div><div class="line">                                   timer,</div><div class="line">                                   experimental_parameters.output_filename_rd);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;... all calculations are correct!&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace CoupledConstitutiveLaws</span></div><div class="line"></div><div class="line">} <span class="comment">// namespace Step71</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::SimpleExample::run</a>();</div><div class="line">  <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Step71::CoupledConstitutiveLaws::run</a>(argc, argv);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
