<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_32.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-32 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-32 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_31.html">step-31</a>, <a class="el" href="step_55.html">step-55</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Usingtherightpressure"> Using the "right" pressure </a>
        <li><a href="#Thescalingofdiscretizedequations"> The scaling of discretized equations </a>
        <li><a href="#ChangestotheStokespreconditionerandsolver"> Changes to the Stokes preconditioner and solver </a>
        <li><a href="#Changestotheartificialviscositystabilization"> Changes to the artificial viscosity stabilization </a>
        <li><a href="#LocallyconservativeStokesdiscretization"> Locally conservative Stokes discretization </a>
        <li><a href="#Higherordermappingsforcurvedboundaries"> Higher order mappings for curved boundaries </a>
        <li><a href="#Parallelizationonclusters"> Parallelization on clusters </a>
        <li><a href="#Parallelizationwithinindividualnodesofacluster"> Parallelization within individual nodes of a cluster </a>
        <li><a href="#Thetestcase"> The testcase </a>
        <li><a href="#Implementationdetails"> Implementation details </a>
        <li><a href="#Outlook"> Outlook </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#PreconditioningtheStokessystem">Preconditioning the Stokes system</a>
        <li><a href="#Definitionofassemblydatastructures">Definition of assembly data structures</a>
        <li><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a>
        <li><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemParameters">BoussinesqFlowProblem::Parameters</a>
        <li><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a>
        <li><a href="#TheBoussinesqFlowProblemhelperfunctions">The BoussinesqFlowProblem helper functions</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a>
        <li><a href="#BoussinesqFlowProblemget_cfl_number">BoussinesqFlowProblem::get_cfl_number</a>
        <li><a href="#BoussinesqFlowProblemget_entropy_variation">BoussinesqFlowProblem::get_entropy_variation</a>
        <li><a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a>
        <li><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a>
      </ul>
        <li><a href="#TheBoussinesqFlowProblemsetupfunctions">The BoussinesqFlowProblem setup functions</a>
        <li><a href="#TheBoussinesqFlowProblemassemblyfunctions">The BoussinesqFlowProblem assembly functions</a>
      <ul>
        <li><a href="#Stokespreconditionerassembly">Stokes preconditioner assembly</a>
        <li><a href="#Stokessystemassembly">Stokes system assembly</a>
        <li><a href="#Temperaturematrixassembly">Temperature matrix assembly</a>
        <li><a href="#Temperaturerighthandsideassembly">Temperature right hand side assembly</a>
      </ul>
        <li><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a>
        <li><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a>
        <li><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a>
        <li><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Comparisonofresultswithstep31">Comparison of results with step-31</a>
        <li><a href="#Resultsfora2dcircularshelltestcase">Results for a 2d circular shell testcase</a>
        <li><a href="#Resultsfora3dsphericalshelltestcase">Results for a 3d spherical shell testcase</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Martin Kronbichler, Wolfgang Bangerth, and Timo Heister.</em></p>
<p><em>This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology; and in a continuation by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation, The California Institute of Technology, or of The University of California &ndash; Davis.</em></p>
<p><em>The work discussed here is also presented in the following publication: <b> M. Kronbichler, T. Heister, W. Bangerth: <em>High Accuracy Mantle Convection Simulation through Modern Numerical Methods</em>, Geophysical Journal International, 2012, 191, 12-29. <a href="http://dx.doi.org/10.1111/j.1365-246X.2012.05609.x">[DOI]</a> </b></em></p>
<p><em>The continuation of development of this program has led to the much larger open source code <em>ASPECT</em> (see <a href="http://aspect.geodynamics.org/">http://aspect.geodynamics.org/</a>) which is much more flexible in solving many kinds of related problems. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program does pretty much exactly what <a class="el" href="step_31.html">step-31</a> already does: it solves the Boussinesq equations that describe the motion of a fluid whose temperature is not in equilibrium. As such, all the equations we have described in <a class="el" href="step_31.html">step-31</a> still hold: we solve the same general partial differential equation (with only minor modifications to adjust for more realism in the problem setting), using the same finite element scheme, the same time stepping algorithm, and more or less the same stabilization method for the temperature advection-diffusion equation. As a consequence, you may first want to understand that program &mdash; and its implementation &mdash; before you work on the current one.</p>
<p>The difference between <a class="el" href="step_31.html">step-31</a> and the current program is that here we want to do things in parallel, using both the availability of many machines in a cluster (with parallelization based on MPI) as well as many processor cores within a single machine (with parallelization based on threads). This program's main job is therefore to introduce the changes that are necessary to utilize the availability of these parallel compute resources. In this regard, it builds on the <a class="el" href="step_40.html">step-40</a> program that first introduces the necessary classes for much of the parallel functionality, and on <a class="el" href="step_55.html">step-55</a> that shows how this is done for a vector-valued problem.</p>
<p>In addition to these changes, we also use a slightly different preconditioner, and we will have to make a number of changes that have to do with the fact that we want to solve a <em>realistic</em> problem here, not a model problem. The latter, in particular, will require that we think about scaling issues as well as what all those parameters and coefficients in the equations under consideration actually mean. We will discuss first the issues that affect changes in the mathematical formulation and solver structure, then how to parallelize things, and finally the actual testcase we will consider.</p>
<p><a class="anchor" id="Usingtherightpressure"></a></p><h3>Using the "right" pressure </h3>
<p>In <a class="el" href="step_31.html">step-31</a>, we used the following Stokes model for the velocity and pressure field: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho \; \beta \; T \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> The right hand side of the first equation appears a wee bit unmotivated. Here's how things should really be. We need the external forces that act on the fluid, which we assume are given by gravity only. In the current case, we assume that the fluid does expand slightly for the purposes of this gravity force, but not enough that we need to modify the incompressibility condition (the second equation). What this means is that for the purpose of the right hand side, we can assume that \(\rho=\rho(T)\). An assumption that may not be entirely justified is that we can assume that the changes of density as a function of temperature are small, leading to an expression of the form \(\rho(T) = \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})]\), i.e., the density equals \(\rho_{\text{ref}}\) at reference temperature and decreases linearly as the temperature increases (as the material expands). The force balance equation then looks properly written like this: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})] \mathbf{g}. \end{eqnarray*}
</p>
<p> Now note that the gravity force results from a gravity potential as \(\mathbf g=-\nabla \varphi\), so that we can re-write this as follows: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho_{\text{ref}} \; \beta\; T\; \mathbf{g} -\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \nabla\varphi. \end{eqnarray*}
</p>
<p> The second term on the right is time independent, and so we could introduce a new "dynamic" pressure \(p_{\text{dyn}}=p+\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi=p_{\text{total}}-p_{\text{static}}\) with which the Stokes equations would read: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p_{\text{dyn}} &amp;=&amp; -\rho_{\text{ref}} \; \beta \; T \; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> This is exactly the form we used in <a class="el" href="step_31.html">step-31</a>, and it was appropriate to do so because all changes in the fluid flow are only driven by the dynamic pressure that results from temperature differences. (In other words: Any contribution to the right hand side that results from taking the gradient of a scalar field have no effect on the velocity field.)</p>
<p>On the other hand, we will here use the form of the Stokes equations that considers the total pressure instead: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T)\; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> There are several advantages to this:</p>
<ul>
<li>This way we can plot the pressure in our program in such a way that it actually shows the total pressure that includes the effects of temperature differences as well as the static pressure of the overlying rocks. Since the pressure does not appear any further in any of the other equations, whether to use one or the other is more a matter of taste than of correctness. The flow field is exactly the same, but we get a pressure that we can now compare with values that are given in geophysical books as those that hold at the bottom of the earth mantle, for example.</li>
<li>If we wanted to make the model even more realistic, we would have to take into account that many of the material parameters (e.g. the viscosity, the density, etc) not only depend on the temperature but also the <em>total</em> pressure.</li>
<li>The model above assumed a linear dependence \(\rho(T) = \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})]\) and assumed that \(\beta\) is small. In practice, this may not be so. In fact, realistic models are certainly not linear, and \(\beta\) may also not be small for at least part of the temperature range because the density's behavior is substantially dependent not only on thermal expansion but by phase changes.</li>
<li>A final reason to do this is discussed in the results section and concerns possible extensions to the model we use here. It has to do with the fact that the temperature equation (see below) we use here does not include a term that contains the pressure. It should, however: rock, like gas, heats up as you compress it. Consequently, material that rises up cools adiabatically, and cold material that sinks down heats adiabatically. We discuss this further below.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>There is, however, a downside to this procedure. In the earth, the dynamic pressure is several orders of magnitude smaller than the total pressure. If we use the equations above and solve all variables to, say, 4 digits of accuracy, then we may be able to get the velocity and the total pressure right, but we will have no accuracy at all if we compute the dynamic pressure by subtracting from the total pressure the static part \(p_\text{static}=\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi\). If, for example, the dynamic pressure is six orders of magnitude smaller than the static pressure, then we need to solve the overall pressure to at least seven digits of accuracy to get anything remotely accurate. That said, in practice this turns out not to be a limiting factor.</dd></dl>
<p><a class="anchor" id="Thescalingofdiscretizedequations"></a></p><h3>The scaling of discretized equations </h3>
<p>Remember that we want to solve the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T) \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
<p> augmented by appropriate boundary and initial conditions. As discussed in <a class="el" href="step_31.html">step-31</a>, we will solve this set of equations by solving for a Stokes problem first in each time step, and then moving the temperature equation forward by one time interval.</p>
<p>The problem under consideration in this current section is with the Stokes problem: if we discretize it as usual, we get a linear system </p><p class="formulaDsp">
\begin{eqnarray*} M \; X = \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F_U \\ 0 \end{array}\right) = F \end{eqnarray*}
</p>
<p> which in this program we will solve with a FGMRES solver. This solver iterates until the residual of these linear equations is below a certain tolerance, i.e., until </p><p class="formulaDsp">
\[ \left\| \left(\begin{array}{c} F_U - A U^{(k)} - B P^{(k)} \\ B^T U^{(k)} \end{array}\right) \right\| &lt; \text{Tol}. \]
</p>
<p> This does not make any sense from the viewpoint of physical units: the quantities involved here have physical units so that the first part of the residual has units \(\frac{\text{Pa}}{\text{m}} \text{m}^{\text{dim}}\) (most easily established by considering the term \((\nabla \cdot \mathbf v, p)_{\Omega}\) and considering that the pressure has units \(\text{Pa}=\frac{\text{kg}}{\text{m}\;\text{s}^2}\) and the integration yields a factor of \(\text{m}^{\text{dim}}\)), whereas the second part of the residual has units \(\frac{\text{m}^{\text{dim}}}{\text{s}}\). Taking the norm of this residual vector would yield a quantity with units \(\text{m}^{\text{dim}-1} \sqrt{\left(\text{Pa}\right)^2 + \left(\frac{\text{m}}{\text{s}}\right)^2}\). This, quite obviously, does not make sense, and we should not be surprised that doing so is eventually going to come back hurting us.</p>
<p>So why is this an issue here, but not in <a class="el" href="step_31.html">step-31</a>? The reason back there is that everything was nicely balanced: velocities were on the order of one, the pressure likewise, the viscosity was one, and the domain had a diameter of \(\sqrt{2}\). As a result, while nonsensical, nothing bad happened. On the other hand, as we will explain below, things here will not be that simply scaled: \(\eta\) will be around \(10^{21}\), velocities on the order of \(10^{-8}\), pressure around \(10^8\), and the diameter of the domain is \(10^7\). In other words, the order of magnitude for the first equation is going to be \(\eta\text{div}\varepsilon(\mathbf u) \approx 10^{21} \frac{10^{-8}}{(10^7)^2} \approx 10^{-1}\), whereas the second equation will be around \(\text{div}{\mathbf u}\approx \frac{10^{-8}}{10^7} \approx 10^{-15}\). Well, so what this will lead to is this: if the solver wants to make the residual small, it will almost entirely focus on the first set of equations because they are so much bigger, and ignore the divergence equation that describes mass conservation. That's exactly what happens: unless we set the tolerance to extremely small values, the resulting flow field is definitely not divergence free. As an auxiliary problem, it turns out that it is difficult to find a tolerance that always works; in practice, one often ends up with a tolerance that requires 30 or 40 iterations for most time steps, and 10,000 for some others.</p>
<p>So what's a numerical analyst to do in a case like this? The answer is to start at the root and first make sure that everything is mathematically consistent first. In our case, this means that if we want to solve the system of Stokes equations jointly, we have to scale them so that they all have the same physical dimensions. In our case, this means multiplying the second equation by something that has units \(\frac{\text{Pa}\;\text{s}}{\text{m}}\); one choice is to multiply with \(\frac{\eta}{L}\) where \(L\) is a typical lengthscale in our domain (which experiments show is best chosen to be the diameter of plumes &mdash; around 10 km &mdash; rather than the diameter of the domain). Using these numbers for \(\eta\) and \(L\), this factor is around \(10^{17}\). So, we now get this for the Stokes system: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T) \; \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> The trouble with this is that the result is not symmetric any more (we have \(\frac{\eta}{L} \nabla \cdot\) at the bottom left, but not its transpose operator at the top right). This, however, can be cured by introducing a scaled pressure \(\hat p = \frac{L}{\eta}p\), and we get the scaled equations </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla \left(\frac{\eta}{L} \hat p\right) &amp;=&amp; \rho(T) \; \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> This is now symmetric. Obviously, we can easily recover the original pressure \(p\) from the scaled pressure \(\hat p\) that we compute as a result of this procedure.</p>
<p>In the program below, we will introduce a factor <code>EquationData::pressure_scaling</code> that corresponds to \(\frac{\eta}{L}\), and we will use this factor in the assembly of the system matrix and preconditioner. Because it is annoying and error prone, we will recover the unscaled pressure immediately following the solution of the linear system, i.e., the solution vector's pressure component will immediately be unscaled to retrieve the physical pressure. Since the solver uses the fact that we can use a good initial guess by extrapolating the previous solutions, we also have to scale the pressure immediately <em>before</em> solving.</p>
<p><a class="anchor" id="ChangestotheStokespreconditionerandsolver"></a></p><h3>Changes to the Stokes preconditioner and solver </h3>
<p>In this tutorial program, we apply a variant of the preconditioner used in <a class="el" href="step_31.html">step-31</a>. That preconditioner was built to operate on the system matrix \(M\) in block form such that the product matrix </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1} M = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p> is of a form that Krylov-based iterative solvers like GMRES can solve in a few iterations. We then replaced the exact inverse of \(A\) by the action of an AMG preconditioner \(\tilde{A}\) based on a vector Laplace matrix, approximated the Schur complement \(S = B A^{-1} B^T\) by a mass matrix \(M_p\) on the pressure space and wrote an <code>InverseMatrix</code> class for implementing the action of \(M_p^{-1}\approx S^{-1}\) on vectors. In the InverseMatrix class, we used a CG solve with an incomplete Cholesky (IC) preconditioner for performing the inner solves.</p>
<p>An observation one can make is that we use just the action of a preconditioner for approximating the velocity inverse \(A^{-1}\) (and the outer GMRES iteration takes care of the approximate character of the inverse), whereas we use a more or less <em>exact</em> inverse for \(M_p^{-1}\), realized by a fully converged CG solve. This appears unbalanced, but there's system to this madness: almost all the effort goes into the upper left block to which we apply the AMG preconditioner, whereas even an exact inversion of the pressure mass matrix costs basically nothing. Consequently, if it helps us reduce the overall number of iterations somewhat, then this effort is well spent.</p>
<p>That said, even though the solver worked well for <a class="el" href="step_31.html">step-31</a>, we have a problem here that is a bit more complicated (cells are deformed, the pressure varies by orders of magnitude, and we want to plan ahead for more complicated physics), and so we'll change a few things slightly:</p>
<ul>
<li>For more complex problems, it turns out that using just a single AMG V-cycle as preconditioner is not always sufficient. The outer solver converges just fine most of the time in a reasonable number of iterations (say, less than 50) but there are the occasional time step where it suddenly takes 700 or so. What exactly is going on there is hard to determine, but the problem can be avoided by using a more accurate solver for the top left block. Consequently, we'll want to use a CG iteration to invert the top left block of the preconditioner matrix, and use the AMG as a preconditioner for the CG solver.</li>
<li>The downside of this is that, of course, the Stokes preconditioner becomes much more expensive (approximately 10 times more expensive than when we just use a single V-cycle). Our strategy then is this: let's do up to 30 GMRES iterations with just the V-cycle as a preconditioner and if that doesn't yield convergence, then take the best approximation of the Stokes solution obtained after this first round of iterations and use that as the starting guess for iterations where we use the full inner solver with a rather lenient tolerance as preconditioner. In all our experiments this leads to convergence in only a few additional iterations.</li>
<li>One thing we need to pay attention to is that when using a CG with a lenient tolerance in the preconditioner, then \(y = \tilde A^{-1} r\) is no longer a linear function of \(r\) (it is, of course, if we have a very stringent tolerance in our solver, or if we only apply a single V-cycle). This is a problem since now our preconditioner is no longer a linear operator; in other words, every time GMRES uses it the preconditioner looks different. The standard GMRES solver can't deal with this, leading to slow convergence or even breakdown, but the F-GMRES variant is designed to deal with exactly this kind of situation and we consequently use it.</li>
<li>On the other hand, once we have settled on using F-GMRES we can relax the tolerance used in inverting the preconditioner for \(S\). In <a class="el" href="step_31.html">step-31</a>, we ran a preconditioned CG method on \(\tilde S\) until the residual had been reduced by 7 orders of magnitude. Here, we can again be more lenient because we know that the outer preconditioner doesn't suffer.</li>
<li>In <a class="el" href="step_31.html">step-31</a>, we used a left preconditioner in which we first invert the top left block of the preconditioner matrix, then apply the bottom left (divergence) one, and then invert the bottom right. In other words, the application of the preconditioner acts as a lower left block triangular matrix. Another option is to use a right preconditioner that here would be upper right block triangulation, i.e., we first invert the bottom right Schur complement, apply the top right (gradient) operator and then invert the elliptic top left block. To a degree, which one to choose is a matter of taste. That said, there is one significant advantage to a right preconditioner in GMRES-type solvers: the residual with which we determine whether we should stop the iteration is the true residual, not the norm of the preconditioned equations. Consequently, it is much simpler to compare it to the stopping criterion we typically use, namely the norm of the right hand side vector. In writing this code we found that the scaling issues we discussed above also made it difficult to determine suitable stopping criteria for left-preconditioned linear systems, and consequently this program uses a right preconditioner.</li>
<li>In <a class="el" href="step_31.html">step-31</a>, we used an IC (incomplete Cholesky) preconditioner for the pressure mass matrix in the Schur complement preconditioner and for the solution of the temperature system. Here, we could in principle do the same, but we do choose an even simpler preconditioner, namely a Jacobi preconditioner for both systems. This is because here we target at massively parallel computations, where the decompositions for IC/ILU would have to be performed block-wise for the locally owned degrees of freedom on each processor. This means, that the preconditioner gets more like a Jacobi preconditioner anyway, so we rather start from that variant straight away. Note that we only use the Jacobi preconditioners for CG solvers with mass matrices, where they give optimal (<em>h</em>-independent) convergence anyway, even though they usually require about twice as many iterations as an IC preconditioner.</li>
</ul>
<p>As a final note, let us remark that in <a class="el" href="step_31.html">step-31</a> we computed the Schur complement \(S=B A^{-1} B^T\) by approximating \(-\text{div}(-\eta\Delta)^{-1}\nabla \approx \frac 1{\eta} \mathbf{1}\). Now, however, we have re-scaled the \(B\) and \(B^T\) operators. So \(S\) should now approximate \(-\frac{\eta}{L}\text{div}(-\eta\Delta)^{-1}\nabla \frac{\eta}{L} \approx \left(\frac{\eta}{L}\right)^2 \frac 1{\eta} \mathbf{1}\). We use the discrete form of the right hand side of this as our approximation \(\tilde S\) to \(S\).</p>
<p><a class="anchor" id="Changestotheartificialviscositystabilization"></a></p><h3>Changes to the artificial viscosity stabilization </h3>
<p>Similarly to <a class="el" href="step_31.html">step-31</a>, we will use an artificial viscosity for stabilization based on a residual of the equation. As a difference to <a class="el" href="step_31.html">step-31</a>, we will provide two slightly different definitions of the stabilization parameter. For \(\alpha=1\), we use the same definition as in <a class="el" href="step_31.html">step-31</a>: </p><p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \nu_1(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K \min\left\{ 1, \frac{\|R_1(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\} \end{eqnarray*}
</p>
<p> where we compute the viscosity from a residual \(\|R_1(T)\|_{L^\infty(K)}\) of the equation, limited by a diffusion proportional to the mesh size \(h_K\) in regions where the residual is large (around steep gradients). This definition has been shown to work well for the given case, \(\alpha = 1\) in <a class="el" href="step_31.html">step-31</a>, but it is usually less effective as the diffusion for \(\alpha=2\). For that case, we choose a slightly more readable definition of the viscosity, </p><p class="formulaDsp">
\begin{eqnarray*} \nu_2(T)|_K = \min (\nu_h^\mathrm{max}|_K,\nu_h^\mathrm{E}|_K) \end{eqnarray*}
</p>
<p> where the first term gives again the maximum dissipation (similarly to a first order upwind scheme), </p><p class="formulaDsp">
\begin{eqnarray*} \nu^\mathrm{max}_h|_K = \beta h_K \|\mathbf {u}\|_{L^\infty(K)} \end{eqnarray*}
</p>
<p> and the entropy viscosity is defined as </p><p class="formulaDsp">
\begin{eqnarray*} \nu^\mathrm{E}_h|_K = c_R \frac{h_K^2 \|R_\mathrm{2,E}(T)\|_{L^\infty(K)}} {\|E(T) - \bar{E}(T)\|_{L^\infty(\Omega)} }. \end{eqnarray*}
</p>
<p>This formula is described in the article <em>J.-L. Guermond, R. Pasquetti, &amp; B. Popov, 2011. Entropy viscosity method for nonlinear conservation laws, J. Comput. Phys., 230, 4248&ndash;4267.</em> Compared to the case \(\alpha = 1\), the residual is computed from the temperature entropy, \(E(T) = \frac12 (T-T_m)^2\) with \(T_m\) an average temperature (we choose the mean between the maximum and minimum temperature in the computation), which gives the following formula </p><p class="formulaDsp">
\begin{eqnarray*} R_\mathrm{E}(T) = \frac{\partial E(T)}{\partial t} + (T-T_\mathrm{m}) \left(\mathbf{u} \cdot \nabla T - \kappa \nabla^2 T - \gamma\right). \end{eqnarray*}
</p>
<p> The denominator in the formula for \(\nu^\mathrm{E}_h|_K\) is computed as the global deviation of the entropy from the space-averaged entropy \(\bar{E}(T) = \int_\Omega E(T) d\mathbf{x}/\int_\Omega d\mathbf{x}\). As in <a class="el" href="step_31.html">step-31</a>, we evaluate the artificial viscosity from the temperature and velocity at two previous time levels, in order to avoid a nonlinearity in its definition.</p>
<p>The above definitions of the viscosity are simple, but depend on two parameters, namely \(\beta\) and \(c_R\). For the current program, we want to go about this issue a bit more systematically for both parameters in the case \(\alpha =1\), using the same line of reasoning with which we chose two other parameters in our discretization, \(c_k\) and \(\beta\), in the results section of <a class="el" href="step_31.html">step-31</a>. In particular, remember that we would like to make the artificial viscosity as small as possible while keeping it as large as necessary. In the following, let us describe the general strategy one may follow. The computations shown here were done with an earlier version of the program and so the actual numerical values you get when running the program may no longer match those shown here; that said, the general approach remains valid and has been used to find the values of the parameters actually used in the program.</p>
<p>To see what is happening, note that below we will impose boundary conditions for the temperature between 973 and 4273 Kelvin, and initial conditions are also chosen in this range; for these considerations, we run the program without internal heat sources or sinks, and consequently the temperature should always be in this range, barring any internal oscillations. If the minimal temperature drops below 973 Kelvin, then we need to add stabilization by either increasing \(\beta\) or decreasing \(c_R\).</p>
<p>As we did in <a class="el" href="step_31.html">step-31</a>, we first determine an optimal value of \(\beta\) by using the "traditional" formula </p><p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K, \end{eqnarray*}
</p>
<p> which we know to be stable if only \(\beta\) is large enough. Doing a couple hundred time steps (on a coarser mesh than the one shown in the program, and with a different viscosity that affects transport velocities and therefore time step sizes) in 2d will produce the following graph:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.beta.2d.png"/>
</div>
<p>As can be seen, values \(\beta \le 0.05\) are too small whereas \(\beta=0.052\) appears to work, at least to the time horizon shown here. As a remark on the side, there are at least two questions one may wonder here: First, what happens at the time when the solution becomes unstable? Looking at the graphical output, we can see that with the unreasonably coarse mesh chosen for these experiments, around time \(t=10^{15}\) seconds the plumes of hot material that have been rising towards the cold outer boundary and have then spread sideways are starting to get close to each other, squeezing out the cold material in-between. This creates a layer of cells into which fluids flows from two opposite sides and flows out toward a third, apparently a scenario that then produce these instabilities without sufficient stabilization. Second: In <a class="el" href="step_31.html">step-31</a>, we used \(\beta=0.015\cdot\text{dim}\); why does this not work here? The answer to this is not entirely clear &ndash; stabilization parameters are certainly known to depend on things like the shape of cells, for which we had squares in <a class="el" href="step_31.html">step-31</a> but have trapezoids in the current program. Whatever the exact cause, we at least have a value of \(\beta\), namely 0.052 for 2d, that works for the current program. A similar set of experiments can be made in 3d where we find that \(\beta=0.078\) is a good choice &mdash; neatly leading to the formula \(\beta=0.026 \cdot \textrm{dim}\).</p>
<p>With this value fixed, we can go back to the original formula for the viscosity \(\nu\) and play with the constant \(c_R\), making it as large as possible in order to make \(\nu\) as small as possible. This gives us a picture like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.beta_cr.2d.png"/>
</div>
<p>Consequently, \(c_R=0.1\) would appear to be the right value here. While this graph has been obtained for an exponent \(\alpha=1\), in the program we use \(\alpha=2\) instead, and in that case one has to re-tune the parameter (and observe that \(c_R\) appears in the numerator and not in the denominator). It turns out that \(c_R=1\) works with \(\alpha=2\).</p>
<p><a class="anchor" id="LocallyconservativeStokesdiscretization"></a></p><h3>Locally conservative Stokes discretization </h3>
<p>The standard Taylor-Hood discretization for Stokes, using the \(Q_{k+1}^d \times Q_k\) element, is globally conservative, i.e. \(\int_{\partial\Omega} \mathbf n \cdot \mathbf u_h = 0\). This can easily be seen: the weak form of the divergence equation reads \((q_h, \textrm{div}\; \mathbf u_h)=0, \forall q_h\in Q_h\). Because the pressure space does contain the function \(q_h=1\), we get </p><p class="formulaDsp">
\begin{align*} 0 = (1, \textrm{div}\; \mathbf u_h)_\Omega = \int_\Omega \textrm{div}\; \mathbf u_h = \int_{\partial\Omega} \mathbf n \cdot \mathbf u_h \end{align*}
</p>
<p> by the divergence theorem. This property is important: if we want to use the velocity field \(u_h\) to transport along other quantities (such as the temperature in the current equations, but it could also be concentrations of chemical substances or entirely artificial tracer quantities) then the conservation property guarantees that the amount of the quantity advected remains constant.</p>
<p>That said, there are applications where this <em>global</em> property is not enough. Rather, we would like that it holds <em>locally</em>, on every cell. This can be achieved by using the space \(Q_{k+1}^d \times DGP_k\) for discretization, where we have replaced the <em>continuous</em> space of tensor product polynomials of degree \(k\) for the pressure by the <em>discontinuous</em> space of the complete polynomials of the same degree. (Note that tensor product polynomials in 2d contain the functions \(1, x, y, xy\), whereas the complete polynomials only have the functions \(1,x,y\).) This space turns out to be stable for the Stokes equation.</p>
<p>Because the space is discontinuous, we can now in particular choose the test function \(q_h(\mathbf x)=\chi_K(\mathbf x)\), i.e. the characteristic function of cell \(K\). We then get in a similar fashion as above </p><p class="formulaDsp">
\begin{align*} 0 = (q_h, \textrm{div}\; \mathbf u_h)_\Omega = (1, \textrm{div}\; \mathbf u_h)_K = \int_K \textrm{div}\; \mathbf u_h = \int_{\partial K} \mathbf n \cdot \mathbf u_h, \end{align*}
</p>
<p> showing the conservation property for cell \(K\). This clearly holds for each cell individually.</p>
<p>There are good reasons to use this discretization. As mentioned above, this element guarantees conservation of advected quantities on each cell individually. A second advantage is that the pressure mass matrix we use as a preconditioner in place of the Schur complement becomes block diagonal and consequently very easy to invert. However, there are also downsides. For one, there are now more pressure variables, increasing the overall size of the problem, although this doesn't seem to cause much harm in practice. More importantly, though, the fact that now the divergence integrated over each cell is zero when it wasn't before does not guarantee that the divergence is pointwise smaller. In fact, as one can easily verify, the \(L_2\) norm of the divergence is <em>larger</em> for this than for the standard Taylor-Hood discretization. (However, both converge at the same rate to zero, since it is easy to see that \(\|\textrm{div}\; u_h\|= \|\textrm{div}\; (u-u_h)\|= \|\textrm{trace}\; \nabla (u-u_h)\|\le \|\nabla (u-u_h)\|={\cal O}(h^{k+2})\).) It is therefore not a priori clear that the error is indeed smaller just because we now have more degrees of freedom.</p>
<p>Given these considerations, it remains unclear which discretization one should prefer. Consequently, we leave that up to the user and make it a parameter in the input file which one to use.</p>
<p><a class="anchor" id="Higherordermappingsforcurvedboundaries"></a></p><h3>Higher order mappings for curved boundaries </h3>
<p>In the program, we will use a spherical shell as domain. This means that the inner and outer boundary of the domain are no longer "straight" (by which we usually mean that they are bilinear surfaces that can be represented by the <a class="el" href="classFlatManifold.html">FlatManifold</a> class). Rather, they are curved and it seems prudent to use a curved approximation in the program if we are already using higher order finite elements for the velocity. Consequently, we will introduce a member variable of type <a class="el" href="classMappingQ.html">MappingQ</a> that denotes such a mapping (<a class="el" href="step_10.html">step-10</a> and <a class="el" href="step_11.html">step-11</a> introduce such mappings for the first time) and that we will use in all computations on cells that are adjacent to the boundary. Since this only affects a relatively small fraction of cells, the additional effort is not very large and we will take the luxury of using a quartic mapping for these cells.</p>
<p><a class="anchor" id="Parallelizationonclusters"></a></p><h3>Parallelization on clusters </h3>
<p>Running convection codes in 3d with significant Rayleigh numbers requires a lot of computations &mdash; in the case of whole earth simulations on the order of one or several hundred million unknowns. This can obviously not be done with a single machine any more (at least not in 2010 when we started writing this code). Consequently, we need to parallelize it. Parallelization of scientific codes across multiple machines in a cluster of computers is almost always done using the Message Passing Interface (MPI). This program is no exception to that, and it follows the general spirit of the <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> programs in this though in practice it borrows more from <a class="el" href="step_40.html">step-40</a> in which we first introduced the classes and strategies we use when we want to <em>completely</em> distribute all computations, and <a class="el" href="step_55.html">step-55</a> that shows how to do that for <a class="el" href="group__vector__valued.html">vector-valued problems</a>: including, for example, splitting the mesh up into a number of parts so that each processor only stores its own share plus some ghost cells, and using strategies where no processor potentially has enough memory to hold the entries of the combined solution vector locally. The goal is to run this code on hundreds or maybe even thousands of processors, at reasonable scalability.</p>
<dl class="section note"><dt>Note</dt><dd>Even though it has a larger number, <a class="el" href="step_40.html">step-40</a> comes logically before the current program. The same is true for <a class="el" href="step_55.html">step-55</a>. You will probably want to look at these programs before you try to understand what we do here.</dd></dl>
<p>MPI is a rather awkward interface to program with. It is a semi-object oriented set of functions, and while one uses it to send data around a network, one needs to explicitly describe the data types because the MPI functions insist on getting the address of the data as <code>void*</code> objects rather than deducing the data type automatically through overloading or templates. We've already seen in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> how to avoid almost all of MPI by putting all the communication necessary into either the deal.II library or, in those programs, into PETSc. We'll do something similar here: like in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_55.html">step-55</a>, deal.II and the underlying p4est library are responsible for all the communication necessary for distributing the mesh, and we will let the Trilinos library (along with the wrappers in namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a>) deal with parallelizing the linear algebra components. We have already used Trilinos in <a class="el" href="step_31.html">step-31</a>, and will do so again here, with the difference that we will use its parallel capabilities.</p>
<p>Trilinos consists of a significant number of packages, implementing basic parallel linear algebra operations (the Epetra package), different solver and preconditioner packages, and on to things that are of less importance to deal.II (e.g., optimization, uncertainty quantification, etc). deal.II's Trilinos interfaces encapsulate many of the things Trilinos offers that are of relevance to PDE solvers, and provides wrapper classes (in namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a>) that make the Trilinos matrix, vector, solver and preconditioner classes look very much the same as deal.II's own implementations of this functionality. However, as opposed to deal.II's classes, they can be used in parallel if we give them the necessary information. As a consequence, there are two Trilinos classes that we have to deal with directly (rather than through wrappers), both of which are part of Trilinos' Epetra library of basic linear algebra and tool classes: </p><ul>
<li>
<p class="startli">The Epetra_Comm class is an abstraction of an MPI "communicator", i.e., it describes how many and which machines can communicate with each other. Each distributed object, such as a sparse matrix or a vector for which we may want to store parts on different machines, needs to have a communicator object to know how many parts there are, where they can be found, and how they can be accessed.</p>
<p>In this program, we only really use one communicator object &ndash; based on the MPI variable <code>MPI_COMM_WORLD</code> &ndash; that encompasses <em>all</em> processes that work together. It would be perfectly legitimate to start a process on \(N\) machines but only store vectors on a subset of these by producing a communicator object that only encompasses this subset of machines; there is really no compelling reason to do so here, however.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The <a class="el" href="classIndexSet.html">IndexSet</a> class is used to describe which elements of a vector or which rows of a matrix should reside on the current machine that is part of a communicator. To create such an object, you need to know (i) the total number of elements or rows, (ii) the indices of the elements you want to store locally. We will set up these <code>partitioners</code> in the <code>BoussinesqFlowProblem::setup_dofs</code> function below and then hand it to every parallel object we create.</p>
<p class="endli">Unlike PETSc, Trilinos makes no assumption that the elements of a vector need to be partitioned into contiguous chunks. At least in principle, we could store all elements with even indices on one processor and all odd ones on another. That's not very efficient, of course, but it's possible. Furthermore, the elements of these partitionings do not necessarily be mutually exclusive. This is important because when postprocessing solutions, we need access to all locally relevant or at least the locally active degrees of freedom (see the module on <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> for a definition, as well as the discussion in <a class="el" href="step_40.html">step-40</a>). Which elements the Trilinos vector considers as locally owned is not important to us then. All we care about is that it stores those elements locally that we need. </p>
</li>
</ul>
<p>There are a number of other concepts relevant to distributing the mesh to a number of processors; you may want to take a look at the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module and <a class="el" href="step_40.html">step-40</a> or <a class="el" href="step_55.html">step-55</a> before trying to understand this program. The rest of the program is almost completely agnostic about the fact that we don't store all objects completely locally. There will be a few points where we have to limit loops over all cells to those that are locally owned, or where we need to distinguish between vectors that store only locally owned elements and those that store everything that is locally relevant (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">this glossary entry</a>), but by and large the amount of heavy lifting necessary to make the program run in parallel is well hidden in the libraries upon which this program builds. In any case, we will comment on these locations as we get to them in the program code.</p>
<p><a class="anchor" id="Parallelizationwithinindividualnodesofacluster"></a></p><h3>Parallelization within individual nodes of a cluster </h3>
<p>The second strategy to parallelize a program is to make use of the fact that most computers today have more than one processor that all have access to the same memory. In other words, in this model, we don't explicitly have to say which pieces of data reside where &ndash; all of the data we need is directly accessible and all we have to do is split <em>processing</em> this data between the available processors. We will then couple this with the MPI parallelization outlined above, i.e., we will have all the processors on a machine work together to, for example, assemble the local contributions to the global matrix for the cells that this machine actually "owns" but not for those cells that are owned by other machines. We will use this strategy for four kinds of operations we frequently do in this program: assembly of the Stokes and temperature matrices, assembly of the matrix that forms the Stokes preconditioner, and assembly of the right hand side of the temperature system.</p>
<p>All of these operations essentially look as follows: we need to loop over all cells for which <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> equals the index our machine has within the communicator object used for all communication (i.e., <code>MPI_COMM_WORLD</code>, as explained above). The test we are actually going to use for this, and which describes in a concise way why we test this condition, is <code>cell-&gt;is_locally_owned()</code>. On each such cell we need to assemble the local contributions to the global matrix or vector, and then we have to copy each cell's contribution into the global matrix or vector. Note that the first part of this (the loop) defines a range of iterators on which something has to happen. The second part, assembly of local contributions is something that takes the majority of CPU time in this sequence of steps, and is a typical example of things that can be done in parallel: each cell's contribution is entirely independent of all other cells' contributions. The third part, copying into the global matrix, must not happen in parallel since we are modifying one object and so several threads can not at the same time read an existing matrix element, add their contribution, and write the sum back into memory without danger of producing a <a href="http://en.wikipedia.org/wiki/Race_condition">race condition</a>.</p>
<p>deal.II has a class that is made for exactly this workflow: <a class="el" href="namespaceWorkStream.html">WorkStream</a>, first discussed in <a class="el" href="step_9.html">step-9</a> and <a class="el" href="step_13.html">step-13</a>. Its use is also extensively documented in the module on <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> (in the section on <a class="el" href="group__threads.html#MTWorkStream">the WorkStream class</a>) and we won't repeat here the rationale and detailed instructions laid out there, though you will want to read through this module to understand the distinction between scratch space and per-cell data. Suffice it to mention that we need the following:</p>
<ul>
<li>An iterator range for those cells on which we are supposed to work. This is provided by the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> class which acts just like every other cell iterator in deal.II with the exception that it skips all cells that do not satisfy a particular predicate (i.e., a criterion that evaluates to true or false). In our case, the predicate is whether a cell is locally owned.</li>
<li>A function that does the work on each cell for each of the tasks identified above, i.e., functions that assemble the local contributions to Stokes matrix and preconditioner, temperature matrix, and temperature right hand side. These are the <code>BoussinesqFlowProblem::local_assemble_stokes_system</code>, <code>BoussinesqFlowProblem::local_assemble_stokes_preconditioner</code>, <code>BoussinesqFlowProblem::local_assemble_temperature_matrix</code>, and <code>BoussinesqFlowProblem::local_assemble_temperature_rhs</code> functions in the code below. These four functions can all have several instances running in parallel at the same time.</li>
<li>Functions that copy the result of the previous ones into the global object and that run sequentially to avoid race conditions. These are the <code>BoussinesqFlowProblem::copy_local_to_global_stokes_system</code>, <code>BoussinesqFlowProblem::copy_local_to_global_stokes_preconditioner</code>, <code>BoussinesqFlowProblem::copy_local_to_global_temperature_matrix</code>, and <code>BoussinesqFlowProblem::copy_local_to_global_temperature_rhs</code> functions.</li>
</ul>
<p>We will comment on a few more points in the actual code, but in general their structure should be clear from the discussion in <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a>.</p>
<p>The underlying technology for <a class="el" href="namespaceWorkStream.html">WorkStream</a> identifies "tasks" that need to be worked on (e.g. assembling local contributions on a cell) and schedules these tasks automatically to available processors. <a class="el" href="namespaceWorkStream.html">WorkStream</a> creates these tasks automatically, by splitting the iterator range into suitable chunks.</p>
<dl class="section note"><dt>Note</dt><dd>Using multiple threads within each MPI process only makes sense if you have fewer MPI processes running on each node of your cluster than there are processor cores on this machine. Otherwise, MPI will already keep your processors busy and you won't get any additional speedup from using threads. For example, if your cluster nodes have 8 cores as they often have at the time of writing this, and if your batch scheduler puts 8 MPI processes on each node, then using threads doesn't make the program any faster. Consequently, you probably want to either configure your deal.II without threads, or set the number of threads in <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> to 1 (third argument), or "export DEAL_II_NUM_THREADS=1" before running. That said, at the time of writing this, we only use the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class for assembling (parts of) linear systems, while 75% or more of the run time of the program is spent in the linear solvers that are not parallelized &mdash; in other words, the best we could hope is to parallelize the remaining 25%.</dd></dl>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase </h3>
<p>The setup for this program is mildly reminiscent of the problem we wanted to solve in the first place (see the introduction of <a class="el" href="step_31.html">step-31</a>): convection in the earth mantle. As a consequence, we choose the following data, all of which appears in the program in units of meters and seconds (the SI system) even if we list them here in other units. We do note, however, that these choices are essentially still only exemplary, and not meant to result in a completely realistic description of convection in the earth mantle: for that, more and more difficult physics would have to be implemented, and several other aspects are currently missing from this program as well. We will come back to this issue in the results section again, but state for now that providing a realistic description is a goal of the <em>ASPECT</em> code in development at the time of writing this.</p>
<p>As a reminder, let us again state the equations we want to solve are these: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla \left( \frac{\eta}{L} \hat p\right) &amp;=&amp; \rho(T) \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
<p> augmented by boundary and initial conditions. We then have to choose data for the following quantities: </p><ul>
<li>
<p class="startli">The domain is an annulus (in 2d) or a spherical shell (in 3d) with inner and outer radii that match that of the earth: the total radius of the earth is 6371km, with the mantle starting at a depth of around 35km (just under the solid earth <a href="http://en.wikipedia.org/wiki/Crust_(geology)" target="_top">crust</a> composed of <a href="http://en.wikipedia.org/wiki/Continental_crust" target="_top">continental</a> and <a href="http://en.wikipedia.org/wiki/Oceanic_crust" target="_top">oceanic plates</a>) to a depth of 2890km (where the <a href="http://en.wikipedia.org/wiki/Outer_core" target="_top">outer earth core</a> starts). The radii are therefore \(R_0=(6371-2890)\text{km}, R_1=(6371-35)\text{km}\). This domain is conveniently generated using the <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> function.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">At the interface between crust and mantle, the temperature is between 500 and 900 degrees Celsius, whereas at its bottom it is around 4000 degrees Celsius (see, for example, <a href="http://en.wikipedia.org/wiki/Mantle_(geology)" target="_top">this Wikipedia entry</a>). In Kelvin, we therefore choose \(T_0=(4000+273)\text{K}\), \(T_1=(500+273)\text{K}\) as boundary conditions at the inner and outer edge.</p>
<p>In addition to this, we also have to specify some initial conditions for the temperature field. The real temperature field of the earth is quite complicated as a consequence of the convection that has been going on for more than four billion years &ndash; in fact, it is the properties of this temperature distribution that we want to explore with programs like this. As a consequence, we don't really have anything useful to offer here, but we can hope that if we start with something and let things run for a while that the exact initial conditions don't matter that much any more &mdash; as is in fact suggested by looking at the pictures shown in the <a href="#Results">results section below</a>. The initial temperature field we use here is given in terms of the radius by </p><p class="formulaDsp">
\begin{align*} s &amp;= \frac{\|\mathbf x\|-R_0}{R_1-R_0}, \\ \varphi &amp;= \arctan \frac{y}{x}, \\ \tau &amp;= s + \frac 15 s(1-s) \sin(6\varphi) q(z), \\ T(\mathbf x) &amp;= T_0(1-\tau) + T_1\tau, \end{align*}
</p>
<p> where </p><p class="formulaDsp">
\begin{align*} q(z) = \left\{ \begin{array}{ll} 1 &amp; \text{in 2d} \\ \max\{0, \cos(\pi |z/R_1|)\} &amp; \text{in 3d} \end{array} \right. . \end{align*}
</p>
<p> This complicated function is essentially a perturbation of a linear profile between the inner and outer temperatures. In 2d, the function \(\tau=\tau(\mathbf x)\) looks like this (I got the picture from <a href="http://www.wolframalpha.com/input/?i=plot+%28sqrt%28x^2%2By^2%29%2B0.2*%28sqrt%28x^2%2By^2%29*%281-sqrt%28x^2%2By^2%29%29*sin%286*atan2%28x%2Cy%29%29%29%2C+x%3D-1+to+1%2C+y%3D-1+to+1">this page</a>):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d-initial.png"/>
</div>
<p>The point of this profile is that if we had used \(s\) instead of \(\tau\) in the definition of \(T(\mathbf x)\) then it would simply be a linear interpolation. \(\tau\) has the same function values as \(s\) on the inner and outer boundaries (zero and one, respectively), but it stretches the temperature profile a bit depending on the angle and the \(z\) value in 3d, producing an angle-dependent perturbation of the linearly interpolating field. We will see in the results section that this is an entirely unphysical temperature field (though it will make for interesting images) as the equilibrium state for the temperature will be an almost constant temperature with boundary layers at the inner and outer boundary.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The right hand side of the temperature equation contains the rate of internal heating \(\gamma\). The earth does heat naturally through several mechanisms: radioactive decay, chemical separation (heavier elements sink to the bottom, lighter ones rise to the top; the countercurrents dissipate energy equal to the loss of potential energy by this separation process); heat release by crystallization of liquid metal as the solid inner core of the earth grows; and heat dissipation from viscous friction as the fluid moves.</p>
<p>Chemical separation is difficult to model since it requires modeling mantle material as multiple phases; it is also a relatively small effect. Crystallization heat is even more difficult since it is confined to areas where temperature and pressure allow for phase changes, i.e., a discontinuous process. Given the difficulties in modeling these two phenomena, we will neglect them.</p>
<p>The other two are readily handled and, given the way we scaled the temperature equation, lead to the equation </p><p class="formulaDsp">
\[ \gamma(\mathbf x) = \frac{\rho q+2\eta \varepsilon(\mathbf u):\varepsilon(\mathbf u)} {\rho c_p}, \]
</p>
<p> where \(q\) is the radiogenic heating in \(\frac{W}{kg}\), and the second term in the enumerator is viscous friction heating. \(\rho\) is the density and \(c_p\) is the specific heat. The literature provides the following approximate values: \(c_p=1250 \frac{J}{kg\; K}, q=7.4\cdot 10^{-12}\frac{W}{kg}\). The other parameters are discussed elsewhere in this section.</p>
<p>We neglect one internal heat source, namely adiabatic heating here, which will lead to a surprising temperature field. This point is commented on in detail in the results section below.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">For the velocity we choose as boundary conditions \(\mathbf{v}=0\) at the inner radius (i.e., the fluid sticks to the earth core) and \(\mathbf{n}\cdot\mathbf{v}=0\) at the outer radius (i.e., the fluid flows tangentially along the bottom of the earth crust). Neither of these is physically overly correct: certainly, on both boundaries, fluids can flow tangentially, but they will incur a shear stress through friction against the medium at the other side of the interface (the metallic core and the crust, respectively). Such a situation could be modeled by a Robin-type boundary condition for the tangential velocity; in either case, the normal (vertical) velocity would be zero, although even that is not entirely correct since continental plates also have vertical motion (see, for example, the phenomenon of <a href="http://en.wikipedia.org/wiki/Postglacial_rebound">post-glacial rebound</a>). But to already make things worse for the tangential velocity, the medium on the other side is in motion as well, so the shear stress would, in the simplest case, be proportional to the <em>velocity difference</em>, leading to a boundary condition of the form </p><p class="formulaDsp">
\begin{align*} \mathbf{n}\cdot [2\eta \varepsilon(\mathbf v)] &amp;= s \mathbf{n} \times [\mathbf v - \mathbf v_0], \\ \mathbf{n} \cdot \mathbf v &amp;= 0, \end{align*}
</p>
<p> with a proportionality constant \(s\). Rather than going down this route, however, we go with the choice of zero (stick) and tangential flow boundary conditions.</p>
<p>As a side note of interest, we may also have chosen tangential flow conditions on both inner and outer boundary. That has a significant drawback, however: it leaves the velocity not uniquely defined. The reason is that all velocity fields \(\hat{\mathbf v}\) that correspond to a solid body rotation around the center of the domain satisfy \(\mathrm{div}\; \varepsilon(\hat{\mathbf v})=0, \mathrm{div} \;\hat{\mathbf v} = 0\), and \(\mathbf{n} \cdot \hat{\mathbf v} = 0\). As a consequence, if \(\mathbf v\) satisfies equations and boundary conditions, then so does \(\mathbf v + \hat{\mathbf v}\). That's certainly not a good situation that we would like to avoid. The traditional way to work around this is to pick an arbitrary point on the boundary and call this your fixed point by choosing the velocity to be zero in all components there. (In 3d one has to choose two points.) Since this program isn't meant to be too realistic to begin with, we avoid this complication by simply fixing the velocity along the entire interior boundary.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">To first order, the gravity vector always points downward. The question for a body as big as the earth is just: where is "up". The naive answer of course is "radially inward, towards the center of the earth". So at the surface of the earth, we have </p><p class="formulaDsp">
\[ \mathbf g = -9.81 \frac{\text{m}}{\text{s}^2} \frac{\mathbf x}{\|\mathbf x\|}, \]
</p>
<p> where \(9.81 \frac{\text{m}}{\text{s}^2}\) happens to be the average gravity acceleration at the earth surface. But in the earth interior, the question becomes a bit more complicated: at the (bary-)center of the earth, for example, you have matter pulling equally hard in all directions, and so \(\mathbf g=0\). In between, the net force is described as follows: let us define the <a href="http://en.wikipedia.org/wiki/Potential_energy#Gravitational_potential_energy" target="_top">gravity potential</a> by </p><p class="formulaDsp">
\[ \varphi(\mathbf x) = \int_{\text{earth}} -G \frac{\rho(\mathbf y)}{\|\mathbf x-\mathbf y\|} \ \text{d}y, \]
</p>
<p> then \(\mathbf g(\mathbf x) = -\nabla \varphi(\mathbf x)\). If we assume that the density \(\rho\) is constant throughout the earth, we can produce an analytical expression for the gravity vector (don't try to integrate above equation somehow &ndash; it leads to elliptic integrals; a simpler way is to notice that \(-\Delta\varphi(\mathbf x) = -4\pi G \rho \chi_{\text{earth}}(\mathbf x)\) and solving this partial differential equation in all of \({\mathbb R}^3\) exploiting the radial symmetry): </p><p class="formulaDsp">
\[ \mathbf g(\mathbf x) = \left\{ \begin{array}{ll} -\frac{4}{3}\pi G \rho \|\mathbf x\| \frac{\mathbf x}{\|\mathbf x\|} &amp; \text{for} \ \|\mathbf x\|&lt;R_1, \\ -\frac{4}{3}\pi G \rho R^3 \frac{1}{\|\mathbf x\|^2} \frac{\mathbf x}{\|\mathbf x\|} &amp; \text{for} \ \|\mathbf x\|\ge R_1. \end{array} \right. \]
</p>
<p> The factor \(-\frac{\mathbf x}{\|\mathbf x\|}\) is the unit vector pointing radially inward. Of course, within this problem, we are only interested in the branch that pertains to within the earth, i.e., \(\|\mathbf x\|&lt;R_1\). We would therefore only consider the expression </p><p class="formulaDsp">
\[ \mathbf g(\mathbf x) = -\frac{4}{3}\pi G \rho \|\mathbf x\| \frac{\mathbf x}{\|\mathbf x\|} = -\frac{4}{3}\pi G \rho \mathbf x = - 9.81 \frac{\mathbf x}{R_1} \frac{\text{m}}{\text{s}^2}, \]
</p>
<p> where we can infer the last expression because we know Earth's gravity at the surface (where \(\|x\|=R_1\)).</p>
<p>One can derive a more general expression by integrating the differential equation for \(\varphi(r)\) in the case that the density distribution is radially symmetric, i.e., \(\rho(\mathbf x)=\rho(\|\mathbf x\|)=\rho(r)\). In that case, one would get </p><p class="formulaDsp">
\[ \varphi(r) = 4\pi G \int_0^r \frac 1{s^2} \int_0^s t^2 \rho(t) \; dt \; ds. \]
</p>
<p>There are two problems with this, however: (i) The Earth is not homogeneous, i.e., the density \(\rho\) depends on \(\mathbf x\); in fact it is not even a function that only depends on the radius \(r=\|\mathbf x\|\). In reality, gravity therefore does not always decrease as we get deeper: because the earth core is so much denser than the mantle, gravity actually peaks at around \(10.7 \frac{\text{m}}{\text{s}^2}\) at the core mantle boundary (see <a href="http://en.wikipedia.org/wiki/Earth&apos;s_gravity" target="_top">this article</a>). (ii) The density, and by consequence the gravity vector, is not even constant in time: after all, the problem we want to solve is the time dependent upwelling of hot, less dense material and the downwelling of cold dense material. This leads to a gravity vector that varies with space and time, and does not always point straight down.</p>
<p>In order to not make the situation more complicated than necessary, we could use the approximation that at the inner boundary of the mantle, gravity is \(10.7 \frac{\text{m}}{\text{s}^2}\) and at the outer boundary it is \(9.81 \frac{\text{m}}{\text{s}^2}\), in each case pointing radially inward, and that in between gravity varies linearly with the radial distance from the earth center. That said, it isn't that hard to actually be slightly more realistic and assume (as we do below) that the earth mantle has constant density. In that case, the equation above can be integrated and we get an expression for \(\|\mathbf{g}\|\) where we can fit constants to match the gravity at the top and bottom of the earth mantle to obtain </p><p class="formulaDsp">
\[ \|\mathbf{g}\| = 1.245\cdot 10^{-6} \frac{1}{\textrm{s}^2} r + 7.714\cdot 10^{13} \frac{\textrm{m}^3}{\textrm{s}^2}\frac{1}{r^2}. \]
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The density of the earth mantle varies spatially, but not by very much. \(\rho_{\text{ref}}=3300 \frac{\text{kg}}{\text{m}^3}\) is a relatively good average value for the density at reference temperature \(T_{\text{ref}}=293\) Kelvin.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The thermal expansion coefficient \(\beta\) also varies with depth (through its dependence on temperature and pressure). Close to the surface, it appears to be on the order of \(\beta=45\cdot 10^{-6} \frac 1{\text{K}}\), whereas at the core mantle boundary, it may be closer to \(\beta=10\cdot 10^{-6} \frac 1{\text{K}}\). As a reasonable value, let us choose \(\beta=2\cdot 10^{-5} \frac 1{\text{K}}\). The density as a function of temperature is then \(\rho(T)=[1-\beta(T-T_{\text{ref}})]\rho_{\text{ref}}\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The second to last parameter we need to specify is the viscosity \(\eta\). This is a tough one, because rocks at the temperatures and pressure typical for the earth mantle flow so slowly that the viscosity can not be determined accurately in the laboratory. So how do we know about the viscosity of the mantle? The most commonly used route is to consider that during and after ice ages, ice shields form and disappear on time scales that are shorter than the time scale of flow in the mantle. As a consequence, continents slowly sink into the earth mantle under the added weight of an ice shield, and they rise up again slowly after the ice shield has disappeared again (this is called <a href="http://en.wikipedia.org/wiki/Postglacial_rebound" target="_top"><em>postglacial rebound</em></a>). By measuring the speed of this rebound, we can infer the viscosity of the material that flows into the area vacated under the rebounding continental plates.</p>
<p>Using this technique, values around \(\eta=10^{21} \text{Pa}\;\text{s} = 10^{21} \frac{\text{N}\;\text{s}}{\text{m}^2} = 10^{21} \frac{\text{kg}}{\text{m}\;\text{s}}\) have been found as the most likely, though the error bar on this is at least one order of magnitude.</p>
<p>While we will use this value, we again have to caution that there are many physical reasons to assume that this is not the correct value. First, it should really be made dependent on temperature: hotter material is most likely to be less viscous than colder material. In reality, however, the situation is even more complex. Most rocks in the mantle undergo phase changes as temperature and pressure change: depending on temperature and pressure, different crystal configurations are thermodynamically favored over others, even if the chemical composition of the mantle were homogeneous. For example, the common mantle material MgSiO<sub>3</sub> exists in its <a href="http://en.wikipedia.org/wiki/Perovskite_(structure)" target="_top">perovskite structure</a> throughout most of the mantle, but in the lower mantle the same substance is stable only as <a href="http://en.wikipedia.org/wiki/Postperovskite" targe="_top">post-perovskite</a>. Clearly, to compute realistic viscosities, we would not only need to know the exact chemical composition of the mantle and the viscosities of all materials, but we would also have to compute the thermodynamically most stable configurations for all materials at each quadrature point. This is at the time of writing this program not a feasible suggestion.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Our last material parameter is the thermal diffusivity \(\kappa\), which is defined as \(\kappa=\frac{k}{\rho c_p}\) where \(k\) is the thermal conductivity, \(\rho\) the density, and \(c_p\) the specific heat. For this, the literature indicates that it increases from around \(0.7\) in the upper mantle to around \(1.7 \frac{\text{mm}^2}{\text{s}}\) in the lower mantle, though the exact value is not really all that important: heat transport through convection is several orders of magnitude more important than through thermal conduction. It may be of interest to know that perovskite, the most abundant material in the earth mantle, appears to become transparent at pressures above around 120 GPa (see, for example, J. Badro et al., Science 305, 383-386 (2004)); in the lower mantle, it may therefore be that heat transport through radiative transfer is more efficient than through thermal conduction.</p>
<p class="endli">In view of these considerations, let us choose \(\kappa=1 \frac{\text{mm}^2}{\text{s}} =10^{-6} \frac{\text{m}^2}{\text{s}}\) for the purpose of this program. </p>
</li>
</ul>
<p>All of these pieces of equation data are defined in the program in the <code>EquationData</code> namespace. When run, the program produces long-term maximal velocities around 10-40 centimeters per year (see the results section below), approximately the physically correct order of magnitude. We will set the end time to 1 billion years.</p>
<dl class="section note"><dt>Note</dt><dd>The choice of the constants and material parameters above follows in large part the comprehensive book "Mantle Convection in the Earth and Planets,
Part 1" by G. Schubert and D. L. Turcotte and P. Olson (Cambridge, 2001). It contains extensive discussion of ways to make the program more realistic.</dd></dl>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details </h3>
<p>Compared to <a class="el" href="step_31.html">step-31</a>, this program has a number of noteworthy differences:</p>
<ul>
<li>The <code>EquationData</code> namespace is significantly larger, reflecting the fact that we now have much more physics to deal with. That said, most of this additional physical detail is rather self-contained in functions in this one namespace, and does not proliferate throughout the rest of the program.</li>
<li>Of more obvious visibility is the fact that we have put a good number of parameters into an input file handled by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class (see, for example, <a class="el" href="step_29.html">step-29</a>, for ways to set up run-time parameter files with this class). This often makes sense when one wants to avoid re-compiling the program just because one wants to play with a single parameter (think, for example, of parameter studies determining the best values of the stabilization constants discussed above), in particular given that it takes a nontrivial amount of time to re-compile programs of the current size. To just give an overview of the kinds of parameters we have moved from fixed values into the input file, here is a listing of a typical <code>step-32.prm</code> file : <div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line"><span class="preprocessor"># The end time of the simulation in years.</span></div><div class="line"><span class="keyword">set</span> End time                            = 1e8</div><div class="line"></div><div class="line"><span class="preprocessor"># Whether graphical output is to be generated or not. You may not want to get</span></div><div class="line"><span class="preprocessor"># graphical output if the number of processors is large.</span></div><div class="line"><span class="keyword">set</span> Generate graphical output           = <span class="keyword">false</span></div><div class="line"></div><div class="line"><span class="preprocessor"># The number of adaptive refinement steps performed after initial global</span></div><div class="line"><span class="preprocessor"># refinement.</span></div><div class="line"><span class="keyword">set</span> Initial adaptive refinement         = 1</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of global refinement steps performed on the initial coarse mesh,</span></div><div class="line"><span class="preprocessor"># before the problem is first solved there.</span></div><div class="line"><span class="keyword">set</span> Initial global refinement           = 1</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of time steps between each generation of graphical output files.</span></div><div class="line"><span class="keyword">set</span> Time steps between graphical output = 50</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of time steps after which the mesh is to be adapted based on</span></div><div class="line"><span class="preprocessor"># computed error indicators.</span></div><div class="line"><span class="keyword">set</span> Time steps between mesh refinement  = 10</div><div class="line"></div><div class="line"></div><div class="line">subsection Discretization</div><div class="line"><span class="preprocessor">  # The polynomial degree to use for the velocity variables in the Stokes</span></div><div class="line"><span class="preprocessor">  # system.</span></div><div class="line">  <span class="keyword">set</span> Stokes velocity polynomial degree       = 2</div><div class="line"></div><div class="line"><span class="preprocessor">  # The polynomial degree to use for the temperature variable.</span></div><div class="line">  <span class="keyword">set</span> Temperature polynomial degree           = 2</div><div class="line"></div><div class="line"><span class="preprocessor">  # Whether to use a Stokes discretization that is locally conservative at the</span></div><div class="line"><span class="preprocessor">  # expense of a larger number of degrees of freedom, or to go with a cheaper</span></div><div class="line"><span class="preprocessor">  # discretization that does not locally conserve mass (although it is</span></div><div class="line"><span class="preprocessor">  # globally conservative.</span></div><div class="line">  <span class="keyword">set</span> Use locally conservative discretization = <span class="keyword">true</span></div><div class="line"><a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a></div><div class="line"></div><div class="line"></div><div class="line">subsection Stabilization parameters</div><div class="line"><span class="preprocessor">  # The exponent in the entropy viscosity stabilization.</span></div><div class="line">  <span class="keyword">set</span> alpha = 2</div><div class="line"></div><div class="line"><span class="preprocessor">  # The beta factor in the artificial viscosity stabilization. An appropriate</span></div><div class="line"><span class="preprocessor">  # value for 2d is 0.052 and 0.078 for 3d.</span></div><div class="line">  <span class="keyword">set</span> beta  = 0.078</div><div class="line"></div><div class="line">  # The c_R factor in the entropy viscosity stabilization.</div><div class="line">  <span class="keyword">set</span> c_R   = 0.5</div><div class="line">end</div></div><!-- fragment --></li>
<li>There are, obviously, a good number of changes that have to do with the fact that we want to run our program on a possibly very large number of machines. Although one may suspect that this requires us to completely re-structure our code, that isn't in fact the case (although the classes that implement much of this functionality in deal.II certainly look very different from an implementation viewpoint, but this doesn't reflect in their public interface). Rather, the changes are mostly subtle, and the overall structure of the main class is pretty much unchanged. That said, the devil is in the detail: getting parallel computing right, without deadlocks, ensuring that the right data is available at the right place (see, for example, the discussion on fully distributed vectors vs. vectors with ghost elements), and avoiding bottlenecks is difficult and discussions on this topic will appear in a good number of places in this program.</li>
</ul>
<p><a class="anchor" id="Outlook"></a></p><h3>Outlook </h3>
<p>This is a tutorial program. That means that at least most of its focus needs to lie on demonstrating ways of using deal.II and associated libraries, and not diluting this teaching lesson by focusing overly much on physical details. Despite the lengthy section above on the choice of physical parameters, the part of the program devoted to this is actually quite short and self contained.</p>
<p>That said, both <a class="el" href="step_31.html">step-31</a> and the current <a class="el" href="step_32.html">step-32</a> have not come about by chance but are certainly meant as wayposts along the path to a more comprehensive program that will simulate convection in the earth mantle. We call this code <em>ASPECT</em> (short for <em>Advanced Solver for Problems in Earth's ConvecTion</em>); its development is funded by the <a href="http://www.geodynamics.org">Computational Infrastructure in Geodynamics</a> initiative with support from the National Science Foundation. More information on <em>ASPECT</em> is available at its <a href="https://aspect.geodynamics.org/">homepage</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first task as usual is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="filtered__iterator_8h.html">deal.II/grid/filtered_iterator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgp_8h.html">deal.II/fe/fe_dgp.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;locale&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --><p>This is the only include file that is new: It introduces the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> equivalent of the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class to take a solution from on mesh to the next one upon mesh refinement, but in the case of parallel distributed triangulations:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --><p>The following classes are used in parallel distributed computations and have all already been introduced in <a class="el" href="step_40.html">step-40</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div></div><!-- fragment --><p>The next step is like in all previous tutorial programs: We put everything into a namespace of its own and then import the deal.II classes and functions into it:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step32</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>In the following namespace, we define the various pieces of equation data that describe the problem. This corresponds to the various aspects of making the problem at least slightly realistic and that were exhaustively discussed in the description of the testcase in the introduction.</p>
<p>We start with a few coefficients that have constant values (the comment after the value indicates its physical units):</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">double</span> eta                   = 1e21;    <span class="comment">// Pa s      </span></div><div class="line">  constexpr <span class="keywordtype">double</span> kappa                 = 1e-6;    <span class="comment">// m^2 / s    </span></div><div class="line">  constexpr <span class="keywordtype">double</span> reference_density     = 3300;    <span class="comment">// kg / m^3   </span></div><div class="line">  constexpr <span class="keywordtype">double</span> reference_temperature = 293;     <span class="comment">// K         </span></div><div class="line">  constexpr <span class="keywordtype">double</span> expansion_coefficient = 2e-5;    <span class="comment">// 1/K        </span></div><div class="line">  constexpr <span class="keywordtype">double</span> specific_heat         = 1250;    <span class="comment">// J / K / kg </span></div><div class="line">  constexpr <span class="keywordtype">double</span> radiogenic_heating    = 7.4e-12; <span class="comment">// W / kg     </span></div><div class="line"></div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> R0 = 6371000. - 2890000.; <span class="comment">// m          </span></div><div class="line">  constexpr <span class="keywordtype">double</span> R1 = 6371000. - 35000.;   <span class="comment">// m          </span></div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> T0 = 4000 + 273; <span class="comment">// K          </span></div><div class="line">  constexpr <span class="keywordtype">double</span> T1 = 700 + 273;  <span class="comment">// K          </span></div></div><!-- fragment --><p>The next set of definitions are for functions that encode the density as a function of temperature, the gravity vector, and the initial values for the temperature. Again, all of these (along with the values they compute) are discussed in the introduction:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> density(<span class="keyword">const</span> <span class="keywordtype">double</span> temperature)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (</div><div class="line">    reference_density *</div><div class="line">    (1 - expansion_coefficient * (temperature - reference_temperature)));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> gravity_vector(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">  <span class="keywordflow">return</span> -(1.245e-6 * r + 7.714e13 / r / r) * p / r;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TemperatureInitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TemperatureInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h = R1 - R0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> s = (r - R0) / h;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> q =</div><div class="line">    (dim == 3) ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(0.0, <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * <a class="code" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">abs</a>(p(2) / R1))) : 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(p(0), p(1));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tau = s + 0.2 * s * (1 - s) * std::sin(6 * phi) * q;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> T0 * (1.0 - tau) + T1 * tau;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">TemperatureInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p>As mentioned in the introduction we need to rescale the pressure to avoid the relative ill-conditioning of the momentum and mass conservation equations. The scaling factor is \(\frac{\eta}{L}\) where \(L\) was a typical length scale. By experimenting it turns out that a good length scale is the diameter of plumes, which is around 10 km:</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">double</span> pressure_scaling = eta / 10000;</div></div><!-- fragment --><p>The final number in this namespace is a constant that denotes the number of seconds per (average, tropical) year. We use this only when generating screen output: internally, all computations of this program happen in SI units (kilogram, meter, seconds) but writing geological times in seconds yields numbers that one can't relate to reality, and so we convert to years using the factor defined here:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> year_in_seconds = 60 * 60 * 24 * 365.2425;</div><div class="line"></div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --><p><a class="anchor" id="PreconditioningtheStokessystem"></a> </p><h3>Preconditioning the Stokes system</h3>
<p>This namespace implements the preconditioner. As discussed in the introduction, this preconditioner differs in a number of key portions from the one used in <a class="el" href="step_31.html">step-31</a>. Specifically, it is a right preconditioner, implementing the matrix </p><p class="formulaDsp">
\begin{align*} \left(\begin{array}{cc}A^{-1} &amp; B^T \\0 &amp; S^{-1} \end{array}\right) \end{align*}
</p>
<p> where the two inverse matrix operations are approximated by linear solvers or, if the right flag is given to the constructor of this class, by a single AMG V-cycle for the velocity block. The three code blocks of the <code>vmult</code> function implement the multiplications with the three blocks of this preconditioner matrix and should be self explanatory if you have read through <a class="el" href="step_31.html">step-31</a> or the discussion of composing solvers in <a class="el" href="step_20.html">step-20</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;Spre,</div><div class="line">                             <span class="keyword">const</span> PreconditionerTypeMp &amp;Mppreconditioner,</div><div class="line">                             <span class="keyword">const</span> PreconditionerTypeA &amp; Apreconditioner,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">bool</span>                  do_solve_A)</div><div class="line">      : stokes_matrix(&amp;S)</div><div class="line">      , stokes_preconditioner_matrix(&amp;Spre)</div><div class="line">      , mp_preconditioner(Mppreconditioner)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , do_solve_A(do_solve_A)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> utmp(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, 1e-6 * src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).l2_norm());</div><div class="line"></div><div class="line">        <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">        solver.solve(stokes_preconditioner_matrix-&gt;block(1, 1),</div><div class="line">                     dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                     src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                     mp_preconditioner);</div><div class="line"></div><div class="line">        dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) *= -1.0;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        stokes_matrix-&gt;block(0, 1).vmult(utmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">        utmp *= -1.0;</div><div class="line">        utmp.add(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (do_solve_A == <span class="keyword">true</span>)</div><div class="line">        {</div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, utmp.l2_norm() * 1e-2);</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1SolverCG.html">TrilinosWrappers::SolverCG</a> solver(solver_control);</div><div class="line">          solver.solve(stokes_matrix-&gt;block(0, 0),</div><div class="line">                       dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0),</div><div class="line">                       utmp,</div><div class="line">                       a_preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">      stokes_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">                                stokes_preconditioner_matrix;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeMp &amp;mp_preconditioner;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp; a_preconditioner;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>                  do_solve_A;</div><div class="line">  };</div><div class="line">} <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --><p><a class="anchor" id="Definitionofassemblydatastructures"></a> </p><h3>Definition of assembly data structures</h3>
<p>As described in the introduction, we will use the <a class="el" href="namespaceWorkStream.html">WorkStream</a> mechanism discussed in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> module to parallelize operations among the processors of a single machine. The <a class="el" href="namespaceWorkStream.html">WorkStream</a> class requires that data is passed around in two kinds of data structures, one for scratch data and one to pass data from the assembly function to the function that copies local contributions into global objects.</p>
<p>The following namespace (and the two sub-namespaces) contains a collection of data structures that serve this purpose, one pair for each of the four operations discussed in the introduction that we will want to parallelize. Each assembly routine gets two sets of data: a Scratch array that collects all the classes and arrays that are used for the calculation of the cell contribution, and a CopyData array that keeps local matrices and vectors which will be written into the global matrix. Whereas CopyData is a container for the final data that is written into the global matrices and vector (and, thus, absolutely necessary), the Scratch arrays are merely there for performance reasons &mdash; it would be much more expensive to set up a <a class="el" href="classFEValues.html">FEValues</a> object on each cell, than creating it only once and updating some derivative data.</p>
<p><a class="el" href="step_31.html">step-31</a> had four assembly routines: One for the preconditioner matrix of the Stokes system, one for the Stokes matrix and right hand side, one for the temperature matrices and one for the right hand side of the temperature equation. We here organize the scratch arrays and CopyData objects for each of those four assembly components using a <code>struct</code> environment (since we consider these as temporary objects we pass around, rather than classes that implement functionality of their own, though this is a more subjective point of view to distinguish between <code>struct</code>s and <code>class</code>es).</p>
<p>Regarding the Scratch objects, each struct is equipped with a constructor that creates an <a class="el" href="classFEValues.html">FEValues</a> object using the <a class="el" href="classFiniteElement.html">FiniteElement</a>, <a class="el" href="classQuadrature.html">Quadrature</a>, <a class="el" href="classMapping.html">Mapping</a> (which describes the interpolation of curved boundaries), and <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> instances. Moreover, we manually implement a copy constructor (since the <a class="el" href="classFEValues.html">FEValues</a> class is not copyable by itself), and provide some additional vector fields that are used to hold intermediate data during the computation of local contributions.</p>
<p>Let us start with the scratch arrays and, specifically, the one used for assembly of the Stokes preconditioner:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Assembly</div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span>Scratch</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">    {</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags);</div><div class="line"></div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> stokes_fe_values;</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u;</div><div class="line">      std::vector&lt;double&gt;         phi_p;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">      : stokes_fe_values(mapping, stokes_fe, stokes_quadrature, update_flags)</div><div class="line">      , grad_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">      , phi_p(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> StokesPreconditioner &amp;scratch)</div><div class="line">      : stokes_fe_values(scratch.stokes_fe_values.get_mapping(),</div><div class="line">                         scratch.stokes_fe_values.get_fe(),</div><div class="line">                         scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                         scratch.stokes_fe_values.get_update_flags())</div><div class="line">      , grad_phi_u(scratch.grad_phi_u)</div><div class="line">      , phi_p(scratch.phi_p)</div><div class="line">    {}</div></div><!-- fragment --><p>The next one is the scratch object used for the assembly of the full Stokes system. Observe that we derive the StokesSystem scratch class from the StokesPreconditioner class above. We do this because all the objects that are necessary for the assembly of the preconditioner are also needed for the actual matrix system and right hand side, plus some extra data. This makes the program more compact. Note also that the assembly of the Stokes system and the temperature right hand side further down requires data from temperature and velocity, respectively, so we actually need two <a class="el" href="classFEValues.html">FEValues</a> objects for those two cases.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">{</div><div class="line">  StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags);</div><div class="line"></div><div class="line">  StokesSystem(<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u;</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u;</div><div class="line">  std::vector&lt;double&gt;                  div_phi_u;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_temperature_values;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesSystem&lt;dim&gt;::StokesSystem(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags)</div><div class="line">  : StokesPreconditioner&lt;dim&gt;(stokes_fe,</div><div class="line">                              stokes_quadrature,</div><div class="line">                              mapping,</div><div class="line">                              stokes_update_flags)</div><div class="line">  , temperature_fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          stokes_quadrature,</div><div class="line">                          temperature_update_flags)</div><div class="line">  , phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , grads_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , div_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , old_temperature_values(stokes_quadrature.size())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesSystem&lt;dim&gt;::StokesSystem(<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;scratch)</div><div class="line">  : StokesPreconditioner&lt;dim&gt;(scratch)</div><div class="line">  , temperature_fe_values(</div><div class="line">      scratch.temperature_fe_values.get_mapping(),</div><div class="line">      scratch.temperature_fe_values.get_fe(),</div><div class="line">      scratch.temperature_fe_values.get_quadrature(),</div><div class="line">      scratch.temperature_fe_values.get_update_flags())</div><div class="line">  , phi_u(scratch.phi_u)</div><div class="line">  , grads_phi_u(scratch.grads_phi_u)</div><div class="line">  , div_phi_u(scratch.div_phi_u)</div><div class="line">  , old_temperature_values(scratch.old_temperature_values)</div><div class="line">{}</div></div><!-- fragment --><p>After defining the objects used in the assembly of the Stokes system, we do the same for the assembly of the matrices necessary for the temperature system. The general structure is very similar:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>TemperatureMatrix</div><div class="line">{</div><div class="line">  TemperatureMatrix(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   temperature_quadrature);</div><div class="line"></div><div class="line">  TemperatureMatrix(<span class="keyword">const</span> TemperatureMatrix &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         phi_T;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   temperature_quadrature)</div><div class="line">  : temperature_fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          temperature_quadrature,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">  , phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">  , grad_phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">  <span class="keyword">const</span> TemperatureMatrix &amp;scratch)</div><div class="line">  : temperature_fe_values(</div><div class="line">      scratch.temperature_fe_values.get_mapping(),</div><div class="line">      scratch.temperature_fe_values.get_fe(),</div><div class="line">      scratch.temperature_fe_values.get_quadrature(),</div><div class="line">      scratch.temperature_fe_values.get_update_flags())</div><div class="line">  , phi_T(scratch.phi_T)</div><div class="line">  , grad_phi_T(scratch.grad_phi_T)</div><div class="line">{}</div></div><!-- fragment --><p>The final scratch object is used in the assembly of the right hand side of the temperature system. This object is significantly larger than the ones above because a lot more quantities enter the computation of the right hand side of the temperature equation. In particular, the temperature values and gradients of the previous two time steps need to be evaluated at the quadrature points, as well as the velocities and the strain rates (i.e. the symmetric gradients of the velocity) that enter the right hand side as friction heating terms. Despite the number of terms, the following should be rather self explanatory:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>TemperatureRHS</div><div class="line">  {</div><div class="line">    TemperatureRHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line"></div><div class="line">    TemperatureRHS(<span class="keyword">const</span> TemperatureRHS &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> stokes_fe_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values;</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_strain_rates;</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_old_strain_rates;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         old_temperature_values;</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads;</div><div class="line">    std::vector&lt;double&gt;         old_temperature_laplacians;</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_laplacians;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TemperatureRHS&lt;dim&gt;::TemperatureRHS(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">    : temperature_fe_values(mapping,</div><div class="line">                            temperature_fe,</div><div class="line">                            quadrature,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    , stokes_fe_values(mapping,</div><div class="line">                       stokes_fe,</div><div class="line">                       quadrature,</div><div class="line">                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div><div class="line">    , phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">    , grad_phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_velocity_values(quadrature.size())</div><div class="line">    , old_old_velocity_values(quadrature.size())</div><div class="line">    , old_strain_rates(quadrature.size())</div><div class="line">    , old_old_strain_rates(quadrature.size())</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_temperature_values(quadrature.size())</div><div class="line">    , old_old_temperature_values(quadrature.size())</div><div class="line">    , old_temperature_grads(quadrature.size())</div><div class="line">    , old_old_temperature_grads(quadrature.size())</div><div class="line">    , old_temperature_laplacians(quadrature.size())</div><div class="line">    , old_old_temperature_laplacians(quadrature.size())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TemperatureRHS&lt;dim&gt;::TemperatureRHS(<span class="keyword">const</span> TemperatureRHS &amp;scratch)</div><div class="line">    : temperature_fe_values(</div><div class="line">        scratch.temperature_fe_values.get_mapping(),</div><div class="line">        scratch.temperature_fe_values.get_fe(),</div><div class="line">        scratch.temperature_fe_values.get_quadrature(),</div><div class="line">        scratch.temperature_fe_values.get_update_flags())</div><div class="line">    , stokes_fe_values(scratch.stokes_fe_values.get_mapping(),</div><div class="line">                       scratch.stokes_fe_values.get_fe(),</div><div class="line">                       scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                       scratch.stokes_fe_values.get_update_flags())</div><div class="line">    , phi_T(scratch.phi_T)</div><div class="line">    , grad_phi_T(scratch.grad_phi_T)</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_velocity_values(scratch.old_velocity_values)</div><div class="line">    , old_old_velocity_values(scratch.old_old_velocity_values)</div><div class="line">    , old_strain_rates(scratch.old_strain_rates)</div><div class="line">    , old_old_strain_rates(scratch.old_old_strain_rates)</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_temperature_values(scratch.old_temperature_values)</div><div class="line">    , old_old_temperature_values(scratch.old_old_temperature_values)</div><div class="line">    , old_temperature_grads(scratch.old_temperature_grads)</div><div class="line">    , old_old_temperature_grads(scratch.old_old_temperature_grads)</div><div class="line">    , old_temperature_laplacians(scratch.old_temperature_laplacians)</div><div class="line">    , old_old_temperature_laplacians(scratch.old_old_temperature_laplacians)</div><div class="line">  {}</div><div class="line">} <span class="comment">// namespace Scratch</span></div></div><!-- fragment --><p>The CopyData objects are even simpler than the Scratch objects as all they have to do is to store the results of local computations until they can be copied into the global matrix or vector objects. These structures therefore only need to provide a constructor, a copy operation, and some arrays for local matrix, local vectors and the relation between local and global degrees of freedom (a.k.a. <code>local_dof_indices</code>). Again, we have one such structure for each of the four operations we will parallelize using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class:</p>
<div class="fragment"><div class="line">  <span class="keyword">namespace </span>CopyData</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">    {</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line">      StokesPreconditioner &amp;operator=(<span class="keyword">const</span> StokesPreconditioner &amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_matrix;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">      : local_matrix(stokes_fe.n_dofs_per_cell(), stokes_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> StokesPreconditioner &amp;data)</div><div class="line">      : local_matrix(data.local_matrix)</div><div class="line">      , local_dof_indices(data.local_dof_indices)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">    {</div><div class="line">      StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesSystem&lt;dim&gt;::StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">      : StokesPreconditioner&lt;dim&gt;(stokes_fe)</div><div class="line">      , local_rhs(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>TemperatureMatrix</div><div class="line">    {</div><div class="line">      TemperatureMatrix(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_mass_matrix;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_stiffness_matrix;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">      : local_mass_matrix(temperature_fe.n_dofs_per_cell(),</div><div class="line">                          temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_stiffness_matrix(temperature_fe.n_dofs_per_cell(),</div><div class="line">                               temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(temperature_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>TemperatureRHS</div><div class="line">    {</div><div class="line">      TemperatureRHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       local_rhs;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   matrix_for_bc;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureRHS&lt;dim&gt;::TemperatureRHS(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">      : local_rhs(temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(temperature_fe.n_dofs_per_cell())</div><div class="line">      , matrix_for_bc(temperature_fe.n_dofs_per_cell(),</div><div class="line">                      temperature_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line">  } <span class="comment">// namespace CopyData</span></div><div class="line">}   <span class="comment">// namespace Assembly</span></div></div><!-- fragment --><p><a class="anchor" id="ThecodeBoussinesqFlowProblemcodeclasstemplate"></a> </p><h3>The <code>BoussinesqFlowProblem</code> class template</h3>
<p>This is the declaration of the main class. It is very similar to <a class="el" href="step_31.html">step-31</a> but there are a number differences we will comment on below.</p>
<p>The top of the class is essentially the same as in <a class="el" href="step_31.html">step-31</a>, listing the public methods and a set of private functions that do the heavy lifting. Compared to <a class="el" href="step_31.html">step-31</a> there are only two additions to this section: the function <code>get_cfl_number()</code> that computes the maximum CFL number over all cells which we then compute the global time step from, and the function <code>get_entropy_variation()</code> that is used in the computation of the entropy stabilization. It is akin to the <code>get_extrapolated_temperature_range()</code> we have used in <a class="el" href="step_31.html">step-31</a> for this purpose, but works on the entropy instead of the temperature instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">struct </span>Parameters;</div><div class="line">  BoussinesqFlowProblem(Parameters &amp;parameters);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_cfl_number() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_entropy_variation(<span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature) <span class="keyword">const</span>;</div><div class="line">  std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      solve();</div><div class="line">  <span class="keywordtype">void</span>                      output_results();</div><div class="line">  <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_strain_rates,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_old_strain_rates,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                average_temperature,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_entropy_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p>The first significant new component is the definition of a struct for the parameters according to the discussion in the introduction. This structure is initialized by reading from a parameter file during construction of this object.</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>Parameters</div><div class="line">  {</div><div class="line">    Parameters(<span class="keyword">const</span> std::string &amp;parameter_filename);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    <span class="keywordtype">void</span>        parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_global_refinement;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_adaptive_refinement;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span>         generate_graphical_output;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> graphical_output_interval;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> adaptive_refinement_interval;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> stabilization_alpha;</div><div class="line">    <span class="keywordtype">double</span> stabilization_c_R;</div><div class="line">    <span class="keywordtype">double</span> stabilization_beta;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_velocity_degree;</div><div class="line">    <span class="keywordtype">bool</span>         use_locally_conservative_discretization;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temperature_degree;</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Parameters &amp;parameters;</div></div><!-- fragment --><p>The <code>pcout</code> (for <em>parallel <code>std::cout</code></em>) object is used to simplify writing output: each MPI process can use this to generate output as usual, but since each of these processes will (hopefully) produce the same output it will just be replicated many times over; with the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> class, only the output generated by one MPI process will actually be printed to screen, whereas the output by all the other threads will simply be forgotten.</p>
<div class="fragment"><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div></div><!-- fragment --><p>The following member variables will then again be similar to those in <a class="el" href="step_31.html">step-31</a> (and to other tutorial programs). As mentioned in the introduction, we fully distribute computations, so we will have to use the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see <a class="el" href="step_40.html">step-40</a>) but the remainder of these variables is rather standard with two exceptions:</p>
<ul>
<li>The <code>mapping</code> variable is used to denote a higher-order polynomial mapping. As mentioned in the introduction, we use this mapping when forming integrals through quadrature for all cells that are adjacent to either the inner or outer boundaries of our domain where the boundary is curved.</li>
<li>In a bit of naming confusion, you will notice below that some of the variables from namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> are taken from namespace <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">TrilinosWrappers::MPI</a> (such as the right hand side vectors) whereas others are not (such as the various matrices). This is due to legacy reasons. We will frequently have to query velocities and temperatures at arbitrary quadrature points; consequently, rather than importing ghost information of a vector whenever we need access to degrees of freedom that are relevant locally but owned by another processor, we solve linear systems in parallel but then immediately initialize a vector including ghost entries of the solution for further processing. The various <code>*_solution</code> vectors are therefore filled immediately after solving their respective linear system in parallel and will always contain values for all <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant degrees of freedom</a>; the fully distributed vectors that we obtain from the solution process and that only ever contain the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned degrees of freedom</a> are destroyed immediately after the solution process and after we have copied the relevant values into the member variable vectors.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keywordtype">double</span>                                    global_Omega_diameter;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>       stokes_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time_step;</div><div class="line"><span class="keywordtype">double</span>       old_time_step;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt;    Amg_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; Mp_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; T_preconditioner;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line"><span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line"><span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line"><span class="keywordtype">bool</span> rebuild_temperature_preconditioner;</div></div><!-- fragment --><p>The next member variable, <code>computing_timer</code> is used to conveniently account for compute time spent in certain "sections" of the code that are repeatedly entered. For example, we will enter (and leave) sections for Stokes matrix assembly and would like to accumulate the run time spent in this section over all time steps. Every so many time steps as well as at the end of the program (through the destructor of the <a class="el" href="classTimerOutput.html">TimerOutput</a> class) we will then produce a nice summary of the times spent in the different sections into which we categorize the run-time of this program.</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div></div><!-- fragment --><p>After these member variables we have a number of auxiliary functions that have been broken out of the ones listed above. Specifically, there are first three functions that we call from <code>setup_dofs</code> and then the ones that do the assembling of linear systems:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_stokes_matrix(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line"><span class="keywordtype">void</span> setup_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line"><span class="keywordtype">void</span> setup_temperature_matrices(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioning,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioning);</div></div><!-- fragment --><p>Following the <a class="el" href="group__threads.html#MTWorkStream">task-based parallelization</a> paradigm, we split all the assembly routines into two parts: a first part that can do all the calculations on a certain cell without taking care of other threads, and a second part (which is writing the local data into the global matrices and vectors) which can be entered by only one thread at a time. In order to implement that, we provide functions for each of those two steps for all the four assembly routines that we use in this program. The following eight functions do exactly this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> local_assemble_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">  Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_stokes_system(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">  Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_stokes_system(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">  Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_velocity,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">  Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data);</div></div><!-- fragment --><p>Finally, we forward declare a member class that we will define later on and that will be used to compute a number of quantities from our solution vectors that we'd like to put into the output files for visualization.</p>
<div class="fragment"><div class="line">  <span class="keyword">class </span>Postprocessor;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemclassimplementation"></a> </p><h3>BoussinesqFlowProblem class implementation</h3>
<p><a class="anchor" id="BoussinesqFlowProblemParameters"></a> </p><h4>BoussinesqFlowProblem::Parameters</h4>
<p>Here comes the definition of the parameters for the Stokes problem. We allow to set the end time for the simulation, the level of refinements (both global and adaptive, which in the sum specify what maximum level the cells are allowed to have), and the interval between refinements in the time stepping.</p>
<p>Then, we let the user specify constants for the stabilization parameters (as discussed in the introduction), the polynomial degree for the Stokes velocity space, whether to use the locally conservative discretization based on <a class="el" href="classFE__DGP.html">FE_DGP</a> elements for the pressure or not (<a class="el" href="classFE__Q.html">FE_Q</a> elements for pressure), and the polynomial degree for the temperature interpolation.</p>
<p>The constructor checks for a valid input file (if not, a file with default parameters for the quantities is written), and eventually parses the parameters.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Parameters::Parameters(</div><div class="line">  <span class="keyword">const</span> std::string &amp;parameter_filename)</div><div class="line">  : end_time(1e8)</div><div class="line">  , initial_global_refinement(2)</div><div class="line">  , initial_adaptive_refinement(2)</div><div class="line">  , adaptive_refinement_interval(10)</div><div class="line">  , stabilization_alpha(2)</div><div class="line">  , stabilization_c_R(0.11)</div><div class="line">  , stabilization_beta(0.078)</div><div class="line">  , stokes_velocity_degree(2)</div><div class="line">  , use_locally_conservative_discretization(true)</div><div class="line">  , temperature_degree(2)</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters(prm);</div><div class="line"></div><div class="line">  std::ifstream parameter_file(parameter_filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!parameter_file)</div><div class="line">    {</div><div class="line">      parameter_file.close();</div><div class="line"></div><div class="line">      std::ofstream parameter_out(parameter_filename);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(parameter_out, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">        <span class="keyword">false</span>,</div><div class="line">        <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">          <span class="stringliteral">&quot;Input parameter file &lt;&quot;</span> + parameter_filename +</div><div class="line">          <span class="stringliteral">&quot;&gt; not found. Creating a template file of the same name.&quot;</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">  parse_parameters(prm);</div><div class="line">}</div></div><!-- fragment --><p>Next we have a function that declares the parameters that we expect in the input file, together with their data types, default values and a description:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters(</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;End time&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;1e8&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The end time of the simulation in years.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Initial global refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The number of global refinement steps performed on &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;the initial coarse mesh, before the problem is first &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;solved there.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The number of adaptive refinement steps performed after &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;initial global refinement.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;The number of time steps after which the mesh is to be &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;adapted based on computed error indicators.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Generate graphical output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Whether graphical output is to be generated or not. &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;You may not want to get graphical output if the number &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;of processors is large.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;50&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;The number of time steps between each generation of &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;graphical output files.&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;alpha&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(1, 2),</div><div class="line">                      <span class="stringliteral">&quot;The exponent in the entropy viscosity stabilization.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c_R&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.11&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The c_R factor in the entropy viscosity &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;stabilization.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;beta&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.078&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The beta factor in the artificial viscosity &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;stabilization. An appropriate value for 2d is 0.052 &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;and 0.078 for 3d.&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">      <span class="stringliteral">&quot;The polynomial degree to use for the velocity variables &quot;</span></div><div class="line">      <span class="stringliteral">&quot;in the Stokes system.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">      <span class="stringliteral">&quot;The polynomial degree to use for the temperature variable.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">      <span class="stringliteral">&quot;Whether to use a Stokes discretization that is locally &quot;</span></div><div class="line">      <span class="stringliteral">&quot;conservative at the expense of a larger number of degrees &quot;</span></div><div class="line">      <span class="stringliteral">&quot;of freedom, or to go with a cheaper discretization &quot;</span></div><div class="line">      <span class="stringliteral">&quot;that does not locally conserve mass (although it is &quot;</span></div><div class="line">      <span class="stringliteral">&quot;globally conservative.&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p>And then we need a function that reads the contents of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object we get by reading the input file and puts the results into variables that store the values of the parameters we have previously declared:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Parameters::parse_parameters(</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  end_time                  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">  initial_global_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Initial global refinement&quot;</span>);</div><div class="line">  initial_adaptive_refinement =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>);</div><div class="line"></div><div class="line">  adaptive_refinement_interval =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>);</div><div class="line"></div><div class="line">  generate_graphical_output = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Generate graphical output&quot;</span>);</div><div class="line">  graphical_output_interval =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">  {</div><div class="line">    stabilization_alpha = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;alpha&quot;</span>);</div><div class="line">    stabilization_c_R   = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c_R&quot;</span>);</div><div class="line">    stabilization_beta  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;beta&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">  {</div><div class="line">    stokes_velocity_degree =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>);</div><div class="line">    temperature_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>);</div><div class="line">    use_locally_conservative_discretization =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemBoussinesqFlowProblem"></a> </p><h4>BoussinesqFlowProblem::BoussinesqFlowProblem</h4>
<p>The constructor of the problem is very similar to the constructor in <a class="el" href="step_31.html">step-31</a>. What is different is the parallel communication: Trilinos uses a message passing interface (MPI) for data distribution. When entering the BoussinesqFlowProblem class, we have to decide how the parallelization is to be done. We choose a rather simple strategy and let all processors that are running the program work together, specified by the communicator <code>MPI_COMM_WORLD</code>. Next, we create the output stream (as we already did in <a class="el" href="step_18.html">step-18</a>) that only generates output on the first MPI process and is completely forgetful on all others. The implementation of this idea is to check the process number when <code>pcout</code> gets a true argument, and it uses the <code>std::cout</code> stream for output. If we are one processor five, for instance, then we will give a <code>false</code> argument to <code>pcout</code>, which means that the output of that processor will not be printed. With the exception of the mapping object (for which we use polynomials of degree 4) all but the final member variable are exactly the same as in <a class="el" href="step_31.html">step-31</a>.</p>
<p>This final object, the <a class="el" href="classTimerOutput.html">TimerOutput</a> object, is then told to restrict output to the <code>pcout</code> stream (processor 0), and then we specify that we want to get a summary table at the end of the program which shows us wallclock times (as opposed to CPU times). We will manually also request intermediate summaries every so many time steps in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem(Parameters &amp;parameters_)</div><div class="line">  : parameters(parameters_)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0))</div><div class="line">  ,</div><div class="line"></div><div class="line">  triangulation(MPI_COMM_WORLD,</div><div class="line">                typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing(</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening))</div><div class="line">  ,</div><div class="line"></div><div class="line">  global_Omega_diameter(0.)</div><div class="line">  ,</div><div class="line"></div><div class="line">  mapping(4)</div><div class="line">  ,</div><div class="line"></div><div class="line">  stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree),</div><div class="line">            dim,</div><div class="line">            (parameters.use_locally_conservative_discretization ?</div><div class="line">               static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;(</div><div class="line">                 <a class="code" href="classFE__DGP.html">FE_DGP</a>&lt;dim&gt;(parameters.stokes_velocity_degree - 1)) :</div><div class="line">               static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;(</div><div class="line">                 <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree - 1))),</div><div class="line">            1)</div><div class="line">  ,</div><div class="line"></div><div class="line">  stokes_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  temperature_fe(parameters.temperature_degree)</div><div class="line">  , temperature_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , rebuild_stokes_matrix(true)</div><div class="line">  , rebuild_stokes_preconditioner(true)</div><div class="line">  , rebuild_temperature_matrices(true)</div><div class="line">  , rebuild_temperature_preconditioner(true)</div><div class="line">  ,</div><div class="line"></div><div class="line">  computing_timer(MPI_COMM_WORLD,</div><div class="line">                  pcout,</div><div class="line">                  <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                  <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemhelperfunctions"></a> </p><h4>The BoussinesqFlowProblem helper functions</h4>
<p><a class="anchor" id="BoussinesqFlowProblemget_maximal_velocity"></a> </p><h5>BoussinesqFlowProblem::get_maximal_velocity</h5>
<p>Except for two small details, the function to compute the global maximum of the velocity is the same as in <a class="el" href="step_31.html">step-31</a>. The first detail is actually common to all functions that implement loops over all cells in the triangulation: When operating in parallel, each processor can only work on a chunk of cells since each processor only has a certain part of the entire triangulation. This chunk of cells that we want to work on is identified via a so-called <code>subdomain_id</code>, as we also did in <a class="el" href="step_18.html">step-18</a>. All we need to change is hence to perform the cell-related operations only on cells that are owned by the current process (as opposed to ghost or artificial cells), i.e. for which the subdomain id equals the number of the process ID. Since this is a commonly used operation, there is a shortcut for this operation: we can ask whether the cell is owned by the current processor using <code>cell-&gt;is_locally_owned()</code>.</p>
<p>The second difference is the way we calculate the maximum value. Before, we could simply have a <code>double</code> variable that we checked against on each quadrature point for each cell. Now, we have to be a bit more careful since each processor only operates on a subset of cells. What we do is to first let each processor calculate the maximum among its cells, and then do a global communication operation <code><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a></code> that computes the maximum value among all the maximum values of the individual processors. MPI provides such a call, but it's even simpler to use the respective function in namespace <a class="el" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a> using the MPI communicator object since that will do the right thing even if we work without MPI and on a single machine only. The call to <code><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a></code> needs two arguments, namely the local maximum (input) and the MPI communicator, which is MPI_COMM_WORLD in this example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.stokes_velocity_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(mapping,</div><div class="line">                          stokes_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_local_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_local_velocity =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_local_velocity, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_cfl_number"></a> </p><h5>BoussinesqFlowProblem::get_cfl_number</h5>
<p>The next function does something similar, but we now compute the CFL number, i.e., maximal velocity on a cell divided by the cell diameter. This number is necessary to determine the time step size, as we use a semi-explicit time stepping scheme for the temperature equation (see <a class="el" href="step_31.html">step-31</a> for a discussion). We compute it in the same way as above: Compute the local maximum over all locally owned cells, then exchange it via MPI to find the global maximum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_cfl_number()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.stokes_velocity_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(mapping,</div><div class="line">                          stokes_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_local_cfl = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> max_local_velocity = 1e-10;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_local_velocity =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">        max_local_cfl =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_cfl, max_local_velocity / cell-&gt;diameter());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_local_cfl, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_entropy_variation"></a> </p><h5>BoussinesqFlowProblem::get_entropy_variation</h5>
<p>Next comes the computation of the global entropy variation \(\|E(T)-\bar{E}(T)\|_\infty\) where the entropy \(E\) is defined as discussed in the introduction. This is needed for the evaluation of the stabilization in the temperature equation as explained in the introduction. The entropy variation is actually only needed if we use \(\alpha=2\) as a power in the residual computation. The infinity norm is computed by the maxima over quadrature points, as usual in discrete computations.</p>
<p>In order to compute this quantity, we first have to find the space-average \(\bar{E}(T)\) and then evaluate the maximum. However, that means that we would need to perform two loops. We can avoid the overhead by noting that \(\|E(T)-\bar{E}(T)\|_\infty = \max\big(E_{\textrm{max}}(T)-\bar{E}(T), \bar{E}(T)-E_{\textrm{min}}(T)\big)\), i.e., the maximum out of the deviation from the average entropy in positive and negative directions. The four quantities we need for the latter formula (maximum entropy, minimum entropy, average entropy, area) can all be evaluated in the same loop over all cells, so we choose this simpler variant.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_entropy_variation(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (parameters.stabilization_alpha != 2)</div><div class="line">    <span class="keywordflow">return</span> 1.;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(parameters.temperature_degree + 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>       fe_values(temperature_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div></div><!-- fragment --><p>In the two functions above we computed the maximum of numbers that were all non-negative, so we knew that zero was certainly a lower bound. On the other hand, here we need to find the maximum deviation from the average value, i.e., we will need to know the maximal and minimal values of the entropy for which we don't a priori know the sign.</p>
<p>To compute it, we can therefore start with the largest and smallest possible values we can store in a double precision number: The minimum is initialized with a bigger and the maximum with a smaller number than any one that is going to appear. We are then guaranteed that these numbers will be overwritten in the loop on the first cell or, if this processor does not own any cells, in the communication step at the latest. The following loop then computes the minimum and maximum local entropy as well as keeps track of the area/volume of the part of the domain we locally own and the integral over the entropy on it:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> min_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">       max_entropy = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(), area = 0,</div><div class="line">       entropy_integrated = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                    old_temperature_values);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                    old_old_temperature_values);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a> =</div><div class="line">            (old_temperature_values[q] + old_old_temperature_values[q]) / 2;</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> entropy =</div><div class="line">            ((T - average_temperature) * (T - average_temperature));</div><div class="line"></div><div class="line">          min_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_entropy, entropy);</div><div class="line">          max_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_entropy, entropy);</div><div class="line">          area += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">          entropy_integrated += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) * entropy;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Now we only need to exchange data between processors: we need to sum the two integrals (<code>area</code>, <code>entropy_integrated</code>), and get the extrema for maximum and minimum. We could do this through four different data exchanges, but we can it with two: <a class="el" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> also exists in a variant that takes an array of values that are all to be summed up. And we can also utilize the <a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> function by realizing that forming the minimum over the minimal entropies equals forming the negative of the maximum over the negative of the minimal entropies; this maximum can then be combined with forming the maximum over the maximal entropies.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> local_sums[2]   = {entropy_integrated, area},</div><div class="line">             local_maxima[2] = {-min_entropy, max_entropy};</div><div class="line"><span class="keywordtype">double</span> global_sums[2], global_maxima[2];</div><div class="line"></div><div class="line"><a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(local_sums, MPI_COMM_WORLD, global_sums);</div><div class="line"><a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(local_maxima, MPI_COMM_WORLD, global_maxima);</div></div><!-- fragment --><p>Having computed everything this way, we can then compute the average entropy and find the \(L^\infty\) norm by taking the larger of the deviation of the maximum or minimum from the average:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_entropy = global_sums[0] / global_sums[1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> entropy_diff    = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(global_maxima[1] - average_entropy,</div><div class="line">                                       average_entropy - (-global_maxima[0]));</div><div class="line">  <span class="keywordflow">return</span> entropy_diff;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_extrapolated_temperature_range"></a> </p><h5>BoussinesqFlowProblem::get_extrapolated_temperature_range</h5>
<p>The next function computes the minimal and maximal value of the extrapolated temperature over the entire domain. Again, this is only a slightly modified version of the respective function in <a class="el" href="step_31.html">step-31</a>. As in the function above, we collect local minima and maxima and then compute the global extrema using the same trick as above.</p>
<p>As already discussed in <a class="el" href="step_31.html">step-31</a>, the function needs to distinguish between the first and all following time steps because it uses a higher order temperature extrapolation scheme when at least two previous time steps are available.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.temperature_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>       fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> min_local_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">         max_local_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                          old_old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                  (1. + time_step / old_time_step) *</div><div class="line">                    old_temperature_values[q] -</div><div class="line">                  time_step / old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">                min_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_local_temperature, temperature);</div><div class="line">                max_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                min_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_local_temperature, temperature);</div><div class="line">                max_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> local_extrema[2] = {-min_local_temperature, max_local_temperature};</div><div class="line">  <span class="keywordtype">double</span> global_extrema[2];</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(local_extrema, MPI_COMM_WORLD, global_extrema);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> std::make_pair(-global_extrema[0], global_extrema[1]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemcompute_viscosity"></a> </p><h5>BoussinesqFlowProblem::compute_viscosity</h5>
<p>The function that calculates the viscosity is purely local and so needs no communication at all. It is mostly the same as in <a class="el" href="step_31.html">step-31</a> but with an updated formulation of the viscosity if \(\alpha=2\) is chosen:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_strain_rates,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_old_strain_rates,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_u_infty,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_T_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                average_temperature,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">    <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">  <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">        (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_rate =</div><div class="line">        (old_strain_rates[q] + old_old_strain_rates[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> T = (old_temperature[q] + old_old_temperature[q]) / 2;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">        (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">        u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">        EquationData::kappa *</div><div class="line">        (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">        2;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a> =</div><div class="line">        ((EquationData::radiogenic_heating * EquationData::density(T) +</div><div class="line">          2 * EquationData::eta * strain_rate * strain_rate) /</div><div class="line">         (EquationData::density(T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> residual = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(dT_dt + u_grad_T - kappa_Delta_T - gamma);</div><div class="line">      <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">        residual *= <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(T - average_temperature);</div><div class="line"></div><div class="line">      max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">      max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_viscosity =</div><div class="line">    (parameters.stabilization_beta * max_velocity * cell_diameter);</div><div class="line">  <span class="keywordflow">if</span> (timestep_number == 0)</div><div class="line">    <span class="keywordflow">return</span> max_viscosity;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(old_time_step &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> entropy_viscosity;</div><div class="line">      <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">        entropy_viscosity =</div><div class="line">          (parameters.stabilization_c_R * cell_diameter * cell_diameter *</div><div class="line">           max_residual / global_entropy_variation);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        entropy_viscosity =</div><div class="line">          (parameters.stabilization_c_R * cell_diameter *</div><div class="line">           global_Omega_diameter * max_velocity * max_residual /</div><div class="line">           (global_u_infty * global_T_variation));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(max_viscosity, entropy_viscosity);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemsetupfunctions"></a> </p><h4>The BoussinesqFlowProblem setup functions</h4>
<p>The following three functions set up the Stokes matrix, the matrix used for the Stokes preconditioner, and the temperature matrix. The code is mostly the same as in <a class="el" href="step_31.html">step-31</a>, but it has been broken out into three functions of their own for simplicity.</p>
<p>The main functional difference between the code here and that in <a class="el" href="step_31.html">step-31</a> is that the matrices we want to set up are distributed across multiple processors. Since we still want to build up the sparsity pattern first for efficiency reasons, we could continue to build the <em>entire</em> sparsity pattern as a <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>, as we did in <a class="el" href="step_31.html">step-31</a>. However, that would be inefficient: every processor would build the same sparsity pattern, but only initialize a small part of the matrix using it. It also violates the principle that every processor should only work on those cells it owns (and, if necessary the layer of ghost cells around it).</p>
<p>Rather, we use an object of type <a class="el" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a>, which is (obviously) a wrapper around a sparsity pattern object provided by Trilinos. The advantage is that the Trilinos sparsity pattern class can communicate across multiple processors: if this processor fills in all the nonzero entries that result from the cells it owns, and every other processor does so as well, then at the end after some MPI communication initiated by the <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> call, we will have the globally assembled sparsity pattern available with which the global matrix can be initialized.</p>
<p>There is one important aspect when initializing Trilinos sparsity patterns in parallel: In addition to specifying the locally owned rows and columns of the matrices via the <code>stokes_partitioning</code> index set, we also supply information about all the rows we are possibly going to write into when assembling on a certain processor. The set of locally relevant rows contains all such rows (possibly also a few unnecessary ones, but it is difficult to find the exact row indices before actually getting indices on all cells and resolving constraints). This additional information allows to exactly determine the structure for the off-processor data found during assembly. While Trilinos matrices are able to collect this information on the fly as well (when initializing them from some other reinit method), it is less efficient and leads to problems when assembling matrices with multiple threads. In this program, we pessimistically assume that only one processor at a time can write into the matrix while assembly (whereas the computation is parallel), which is fine for Trilinos matrices. In practice, one can do better by hinting <a class="el" href="namespaceWorkStream.html">WorkStream</a> at cells that do not share vertices, allowing for parallelism among those cells (see the graph coloring algorithms and <a class="el" href="namespaceWorkStream.html">WorkStream</a> with colored iterators argument). However, that only works when only one MPI processor is present because Trilinos' internal data structures for accumulating off-processor data on the fly are not thread safe. With the initialization presented here, there is no such problem and one could safely introduce graph coloring for this algorithm.</p>
<p>The only other change we need to make is to tell the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function that it is only supposed to work on a subset of cells, namely the ones whose <code>subdomain_id</code> equals the number of the current processor, and to ignore all other cells.</p>
<p>This strategy is replicated across all three of the following functions.</p>
<p>Note that Trilinos matrices store the information contained in the sparsity patterns, so we can safely release the <code>sp</code> variable once the matrix has been given the sparsity structure.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_stokes_matrix(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">{</div><div class="line">  stokes_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning,</div><div class="line">                                            stokes_partitioning,</div><div class="line">                                            stokes_relevant_partitioning,</div><div class="line">                                            MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(stokes_dof_handler,</div><div class="line">                                  coupling,</div><div class="line">                                  sp,</div><div class="line">                                  stokes_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  stokes_matrix.reinit(sp);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">{</div><div class="line">  Amg_preconditioner.reset();</div><div class="line">  Mp_preconditioner.reset();</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning,</div><div class="line">                                            stokes_partitioning,</div><div class="line">                                            stokes_relevant_partitioning,</div><div class="line">                                            MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(stokes_dof_handler,</div><div class="line">                                  coupling,</div><div class="line">                                  sp,</div><div class="line">                                  stokes_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.reinit(sp);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_temperature_matrices(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioner,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioner)</div><div class="line">{</div><div class="line">  T_preconditioner.reset();</div><div class="line">  temperature_mass_matrix.clear();</div><div class="line">  temperature_stiffness_matrix.clear();</div><div class="line">  temperature_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(temperature_partitioner,</div><div class="line">                                       temperature_partitioner,</div><div class="line">                                       temperature_relevant_partitioner,</div><div class="line">                                       MPI_COMM_WORLD);</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                  sp,</div><div class="line">                                  temperature_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  temperature_matrix.reinit(sp);</div><div class="line">  temperature_mass_matrix.reinit(sp);</div><div class="line">  temperature_stiffness_matrix.reinit(sp);</div><div class="line">}</div></div><!-- fragment --><p>The remainder of the setup function (after splitting out the three functions above) mostly has to deal with the things we need to do for parallelization across processors. Because setting all of this up is a significant compute time expense of the program, we put everything we do here into a timer group so that we can get summary information about the fraction of time spent in this part of the program at its end.</p>
<p>At the top as usual we enumerate degrees of freedom and sort them by component/block, followed by writing their numbers to the screen from processor zero. The DoFHandler::distributed_dofs() function, when applied to a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, sorts degrees of freedom in such a way that all degrees of freedom associated with subdomain zero come before all those associated with subdomain one, etc. For the Stokes part, this entails, however, that velocities and pressures become intermixed, but this is trivially solved by sorting again by blocks; it is worth noting that this latter operation leaves the relative ordering of all velocities and pressures alone, i.e. within the velocity block we will still have all those associated with subdomain zero before all velocities associated with subdomain one, etc. This is important since we store each of the blocks of this matrix distributed across all processors and want this to be done in such a way that each processor stores that part of the matrix that is roughly equal to the degrees of freedom located on those cells that it will actually work on.</p>
<p>When printing the numbers of degrees of freedom, note that these numbers are going to be large if we use many processors. Consequently, we let the stream put a comma separator in between every three digits. The state of the stream, using the locale, is saved from before to after this operation. While slightly opaque, the code works because the default locale (which we get using the constructor call <code>std::locale("")</code>) implies printing numbers with a comma separator for every third digit (i.e., thousands, millions, billions).</p>
<p>In this function as well as many below, we measure how much time we spend here and collect that in a section called "Setup dof
 systems" across function invocations. This is done using an <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> object that gets a timer going in the section with above name of the <code>computing_timer</code> object upon construction of the local variable; the timer is stopped again when the destructor of the <code>timing_section</code> variable is called. This, of course, happens either at the end of the function, or if we leave the function through a <code>return</code> statement or when an exception is thrown somewhere &ndash; in other words, whenever we leave this function in any way. The use of such "scope" objects therefore makes sure that we do not have to manually add code that tells the timer to stop at every location where this function may be left.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timing_section(computing_timer, <span class="stringliteral">&quot;Setup dof systems&quot;</span>);</div><div class="line"></div><div class="line">  stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">  stokes_sub_blocks[dim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                     n_p = stokes_dofs_per_block[1],</div><div class="line">                     n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::locale s = pcout.get_stream().getloc();</div><div class="line">  pcout.get_stream().imbue(std::locale(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u</div><div class="line">        &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">  pcout.get_stream().imbue(s);</div></div><!-- fragment --><p>After this, we have to set up the various partitioners (of type <code><a class="el" href="classIndexSet.html">IndexSet</a></code>, see the introduction) that describe which parts of each matrix or vector will be stored where, then call the functions that actually set up the matrices, and at the end also resize the various vectors we keep around in this program.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; stokes_partitioning, stokes_relevant_partitioning;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>              temperature_partitioning(n_T),</div><div class="line">  temperature_relevant_partitioning(n_T);</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> stokes_relevant_set;</div><div class="line">{</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> stokes_index_set = stokes_dof_handler.locally_owned_dofs();</div><div class="line">  stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u));</div><div class="line">  stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(stokes_dof_handler,</div><div class="line">                                          stokes_relevant_set);</div><div class="line">  stokes_relevant_partitioning.push_back(</div><div class="line">    stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u));</div><div class="line">  stokes_relevant_partitioning.push_back(</div><div class="line">    stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p));</div><div class="line"></div><div class="line">  temperature_partitioning = temperature_dof_handler.locally_owned_dofs();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(</div><div class="line">    temperature_dof_handler, temperature_relevant_partitioning);</div><div class="line">}</div></div><!-- fragment --><p>Following this, we can compute constraints for the solution vectors, including hanging node constraints and homogeneous and inhomogeneous boundary values for the Stokes and temperature fields. Note that as for everything else, the constraint objects can not hold <em>all</em> constraints on every processor. Rather, each processor needs to store only those that are actually necessary for correctness given that it only assembles linear systems on cells it owns. As discussed in the <a class="el" href="DEALGlossary.html#distributed_paper">this paper</a>, the set of constraints we need to know about is exactly the set of constraints on all locally relevant degrees of freedom, so this is what we use to initialize the constraint objects.</p>
<div class="fragment"><div class="line">{</div><div class="line">  stokes_constraints.clear();</div><div class="line">  stokes_constraints.reinit(stokes_relevant_set);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                          stokes_constraints);</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity_components(0);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    stokes_dof_handler,</div><div class="line">    0,</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1),</div><div class="line">    stokes_constraints,</div><div class="line">    stokes_fe.component_mask(velocity_components));</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">  no_normal_flux_boundaries.insert(1);</div><div class="line">  <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                  0,</div><div class="line">                                                  no_normal_flux_boundaries,</div><div class="line">                                                  stokes_constraints,</div><div class="line">                                                  mapping);</div><div class="line">  stokes_constraints.close();</div><div class="line">}</div><div class="line">{</div><div class="line">  temperature_constraints.clear();</div><div class="line">  temperature_constraints.reinit(temperature_relevant_partitioning);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                          temperature_constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    temperature_dof_handler,</div><div class="line">    0,</div><div class="line">    EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">    temperature_constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    temperature_dof_handler,</div><div class="line">    1,</div><div class="line">    EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">    temperature_constraints);</div><div class="line">  temperature_constraints.close();</div><div class="line">}</div></div><!-- fragment --><p>All this done, we can then initialize the various matrix and vector objects to their proper sizes. At the end, we also record that all matrices and preconditioners have to be re-computed at the beginning of the next time step. Note how we initialize the vectors for the Stokes and temperature right hand sides: These are writable vectors (last boolean argument set to <code>true</code>) that have the correct one-to-one partitioning of locally owned elements but are still given the relevant partitioning for means of figuring out the vector entries that are going to be set right away. As for matrices, this allows for writing local contributions into the vector with multiple threads (always assuming that the same vector entry is not accessed by multiple threads at the same time). The other vectors only allow for read access of individual elements, including ghosts, but are not suitable for solvers.</p>
<div class="fragment"><div class="line">  setup_stokes_matrix(stokes_partitioning, stokes_relevant_partitioning);</div><div class="line">  setup_stokes_preconditioner(stokes_partitioning,</div><div class="line">                              stokes_relevant_partitioning);</div><div class="line">  setup_temperature_matrices(temperature_partitioning,</div><div class="line">                             temperature_relevant_partitioning);</div><div class="line"></div><div class="line">  stokes_rhs.reinit(stokes_partitioning,</div><div class="line">                    stokes_relevant_partitioning,</div><div class="line">                    MPI_COMM_WORLD,</div><div class="line">                    <span class="keyword">true</span>);</div><div class="line">  stokes_solution.reinit(stokes_relevant_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_stokes_solution.reinit(stokes_solution);</div><div class="line"></div><div class="line">  temperature_rhs.reinit(temperature_partitioning,</div><div class="line">                         temperature_relevant_partitioning,</div><div class="line">                         MPI_COMM_WORLD,</div><div class="line">                         <span class="keyword">true</span>);</div><div class="line">  temperature_solution.reinit(temperature_relevant_partitioning,</div><div class="line">                              MPI_COMM_WORLD);</div><div class="line">  old_temperature_solution.reinit(temperature_solution);</div><div class="line">  old_old_temperature_solution.reinit(temperature_solution);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix              = <span class="keyword">true</span>;</div><div class="line">  rebuild_stokes_preconditioner      = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_matrices       = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemassemblyfunctions"></a> </p><h4>The BoussinesqFlowProblem assembly functions</h4>
<p>Following the discussion in the introduction and in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> module, we split the assembly functions into different parts:</p>
<ul>
<li>
<p class="startli">The local calculations of matrices and right hand sides, given a certain cell as input (these functions are named <code>local_assemble_*</code> below). The resulting function is, in other words, essentially the body of the loop over all cells in <a class="el" href="step_31.html">step-31</a>. Note, however, that these functions store the result from the local calculations in variables of classes from the CopyData namespace.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">These objects are then given to the second step which writes the local data into the global data structures (these functions are named <code>copy_local_to_global_*</code> below). These functions are pretty trivial.</p>
<p class="endli"></p>
</li>
<li>
These two subfunctions are then used in the respective assembly routine (called <code>assemble_*</code> below), where a <a class="el" href="namespaceWorkStream.html">WorkStream</a> object is set up and runs over all the cells that belong to the processor's subdomain. </li>
</ul>
<p><a class="anchor" id="Stokespreconditionerassembly"></a> </p><h5>Stokes preconditioner assembly</h5>
<p>Let us start with the functions that builds the Stokes preconditioner. The first two of these are pretty trivial, given the discussion above. Note in particular that the main point in using the scratch data object is that we want to avoid allocating any objects on the free space each time we visit a new cell. As a consequence, the assembly function below only has automatic local variables, and everything else is accessed through the scratch data object, which is allocated only once before we start the loop over all cells:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">  Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values.reinit(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  data.local_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.grad_phi_u[k] =</div><div class="line">            scratch.stokes_fe_values[velocities].gradient(k, q);</div><div class="line">          scratch.phi_p[k] = scratch.stokes_fe_values[pressure].value(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          data.local_matrix(i, j) +=</div><div class="line">            (EquationData::eta *</div><div class="line">               <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(scratch.grad_phi_u[i], scratch.grad_phi_u[j]) +</div><div class="line">             (1. / EquationData::eta) * EquationData::pressure_scaling *</div><div class="line">               EquationData::pressure_scaling *</div><div class="line">               (scratch.phi_p[i] * scratch.phi_p[j])) *</div><div class="line">            scratch.stokes_fe_values.JxW(q);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  stokes_constraints.distribute_local_to_global(data.local_matrix,</div><div class="line">                                                data.local_dof_indices,</div><div class="line">                                                stokes_preconditioner_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Now for the function that actually puts things together, using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> functions. <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> needs a start and end iterator to enumerate the cells it is supposed to work on. Typically, one would use <a class="el" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">DoFHandler::begin_active()</a> and <a class="el" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">DoFHandler::end()</a> for that but here we actually only want the subset of cells that in fact are owned by the current processor. This is where the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> class comes into play: you give it a range of cells and it provides an iterator that only iterates over that subset of cells that satisfy a certain predicate (a predicate is a function of one argument that either returns true or false). The predicate we use here is <a class="el" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>, i.e., it returns true exactly if the cell is owned by the current processor. The resulting iterator range is then exactly what we need.</p>
<p>With this obstacle out of the way, we call the <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> function with this set of cells, scratch and copy objects, and with pointers to two functions: the local assembly and copy-local-to-global function. These functions need to have very specific signatures: three arguments in the first and one argument in the latter case (see the documentation of the <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> function for the meaning of these arguments). Note how we use a lambda functions to create a function object that satisfies this requirement. It uses function arguments for the local assembly function that specify cell, scratch data, and copy data, as well as function argument for the copy function that expects the data to be written into the global matrix (also see the discussion in <a class="el" href="step_13.html">step-13</a>'s <code>assemble_linear_system()</code> function). On the other hand, the implicit zeroth argument of member functions (namely the <code>this</code> pointer of the object on which that member function is to operate on) is <em>bound</em> to the <code>this</code> pointer of the current function and is captured. The <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> function, as a consequence, does not need to know anything about the object these functions work on.</p>
<p>When the <a class="el" href="namespaceWorkStream.html">WorkStream</a> is executed, it will create several local assembly routines of the first kind for several cells and let some available processors work on them. The function that needs to be synchronized, i.e., the write operation into the global matrix, however, is executed by only one thread at a time in the prescribed order. Of course, this only holds for the parallelization on a single MPI process. Different MPI processes will have their own <a class="el" href="namespaceWorkStream.html">WorkStream</a> objects and do that work completely independently (and in different memory spaces). In a distributed calculation, some data will accumulate at degrees of freedom that are not owned by the respective processor. It would be inefficient to send data around every time we encounter such a dof. What happens instead is that the Trilinos sparse matrix will keep that data and send it to the owner at the end of assembly, by calling the <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> command.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">{</div><div class="line">  stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">           Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data) {</div><div class="line">      this-&gt;local_assemble_stokes_preconditioner(cell, scratch, data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_stokes_preconditioner(data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             stokes_dof_handler.begin_active()),</div><div class="line">                  CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             stokes_dof_handler.end()),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  Assembly::Scratch::StokesPreconditioner&lt;dim&gt;(</div><div class="line">                    stokes_fe,</div><div class="line">                    quadrature_formula,</div><div class="line">                    mapping,</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>),</div><div class="line">                  Assembly::CopyData::StokesPreconditioner&lt;dim&gt;(stokes_fe));</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>The final function in this block initiates assembly of the Stokes preconditioner matrix and then in fact builds the Stokes preconditioner. It is mostly the same as in the serial case. The only difference to <a class="el" href="step_31.html">step-31</a> is that we use a Jacobi preconditioner for the pressure mass matrix instead of IC, as discussed in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Build Stokes preconditioner&quot;</span>);</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                   stokes_fe.component_mask(</div><div class="line">                                     velocity_components),</div><div class="line">                                   constant_modes);</div><div class="line"></div><div class="line">  Mp_preconditioner =</div><div class="line">    std::make_shared&lt;TrilinosWrappers::PreconditionJacobi&gt;();</div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> Amg_data;</div><div class="line">  Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">  Amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">  Amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">  Amg_data.smoother_sweeps       = 2;</div><div class="line">  Amg_data.aggregation_threshold = 0.02;</div><div class="line"></div><div class="line">  Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line">  Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                 Amg_data);</div><div class="line"></div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Stokessystemassembly"></a> </p><h5>Stokes system assembly</h5>
<p>The next three functions implement the assembly of the Stokes system, again split up into a part performing local calculations, one for writing the local data into the global matrix and vector, and one for actually running the loop over all cells with the help of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class. Note that the assembly of the Stokes matrix needs only to be done in case we have changed the mesh. Otherwise, just the (temperature-dependent) right hand side needs to be calculated here. Since we are working with distributed matrices and vectors, we have to call the respective <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> functions in the end of the assembly in order to send non-local data to the owner process.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_stokes_system(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">  Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.stokes_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> temperature_cell(</div><div class="line">    &amp;triangulation, cell-&gt;level(), cell-&gt;index(), &amp;temperature_dof_handler);</div><div class="line">  scratch.temperature_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(temperature_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">    data.local_matrix = 0;</div><div class="line">  data.local_rhs = 0;</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_temperature_solution, scratch.old_temperature_values);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = scratch.old_temperature_values[q];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value(k, q);</div><div class="line">          <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">            {</div><div class="line">              scratch.grads_phi_u[k] =</div><div class="line">                scratch.stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">              scratch.div_phi_u[k] =</div><div class="line">                scratch.stokes_fe_values[velocities].divergence(k, q);</div><div class="line">              scratch.phi_p[k] =</div><div class="line">                scratch.stokes_fe_values[pressure].value(k, q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            data.local_matrix(i, j) +=</div><div class="line">              (EquationData::eta * 2 *</div><div class="line">                 (scratch.grads_phi_u[i] * scratch.grads_phi_u[j]) -</div><div class="line">               (EquationData::pressure_scaling * scratch.div_phi_u[i] *</div><div class="line">                scratch.phi_p[j]) -</div><div class="line">               (EquationData::pressure_scaling * scratch.phi_p[i] *</div><div class="line">                scratch.div_phi_u[j])) *</div><div class="line">              scratch.stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> gravity = EquationData::gravity_vector(</div><div class="line">        scratch.stokes_fe_values.quadrature_point(q));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        data.local_rhs(i) += (EquationData::density(old_temperature) *</div><div class="line">                              gravity * scratch.phi_u[i]) *</div><div class="line">                             scratch.stokes_fe_values.JxW(q);</div><div class="line">    }</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_stokes_system(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_constraints.distribute_local_to_global(data.local_matrix,</div><div class="line">                                                  data.local_rhs,</div><div class="line">                                                  data.local_dof_indices,</div><div class="line">                                                  stokes_matrix,</div><div class="line">                                                  stokes_rhs);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    stokes_constraints.distribute_local_to_global(data.local_rhs,</div><div class="line">                                                  data.local_dof_indices,</div><div class="line">                                                  stokes_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Assemble Stokes system&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix = 0;</div><div class="line"></div><div class="line">  stokes_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               stokes_dof_handler.begin_active()),</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(), stokes_dof_handler.end()),</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">           Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data) {</div><div class="line">      this-&gt;local_assemble_stokes_system(cell, scratch, data);</div><div class="line">    },</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_stokes_system(data);</div><div class="line">    },</div><div class="line">    Assembly::Scratch::StokesSystem&lt;dim&gt;(</div><div class="line">      stokes_fe,</div><div class="line">      mapping,</div><div class="line">      quadrature_formula,</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">       (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0))),</div><div class="line">      temperature_fe,</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>),</div><div class="line">    Assembly::CopyData::StokesSystem&lt;dim&gt;(stokes_fe));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  stokes_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Temperaturematrixassembly"></a> </p><h5>Temperature matrix assembly</h5>
<p>The task to be performed by the next three functions is to calculate a mass matrix and a Laplace matrix on the temperature system. These will be combined in order to yield the semi-implicit time stepping matrix that consists of the mass matrix plus a time step-dependent weight factor times the Laplace matrix. This function is again essentially the body of the loop over all cells from <a class="el" href="step_31.html">step-31</a>.</p>
<p>The two following functions perform similar services as the ones above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">  Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.temperature_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.reinit(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  data.local_mass_matrix      = 0;</div><div class="line">  data.local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.grad_phi_T[k] =</div><div class="line">            scratch.temperature_fe_values.shape_grad(k, q);</div><div class="line">          scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          {</div><div class="line">            data.local_mass_matrix(i, j) +=</div><div class="line">              (scratch.phi_T[i] * scratch.phi_T[j] *</div><div class="line">               scratch.temperature_fe_values.JxW(q));</div><div class="line">            data.local_stiffness_matrix(i, j) +=</div><div class="line">              (EquationData::kappa * scratch.grad_phi_T[i] *</div><div class="line">               scratch.grad_phi_T[j] * scratch.temperature_fe_values.JxW(q));</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  temperature_constraints.distribute_local_to_global(data.local_mass_matrix,</div><div class="line">                                                     data.local_dof_indices,</div><div class="line">                                                     temperature_mass_matrix);</div><div class="line">  temperature_constraints.distribute_local_to_global(</div><div class="line">    data.local_stiffness_matrix,</div><div class="line">    data.local_dof_indices,</div><div class="line">    temperature_stiffness_matrix);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Assemble temperature matrices&quot;</span>);</div><div class="line">  temperature_mass_matrix      = 0;</div><div class="line">  temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree + 2);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               temperature_dof_handler.begin_active()),</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               temperature_dof_handler.end()),</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">           Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data) {</div><div class="line">      this-&gt;local_assemble_temperature_matrix(cell, scratch, data);</div><div class="line">    },</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_temperature_matrix(data);</div><div class="line">    },</div><div class="line">    Assembly::Scratch::TemperatureMatrix&lt;dim&gt;(temperature_fe,</div><div class="line">                                              mapping,</div><div class="line">                                              quadrature_formula),</div><div class="line">    Assembly::CopyData::TemperatureMatrix&lt;dim&gt;(temperature_fe));</div><div class="line"></div><div class="line">  temperature_mass_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  temperature_stiffness_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  rebuild_temperature_matrices       = <span class="keyword">false</span>;</div><div class="line">  rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Temperaturerighthandsideassembly"></a> </p><h5>Temperature right hand side assembly</h5>
<p>This is the last assembly function. It calculates the right hand side of the temperature system, which includes the convection and the stabilization terms. It includes a lot of evaluations of old solutions at the quadrature points (which are necessary for calculating the artificial viscosity of stabilization), but is otherwise similar to the other assembly functions. Notice, once again, how we resolve the dilemma of having inhomogeneous boundary conditions, by just making a right hand side at this point (compare the comments for the <code><a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project()</a></code> function above): We create some matrix columns with exactly the values that would be entered for the temperature stiffness matrix, in case we have inhomogeneously constrained dofs. That will account for the correct balance of the right hand side vector with the matrix system of temperature.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_velocity,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">  Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.temperature_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  data.local_rhs     = 0;</div><div class="line">  data.matrix_for_bc = 0;</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> stokes_cell(</div><div class="line">    &amp;triangulation, cell-&gt;level(), cell-&gt;index(), &amp;stokes_dof_handler);</div><div class="line">  scratch.stokes_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(stokes_cell);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_temperature_solution, scratch.old_temperature_values);</div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_values);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_gradients(</div><div class="line">    old_temperature_solution, scratch.old_temperature_grads);</div><div class="line">  scratch.temperature_fe_values.get_function_gradients(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_grads);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_laplacians(</div><div class="line">    old_temperature_solution, scratch.old_temperature_laplacians);</div><div class="line">  scratch.temperature_fe_values.get_function_laplacians(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_laplacians);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values[velocities].get_function_values(</div><div class="line">    stokes_solution, scratch.old_velocity_values);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_values(</div><div class="line">    old_stokes_solution, scratch.old_old_velocity_values);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_symmetric_gradients(</div><div class="line">    stokes_solution, scratch.old_strain_rates);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_symmetric_gradients(</div><div class="line">    old_stokes_solution, scratch.old_old_strain_rates);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">    compute_viscosity(scratch.old_temperature_values,</div><div class="line">                      scratch.old_old_temperature_values,</div><div class="line">                      scratch.old_temperature_grads,</div><div class="line">                      scratch.old_old_temperature_grads,</div><div class="line">                      scratch.old_temperature_laplacians,</div><div class="line">                      scratch.old_old_temperature_laplacians,</div><div class="line">                      scratch.old_velocity_values,</div><div class="line">                      scratch.old_old_velocity_values,</div><div class="line">                      scratch.old_strain_rates,</div><div class="line">                      scratch.old_old_strain_rates,</div><div class="line">                      global_max_velocity,</div><div class="line">                      global_T_range.second - global_T_range.first,</div><div class="line">                      0.5 * (global_T_range.second + global_T_range.first),</div><div class="line">                      global_entropy_variation,</div><div class="line">                      cell-&gt;diameter());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);</div><div class="line">          scratch.grad_phi_T[k] =</div><div class="line">            scratch.temperature_fe_values.shape_grad(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_temperature_values[q] *</div><div class="line">              (1 + time_step / old_time_step) -</div><div class="line">            scratch.old_old_temperature_values[q] * (time_step * time_step) /</div><div class="line">              (old_time_step * (time_step + old_time_step))) :</div><div class="line">           scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> ext_T =</div><div class="line">        (use_bdf2_scheme ? (scratch.old_temperature_values[q] *</div><div class="line">                              (1 + time_step / old_time_step) -</div><div class="line">                            scratch.old_old_temperature_values[q] *</div><div class="line">                              time_step / old_time_step) :</div><div class="line">                           scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">        (use_bdf2_scheme ? (scratch.old_temperature_grads[q] *</div><div class="line">                              (1 + time_step / old_time_step) -</div><div class="line">                            scratch.old_old_temperature_grads[q] * time_step /</div><div class="line">                              old_time_step) :</div><div class="line">                           scratch.old_temperature_grads[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_velocity_values[q] * (1 + time_step / old_time_step) -</div><div class="line">            scratch.old_old_velocity_values[q] * time_step / old_time_step) :</div><div class="line">           scratch.old_velocity_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> extrapolated_strain_rate =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_strain_rates[q] * (1 + time_step / old_time_step) -</div><div class="line">            scratch.old_old_strain_rates[q] * time_step / old_time_step) :</div><div class="line">           scratch.old_strain_rates[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma =</div><div class="line">        ((EquationData::radiogenic_heating * EquationData::density(ext_T) +</div><div class="line">          2 * EquationData::eta * extrapolated_strain_rate *</div><div class="line">            extrapolated_strain_rate) /</div><div class="line">         (EquationData::density(ext_T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          data.local_rhs(i) +=</div><div class="line">            (T_term_for_rhs * scratch.phi_T[i] -</div><div class="line">             time_step * extrapolated_u * ext_grad_T * scratch.phi_T[i] -</div><div class="line">             time_step * nu * ext_grad_T * scratch.grad_phi_T[i] +</div><div class="line">             time_step * gamma * scratch.phi_T[i]) *</div><div class="line">            scratch.temperature_fe_values.JxW(q);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (temperature_constraints.is_inhomogeneously_constrained(</div><div class="line">                data.local_dof_indices[i]))</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                data.matrix_for_bc(j, i) +=</div><div class="line">                  (scratch.phi_T[i] * scratch.phi_T[j] *</div><div class="line">                     (use_bdf2_scheme ? ((2 * time_step + old_time_step) /</div><div class="line">                                         (time_step + old_time_step)) :</div><div class="line">                                        1.) +</div><div class="line">                   scratch.grad_phi_T[i] * scratch.grad_phi_T[j] *</div><div class="line">                     EquationData::kappa * time_step) *</div><div class="line">                  scratch.temperature_fe_values.JxW(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  temperature_constraints.distribute_local_to_global(data.local_rhs,</div><div class="line">                                                     data.local_dof_indices,</div><div class="line">                                                     temperature_rhs,</div><div class="line">                                                     data.matrix_for_bc);</div><div class="line">}</div></div><!-- fragment --><p>In the function that runs the <a class="el" href="namespaceWorkStream.html">WorkStream</a> for actually calculating the right hand side, we also generate the final matrix. As mentioned above, it is a sum of the mass matrix and the Laplace matrix, times some time step-dependent weight. This weight is specified by the BDF-2 time integration scheme, see the introduction in <a class="el" href="step_31.html">step-31</a>. What is new in this tutorial program (in addition to the use of MPI parallelization and the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class), is that we now precompute the temperature preconditioner as well. The reason is that the setup of the Jacobi preconditioner takes a noticeable time compared to the solver because we usually only need between 10 and 20 iterations for solving the temperature system (this might sound strange, as Jacobi really only consists of a diagonal, but in Trilinos it is derived from more general framework for point relaxation preconditioners which is a bit inefficient). Hence, it is more efficient to precompute the preconditioner, even though the matrix entries may slightly change because the time step might change. This is not too big a problem because we remesh every few time steps (and regenerate the preconditioner then).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix *=</div><div class="line">        (2 * time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_preconditioner == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      T_preconditioner =</div><div class="line">        std::make_shared&lt;TrilinosWrappers::PreconditionJacobi&gt;();</div><div class="line">      T_preconditioner-&gt;initialize(temperature_matrix);</div><div class="line">      rebuild_temperature_preconditioner = <span class="keyword">false</span>;</div><div class="line">    }</div></div><!-- fragment --><p>The next part is computing the right hand side vectors. To do so, we first compute the average temperature \(T_m\) that we use for evaluating the artificial viscosity stabilization through the residual \(E(T) = (T-T_m)^2\). We do this by defining the midpoint between maximum and minimum temperature as average temperature in the definition of the entropy viscosity. An alternative would be to use the integral average, but the results are not very sensitive to this choice. The rest then only requires calling <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> again, binding the arguments to the <code>local_assemble_temperature_rhs</code> function that are the same in every call to the correct values:</p>
<div class="fragment"><div class="line">  temperature_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree + 2);</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">    get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature =</div><div class="line">    0.5 * (global_T_range.first + global_T_range.second);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_entropy_variation =</div><div class="line">    get_entropy_variation(average_temperature);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>, global_T_range, maximal_velocity, global_entropy_variation](</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">      Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data) {</div><div class="line">      this-&gt;local_assemble_temperature_rhs(global_T_range,</div><div class="line">                                           maximal_velocity,</div><div class="line">                                           global_entropy_variation,</div><div class="line">                                           cell,</div><div class="line">                                           scratch,</div><div class="line">                                           data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data) {</div><div class="line">    this-&gt;copy_local_to_global_temperature_rhs(data);</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             temperature_dof_handler.begin_active()),</div><div class="line">                  CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             temperature_dof_handler.end()),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  Assembly::Scratch::TemperatureRHS&lt;dim&gt;(</div><div class="line">                    temperature_fe, stokes_fe, mapping, quadrature_formula),</div><div class="line">                  Assembly::CopyData::TemperatureRHS&lt;dim&gt;(temperature_fe));</div><div class="line"></div><div class="line">  temperature_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsolve"></a> </p><h4>BoussinesqFlowProblem::solve</h4>
<p>This function solves the linear systems in each time step of the Boussinesq problem. First, we work on the Stokes system and then on the temperature system. In essence, it does the same things as the respective function in <a class="el" href="step_31.html">step-31</a>. However, there are a few changes here.</p>
<p>The first change is related to the way we store our solution: we keep the vectors with locally owned degrees of freedom plus ghost nodes on each MPI node. When we enter a solver which is supposed to perform matrix-vector products with a distributed matrix, this is not the appropriate form, though. There, we will want to have the solution vector to be distributed in the same way as the matrix, i.e. without any ghosts. So what we do first is to generate a distributed vector called <code>distributed_stokes_solution</code> and put only the locally owned dofs into that, which is neatly done by the <code>operator=</code> of the Trilinos vector.</p>
<p>Next, we scale the pressure solution (or rather, the initial guess) for the solver so that it matches with the length scales in the matrices, as discussed in the introduction. We also immediately scale the pressure solution back to the correct units after the solution is completed. We also need to set the pressure values at hanging nodes to zero. This we also did in <a class="el" href="step_31.html">step-31</a> in order not to disturb the Schur complement by some vector entries that actually are irrelevant during the solve stage. As a difference to <a class="el" href="step_31.html">step-31</a>, here we do it only for the locally owned pressure dofs. After solving for the Stokes solution, each processor copies the distributed solution back into the solution vector that also includes ghost elements.</p>
<p>The third and most obvious change is that we have two variants for the Stokes solver: A fast solver that sometimes breaks down, and a robust solver that is slower. This is what we already discussed in the introduction. Here is how we realize it: First, we perform 30 iterations with the fast solver based on the simple preconditioner based on the AMG V-cycle instead of an approximate solve (this is indicated by the <code>false</code> argument to the <code>LinearSolvers::BlockSchurPreconditioner</code> object). If we converge, everything is fine. If we do not converge, the solver control object will throw an exception <a class="el" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a>. Usually, this would abort the program because we don't catch them in our usual <code>solve()</code> functions. This is certainly not what we want to happen here. Rather, we want to switch to the strong solver and continue the solution process with whatever vector we got so far. Hence, we catch the exception with the C++ try/catch mechanism. We then simply go through the same solver sequence again in the <code>catch</code> clause, this time passing the <code>true</code> flag to the preconditioner for the strong solver, signaling an approximate CG solve.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Solve Stokes system&quot;</span>);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solving Stokes system... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes_solution(</div><div class="line">      stokes_rhs);</div><div class="line">    distributed_stokes_solution = stokes_solution;</div><div class="line"></div><div class="line">    distributed_stokes_solution.block(1) /= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">      start = (distributed_stokes_solution.block(0).size() +</div><div class="line">               distributed_stokes_solution.block(1).local_range().first),</div><div class="line">      <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>   = (distributed_stokes_solution.block(0).size() +</div><div class="line">             distributed_stokes_solution.block(1).local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = start; i &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++i)</div><div class="line">      <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">        distributed_stokes_solution(i) = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classPrimitiveVectorMemory.html">PrimitiveVectorMemory&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> mem;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_iterations     = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>  solver_tolerance = 1e-8 * stokes_rhs.l2_norm();</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(30, solver_tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">          preconditioner(stokes_matrix,</div><div class="line">                         stokes_preconditioner_matrix,</div><div class="line">                         *Mp_preconditioner,</div><div class="line">                         *Amg_preconditioner,</div><div class="line">                         <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> solver(</div><div class="line">          solver_control,</div><div class="line">          mem,</div><div class="line">          <a class="code" href="structSolverFGMRES_1_1AdditionalData.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            30));</div><div class="line">        solver.solve(stokes_matrix,</div><div class="line">                     distributed_stokes_solution,</div><div class="line">                     stokes_rhs,</div><div class="line">                     preconditioner);</div><div class="line"></div><div class="line">        n_iterations = solver_control.last_step();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">catch</span> (<a class="code" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a> &amp;)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">          preconditioner(stokes_matrix,</div><div class="line">                         stokes_preconditioner_matrix,</div><div class="line">                         *Mp_preconditioner,</div><div class="line">                         *Amg_preconditioner,</div><div class="line">                         <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control_refined(stokes_matrix.m(),</div><div class="line">                                             solver_tolerance);</div><div class="line">        <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> solver(</div><div class="line">          solver_control_refined,</div><div class="line">          mem,</div><div class="line">          <a class="code" href="structSolverFGMRES_1_1AdditionalData.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            50));</div><div class="line">        solver.solve(stokes_matrix,</div><div class="line">                     distributed_stokes_solution,</div><div class="line">                     stokes_rhs,</div><div class="line">                     preconditioner);</div><div class="line"></div><div class="line">        n_iterations =</div><div class="line">          (solver_control.last_step() + solver_control_refined.last_step());</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    stokes_constraints.distribute(distributed_stokes_solution);</div><div class="line"></div><div class="line">    distributed_stokes_solution.block(1) *= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">    stokes_solution = distributed_stokes_solution;</div><div class="line">    pcout &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>Now let's turn to the temperature part: First, we compute the time step size. We found that we need smaller time steps for 3D than for 2D for the shell geometry. This is because the cells are more distorted in that case (it is the smallest edge length that determines the CFL number). Instead of computing the time step from maximum velocity and minimal mesh size as in <a class="el" href="step_31.html">step-31</a>, we compute local CFL numbers, i.e., on each cell we compute the maximum velocity times the mesh size, and compute the maximum of them. Hence, we need to choose the factor in front of the time step slightly smaller.</p>
<p>After temperature right hand side assembly, we solve the linear system for temperature (with fully distributed vectors without any ghosts), apply constraints and copy the vector back to one with ghosts.</p>
<p>In the end, we extract the temperature range similarly to <a class="el" href="step_31.html">step-31</a> to produce some output (for example in order to help us choose the stabilization constants, as discussed in the introduction). The only difference is that we need to exchange maxima over all processors.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Assemble temperature rhs&quot;</span>);</div><div class="line"></div><div class="line">    old_time_step = time_step;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> scaling = (dim == 3 ? 0.25 : 1.0);</div><div class="line">    time_step            = (scaling / (2.1 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) /</div><div class="line">                 (parameters.temperature_degree * get_cfl_number()));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Maximal velocity: &quot;</span></div><div class="line">          &lt;&lt; maximal_velocity * EquationData::year_in_seconds * 100</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; cm/year&quot;</span> &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step / EquationData::year_in_seconds</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; years&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    temperature_solution = old_temperature_solution;</div><div class="line">    assemble_temperature_system(maximal_velocity);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Solve temperature system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                                 1e-12 * temperature_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temperature_solution(</div><div class="line">      temperature_rhs);</div><div class="line">    distributed_temperature_solution = temperature_solution;</div><div class="line"></div><div class="line">    cg.solve(temperature_matrix,</div><div class="line">             distributed_temperature_solution,</div><div class="line">             temperature_rhs,</div><div class="line">             *T_preconditioner);</div><div class="line"></div><div class="line">    temperature_constraints.distribute(distributed_temperature_solution);</div><div class="line">    temperature_solution = distributed_temperature_solution;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> temperature[2] = {<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">                             -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>()};</div><div class="line">    <span class="keywordtype">double</span> global_temperature[2];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =</div><div class="line">           distributed_temperature_solution.local_range().first;</div><div class="line">         i &lt; distributed_temperature_solution.local_range().second;</div><div class="line">         ++i)</div><div class="line">      {</div><div class="line">        temperature[0] =</div><div class="line">          std::min&lt;double&gt;(temperature[0],</div><div class="line">                           distributed_temperature_solution(i));</div><div class="line">        temperature[1] =</div><div class="line">          std::max&lt;double&gt;(temperature[1],</div><div class="line">                           distributed_temperature_solution(i));</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature[0] *= -1.0;</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(temperature, MPI_COMM_WORLD, global_temperature);</div><div class="line">    global_temperature[0] *= -1.0;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; global_temperature[0] &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">          &lt;&lt; global_temperature[1] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemoutput_results"></a> </p><h4>BoussinesqFlowProblem::output_results</h4>
<p>Next comes the function that generates the output. The quantities to output could be introduced manually like we did in <a class="el" href="step_31.html">step-31</a>. An alternative is to hand this task over to a class PostProcessor that inherits from the class <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>, which can be attached to <a class="el" href="classDataOut.html">DataOut</a>. This allows us to output derived quantities from the solution, like the friction heating included in this example. It overloads the virtual function <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a>, which is then internally called from <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. We have to give it values of the numerical solution, its derivatives, normals to the cell, the actual evaluation points and any additional quantities. This follows the same procedure as discussed in <a class="el" href="step_29.html">step-29</a> and other programs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem&lt;dim&gt;::Postprocessor</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="classDataPostprocessor.html">DataPostprocessor</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Postprocessor(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> minimal_pressure);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::vector&lt;std::string&gt; <a class="code" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::vector&lt;</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">  <a class="code" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">get_data_component_interpretation</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="code" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::Postprocessor(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure)</div><div class="line">  : partition(partition)</div><div class="line">  , minimal_pressure(minimal_pressure)</div><div class="line">{}</div></div><!-- fragment --><p>Here we define the names for the variables we want to output. These are the actual solution values for velocity, pressure, and temperature, as well as the friction heating and to each cell the number of the processor that owns it. This allows us to visualize the partitioning of the domain among the processors. Except for the velocity, which is vector-valued, all other quantities are scalar.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;std::string&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_names()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;friction_heating&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;partition&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> solution_names;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_data_component_interpretation()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    interpretation(dim,</div><div class="line">                   <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> interpretation;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_needed_update_flags()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>;</div><div class="line">}</div></div><!-- fragment --><p>Now we implement the function that computes the derived quantities. As we also did for the output, we rescale the velocity from its SI units to something more readable, namely cm/year. Next, the pressure is scaled to be between 0 and the maximum pressure. This makes it more easily comparable &ndash; in essence making all pressure variables positive or zero. Temperature is taken as is, and the friction heating is computed as \(2 \eta \varepsilon(\mathbf{u}) \cdot \varepsilon(\mathbf{u})\).</p>
<p>The quantities we output here are more for illustration, rather than for actual scientific value. We come back to this briefly in the results section of this program and explain what one may in fact be interested in.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::evaluate_vector_field(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_quadrature_points = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size();</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>.size() == n_quadrature_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == n_quadrature_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[0].size() == dim + 2, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        computed_quantities[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) = (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) *</div><div class="line">                                     EquationData::year_in_seconds * 100);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> pressure =</div><div class="line">        (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim) - minimal_pressure);</div><div class="line">      computed_quantities[q](dim) = pressure;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> temperature        = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim + 1);</div><div class="line">      computed_quantities[q](dim + 1) = temperature;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> grad_u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        grad_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>[q][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_rate = <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(grad_u);</div><div class="line">      computed_quantities[q](dim + 2) =</div><div class="line">        2 * EquationData::eta * strain_rate * strain_rate;</div><div class="line"></div><div class="line">      computed_quantities[q](dim + 3) = <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The <code>output_results()</code> function has a similar task to the one in <a class="el" href="step_31.html">step-31</a>. However, here we are going to demonstrate a different technique on how to merge output from different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The way we're going to achieve this recombination is to create a joint <a class="el" href="classDoFHandler.html">DoFHandler</a> that collects both components, the Stokes solution and the temperature solution. This can be nicely done by combining the finite elements from the two systems to form one <a class="el" href="classFESystem.html">FESystem</a>, and let this collective system define a new <a class="el" href="classDoFHandler.html">DoFHandler</a> object. To be sure that everything was done correctly, we perform a sanity check that ensures that we got all the dofs from both Stokes and temperature even in the combined system. We then combine the data vectors. Unfortunately, there is no straight-forward relation that tells us how to sort Stokes and temperature vector into the joint vector. The way we can get around this trouble is to rely on the information collected in the <a class="el" href="classFESystem.html">FESystem</a>. For each dof on a cell, the joint finite element knows to which equation component (velocity component, pressure, or temperature) it belongs – that's the information we need! So we step through all cells (with iterators into all three DoFHandlers moving in sync), and for each joint cell dof, we read out that component using the <a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">FiniteElement::system_to_base_index</a> function (see there for a description of what the various parts of its return value contain). We also need to keep track whether we're on a Stokes dof or a temperature dof, which is contained in joint_fe.system_to_base_index(i).first.first. Eventually, the dof_indices data structures on either of the three systems tell us how the relation between global vector and local dofs looks like on the present cell, which concludes this tedious work. We make sure that each processor only works on the subdomain it owns locally (and not on ghost or artificial cells) when building the joint solution vector. The same will then have to be done in <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>, but that function does so automatically.</p>
<p>What we end up with is a set of patches that we can write using the functions in <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> in a variety of output formats. Here, we then have to pay attention that what each processor writes is really only its own part of the domain, i.e. we will want to write each processor's contribution into a separate file. This we do by adding an additional number to the filename when we write the solution. This is not really new, we did it similarly in <a class="el" href="step_40.html">step-40</a>. Note that we write in the compressed format <code></code>.vtu instead of plain vtk files, which saves quite some storage.</p>
<p>All the rest of the work is done in the PostProcessor class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer, <span class="stringliteral">&quot;Postprocessing&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(stokes_fe, 1, temperature_fe, 1);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> joint_dof_handler(triangulation);</div><div class="line">  joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">           stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> joint_solution;</div><div class="line">  joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(joint_dof_handler.locally_owned_dofs(),</div><div class="line">                        MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">      joint_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_stokes_dof_indices(</div><div class="line">      stokes_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_temperature_dof_indices(</div><div class="line">      temperature_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      joint_cell       = joint_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">      joint_endc       = joint_dof_handler.end(),</div><div class="line">      stokes_cell      = stokes_dof_handler.begin_active(),</div><div class="line">      temperature_cell = temperature_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">         ++joint_cell, ++stokes_cell, ++temperature_cell)</div><div class="line">      <span class="keywordflow">if</span> (joint_cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">          stokes_cell-&gt;get_dof_indices(local_stokes_dof_indices);</div><div class="line">          temperature_cell-&gt;get_dof_indices(local_temperature_dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_stokes_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                joint_solution(local_joint_dof_indices[i]) = stokes_solution(</div><div class="line">                  local_stokes_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                             .second]);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_temperature_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                  temperature_solution(</div><div class="line">                    local_temperature_dof_indices</div><div class="line">                      [joint_fe.system_to_base_index(i).second]);</div><div class="line">              }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  joint_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_joint_dofs(joint_dof_handler.n_dofs());</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(joint_dof_handler,</div><div class="line">                                          locally_relevant_joint_dofs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_joint_solution;</div><div class="line">  locally_relevant_joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(locally_relevant_joint_dofs,</div><div class="line">                                         MPI_COMM_WORLD);</div><div class="line">  locally_relevant_joint_solution = joint_solution;</div><div class="line"></div><div class="line">  Postprocessor postprocessor(<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                MPI_COMM_WORLD),</div><div class="line">                              stokes_solution.block(1).min());</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">  data_out.add_data_vector(locally_relevant_joint_solution, postprocessor);</div><div class="line">  data_out.build_patches();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> out_index = 0;</div><div class="line">  data_out.write_vtu_with_pvtu_record(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, out_index, MPI_COMM_WORLD, 5);</div><div class="line"></div><div class="line">  out_index++;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrefine_mesh"></a> </p><h4>BoussinesqFlowProblem::refine_mesh</h4>
<p>This function isn't really new either. Since the <code>setup_dofs</code> function that we call in the middle has its own timer section, we split timing this function into two sections. It will also allow us to easily identify which of the two is more expensive.</p>
<p>One thing of note, however, is that we only want to compute error indicators on the locally owned subdomain. In order to achieve this, we pass one additional argument to the <a class="el" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator::estimate</a> function. Note that the vector for error estimates is resized to the number of active cells present on the current process, which is less than the total number of active cells on all processors (but more than the number of locally owned active cells); each processor only has a few coarse cells around the locally owned ones, as also explained in <a class="el" href="step_40.html">step-40</a>.</p>
<p>The local error estimates are then handed to a parallel version of <a class="el" href="namespaceGridRefinement.html">GridRefinement</a> (in namespace <a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html">parallel::distributed::GridRefinement</a>, see also <a class="el" href="step_40.html">step-40</a>) which looks at the errors and finds the cells that need refinement by comparing the error values across processors. As in <a class="el" href="step_31.html">step-31</a>, we want to limit the maximum grid level. So in case some cells have been marked that are already at the finest level, we simply clear the refine flags.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">    temperature_trans(temperature_dof_handler);</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt;dim,</div><div class="line">                                          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>&gt;</div><div class="line">    stokes_trans(stokes_dof_handler);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;Refine mesh structure, part 1&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      temperature_dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(parameters.temperature_degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      temperature_solution,</div><div class="line">      estimated_error_per_cell,</div><div class="line">      <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">      <span class="keyword">nullptr</span>,</div><div class="line">      0,</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction</a>(</div><div class="line">      triangulation, estimated_error_per_cell, 0.3, 0.1);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">             triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(max_grid_level);</div><div class="line">           cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">           ++cell)</div><div class="line">        cell-&gt;clear_refine_flag();</div></div><!-- fragment --><p>With all flags marked as necessary, we can then tell the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> objects to get ready to transfer data from one mesh to the next, which they will do when notified by <a class="el" href="classTriangulation.html">Triangulation</a> as part of the <code>execute_coarsening_and_refinement()</code> call. The syntax is similar to the non-parallel solution transfer (with the exception that here a pointer to the vector entries is enough). The remainder of the function further down below is then concerned with setting up the data structures again after mesh refinement and restoring the solution vectors on the new mesh.</p>
<div class="fragment"><div class="line">  std::vector&lt;const TrilinosWrappers::MPI::Vector *&gt; x_temperature(2);</div><div class="line">  x_temperature[0] = &amp;temperature_solution;</div><div class="line">  x_temperature[1] = &amp;old_temperature_solution;</div><div class="line">  std::vector&lt;const TrilinosWrappers::MPI::BlockVector *&gt; x_stokes(2);</div><div class="line">  x_stokes[0] = &amp;stokes_solution;</div><div class="line">  x_stokes[1] = &amp;old_stokes_solution;</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">  stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div><div class="line"></div><div class="line">setup_dofs();</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;Refine mesh structure, part 2&quot;</span>);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp1(temperature_rhs);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp2(temperature_rhs);</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector *&gt; tmp(2);</div><div class="line">    tmp[0] = &amp;(distributed_temp1);</div><div class="line">    tmp[1] = &amp;(distributed_temp2);</div><div class="line">    temperature_trans.interpolate(tmp);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">  temperature_constraints.distribute(distributed_temp1);</div><div class="line">  temperature_constraints.distribute(distributed_temp2);</div><div class="line"></div><div class="line">  temperature_solution     = distributed_temp1;</div><div class="line">  old_temperature_solution = distributed_temp2;</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes(stokes_rhs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_distributed_stokes(stokes_rhs);</div><div class="line"></div><div class="line">  std::vector&lt;TrilinosWrappers::MPI::BlockVector *&gt; stokes_tmp(2);</div><div class="line">  stokes_tmp[0] = &amp;(distributed_stokes);</div><div class="line">  stokes_tmp[1] = &amp;(old_distributed_stokes);</div><div class="line"></div><div class="line">  stokes_trans.interpolate(stokes_tmp);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">      stokes_constraints.distribute(distributed_stokes);</div><div class="line">      stokes_constraints.distribute(old_distributed_stokes);</div><div class="line"></div><div class="line">      stokes_solution     = distributed_stokes;</div><div class="line">      old_stokes_solution = old_distributed_stokes;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrun"></a> </p><h4>BoussinesqFlowProblem::run</h4>
<p>This is the final and controlling function in this class. It, in fact, runs the entire rest of the program and is, once more, very similar to <a class="el" href="step_31.html">step-31</a>. The only substantial difference is that we use a different mesh now (a <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> instead of a simple cube geometry).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(triangulation,</div><div class="line">                             <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(),</div><div class="line">                             EquationData::R0,</div><div class="line">                             EquationData::R1,</div><div class="line">                             (dim == 3) ? 96 : 12,</div><div class="line">                             <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(parameters.initial_global_refinement);</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">start_time_iteration:</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution(</div><div class="line">      temperature_dof_handler.locally_owned_dofs());</div></div><!-- fragment --><p><a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> supports parallel vector classes with most standard finite elements via deal.II's own native <a class="el" href="classMatrixFree.html">MatrixFree</a> framework: since we use standard Lagrange elements of moderate order this function works well here.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                     temperature_constraints,</div><div class="line">                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(parameters.temperature_degree + 2),</div><div class="line">                     EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                     solution);</div></div><!-- fragment --><p>Having so computed the current temperature field, let us set the member variable that holds the temperature nodes. Strictly speaking, we really only need to set <code>old_temperature_solution</code> since the first thing we will do is to compute the Stokes solution that only requires the previous time step's temperature field. That said, nothing good can come from not initializing the other vectors as well (especially since it's a relatively cheap operation and we only have to do it once at the beginning of the program) if we ever want to extend our numerical method or physical model, and so we initialize <code>old_temperature_solution</code> and <code>old_old_temperature_solution</code> as well. The assignment makes sure that the vectors on the left hand side (which where initialized to contain ghost elements as well) also get the correct ghost elements. In other words, the assignment here requires communication between processors:</p>
<div class="fragment"><div class="line">  temperature_solution         = solution;</div><div class="line">  old_temperature_solution     = solution;</div><div class="line">  old_old_temperature_solution = solution;</div><div class="line">}</div><div class="line"></div><div class="line">timestep_number = 0;</div><div class="line">time_step = old_time_step = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time / EquationData::year_in_seconds &lt;&lt; <span class="stringliteral">&quot; years&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_stokes_system();</div><div class="line">    build_stokes_preconditioner();</div><div class="line">    assemble_temperature_matrix();</div><div class="line"></div><div class="line">    solve();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">        (pre_refinement_step &lt; parameters.initial_adaptive_refinement))</div><div class="line">      {</div><div class="line">        refine_mesh(parameters.initial_global_refinement +</div><div class="line">                    parameters.initial_adaptive_refinement);</div><div class="line">        ++pre_refinement_step;</div><div class="line">        <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp;</div><div class="line">             (timestep_number % parameters.adaptive_refinement_interval ==</div><div class="line">              0))</div><div class="line">      refine_mesh(parameters.initial_global_refinement +</div><div class="line">                  parameters.initial_adaptive_refinement);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">        (timestep_number % parameters.graphical_output_interval == 0))</div><div class="line">      output_results();</div></div><!-- fragment --><p>In order to speed up linear solvers, we extrapolate the solutions from the old time levels to the new one. This gives a very good initial guess, cutting the number of iterations needed in solvers by more than one half. We do not need to extrapolate in the last iteration, so if we reached the final time, we stop here.</p>
<p>As the last thing during a time step (before actually bumping up the number of the time step), we check whether the current time step number is divisible by 100, and if so we let the computing timer print a summary of CPU times spent so far.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (time &gt; parameters.end_time * EquationData::year_in_seconds)</div><div class="line">  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_old_stokes_solution;</div><div class="line">old_old_stokes_solution      = old_stokes_solution;</div><div class="line">old_stokes_solution          = stokes_solution;</div><div class="line">old_old_temperature_solution = old_temperature_solution;</div><div class="line">old_temperature_solution     = temperature_solution;</div><div class="line"><span class="keywordflow">if</span> (old_time_step &gt; 0)</div><div class="line">  {</div></div><!-- fragment --><p>Trilinos sadd does not like ghost vectors even as input. Copy into distributed vectors for now:</p>
<div class="fragment"><div class="line">        {</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_solution(stokes_rhs);</div><div class="line">          distr_solution = stokes_solution;</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_old_solution(stokes_rhs);</div><div class="line">          distr_old_solution = old_old_stokes_solution;</div><div class="line">          distr_solution.<a class="code" href="classBlockVectorBase.html#a71b0ab8295e98caf3dfe1ef14ae6b6c1">sadd</a>(1. + time_step / old_time_step,</div><div class="line">                              -time_step / old_time_step,</div><div class="line">                              distr_old_solution);</div><div class="line">          stokes_solution = distr_solution;</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_solution(temperature_rhs);</div><div class="line">          distr_solution = temperature_solution;</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_old_solution(temperature_rhs);</div><div class="line">          distr_old_solution = old_old_temperature_solution;</div><div class="line">          distr_solution.sadd(1. + time_step / old_time_step,</div><div class="line">                              -time_step / old_time_step,</div><div class="line">                              distr_old_solution);</div><div class="line">          temperature_solution = distr_solution;</div><div class="line">        }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 100 == 0))</div><div class="line">      computing_timer.print_summary();</div><div class="line"></div><div class="line">    time += time_step;</div><div class="line">    ++timestep_number;</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>);</div></div><!-- fragment --><p>If we are generating graphical output, do so also for the last time step unless we had just done so before we left the do-while loop</p>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">        !((timestep_number - 1) % parameters.graphical_output_interval == 0))</div><div class="line">      output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step32</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function is short as usual and very similar to the one in <a class="el" href="step_31.html">step-31</a>. Since we use a parameter file which is specified as an argument in the command line, we have to read it in here and pass it on to the Parameters class for parsing. If no filename is given in the command line, we simply use the <code>step-32.prm</code> file which is distributed together with the program.</p>
<p>Because 3d computations are simply very slow unless you throw a lot of processors at them, the program defaults to 2d. You can get the 3d version by changing the constant dimension below to 3.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step32;</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      std::string parameter_filename;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt;= 2)</div><div class="line">        parameter_filename = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_filename = <span class="stringliteral">&quot;step-32.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span>                              dim = 2;</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt;::Parameters parameters(parameter_filename);</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt;             flow_problem(parameters);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When run, the program simulates convection in 3d in much the same way as <a class="el" href="step_31.html">step-31</a> did, though with an entirely different testcase.</p>
<p><a class="anchor" id="Comparisonofresultswithstep31"></a></p><h3>Comparison of results with step-31</h3>
<p>Before we go to this testcase, however, let us show a few results from a slightly earlier version of this program that was solving exactly the testcase we used in <a class="el" href="step_31.html">step-31</a>, just that we now solve it in parallel and with much higher resolution. We show these results mainly for comparison.</p>
<p>Here are two images that show this higher resolution if we choose a 3d computation in <code>main()</code> and if we set <code>initial_refinement=3</code> and <code>n_pre_refinement_steps=4</code>. At the time steps shown, the meshes had around 72,000 and 236,000 cells, for a total of 2,680,000 and 8,250,000 degrees of freedom, respectively, more than an order of magnitude more than we had available in <a class="el" href="step_31.html">step-31</a>:</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d.cube.0.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d.cube.1.png"/>
</div>
   </td></tr>
</table>
<p>The computation was done on a subset of 50 processors of the Brazos cluster at Texas A&amp;M University.</p>
<p><a class="anchor" id="Resultsfora2dcircularshelltestcase"></a></p><h3>Results for a 2d circular shell testcase</h3>
<p>Next, we will run <a class="el" href="step_32.html">step-32</a> with the parameter file in the directory with one change: we increase the final time to 1e9. Here we are using 16 processors. The command to launch is (note that <a class="el" href="step_32.html">step-32</a>.prm is the default):</p>
<p><code> </p><pre>
$ mpirun -np 16 ./step-32
</pre><p> </code></p>
<p>Note that running a job on a cluster typically requires going through a job scheduler, which we won't discuss here. The output will look roughly like this:</p>
<p><code> </p><pre>
$ mpirun -np 16 ./step-32
Number of active cells: 12,288 (on 6 levels)
Number of degrees of freedom: 186,624 (99,840+36,864+49,920)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0 years</pre><p></code></p>
<p><code></p><pre>   Rebuilding Stokes preconditioner...
   Solving Stokes system... 41 iterations.
   Maximal velocity: 60.4935 cm/year
   Time step: 18166.9 years
   17 CG iterations for temperature
   Temperature range: 973 4273.16</pre><p></code></p>
<p><code></p><pre>Number of active cells: 15,921 (on 7 levels)
Number of degrees of freedom: 252,723 (136,640+47,763+68,320)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0 years</pre><p></code></p>
<p><code></p><pre>   Rebuilding Stokes preconditioner...
   Solving Stokes system... 50 iterations.
   Maximal velocity: 60.3223 cm/year
   Time step: 10557.6 years
   19 CG iterations for temperature
   Temperature range: 973 4273.16</pre><p></code></p>
<p><code></p><pre>Number of active cells: 19,926 (on 8 levels)
Number of degrees of freedom: 321,246 (174,312+59,778+87,156)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0 years</pre><p></code></p>
<p><code></p><pre>   Rebuilding Stokes preconditioner...
   Solving Stokes system... 50 iterations.
   Maximal velocity: 57.8396 cm/year
   Time step: 5453.78 years
   18 CG iterations for temperature
   Temperature range: 973 4273.16</pre><p></code></p>
<p><code></p><pre>Timestep 1:  t=5453.78 years</pre><p></code></p>
<p><code></p><pre>   Solving Stokes system... 49 iterations.
   Maximal velocity: 59.0231 cm/year
   Time step: 5345.86 years
   18 CG iterations for temperature
   Temperature range: 973 4273.16</pre><p></code></p>
<p><code></p><pre>Timestep 2:  t=10799.6 years</pre><p></code></p>
<p><code></p><pre>   Solving Stokes system... 24 iterations.
   Maximal velocity: 60.2139 cm/year
   Time step: 5241.51 years
   17 CG iterations for temperature
   Temperature range: 973 4273.16</pre><p></code></p>
<p><code></p><pre>[...]</pre><p></code></p>
<p><code></p><pre>Timestep 100:  t=272151 years</pre><p></code></p>
<p><code></p><pre>   Solving Stokes system... 21 iterations.
   Maximal velocity: 161.546 cm/year
   Time step: 1672.96 years
   17 CG iterations for temperature
   Temperature range: 973 4282.57</pre><p></code></p>
<p><code></p><pre>Number of active cells: 56,085 (on 8 levels)
Number of degrees of freedom: 903,408 (490,102+168,255+245,051)</pre><p></code></p>
<p><code></p><pre>+---------------------------------------------+------------+------------+
| Total wallclock time elapsed since start    |       115s |            |
|                                             |            |            |
| Section                         | no. calls |  wall time | % of total |
+---------------------------------+-----------+------------+------------+
| Assemble Stokes system          |       103 |      2.82s |       2.5% |
| Assemble temperature matrices   |        12 |     0.452s |      0.39% |
| Assemble temperature rhs        |       103 |      11.5s |        10% |
| Build Stokes preconditioner     |        12 |      2.09s |       1.8% |
| Solve Stokes system             |       103 |      90.4s |        79% |
| Solve temperature system        |       103 |      1.53s |       1.3% |
| Postprocessing                  |         3 |     0.532s |      0.46% |
| Refine mesh structure, part 1   |        12 |      0.93s |      0.81% |
| Refine mesh structure, part 2   |        12 |     0.384s |      0.33% |
| Setup dof systems               |        13 |      2.96s |       2.6% |
+---------------------------------+-----------+------------+------------+</pre><p></code></p>
<p><code></p><pre>[...]</pre><p></code></p>
<p><code></p><pre>+---------------------------------------------+------------+------------+
| Total wallclock time elapsed since start    |  9.14e+04s |            |
|                                             |            |            |
| Section                         | no. calls |  wall time | % of total |
+---------------------------------+-----------+------------+------------+
| Assemble Stokes system          |     47045 |  2.05e+03s |       2.2% |
| Assemble temperature matrices   |      4707 |       310s |      0.34% |
| Assemble temperature rhs        |     47045 |   8.7e+03s |       9.5% |
| Build Stokes preconditioner     |      4707 |  1.48e+03s |       1.6% |
| Solve Stokes system             |     47045 |  7.34e+04s |        80% |
| Solve temperature system        |     47045 |  1.46e+03s |       1.6% |
| Postprocessing                  |      1883 |       222s |      0.24% |
| Refine mesh structure, part 1   |      4706 |       641s |       0.7% |
| Refine mesh structure, part 2   |      4706 |       259s |      0.28% |
| Setup dof systems               |      4707 |  1.86e+03s |         2% |
+---------------------------------+-----------+------------+------------+
</pre><p> </code></p>
<p>The simulation terminates when the time reaches the 1 billion years selected in the input file. You can extrapolate from this how long a simulation would take for a different final time (the time step size ultimately settles on somewhere around 20,000 years, so computing for two billion years will take 100,000 time steps, give or take 20%). As can be seen here, we spend most of the compute time in assembling linear systems and &mdash; above all &mdash; in solving Stokes systems.</p>
<p>To demonstrate the output we show the output from every 1250th time step here: </p><table class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-000.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-050.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-100.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-150.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-200.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-250.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-300.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-350.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-400.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-450.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-500.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-550.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-time-600.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-cells.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32-2d-partition.png"/>
</div>
   </td></tr>
</table>
<p>The last two images show the grid as well as the partitioning of the mesh for the same computation with 16 subdomains and 16 processors. The full dynamics of this simulation are really only visible by looking at an animation, for example the one <a href="https://www.dealii.org/images/steps/developer/step-32-2d-temperature.webm">shown on this site</a>. This image is well worth watching due to its artistic quality and entrancing depiction of the evolution of the magma plumes.</p>
<p>If you watch the movie, you'll see that the convection pattern goes through several stages: First, it gets rid of the instable temperature layering with the hot material overlain by the dense cold material. After this great driver is removed and we have a sort of stable situation, a few blobs start to separate from the hot boundary layer at the inner ring and rise up, with a few cold fingers also dropping down from the outer boundary layer. During this phase, the solution remains mostly symmetric, reflecting the 12-fold symmetry of the original mesh. In a final phase, the fluid enters vigorous chaotic stirring in which all symmetries are lost. This is a pattern that then continues to dominate flow.</p>
<p>These different phases can also be identified if we look at the maximal velocity as a function of time in the simulation:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d.t_vs_vmax.png"/>
</div>
<p>Here, the velocity (shown in centimeters per year) becomes very large, to the order of several meters per year) at the beginning when the temperature layering is instable. It then calms down to relatively small values before picking up again in the chaotic stirring regime. There, it remains in the range of 10-40 centimeters per year, quite within the physically expected region.</p>
<p><a class="anchor" id="Resultsfora3dsphericalshelltestcase"></a></p><h3>Results for a 3d spherical shell testcase</h3>
<p>3d computations are very expensive computationally. Furthermore, as seen above, interesting behavior only starts after quite a long time requiring more CPU hours than is available on a typical cluster. Consequently, rather than showing a complete simulation here, let us simply show a couple of pictures we have obtained using the successor to this program, called <em>ASPECT</em> (short for <em>Advanced Solver for Problems in Earth's ConvecTion</em>), that is being developed independently of deal.II and that already incorporates some of the extensions discussed below. The following two pictures show isocontours of the temperature and the partition of the domain (along with the mesh) onto 512 processors:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d-sphere.solution.png"/>
</div>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d-sphere.partition.png"/>
</div>
 <p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>There are many directions in which this program could be extended. As mentioned at the end of the introduction, most of these are under active development in the <em>ASPECT</em> (short for <em>Advanced Solver for Problems in Earth's ConvecTion</em>) code at the time this tutorial program is being finished. Specifically, the following are certainly topics that one should address to make the program more useful:</p>
<ul>
<li>
<p class="startli"><b>Adiabatic heating/cooling:</b> The temperature field we get in our simulations after a while is mostly constant with boundary layers at the inner and outer boundary, and streamers of cold and hot material mixing everything. Yet, this doesn't match our expectation that things closer to the earth core should be hotter than closer to the surface. The reason is that the energy equation we have used does not include a term that describes adiabatic cooling and heating: rock, like gas, heats up as you compress it. Consequently, material that rises up cools adiabatically, and cold material that sinks down heats adiabatically. The correct temperature equation would therefore look somewhat like this: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{D T}{Dt} - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma + \tau\frac{Dp}{Dt}, \end{eqnarray*}
</p>
<p> or, expanding the advected derivative \(\frac{D}{Dt} = \frac{\partial}{\partial t} + \mathbf u \cdot \nabla\): </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma + \tau\left\{\frac{\partial p}{\partial t} + \mathbf u \cdot \nabla p \right\}. \end{eqnarray*}
</p>
<p> In other words, as pressure increases in a rock volume ( \(\frac{Dp}{Dt}&gt;0\)) we get an additional heat source, and vice versa.</p>
<p>The time derivative of the pressure is a bit awkward to implement. If necessary, one could approximate using the fact outlined in the introduction that the pressure can be decomposed into a dynamic component due to temperature differences and the resulting flow, and a static component that results solely from the static pressure of the overlying rock. Since the latter is much bigger, one may approximate \(p\approx p_{\text{static}}=-\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi\), and consequently \(\frac{Dp}{Dt} \approx \left\{- \mathbf u \cdot \nabla \rho_{\text{ref}} [1+\beta T_{\text{ref}}]\varphi\right\} = \rho_{\text{ref}} [1+\beta T_{\text{ref}}] \mathbf u \cdot \mathbf g\). In other words, if the fluid is moving in the direction of gravity (downward) it will be compressed and because in that case \(\mathbf u \cdot \mathbf g &gt; 0\) we get a positive heat source. Conversely, the fluid will cool down if it moves against the direction of gravity.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Compressibility:</b> As already hinted at in the temperature model above, mantle rocks are not incompressible. Rather, given the enormous pressures in the earth mantle (at the core-mantle boundary, the pressure is approximately 140 GPa, equivalent to 1,400,000 times atmospheric pressure), rock actually does compress to something around 1.5 times the density it would have at surface pressure. Modeling this presents any number of difficulties. Primarily, the mass conservation equation is no longer \(\textrm{div}\;\mathbf u=0\) but should read \(\textrm{div}(\rho\mathbf u)=0\) where the density \(\rho\) is now no longer spatially constant but depends on temperature and pressure. A consequence is that the model is now no longer linear; a linearized version of the Stokes equation is also no longer symmetric requiring us to rethink preconditioners and, possibly, even the discretization. We won't go into detail here as to how this can be resolved.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Nonlinear material models:</b> As already hinted at in various places, material parameters such as the density, the viscosity, and the various thermal parameters are not constant throughout the earth mantle. Rather, they nonlinearly depend on the pressure and temperature, and in the case of the viscosity on the strain rate \(\varepsilon(\mathbf u)\). For complicated models, the only way to solve such models accurately may be to actually iterate this dependence out in each time step, rather than simply freezing coefficients at values extrapolated from the previous time step(s).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Checkpoint/restart:</b> Running this program in 2d on a number of processors allows solving realistic models in a day or two. However, in 3d, compute times are so large that one runs into two typical problems: (i) On most compute clusters, the queuing system limits run times for individual jobs are to 2 or 3 days; (ii) losing the results of a computation due to hardware failures, misconfigurations, or power outages is a shame when running on hundreds of processors for a couple of days. Both of these problems can be addressed by periodically saving the state of the program and, if necessary, restarting the program at this point. This technique is commonly called <em>checkpoint/restart</em> and it requires that the entire state of the program is written to a permanent storage location (e.g. a hard drive). Given the complexity of the data structures of this program, this is not entirely trivial (it may also involve writing gigabytes or more of data), but it can be made easier by realizing that one can save the state between two time steps where it essentially only consists of the mesh and solution vectors; during restart one would then first re-enumerate degrees of freedom in the same way as done before and then re-assemble matrices. Nevertheless, given the distributed nature of the data structures involved here, saving and restoring the state of a program is not trivial. An additional complexity is introduced by the fact that one may want to change the number of processors between runs, for example because one may wish to continue computing on a mesh that is finer than the one used to precompute a starting temperature field at an intermediate time.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Predictive postprocessing:</b> The point of computations like this is not simply to solve the equations. Rather, it is typically the exploration of different physical models and their comparison with things that we can measure at the earth surface, in order to find which models are realistic and which are contradicted by reality. To this end, we need to compute quantities from our solution vectors that are related to what we can observe. Among these are, for example, heatfluxes at the surface of the earth, as well as seismic velocities throughout the mantle as these affect earthquake waves that are recorded by seismographs.</p>
<p class="endli"></p>
</li>
<li>
<b>Better refinement criteria:</b> As can be seen above for the 3d case, the mesh in 3d is primarily refined along the inner boundary. This is because the boundary layer there is stronger than any other transition in the domain, leading us to refine there almost exclusively and basically not at all following the plumes. One certainly needs better refinement criteria to track the parts of the solution we are really interested in better than the criterion used here, namely the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> applied to the temperature, is able to. </li>
</ul>
<p>There are many other ways to extend the current program. However, rather than discussing them here, let us point to the much larger open source code ASPECT (see <a href="https://aspect.geodynamics.org/">https://aspect.geodynamics.org/</a> ) that constitutes the further development of <a class="el" href="step_32.html">step-32</a> and that already includes many such possible extensions.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2008 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Martin Kronbichler, Uppsala University,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University,</span></div><div class="line"><span class="comment"> *          Timo Heister, University of Goettingen, 2008-2011</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="filtered__iterator_8h.html">deal.II/grid/filtered_iterator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgp_8h.html">deal.II/fe/fe_dgp.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;locale&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step32</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>EquationData</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">double</span> eta                   = 1e21;    <span class="comment">/* Pa s       */</span></div><div class="line">    constexpr <span class="keywordtype">double</span> kappa                 = 1e-6;    <span class="comment">/* m^2 / s    */</span></div><div class="line">    constexpr <span class="keywordtype">double</span> reference_density     = 3300;    <span class="comment">/* kg / m^3   */</span></div><div class="line">    constexpr <span class="keywordtype">double</span> reference_temperature = 293;     <span class="comment">/* K          */</span></div><div class="line">    constexpr <span class="keywordtype">double</span> expansion_coefficient = 2e-5;    <span class="comment">/* 1/K        */</span></div><div class="line">    constexpr <span class="keywordtype">double</span> specific_heat         = 1250;    <span class="comment">/* J / K / kg */</span></div><div class="line">    constexpr <span class="keywordtype">double</span> radiogenic_heating    = 7.4e-12; <span class="comment">/* W / kg     */</span></div><div class="line"></div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">double</span> R0 = 6371000. - 2890000.; <span class="comment">/* m          */</span></div><div class="line">    constexpr <span class="keywordtype">double</span> R1 = 6371000. - 35000.;   <span class="comment">/* m          */</span></div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">double</span> T0 = 4000 + 273; <span class="comment">/* K          */</span></div><div class="line">    constexpr <span class="keywordtype">double</span> T1 = 700 + 273;  <span class="comment">/* K          */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> density(<span class="keyword">const</span> <span class="keywordtype">double</span> temperature)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> (</div><div class="line">        reference_density *</div><div class="line">        (1 - expansion_coefficient * (temperature - reference_temperature)));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> gravity_vector(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">      <span class="keywordflow">return</span> -(1.245e-6 * r + 7.714e13 / r / r) * p / r;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      TemperatureInitialValues()</div><div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> TemperatureInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> h = R1 - R0;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> s = (r - R0) / h;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> q =</div><div class="line">        (dim == 3) ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(0.0, <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * <a class="code" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">abs</a>(p(2) / R1))) : 1.0;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(p(0), p(1));</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> tau = s + 0.2 * s * (1 - s) * std::sin(6 * phi) * q;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> T0 * (1.0 - tau) + T1 * tau;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    TemperatureInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">double</span> pressure_scaling = eta / 10000;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> year_in_seconds = 60 * 60 * 24 * 365.2425;</div><div class="line"></div><div class="line">  } <span class="comment">// namespace EquationData</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LinearSolvers</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BlockSchurPreconditioner(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">                               <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;Spre,</div><div class="line">                               <span class="keyword">const</span> PreconditionerTypeMp &amp;Mppreconditioner,</div><div class="line">                               <span class="keyword">const</span> PreconditionerTypeA &amp; Apreconditioner,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">bool</span>                  do_solve_A)</div><div class="line">        : stokes_matrix(&amp;S)</div><div class="line">        , stokes_preconditioner_matrix(&amp;Spre)</div><div class="line">        , mp_preconditioner(Mppreconditioner)</div><div class="line">        , a_preconditioner(Apreconditioner)</div><div class="line">        , do_solve_A(do_solve_A)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> utmp(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line"></div><div class="line">        {</div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, 1e-6 * src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).l2_norm());</div><div class="line"></div><div class="line">          <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">          solver.solve(stokes_preconditioner_matrix-&gt;block(1, 1),</div><div class="line">                       dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                       src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                       mp_preconditioner);</div><div class="line"></div><div class="line">          dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) *= -1.0;</div><div class="line">        }</div><div class="line"></div><div class="line">        {</div><div class="line">          stokes_matrix-&gt;block(0, 1).vmult(utmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">          utmp *= -1.0;</div><div class="line">          utmp.add(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (do_solve_A == <span class="keyword">true</span>)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, utmp.l2_norm() * 1e-2);</div><div class="line">            <a class="code" href="classTrilinosWrappers_1_1SolverCG.html">TrilinosWrappers::SolverCG</a> solver(solver_control);</div><div class="line">            solver.solve(stokes_matrix-&gt;block(0, 0),</div><div class="line">                         dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0),</div><div class="line">                         utmp,</div><div class="line">                         a_preconditioner);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">        stokes_matrix;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">                                  stokes_preconditioner_matrix;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeMp &amp;mp_preconditioner;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp; a_preconditioner;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span>                  do_solve_A;</div><div class="line">    };</div><div class="line">  } <span class="comment">// namespace LinearSolvers</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>Assembly</div><div class="line">  {</div><div class="line">    <span class="keyword">namespace </span>Scratch</div><div class="line">    {</div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">      {</div><div class="line">        StokesPreconditioner(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags);</div><div class="line"></div><div class="line">        StokesPreconditioner(<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> stokes_fe_values;</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u;</div><div class="line">        std::vector&lt;double&gt;         phi_p;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">        : stokes_fe_values(mapping, stokes_fe, stokes_quadrature, update_flags)</div><div class="line">        , grad_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">        , phi_p(stokes_fe.n_dofs_per_cell())</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">        <span class="keyword">const</span> StokesPreconditioner &amp;scratch)</div><div class="line">        : stokes_fe_values(scratch.stokes_fe_values.get_mapping(),</div><div class="line">                           scratch.stokes_fe_values.get_fe(),</div><div class="line">                           scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                           scratch.stokes_fe_values.get_update_flags())</div><div class="line">        , grad_phi_u(scratch.grad_phi_u)</div><div class="line">        , phi_p(scratch.phi_p)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">      {</div><div class="line">        StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags);</div><div class="line"></div><div class="line">        StokesSystem(<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u;</div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u;</div><div class="line">        std::vector&lt;double&gt;                  div_phi_u;</div><div class="line"></div><div class="line">        std::vector&lt;double&gt; old_temperature_values;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesSystem&lt;dim&gt;::StokesSystem(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags)</div><div class="line">        : StokesPreconditioner&lt;dim&gt;(stokes_fe,</div><div class="line">                                    stokes_quadrature,</div><div class="line">                                    mapping,</div><div class="line">                                    stokes_update_flags)</div><div class="line">        , temperature_fe_values(mapping,</div><div class="line">                                temperature_fe,</div><div class="line">                                stokes_quadrature,</div><div class="line">                                temperature_update_flags)</div><div class="line">        , phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">        , grads_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">        , div_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">        , old_temperature_values(stokes_quadrature.size())</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesSystem&lt;dim&gt;::StokesSystem(<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;scratch)</div><div class="line">        : StokesPreconditioner&lt;dim&gt;(scratch)</div><div class="line">        , temperature_fe_values(</div><div class="line">            scratch.temperature_fe_values.get_mapping(),</div><div class="line">            scratch.temperature_fe_values.get_fe(),</div><div class="line">            scratch.temperature_fe_values.get_quadrature(),</div><div class="line">            scratch.temperature_fe_values.get_update_flags())</div><div class="line">        , phi_u(scratch.phi_u)</div><div class="line">        , grads_phi_u(scratch.grads_phi_u)</div><div class="line">        , div_phi_u(scratch.div_phi_u)</div><div class="line">        , old_temperature_values(scratch.old_temperature_values)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>TemperatureMatrix</div><div class="line">      {</div><div class="line">        TemperatureMatrix(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   temperature_quadrature);</div><div class="line"></div><div class="line">        TemperatureMatrix(<span class="keyword">const</span> TemperatureMatrix &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line"></div><div class="line">        std::vector&lt;double&gt;         phi_T;</div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   temperature_quadrature)</div><div class="line">        : temperature_fe_values(mapping,</div><div class="line">                                temperature_fe,</div><div class="line">                                temperature_quadrature,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">        , phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">        , grad_phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">        <span class="keyword">const</span> TemperatureMatrix &amp;scratch)</div><div class="line">        : temperature_fe_values(</div><div class="line">            scratch.temperature_fe_values.get_mapping(),</div><div class="line">            scratch.temperature_fe_values.get_fe(),</div><div class="line">            scratch.temperature_fe_values.get_quadrature(),</div><div class="line">            scratch.temperature_fe_values.get_update_flags())</div><div class="line">        , phi_T(scratch.phi_T)</div><div class="line">        , grad_phi_T(scratch.grad_phi_T)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>TemperatureRHS</div><div class="line">      {</div><div class="line">        TemperatureRHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line"></div><div class="line">        TemperatureRHS(<span class="keyword">const</span> TemperatureRHS &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> stokes_fe_values;</div><div class="line"></div><div class="line">        std::vector&lt;double&gt;         phi_T;</div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T;</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values;</div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_strain_rates;</div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_old_strain_rates;</div><div class="line"></div><div class="line">        std::vector&lt;double&gt;         old_temperature_values;</div><div class="line">        std::vector&lt;double&gt;         old_old_temperature_values;</div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads;</div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads;</div><div class="line">        std::vector&lt;double&gt;         old_temperature_laplacians;</div><div class="line">        std::vector&lt;double&gt;         old_old_temperature_laplacians;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureRHS&lt;dim&gt;::TemperatureRHS(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">        : temperature_fe_values(mapping,</div><div class="line">                                temperature_fe,</div><div class="line">                                quadrature,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">        , stokes_fe_values(mapping,</div><div class="line">                           stokes_fe,</div><div class="line">                           quadrature,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div><div class="line">        , phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">        , grad_phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">        ,</div><div class="line"></div><div class="line">        old_velocity_values(quadrature.size())</div><div class="line">        , old_old_velocity_values(quadrature.size())</div><div class="line">        , old_strain_rates(quadrature.size())</div><div class="line">        , old_old_strain_rates(quadrature.size())</div><div class="line">        ,</div><div class="line"></div><div class="line">        old_temperature_values(quadrature.size())</div><div class="line">        , old_old_temperature_values(quadrature.size())</div><div class="line">        , old_temperature_grads(quadrature.size())</div><div class="line">        , old_old_temperature_grads(quadrature.size())</div><div class="line">        , old_temperature_laplacians(quadrature.size())</div><div class="line">        , old_old_temperature_laplacians(quadrature.size())</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureRHS&lt;dim&gt;::TemperatureRHS(<span class="keyword">const</span> TemperatureRHS &amp;scratch)</div><div class="line">        : temperature_fe_values(</div><div class="line">            scratch.temperature_fe_values.get_mapping(),</div><div class="line">            scratch.temperature_fe_values.get_fe(),</div><div class="line">            scratch.temperature_fe_values.get_quadrature(),</div><div class="line">            scratch.temperature_fe_values.get_update_flags())</div><div class="line">        , stokes_fe_values(scratch.stokes_fe_values.get_mapping(),</div><div class="line">                           scratch.stokes_fe_values.get_fe(),</div><div class="line">                           scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                           scratch.stokes_fe_values.get_update_flags())</div><div class="line">        , phi_T(scratch.phi_T)</div><div class="line">        , grad_phi_T(scratch.grad_phi_T)</div><div class="line">        ,</div><div class="line"></div><div class="line">        old_velocity_values(scratch.old_velocity_values)</div><div class="line">        , old_old_velocity_values(scratch.old_old_velocity_values)</div><div class="line">        , old_strain_rates(scratch.old_strain_rates)</div><div class="line">        , old_old_strain_rates(scratch.old_old_strain_rates)</div><div class="line">        ,</div><div class="line"></div><div class="line">        old_temperature_values(scratch.old_temperature_values)</div><div class="line">        , old_old_temperature_values(scratch.old_old_temperature_values)</div><div class="line">        , old_temperature_grads(scratch.old_temperature_grads)</div><div class="line">        , old_old_temperature_grads(scratch.old_old_temperature_grads)</div><div class="line">        , old_temperature_laplacians(scratch.old_temperature_laplacians)</div><div class="line">        , old_old_temperature_laplacians(scratch.old_old_temperature_laplacians)</div><div class="line">      {}</div><div class="line">    } <span class="comment">// namespace Scratch</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">namespace </span>CopyData</div><div class="line">    {</div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">      {</div><div class="line">        StokesPreconditioner(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line">        StokesPreconditioner(<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line">        StokesPreconditioner &amp;operator=(<span class="keyword">const</span> StokesPreconditioner &amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_matrix;</div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">        : local_matrix(stokes_fe.n_dofs_per_cell(), stokes_fe.n_dofs_per_cell())</div><div class="line">        , local_dof_indices(stokes_fe.n_dofs_per_cell())</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">        <span class="keyword">const</span> StokesPreconditioner &amp;data)</div><div class="line">        : local_matrix(data.local_matrix)</div><div class="line">        , local_dof_indices(data.local_dof_indices)</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">      {</div><div class="line">        StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line"></div><div class="line">        Vector&lt;double&gt; local_rhs;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      StokesSystem&lt;dim&gt;::StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">        : StokesPreconditioner&lt;dim&gt;(stokes_fe)</div><div class="line">        , local_rhs(stokes_fe.n_dofs_per_cell())</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>TemperatureMatrix</div><div class="line">      {</div><div class="line">        TemperatureMatrix(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line"></div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_mass_matrix;</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_stiffness_matrix;</div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">        : local_mass_matrix(temperature_fe.n_dofs_per_cell(),</div><div class="line">                            temperature_fe.n_dofs_per_cell())</div><div class="line">        , local_stiffness_matrix(temperature_fe.n_dofs_per_cell(),</div><div class="line">                                 temperature_fe.n_dofs_per_cell())</div><div class="line">        , local_dof_indices(temperature_fe.n_dofs_per_cell())</div><div class="line">      {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      <span class="keyword">struct </span>TemperatureRHS</div><div class="line">      {</div><div class="line">        TemperatureRHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line"></div><div class="line">        Vector&lt;double&gt;                       local_rhs;</div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   matrix_for_bc;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">      TemperatureRHS&lt;dim&gt;::TemperatureRHS(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">        : local_rhs(temperature_fe.n_dofs_per_cell())</div><div class="line">        , local_dof_indices(temperature_fe.n_dofs_per_cell())</div><div class="line">        , matrix_for_bc(temperature_fe.n_dofs_per_cell(),</div><div class="line">                        temperature_fe.n_dofs_per_cell())</div><div class="line">      {}</div><div class="line">    } <span class="comment">// namespace CopyData</span></div><div class="line">  }   <span class="comment">// namespace Assembly</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">struct </span>Parameters;</div><div class="line">    BoussinesqFlowProblem(Parameters &amp;parameters);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">    <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">    <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">    <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">    <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">    <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_cfl_number() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">double</span> get_entropy_variation(<span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature) <span class="keyword">const</span>;</div><div class="line">    std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>                      solve();</div><div class="line">    <span class="keywordtype">void</span>                      output_results();</div><div class="line">    <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_strain_rates,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_old_strain_rates,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_u_infty,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_T_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                average_temperature,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_entropy_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">struct </span>Parameters</div><div class="line">    {</div><div class="line">      Parameters(<span class="keyword">const</span> std::string &amp;parameter_filename);</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">      <span class="keywordtype">void</span>        parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_global_refinement;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_adaptive_refinement;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span>         generate_graphical_output;</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> graphical_output_interval;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> adaptive_refinement_interval;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> stabilization_alpha;</div><div class="line">      <span class="keywordtype">double</span> stabilization_c_R;</div><div class="line">      <span class="keywordtype">double</span> stabilization_beta;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_velocity_degree;</div><div class="line">      <span class="keywordtype">bool</span>         use_locally_conservative_discretization;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temperature_degree;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    Parameters &amp;parameters;</div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keywordtype">double</span>                                    global_Omega_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>       stokes_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       old_time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt;    Amg_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; Mp_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; T_preconditioner;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_temperature_preconditioner;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_stokes_matrix(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line">    <span class="keywordtype">void</span> setup_stokes_preconditioner(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line">    <span class="keywordtype">void</span> setup_temperature_matrices(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioning,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioning);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_assemble_stokes_preconditioner(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">      Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> copy_local_to_global_stokes_preconditioner(</div><div class="line">      <span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_assemble_stokes_system(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">      Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> copy_local_to_global_stokes_system(</div><div class="line">      <span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_assemble_temperature_matrix(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">      Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> copy_local_to_global_temperature_matrix(</div><div class="line">      <span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_assemble_temperature_rhs(</div><div class="line">      <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_velocity,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_entropy_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">      Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> copy_local_to_global_temperature_rhs(</div><div class="line">      <span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line">    <span class="keyword">class </span>Postprocessor;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Parameters::Parameters(</div><div class="line">    <span class="keyword">const</span> std::string &amp;parameter_filename)</div><div class="line">    : end_time(1e8)</div><div class="line">    , initial_global_refinement(2)</div><div class="line">    , initial_adaptive_refinement(2)</div><div class="line">    , adaptive_refinement_interval(10)</div><div class="line">    , stabilization_alpha(2)</div><div class="line">    , stabilization_c_R(0.11)</div><div class="line">    , stabilization_beta(0.078)</div><div class="line">    , stokes_velocity_degree(2)</div><div class="line">    , use_locally_conservative_discretization(true)</div><div class="line">    , temperature_degree(2)</div><div class="line">  {</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">    BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters(prm);</div><div class="line"></div><div class="line">    std::ifstream parameter_file(parameter_filename);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!parameter_file)</div><div class="line">      {</div><div class="line">        parameter_file.close();</div><div class="line"></div><div class="line">        std::ofstream parameter_out(parameter_filename);</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(parameter_out, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">          <span class="keyword">false</span>,</div><div class="line">          <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">            <span class="stringliteral">&quot;Input parameter file &lt;&quot;</span> + parameter_filename +</div><div class="line">            <span class="stringliteral">&quot;&gt; not found. Creating a template file of the same name.&quot;</span>));</div><div class="line">      }</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">    parse_parameters(prm);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters(</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;End time&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;1e8&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The end time of the simulation in years.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Initial global refinement&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The number of global refinement steps performed on &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;the initial coarse mesh, before the problem is first &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;solved there.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The number of adaptive refinement steps performed after &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;initial global refinement.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                      <span class="stringliteral">&quot;The number of time steps after which the mesh is to be &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;adapted based on computed error indicators.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Generate graphical output&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Whether graphical output is to be generated or not. &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;You may not want to get graphical output if the number &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;of processors is large.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;50&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                      <span class="stringliteral">&quot;The number of time steps between each generation of &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;graphical output files.&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;alpha&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(1, 2),</div><div class="line">                        <span class="stringliteral">&quot;The exponent in the entropy viscosity stabilization.&quot;</span>);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c_R&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;0.11&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;The c_R factor in the entropy viscosity &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;stabilization.&quot;</span>);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;beta&quot;</span>,</div><div class="line">                        <span class="stringliteral">&quot;0.078&quot;</span>,</div><div class="line">                        <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                        <span class="stringliteral">&quot;The beta factor in the artificial viscosity &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;stabilization. An appropriate value for 2d is 0.052 &quot;</span></div><div class="line">                        <span class="stringliteral">&quot;and 0.078 for 3d.&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">        <span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">        <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">        <span class="stringliteral">&quot;The polynomial degree to use for the velocity variables &quot;</span></div><div class="line">        <span class="stringliteral">&quot;in the Stokes system.&quot;</span>);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">        <span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">        <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">        <span class="stringliteral">&quot;The polynomial degree to use for the temperature variable.&quot;</span>);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">        <span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">        <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">        <span class="stringliteral">&quot;Whether to use a Stokes discretization that is locally &quot;</span></div><div class="line">        <span class="stringliteral">&quot;conservative at the expense of a larger number of degrees &quot;</span></div><div class="line">        <span class="stringliteral">&quot;of freedom, or to go with a cheaper discretization &quot;</span></div><div class="line">        <span class="stringliteral">&quot;that does not locally conserve mass (although it is &quot;</span></div><div class="line">        <span class="stringliteral">&quot;globally conservative.&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Parameters::parse_parameters(</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    end_time                  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">    initial_global_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Initial global refinement&quot;</span>);</div><div class="line">    initial_adaptive_refinement =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>);</div><div class="line"></div><div class="line">    adaptive_refinement_interval =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>);</div><div class="line"></div><div class="line">    generate_graphical_output = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Generate graphical output&quot;</span>);</div><div class="line">    graphical_output_interval =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">    {</div><div class="line">      stabilization_alpha = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;alpha&quot;</span>);</div><div class="line">      stabilization_c_R   = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c_R&quot;</span>);</div><div class="line">      stabilization_beta  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;beta&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">    {</div><div class="line">      stokes_velocity_degree =</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>);</div><div class="line">      temperature_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>);</div><div class="line">      use_locally_conservative_discretization =</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>);</div><div class="line">    }</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem(Parameters &amp;parameters_)</div><div class="line">    : parameters(parameters_)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0))</div><div class="line">    ,</div><div class="line"></div><div class="line">    triangulation(MPI_COMM_WORLD,</div><div class="line">                  typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing(</div><div class="line">                    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening))</div><div class="line">    ,</div><div class="line"></div><div class="line">    global_Omega_diameter(0.)</div><div class="line">    ,</div><div class="line"></div><div class="line">    mapping(4)</div><div class="line">    ,</div><div class="line"></div><div class="line">    stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree),</div><div class="line">              dim,</div><div class="line">              (parameters.use_locally_conservative_discretization ?</div><div class="line">                 static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;(</div><div class="line">                   <a class="code" href="classFE__DGP.html">FE_DGP</a>&lt;dim&gt;(parameters.stokes_velocity_degree - 1)) :</div><div class="line">                 static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;(</div><div class="line">                   <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree - 1))),</div><div class="line">              1)</div><div class="line">    ,</div><div class="line"></div><div class="line">    stokes_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    temperature_fe(parameters.temperature_degree)</div><div class="line">    , temperature_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time_step(0)</div><div class="line">    , old_time_step(0)</div><div class="line">    , timestep_number(0)</div><div class="line">    , rebuild_stokes_matrix(true)</div><div class="line">    , rebuild_stokes_preconditioner(true)</div><div class="line">    , rebuild_temperature_matrices(true)</div><div class="line">    , rebuild_temperature_preconditioner(true)</div><div class="line">    ,</div><div class="line"></div><div class="line">    computing_timer(MPI_COMM_WORLD,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                            parameters.stokes_velocity_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(mapping,</div><div class="line">                            stokes_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_local_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                    velocity_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            max_local_velocity =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_local_velocity, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_cfl_number()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                            parameters.stokes_velocity_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(mapping,</div><div class="line">                            stokes_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_local_cfl = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                    velocity_values);</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> max_local_velocity = 1e-10;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            max_local_velocity =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">          max_local_cfl =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_cfl, max_local_velocity / cell-&gt;diameter());</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_local_cfl, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_entropy_variation(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (parameters.stabilization_alpha != 2)</div><div class="line">      <span class="keywordflow">return</span> 1.;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(parameters.temperature_degree + 1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>       fe_values(temperature_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> min_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">           max_entropy = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(), area = 0,</div><div class="line">           entropy_integrated = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                        old_temperature_values);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                        old_old_temperature_values);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> T =</div><div class="line">                (old_temperature_values[q] + old_old_temperature_values[q]) / 2;</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> entropy =</div><div class="line">                ((T - average_temperature) * (T - average_temperature));</div><div class="line"></div><div class="line">              min_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_entropy, entropy);</div><div class="line">              max_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_entropy, entropy);</div><div class="line">              area += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              entropy_integrated += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) * entropy;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> local_sums[2]   = {entropy_integrated, area},</div><div class="line">                 local_maxima[2] = {-min_entropy, max_entropy};</div><div class="line">    <span class="keywordtype">double</span> global_sums[2], global_maxima[2];</div><div class="line"></div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(local_sums, MPI_COMM_WORLD, global_sums);</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(local_maxima, MPI_COMM_WORLD, global_maxima);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> average_entropy = global_sums[0] / global_sums[1];</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> entropy_diff    = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(global_maxima[1] - average_entropy,</div><div class="line">                                         average_entropy - (-global_maxima[0]));</div><div class="line">    <span class="keywordflow">return</span> entropy_diff;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                            parameters.temperature_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>       fe_values(mapping,</div><div class="line">                            temperature_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> min_local_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">           max_local_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">            {</div><div class="line">              fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                            old_temperature_values);</div><div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                            old_old_temperature_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                    (1. + time_step / old_time_step) *</div><div class="line">                      old_temperature_values[q] -</div><div class="line">                    time_step / old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">                  min_local_temperature =</div><div class="line">                    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_local_temperature, temperature);</div><div class="line">                  max_local_temperature =</div><div class="line">                    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_temperature, temperature);</div><div class="line">                }</div><div class="line">            }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">            {</div><div class="line">              fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">              fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                            old_temperature_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                  min_local_temperature =</div><div class="line">                    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_local_temperature, temperature);</div><div class="line">                  max_local_temperature =</div><div class="line">                    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_temperature, temperature);</div><div class="line">                }</div><div class="line">            }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> local_extrema[2] = {-min_local_temperature, max_local_temperature};</div><div class="line">    <span class="keywordtype">double</span> global_extrema[2];</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(local_extrema, MPI_COMM_WORLD, global_extrema);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> std::make_pair(-global_extrema[0], global_extrema[1]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_strain_rates,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_old_strain_rates,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                average_temperature,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_entropy_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">      <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">    <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">          (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_rate =</div><div class="line">          (old_strain_rates[q] + old_old_strain_rates[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> T = (old_temperature[q] + old_old_temperature[q]) / 2;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">          (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">          EquationData::kappa *</div><div class="line">          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">          2;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> gamma =</div><div class="line">          ((EquationData::radiogenic_heating * EquationData::density(T) +</div><div class="line">            2 * EquationData::eta * strain_rate * strain_rate) /</div><div class="line">           (EquationData::density(T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> residual = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(dT_dt + u_grad_T - kappa_Delta_T - gamma);</div><div class="line">        <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">          residual *= <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(T - average_temperature);</div><div class="line"></div><div class="line">        max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_viscosity =</div><div class="line">      (parameters.stabilization_beta * max_velocity * cell_diameter);</div><div class="line">    <span class="keywordflow">if</span> (timestep_number == 0)</div><div class="line">      <span class="keywordflow">return</span> max_viscosity;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(old_time_step &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> entropy_viscosity;</div><div class="line">        <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">          entropy_viscosity =</div><div class="line">            (parameters.stabilization_c_R * cell_diameter * cell_diameter *</div><div class="line">             max_residual / global_entropy_variation);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          entropy_viscosity =</div><div class="line">            (parameters.stabilization_c_R * cell_diameter *</div><div class="line">             global_Omega_diameter * max_velocity * max_residual /</div><div class="line">             (global_u_infty * global_T_variation));</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(max_viscosity, entropy_viscosity);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_stokes_matrix(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">  {</div><div class="line">    stokes_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning,</div><div class="line">                                              stokes_partitioning,</div><div class="line">                                              stokes_relevant_partitioning,</div><div class="line">                                              MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(stokes_dof_handler,</div><div class="line">                                    coupling,</div><div class="line">                                    sp,</div><div class="line">                                    stokes_constraints,</div><div class="line">                                    <span class="keyword">false</span>,</div><div class="line">                                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                      MPI_COMM_WORLD));</div><div class="line">    sp.compress();</div><div class="line"></div><div class="line">    stokes_matrix.reinit(sp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_stokes_preconditioner(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">  {</div><div class="line">    Amg_preconditioner.reset();</div><div class="line">    Mp_preconditioner.reset();</div><div class="line"></div><div class="line">    stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning,</div><div class="line">                                              stokes_partitioning,</div><div class="line">                                              stokes_relevant_partitioning,</div><div class="line">                                              MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(stokes_dof_handler,</div><div class="line">                                    coupling,</div><div class="line">                                    sp,</div><div class="line">                                    stokes_constraints,</div><div class="line">                                    <span class="keyword">false</span>,</div><div class="line">                                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                      MPI_COMM_WORLD));</div><div class="line">    sp.compress();</div><div class="line"></div><div class="line">    stokes_preconditioner_matrix.reinit(sp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_temperature_matrices(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioner,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioner)</div><div class="line">  {</div><div class="line">    T_preconditioner.reset();</div><div class="line">    temperature_mass_matrix.clear();</div><div class="line">    temperature_stiffness_matrix.clear();</div><div class="line">    temperature_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(temperature_partitioner,</div><div class="line">                                         temperature_partitioner,</div><div class="line">                                         temperature_relevant_partitioner,</div><div class="line">                                         MPI_COMM_WORLD);</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                    sp,</div><div class="line">                                    temperature_constraints,</div><div class="line">                                    <span class="keyword">false</span>,</div><div class="line">                                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                      MPI_COMM_WORLD));</div><div class="line">    sp.compress();</div><div class="line"></div><div class="line">    temperature_matrix.reinit(sp);</div><div class="line">    temperature_mass_matrix.reinit(sp);</div><div class="line">    temperature_stiffness_matrix.reinit(sp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timing_section(computing_timer, <span class="stringliteral">&quot;Setup dof systems&quot;</span>);</div><div class="line"></div><div class="line">    stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">    stokes_sub_blocks[dim] = 1;</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                       n_p = stokes_dofs_per_block[1],</div><div class="line">                       n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">    std::locale s = pcout.get_stream().getloc();</div><div class="line">    pcout.get_stream().imbue(std::locale(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u</div><div class="line">          &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">    pcout.get_stream().imbue(s);</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; stokes_partitioning, stokes_relevant_partitioning;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>              temperature_partitioning(n_T),</div><div class="line">      temperature_relevant_partitioning(n_T);</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> stokes_relevant_set;</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> stokes_index_set = stokes_dof_handler.locally_owned_dofs();</div><div class="line">      stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u));</div><div class="line">      stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p));</div><div class="line"></div><div class="line">      <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(stokes_dof_handler,</div><div class="line">                                              stokes_relevant_set);</div><div class="line">      stokes_relevant_partitioning.push_back(</div><div class="line">        stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u));</div><div class="line">      stokes_relevant_partitioning.push_back(</div><div class="line">        stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p));</div><div class="line"></div><div class="line">      temperature_partitioning = temperature_dof_handler.locally_owned_dofs();</div><div class="line">      <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(</div><div class="line">        temperature_dof_handler, temperature_relevant_partitioning);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      stokes_constraints.clear();</div><div class="line">      stokes_constraints.reinit(stokes_relevant_set);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                              stokes_constraints);</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity_components(0);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        stokes_dof_handler,</div><div class="line">        0,</div><div class="line">        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1),</div><div class="line">        stokes_constraints,</div><div class="line">        stokes_fe.component_mask(velocity_components));</div><div class="line"></div><div class="line">      std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">      no_normal_flux_boundaries.insert(1);</div><div class="line">      <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                      0,</div><div class="line">                                                      no_normal_flux_boundaries,</div><div class="line">                                                      stokes_constraints,</div><div class="line">                                                      mapping);</div><div class="line">      stokes_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      temperature_constraints.clear();</div><div class="line">      temperature_constraints.reinit(temperature_relevant_partitioning);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                              temperature_constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        temperature_dof_handler,</div><div class="line">        0,</div><div class="line">        EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">        temperature_constraints);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        temperature_dof_handler,</div><div class="line">        1,</div><div class="line">        EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">        temperature_constraints);</div><div class="line">      temperature_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">    setup_stokes_matrix(stokes_partitioning, stokes_relevant_partitioning);</div><div class="line">    setup_stokes_preconditioner(stokes_partitioning,</div><div class="line">                                stokes_relevant_partitioning);</div><div class="line">    setup_temperature_matrices(temperature_partitioning,</div><div class="line">                               temperature_relevant_partitioning);</div><div class="line"></div><div class="line">    stokes_rhs.reinit(stokes_partitioning,</div><div class="line">                      stokes_relevant_partitioning,</div><div class="line">                      MPI_COMM_WORLD,</div><div class="line">                      <span class="keyword">true</span>);</div><div class="line">    stokes_solution.reinit(stokes_relevant_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_stokes_solution.reinit(stokes_solution);</div><div class="line"></div><div class="line">    temperature_rhs.reinit(temperature_partitioning,</div><div class="line">                           temperature_relevant_partitioning,</div><div class="line">                           MPI_COMM_WORLD,</div><div class="line">                           <span class="keyword">true</span>);</div><div class="line">    temperature_solution.reinit(temperature_relevant_partitioning,</div><div class="line">                                MPI_COMM_WORLD);</div><div class="line">    old_temperature_solution.reinit(temperature_solution);</div><div class="line">    old_old_temperature_solution.reinit(temperature_solution);</div><div class="line"></div><div class="line">    rebuild_stokes_matrix              = <span class="keyword">true</span>;</div><div class="line">    rebuild_stokes_preconditioner      = <span class="keyword">true</span>;</div><div class="line">    rebuild_temperature_matrices       = <span class="keyword">true</span>;</div><div class="line">    rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_stokes_preconditioner(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">    Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    scratch.stokes_fe_values.reinit(cell);</div><div class="line">    cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">    data.local_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.grad_phi_u[k] =</div><div class="line">              scratch.stokes_fe_values[velocities].gradient(k, q);</div><div class="line">            scratch.phi_p[k] = scratch.stokes_fe_values[pressure].value(k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            data.local_matrix(i, j) +=</div><div class="line">              (EquationData::eta *</div><div class="line">                 <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(scratch.grad_phi_u[i], scratch.grad_phi_u[j]) +</div><div class="line">               (1. / EquationData::eta) * EquationData::pressure_scaling *</div><div class="line">                 EquationData::pressure_scaling *</div><div class="line">                 (scratch.phi_p[i] * scratch.phi_p[j])) *</div><div class="line">              scratch.stokes_fe_values.JxW(q);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_stokes_preconditioner(</div><div class="line">    <span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    stokes_constraints.distribute_local_to_global(data.local_matrix,</div><div class="line">                                                  data.local_dof_indices,</div><div class="line">                                                  stokes_preconditioner_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">  {</div><div class="line">    stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree + 1);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> CellFilter =</div><div class="line">      <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> worker =</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">             Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">             Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data) {</div><div class="line">        this-&gt;local_assemble_stokes_preconditioner(cell, scratch, data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> copier =</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data) {</div><div class="line">        this-&gt;copy_local_to_global_stokes_preconditioner(data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                               stokes_dof_handler.begin_active()),</div><div class="line">                    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                               stokes_dof_handler.end()),</div><div class="line">                    worker,</div><div class="line">                    copier,</div><div class="line">                    Assembly::Scratch::StokesPreconditioner&lt;dim&gt;(</div><div class="line">                      stokes_fe,</div><div class="line">                      quadrature_formula,</div><div class="line">                      mapping,</div><div class="line">                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>),</div><div class="line">                    Assembly::CopyData::StokesPreconditioner&lt;dim&gt;(stokes_fe));</div><div class="line"></div><div class="line">    stokes_preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Build Stokes preconditioner&quot;</span>);</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                     stokes_fe.component_mask(</div><div class="line">                                       velocity_components),</div><div class="line">                                     constant_modes);</div><div class="line"></div><div class="line">    Mp_preconditioner =</div><div class="line">      std::make_shared&lt;TrilinosWrappers::PreconditionJacobi&gt;();</div><div class="line">    Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> Amg_data;</div><div class="line">    Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">    Amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">    Amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">    Amg_data.smoother_sweeps       = 2;</div><div class="line">    Amg_data.aggregation_threshold = 0.02;</div><div class="line"></div><div class="line">    Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line">    Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                   Amg_data);</div><div class="line"></div><div class="line">    rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_stokes_system(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">    Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      scratch.stokes_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    scratch.stokes_fe_values.reinit(cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> temperature_cell(</div><div class="line">      &amp;triangulation, cell-&gt;level(), cell-&gt;index(), &amp;temperature_dof_handler);</div><div class="line">    scratch.temperature_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(temperature_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">      data.local_matrix = 0;</div><div class="line">    data.local_rhs = 0;</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.get_function_values(</div><div class="line">      old_temperature_solution, scratch.old_temperature_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = scratch.old_temperature_values[q];</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value(k, q);</div><div class="line">            <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">              {</div><div class="line">                scratch.grads_phi_u[k] =</div><div class="line">                  scratch.stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                scratch.div_phi_u[k] =</div><div class="line">                  scratch.stokes_fe_values[velocities].divergence(k, q);</div><div class="line">                scratch.phi_p[k] =</div><div class="line">                  scratch.stokes_fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              data.local_matrix(i, j) +=</div><div class="line">                (EquationData::eta * 2 *</div><div class="line">                   (scratch.grads_phi_u[i] * scratch.grads_phi_u[j]) -</div><div class="line">                 (EquationData::pressure_scaling * scratch.div_phi_u[i] *</div><div class="line">                  scratch.phi_p[j]) -</div><div class="line">                 (EquationData::pressure_scaling * scratch.phi_p[i] *</div><div class="line">                  scratch.div_phi_u[j])) *</div><div class="line">                scratch.stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> gravity = EquationData::gravity_vector(</div><div class="line">          scratch.stokes_fe_values.quadrature_point(q));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          data.local_rhs(i) += (EquationData::density(old_temperature) *</div><div class="line">                                gravity * scratch.phi_u[i]) *</div><div class="line">                               scratch.stokes_fe_values.JxW(q);</div><div class="line">      }</div><div class="line"></div><div class="line">    cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_stokes_system(</div><div class="line">    <span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_constraints.distribute_local_to_global(data.local_matrix,</div><div class="line">                                                    data.local_rhs,</div><div class="line">                                                    data.local_dof_indices,</div><div class="line">                                                    stokes_matrix,</div><div class="line">                                                    stokes_rhs);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      stokes_constraints.distribute_local_to_global(data.local_rhs,</div><div class="line">                                                    data.local_dof_indices,</div><div class="line">                                                    stokes_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Assemble Stokes system&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_matrix = 0;</div><div class="line"></div><div class="line">    stokes_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree + 1);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> CellFilter =</div><div class="line">      <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">      CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                 stokes_dof_handler.begin_active()),</div><div class="line">      CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(), stokes_dof_handler.end()),</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">             Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">             Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data) {</div><div class="line">        this-&gt;local_assemble_stokes_system(cell, scratch, data);</div><div class="line">      },</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data) {</div><div class="line">        this-&gt;copy_local_to_global_stokes_system(data);</div><div class="line">      },</div><div class="line">      Assembly::Scratch::StokesSystem&lt;dim&gt;(</div><div class="line">        stokes_fe,</div><div class="line">        mapping,</div><div class="line">        quadrature_formula,</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">         (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0))),</div><div class="line">        temperature_fe,</div><div class="line">        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>),</div><div class="line">      Assembly::CopyData::StokesSystem&lt;dim&gt;(stokes_fe));</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    stokes_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">    rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_temperature_matrix(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">    Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      scratch.temperature_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.reinit(cell);</div><div class="line">    cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">    data.local_mass_matrix      = 0;</div><div class="line">    data.local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.grad_phi_T[k] =</div><div class="line">              scratch.temperature_fe_values.shape_grad(k, q);</div><div class="line">            scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              data.local_mass_matrix(i, j) +=</div><div class="line">                (scratch.phi_T[i] * scratch.phi_T[j] *</div><div class="line">                 scratch.temperature_fe_values.JxW(q));</div><div class="line">              data.local_stiffness_matrix(i, j) +=</div><div class="line">                (EquationData::kappa * scratch.grad_phi_T[i] *</div><div class="line">                 scratch.grad_phi_T[j] * scratch.temperature_fe_values.JxW(q));</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_temperature_matrix(</div><div class="line">    <span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    temperature_constraints.distribute_local_to_global(data.local_mass_matrix,</div><div class="line">                                                       data.local_dof_indices,</div><div class="line">                                                       temperature_mass_matrix);</div><div class="line">    temperature_constraints.distribute_local_to_global(</div><div class="line">      data.local_stiffness_matrix,</div><div class="line">      data.local_dof_indices,</div><div class="line">      temperature_stiffness_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Assemble temperature matrices&quot;</span>);</div><div class="line">    temperature_mass_matrix      = 0;</div><div class="line">    temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree + 2);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> CellFilter =</div><div class="line">      <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">      CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                 temperature_dof_handler.begin_active()),</div><div class="line">      CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                 temperature_dof_handler.end()),</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">             Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">             Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data) {</div><div class="line">        this-&gt;local_assemble_temperature_matrix(cell, scratch, data);</div><div class="line">      },</div><div class="line">      [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data) {</div><div class="line">        this-&gt;copy_local_to_global_temperature_matrix(data);</div><div class="line">      },</div><div class="line">      Assembly::Scratch::TemperatureMatrix&lt;dim&gt;(temperature_fe,</div><div class="line">                                                mapping,</div><div class="line">                                                quadrature_formula),</div><div class="line">      Assembly::CopyData::TemperatureMatrix&lt;dim&gt;(temperature_fe));</div><div class="line"></div><div class="line">    temperature_mass_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    temperature_stiffness_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">    rebuild_temperature_matrices       = <span class="keyword">false</span>;</div><div class="line">    rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_temperature_rhs(</div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_velocity,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_entropy_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">    Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      scratch.temperature_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    data.local_rhs     = 0;</div><div class="line">    data.matrix_for_bc = 0;</div><div class="line">    cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> stokes_cell(</div><div class="line">      &amp;triangulation, cell-&gt;level(), cell-&gt;index(), &amp;stokes_dof_handler);</div><div class="line">    scratch.stokes_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(stokes_cell);</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.get_function_values(</div><div class="line">      old_temperature_solution, scratch.old_temperature_values);</div><div class="line">    scratch.temperature_fe_values.get_function_values(</div><div class="line">      old_old_temperature_solution, scratch.old_old_temperature_values);</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.get_function_gradients(</div><div class="line">      old_temperature_solution, scratch.old_temperature_grads);</div><div class="line">    scratch.temperature_fe_values.get_function_gradients(</div><div class="line">      old_old_temperature_solution, scratch.old_old_temperature_grads);</div><div class="line"></div><div class="line">    scratch.temperature_fe_values.get_function_laplacians(</div><div class="line">      old_temperature_solution, scratch.old_temperature_laplacians);</div><div class="line">    scratch.temperature_fe_values.get_function_laplacians(</div><div class="line">      old_old_temperature_solution, scratch.old_old_temperature_laplacians);</div><div class="line"></div><div class="line">    scratch.stokes_fe_values[velocities].get_function_values(</div><div class="line">      stokes_solution, scratch.old_velocity_values);</div><div class="line">    scratch.stokes_fe_values[velocities].get_function_values(</div><div class="line">      old_stokes_solution, scratch.old_old_velocity_values);</div><div class="line">    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients(</div><div class="line">      stokes_solution, scratch.old_strain_rates);</div><div class="line">    scratch.stokes_fe_values[velocities].get_function_symmetric_gradients(</div><div class="line">      old_stokes_solution, scratch.old_old_strain_rates);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">      compute_viscosity(scratch.old_temperature_values,</div><div class="line">                        scratch.old_old_temperature_values,</div><div class="line">                        scratch.old_temperature_grads,</div><div class="line">                        scratch.old_old_temperature_grads,</div><div class="line">                        scratch.old_temperature_laplacians,</div><div class="line">                        scratch.old_old_temperature_laplacians,</div><div class="line">                        scratch.old_velocity_values,</div><div class="line">                        scratch.old_old_velocity_values,</div><div class="line">                        scratch.old_strain_rates,</div><div class="line">                        scratch.old_old_strain_rates,</div><div class="line">                        global_max_velocity,</div><div class="line">                        global_T_range.second - global_T_range.first,</div><div class="line">                        0.5 * (global_T_range.second + global_T_range.first),</div><div class="line">                        global_entropy_variation,</div><div class="line">                        cell-&gt;diameter());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">          {</div><div class="line">            scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);</div><div class="line">            scratch.grad_phi_T[k] =</div><div class="line">              scratch.temperature_fe_values.shape_grad(k, q);</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">          (use_bdf2_scheme ?</div><div class="line">             (scratch.old_temperature_values[q] *</div><div class="line">                (1 + time_step / old_time_step) -</div><div class="line">              scratch.old_old_temperature_values[q] * (time_step * time_step) /</div><div class="line">                (old_time_step * (time_step + old_time_step))) :</div><div class="line">             scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ext_T =</div><div class="line">          (use_bdf2_scheme ? (scratch.old_temperature_values[q] *</div><div class="line">                                (1 + time_step / old_time_step) -</div><div class="line">                              scratch.old_old_temperature_values[q] *</div><div class="line">                                time_step / old_time_step) :</div><div class="line">                             scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">          (use_bdf2_scheme ? (scratch.old_temperature_grads[q] *</div><div class="line">                                (1 + time_step / old_time_step) -</div><div class="line">                              scratch.old_old_temperature_grads[q] * time_step /</div><div class="line">                                old_time_step) :</div><div class="line">                             scratch.old_temperature_grads[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">          (use_bdf2_scheme ?</div><div class="line">             (scratch.old_velocity_values[q] * (1 + time_step / old_time_step) -</div><div class="line">              scratch.old_old_velocity_values[q] * time_step / old_time_step) :</div><div class="line">             scratch.old_velocity_values[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> extrapolated_strain_rate =</div><div class="line">          (use_bdf2_scheme ?</div><div class="line">             (scratch.old_strain_rates[q] * (1 + time_step / old_time_step) -</div><div class="line">              scratch.old_old_strain_rates[q] * time_step / old_time_step) :</div><div class="line">             scratch.old_strain_rates[q]);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> gamma =</div><div class="line">          ((EquationData::radiogenic_heating * EquationData::density(ext_T) +</div><div class="line">            2 * EquationData::eta * extrapolated_strain_rate *</div><div class="line">              extrapolated_strain_rate) /</div><div class="line">           (EquationData::density(ext_T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            data.local_rhs(i) +=</div><div class="line">              (T_term_for_rhs * scratch.phi_T[i] -</div><div class="line">               time_step * extrapolated_u * ext_grad_T * scratch.phi_T[i] -</div><div class="line">               time_step * nu * ext_grad_T * scratch.grad_phi_T[i] +</div><div class="line">               time_step * gamma * scratch.phi_T[i]) *</div><div class="line">              scratch.temperature_fe_values.JxW(q);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (temperature_constraints.is_inhomogeneously_constrained(</div><div class="line">                  data.local_dof_indices[i]))</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  data.matrix_for_bc(j, i) +=</div><div class="line">                    (scratch.phi_T[i] * scratch.phi_T[j] *</div><div class="line">                       (use_bdf2_scheme ? ((2 * time_step + old_time_step) /</div><div class="line">                                           (time_step + old_time_step)) :</div><div class="line">                                          1.) +</div><div class="line">                     scratch.grad_phi_T[i] * scratch.grad_phi_T[j] *</div><div class="line">                       EquationData::kappa * time_step) *</div><div class="line">                    scratch.temperature_fe_values.JxW(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_temperature_rhs(</div><div class="line">    <span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data)</div><div class="line">  {</div><div class="line">    temperature_constraints.distribute_local_to_global(data.local_rhs,</div><div class="line">                                                       data.local_dof_indices,</div><div class="line">                                                       temperature_rhs,</div><div class="line">                                                       data.matrix_for_bc);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">        temperature_matrix *=</div><div class="line">          (2 * time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_temperature_preconditioner == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        T_preconditioner =</div><div class="line">          std::make_shared&lt;TrilinosWrappers::PreconditionJacobi&gt;();</div><div class="line">        T_preconditioner-&gt;initialize(temperature_matrix);</div><div class="line">        rebuild_temperature_preconditioner = <span class="keyword">false</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree + 2);</div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">      get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature =</div><div class="line">      0.5 * (global_T_range.first + global_T_range.second);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_entropy_variation =</div><div class="line">      get_entropy_variation(average_temperature);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> CellFilter =</div><div class="line">      <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> worker =</div><div class="line">      [<span class="keyword">this</span>, global_T_range, maximal_velocity, global_entropy_variation](</div><div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">        Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">        Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data) {</div><div class="line">        this-&gt;local_assemble_temperature_rhs(global_T_range,</div><div class="line">                                             maximal_velocity,</div><div class="line">                                             global_entropy_variation,</div><div class="line">                                             cell,</div><div class="line">                                             scratch,</div><div class="line">                                             data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> copier = [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_temperature_rhs(data);</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                               temperature_dof_handler.begin_active()),</div><div class="line">                    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                               temperature_dof_handler.end()),</div><div class="line">                    worker,</div><div class="line">                    copier,</div><div class="line">                    Assembly::Scratch::TemperatureRHS&lt;dim&gt;(</div><div class="line">                      temperature_fe, stokes_fe, mapping, quadrature_formula),</div><div class="line">                    Assembly::CopyData::TemperatureRHS&lt;dim&gt;(temperature_fe));</div><div class="line"></div><div class="line">    temperature_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                       <span class="stringliteral">&quot;   Solve Stokes system&quot;</span>);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Solving Stokes system... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes_solution(</div><div class="line">        stokes_rhs);</div><div class="line">      distributed_stokes_solution = stokes_solution;</div><div class="line"></div><div class="line">      distributed_stokes_solution.block(1) /= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">        start = (distributed_stokes_solution.block(0).size() +</div><div class="line">                 distributed_stokes_solution.block(1).local_range().first),</div><div class="line">        end   = (distributed_stokes_solution.block(0).size() +</div><div class="line">               distributed_stokes_solution.block(1).local_range().second);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = start; i &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++i)</div><div class="line">        <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">          distributed_stokes_solution(i) = 0;</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classPrimitiveVectorMemory.html">PrimitiveVectorMemory&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> mem;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_iterations     = 0;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>  solver_tolerance = 1e-8 * stokes_rhs.l2_norm();</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(30, solver_tolerance);</div><div class="line"></div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">            <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">            <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">            preconditioner(stokes_matrix,</div><div class="line">                           stokes_preconditioner_matrix,</div><div class="line">                           *Mp_preconditioner,</div><div class="line">                           *Amg_preconditioner,</div><div class="line">                           <span class="keyword">false</span>);</div><div class="line"></div><div class="line">          <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> solver(</div><div class="line">            solver_control,</div><div class="line">            mem,</div><div class="line">            <a class="code" href="structSolverFGMRES_1_1AdditionalData.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">              30));</div><div class="line">          solver.solve(stokes_matrix,</div><div class="line">                       distributed_stokes_solution,</div><div class="line">                       stokes_rhs,</div><div class="line">                       preconditioner);</div><div class="line"></div><div class="line">          n_iterations = solver_control.last_step();</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">catch</span> (<a class="code" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a> &amp;)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">            <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">            <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">            preconditioner(stokes_matrix,</div><div class="line">                           stokes_preconditioner_matrix,</div><div class="line">                           *Mp_preconditioner,</div><div class="line">                           *Amg_preconditioner,</div><div class="line">                           <span class="keyword">true</span>);</div><div class="line"></div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control_refined(stokes_matrix.m(),</div><div class="line">                                               solver_tolerance);</div><div class="line">          <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> solver(</div><div class="line">            solver_control_refined,</div><div class="line">            mem,</div><div class="line">            <a class="code" href="structSolverFGMRES_1_1AdditionalData.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">              50));</div><div class="line">          solver.solve(stokes_matrix,</div><div class="line">                       distributed_stokes_solution,</div><div class="line">                       stokes_rhs,</div><div class="line">                       preconditioner);</div><div class="line"></div><div class="line">          n_iterations =</div><div class="line">            (solver_control.last_step() + solver_control_refined.last_step());</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      stokes_constraints.distribute(distributed_stokes_solution);</div><div class="line"></div><div class="line">      distributed_stokes_solution.block(1) *= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">      stokes_solution = distributed_stokes_solution;</div><div class="line">      pcout &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                       <span class="stringliteral">&quot;   Assemble temperature rhs&quot;</span>);</div><div class="line"></div><div class="line">      old_time_step = time_step;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> scaling = (dim == 3 ? 0.25 : 1.0);</div><div class="line">      time_step            = (scaling / (2.1 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) /</div><div class="line">                   (parameters.temperature_degree * get_cfl_number()));</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Maximal velocity: &quot;</span></div><div class="line">            &lt;&lt; maximal_velocity * EquationData::year_in_seconds * 100</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; cm/year&quot;</span> &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step / EquationData::year_in_seconds</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; years&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      temperature_solution = old_temperature_solution;</div><div class="line">      assemble_temperature_system(maximal_velocity);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                       <span class="stringliteral">&quot;   Solve temperature system&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                                   1e-12 * temperature_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temperature_solution(</div><div class="line">        temperature_rhs);</div><div class="line">      distributed_temperature_solution = temperature_solution;</div><div class="line"></div><div class="line">      cg.solve(temperature_matrix,</div><div class="line">               distributed_temperature_solution,</div><div class="line">               temperature_rhs,</div><div class="line">               *T_preconditioner);</div><div class="line"></div><div class="line">      temperature_constraints.distribute(distributed_temperature_solution);</div><div class="line">      temperature_solution = distributed_temperature_solution;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> temperature[2] = {<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">                               -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>()};</div><div class="line">      <span class="keywordtype">double</span> global_temperature[2];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =</div><div class="line">             distributed_temperature_solution.local_range().first;</div><div class="line">           i &lt; distributed_temperature_solution.local_range().second;</div><div class="line">           ++i)</div><div class="line">        {</div><div class="line">          temperature[0] =</div><div class="line">            std::min&lt;double&gt;(temperature[0],</div><div class="line">                             distributed_temperature_solution(i));</div><div class="line">          temperature[1] =</div><div class="line">            std::max&lt;double&gt;(temperature[1],</div><div class="line">                             distributed_temperature_solution(i));</div><div class="line">        }</div><div class="line"></div><div class="line">      temperature[0] *= -1.0;</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(temperature, MPI_COMM_WORLD, global_temperature);</div><div class="line">      global_temperature[0] *= -1.0;</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; global_temperature[0] &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">            &lt;&lt; global_temperature[1] &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoussinesqFlowProblem&lt;dim&gt;::Postprocessor</div><div class="line">    : <span class="keyword">public</span> <a class="code" href="classDataPostprocessor.html">DataPostprocessor</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Postprocessor(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> minimal_pressure);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::vector&lt;std::string&gt; get_names() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::vector&lt;</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">    get_data_component_interpretation() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> get_needed_update_flags() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::Postprocessor(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure)</div><div class="line">    : partition(partition)</div><div class="line">    , minimal_pressure(minimal_pressure)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;std::string&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_names()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;friction_heating&quot;</span>);</div><div class="line">    solution_names.emplace_back(<span class="stringliteral">&quot;partition&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> solution_names;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_data_component_interpretation()<span class="keyword"></span></div><div class="line"><span class="keyword">    const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      interpretation(dim,</div><div class="line">                     <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">    interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> interpretation;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_needed_update_flags()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_quadrature_points = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size();</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>.size() == n_quadrature_points,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == n_quadrature_points,</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[0].size() == dim + 2, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_quadrature_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          computed_quantities[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) = (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) *</div><div class="line">                                       EquationData::year_in_seconds * 100);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> pressure =</div><div class="line">          (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim) - minimal_pressure);</div><div class="line">        computed_quantities[q](dim) = pressure;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> temperature        = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim + 1);</div><div class="line">        computed_quantities[q](dim + 1) = temperature;</div><div class="line"></div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> grad_u;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          grad_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>[q][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_rate = <a class="code" href="symmetric__tensor_8h.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(grad_u);</div><div class="line">        computed_quantities[q](dim + 2) =</div><div class="line">          2 * EquationData::eta * strain_rate * strain_rate;</div><div class="line"></div><div class="line">        computed_quantities[q](dim + 3) = <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer, <span class="stringliteral">&quot;Postprocessing&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(stokes_fe, 1, temperature_fe, 1);</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> joint_dof_handler(triangulation);</div><div class="line">    joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">             stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> joint_solution;</div><div class="line">    joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(joint_dof_handler.locally_owned_dofs(),</div><div class="line">                          MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">        joint_fe.n_dofs_per_cell());</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_stokes_dof_indices(</div><div class="line">        stokes_fe.n_dofs_per_cell());</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_temperature_dof_indices(</div><div class="line">        temperature_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">      <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">        joint_cell       = joint_dof_handler.begin_active(),</div><div class="line">        joint_endc       = joint_dof_handler.end(),</div><div class="line">        stokes_cell      = stokes_dof_handler.begin_active(),</div><div class="line">        temperature_cell = temperature_dof_handler.begin_active();</div><div class="line">      <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">           ++joint_cell, ++stokes_cell, ++temperature_cell)</div><div class="line">        <span class="keywordflow">if</span> (joint_cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">            stokes_cell-&gt;get_dof_indices(local_stokes_dof_indices);</div><div class="line">            temperature_cell-&gt;get_dof_indices(local_temperature_dof_indices);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">              <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">                {</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                           local_stokes_dof_indices.size(),</div><div class="line">                         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                  joint_solution(local_joint_dof_indices[i]) = stokes_solution(</div><div class="line">                    local_stokes_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                               .second]);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                           local_temperature_dof_indices.size(),</div><div class="line">                         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                  joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                    temperature_solution(</div><div class="line">                      local_temperature_dof_indices</div><div class="line">                        [joint_fe.system_to_base_index(i).second]);</div><div class="line">                }</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">    joint_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_joint_dofs(joint_dof_handler.n_dofs());</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(joint_dof_handler,</div><div class="line">                                            locally_relevant_joint_dofs);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_joint_solution;</div><div class="line">    locally_relevant_joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(locally_relevant_joint_dofs,</div><div class="line">                                           MPI_COMM_WORLD);</div><div class="line">    locally_relevant_joint_solution = joint_solution;</div><div class="line"></div><div class="line">    Postprocessor postprocessor(<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                  MPI_COMM_WORLD),</div><div class="line">                                stokes_solution.block(1).min());</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">    data_out.add_data_vector(locally_relevant_joint_solution, postprocessor);</div><div class="line">    data_out.build_patches();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> out_index = 0;</div><div class="line">    data_out.write_vtu_with_pvtu_record(</div><div class="line">      <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, out_index, MPI_COMM_WORLD, 5);</div><div class="line"></div><div class="line">    out_index++;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">  {</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">      temperature_trans(temperature_dof_handler);</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt;dim,</div><div class="line">                                            <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>&gt;</div><div class="line">      stokes_trans(stokes_dof_handler);</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                       <span class="stringliteral">&quot;Refine mesh structure, part 1&quot;</span>);</div><div class="line"></div><div class="line">      Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        temperature_dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(parameters.temperature_degree + 1),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        temperature_solution,</div><div class="line">        estimated_error_per_cell,</div><div class="line">        <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">        <span class="keyword">nullptr</span>,</div><div class="line">        0,</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>());</div><div class="line"></div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction</a>(</div><div class="line">        triangulation, estimated_error_per_cell, 0.3, 0.1);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">               triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(max_grid_level);</div><div class="line">             cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">             ++cell)</div><div class="line">          cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">      std::vector&lt;const TrilinosWrappers::MPI::Vector *&gt; x_temperature(2);</div><div class="line">      x_temperature[0] = &amp;temperature_solution;</div><div class="line">      x_temperature[1] = &amp;old_temperature_solution;</div><div class="line">      std::vector&lt;const TrilinosWrappers::MPI::BlockVector *&gt; x_stokes(2);</div><div class="line">      x_stokes[0] = &amp;stokes_solution;</div><div class="line">      x_stokes[1] = &amp;old_stokes_solution;</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">      temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">      stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                       <span class="stringliteral">&quot;Refine mesh structure, part 2&quot;</span>);</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp1(temperature_rhs);</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp2(temperature_rhs);</div><div class="line"></div><div class="line">        std::vector&lt;TrilinosWrappers::MPI::Vector *&gt; tmp(2);</div><div class="line">        tmp[0] = &amp;(distributed_temp1);</div><div class="line">        tmp[1] = &amp;(distributed_temp2);</div><div class="line">        temperature_trans.interpolate(tmp);</div><div class="line"></div><div class="line">        temperature_constraints.distribute(distributed_temp1);</div><div class="line">        temperature_constraints.distribute(distributed_temp2);</div><div class="line"></div><div class="line">        temperature_solution     = distributed_temp1;</div><div class="line">        old_temperature_solution = distributed_temp2;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes(stokes_rhs);</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_distributed_stokes(stokes_rhs);</div><div class="line"></div><div class="line">        std::vector&lt;TrilinosWrappers::MPI::BlockVector *&gt; stokes_tmp(2);</div><div class="line">        stokes_tmp[0] = &amp;(distributed_stokes);</div><div class="line">        stokes_tmp[1] = &amp;(old_distributed_stokes);</div><div class="line"></div><div class="line">        stokes_trans.interpolate(stokes_tmp);</div><div class="line"></div><div class="line">        stokes_constraints.distribute(distributed_stokes);</div><div class="line">        stokes_constraints.distribute(old_distributed_stokes);</div><div class="line"></div><div class="line">        stokes_solution     = distributed_stokes;</div><div class="line">        old_stokes_solution = old_distributed_stokes;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(triangulation,</div><div class="line">                               <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(),</div><div class="line">                               EquationData::R0,</div><div class="line">                               EquationData::R1,</div><div class="line">                               (dim == 3) ? 96 : 12,</div><div class="line">                               <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(parameters.initial_global_refinement);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution(</div><div class="line">        temperature_dof_handler.locally_owned_dofs());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                           temperature_constraints,</div><div class="line">                           <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(parameters.temperature_degree + 2),</div><div class="line">                           EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                           solution);</div><div class="line">      temperature_solution         = solution;</div><div class="line">      old_temperature_solution     = solution;</div><div class="line">      old_old_temperature_solution = solution;</div><div class="line">    }</div><div class="line"></div><div class="line">    timestep_number = 0;</div><div class="line">    time_step = old_time_step = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time / EquationData::year_in_seconds &lt;&lt; <span class="stringliteral">&quot; years&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_stokes_system();</div><div class="line">        build_stokes_preconditioner();</div><div class="line">        assemble_temperature_matrix();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; parameters.initial_adaptive_refinement))</div><div class="line">          {</div><div class="line">            refine_mesh(parameters.initial_global_refinement +</div><div class="line">                        parameters.initial_adaptive_refinement);</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp;</div><div class="line">                 (timestep_number % parameters.adaptive_refinement_interval ==</div><div class="line">                  0))</div><div class="line">          refine_mesh(parameters.initial_global_refinement +</div><div class="line">                      parameters.initial_adaptive_refinement);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">            (timestep_number % parameters.graphical_output_interval == 0))</div><div class="line">          output_results();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time &gt; parameters.end_time * EquationData::year_in_seconds)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_old_stokes_solution;</div><div class="line">        old_old_stokes_solution      = old_stokes_solution;</div><div class="line">        old_stokes_solution          = stokes_solution;</div><div class="line">        old_old_temperature_solution = old_temperature_solution;</div><div class="line">        old_temperature_solution     = temperature_solution;</div><div class="line">        <span class="keywordflow">if</span> (old_time_step &gt; 0)</div><div class="line">          {</div><div class="line">            {</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_solution(stokes_rhs);</div><div class="line">              distr_solution = stokes_solution;</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_old_solution(stokes_rhs);</div><div class="line">              distr_old_solution = old_old_stokes_solution;</div><div class="line">              distr_solution.<a class="code" href="classBlockVectorBase.html#a71b0ab8295e98caf3dfe1ef14ae6b6c1">sadd</a>(1. + time_step / old_time_step,</div><div class="line">                                  -time_step / old_time_step,</div><div class="line">                                  distr_old_solution);</div><div class="line">              stokes_solution = distr_solution;</div><div class="line">            }</div><div class="line">            {</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_solution(temperature_rhs);</div><div class="line">              distr_solution = temperature_solution;</div><div class="line">              <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_old_solution(temperature_rhs);</div><div class="line">              distr_old_solution = old_old_temperature_solution;</div><div class="line">              distr_solution.sadd(1. + time_step / old_time_step,</div><div class="line">                                  -time_step / old_time_step,</div><div class="line">                                  distr_old_solution);</div><div class="line">              temperature_solution = distr_solution;</div><div class="line">            }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 100 == 0))</div><div class="line">          computing_timer.print_summary();</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">        !((timestep_number - 1) % parameters.graphical_output_interval == 0))</div><div class="line">      output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step32</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step32;</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      std::string parameter_filename;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt;= 2)</div><div class="line">        parameter_filename = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_filename = <span class="stringliteral">&quot;step-32.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span>                              dim = 2;</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt;::Parameters parameters(parameter_filename);</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt;             flow_problem(parameters);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_31.html">step-31</a> , <a class="el" href="step_55.html">step-55</a> . <table
 class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Usingtherightpressure"> Using the "right" pressure </a><a
 href="#Usingtherightpressure"> Using the "right" pressure </a>
 <li><a href="#Thescalingofdiscretizedequations"> The scaling of discretized
 equations </a><a href="#Thescalingofdiscretizedequations"> The scaling of
 discretized equations </a>
 <li><a href="#ChangestotheStokespreconditionerandsolver"> Changes to the
 Stokes preconditioner and solver </a><a
 href="#ChangestotheStokespreconditionerandsolver"> Changes to the Stokes
 preconditioner and solver </a>
 <li><a href="#Changestotheartificialviscositystabilization"> Changes to the
 artificial viscosity stabilization </a><a
 href="#Changestotheartificialviscositystabilization"> Changes to the
 artificial viscosity stabilization </a>
 <li><a href="#LocallyconservativeStokesdiscretization"> Locally
 conservative Stokes discretization </a><a
 href="#LocallyconservativeStokesdiscretization"> Locally conservative
 Stokes discretization </a>
 <li><a href="#Higherordermappingsforcurvedboundaries"> Higher order
 mappings for curved boundaries </a><a
 href="#Higherordermappingsforcurvedboundaries"> Higher order mappings for
 curved boundaries </a>
 <li><a href="#Parallelizationonclusters"> Parallelization on clusters
 </a><a href="#Parallelizationonclusters"> Parallelization on clusters </a>
 <li><a href="#Parallelizationwithinindividualnodesofacluster">
 Parallelization within individual nodes of a cluster </a><a
 href="#Parallelizationwithinindividualnodesofacluster"> Parallelization
 within individual nodes of a cluster </a>
 <li><a href="#Thetestcase"> The testcase </a><a href="#Thetestcase"> The
 testcase </a>
 <li><a href="#Implementationdetails"> Implementation details </a><a
 href="#Implementationdetails"> Implementation details </a>
 <li><a href="#Outlook"> Outlook </a><a href="#Outlook"> Outlook </a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#Equationdata">Equation data</a><a
 href="#Equationdata">Equation data</a>
 <li><a href="#PreconditioningtheStokessystem">Preconditioning the Stokes
 system</a><a href="#PreconditioningtheStokessystem">Preconditioning the
 Stokes system</a>
 <li><a href="#Definitionofassemblydatastructures">Definition of assembly
 data structures</a><a href="#Definitionofassemblydatastructures">Definition
 of assembly data structures</a>
 <li><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The
 <code>BoussinesqFlowProblem</code> class template</a><a
 href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The
 <code>BoussinesqFlowProblem</code> class template</a>
 <li><a
 href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem
 class implementation</a><a
 href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem
 class implementation</a>
 <ul>
 <li><a
 href="#BoussinesqFlowProblemParameters">BoussinesqFlowProblem::Parameters</a><a
 href="#BoussinesqFlowProblemParameters">BoussinesqFlowProblem::Parameters</a>
 <li><a
 href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a><a
 href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a>
 <li><a href="#TheBoussinesqFlowProblemhelperfunctions">The
 BoussinesqFlowProblem helper functions</a><a
 href="#TheBoussinesqFlowProblemhelperfunctions">The BoussinesqFlowProblem
 helper functions</a>
 <ul>
 <li><a
 href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a><a
 href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a>
 <li><a
 href="#BoussinesqFlowProblemget_cfl_number">BoussinesqFlowProblem::get_cfl_number</a><a
 href="#BoussinesqFlowProblemget_cfl_number">BoussinesqFlowProblem::get_cfl_number</a>
 <li><a
 href="#BoussinesqFlowProblemget_entropy_variation">BoussinesqFlowProblem::get_entropy_variation</a><a
 href="#BoussinesqFlowProblemget_entropy_variation">BoussinesqFlowProblem::get_entropy_variation</a>
 <li><a
 href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a><a
 href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a>
 <li><a
 href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a><a
 href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a>
 </ul>
 <li><a href="#TheBoussinesqFlowProblemsetupfunctions">The
 BoussinesqFlowProblem setup functions</a><a
 href="#TheBoussinesqFlowProblemsetupfunctions">The BoussinesqFlowProblem
 setup functions</a>
 <li><a href="#TheBoussinesqFlowProblemassemblyfunctions">The
 BoussinesqFlowProblem assembly functions</a><a
 href="#TheBoussinesqFlowProblemassemblyfunctions">The BoussinesqFlowProblem
 assembly functions</a>
 <ul>
 <li><a href="#Stokespreconditionerassembly">Stokes preconditioner
 assembly</a><a href="#Stokespreconditionerassembly">Stokes preconditioner
 assembly</a>
 <li><a href="#Stokessystemassembly">Stokes system assembly</a><a
 href="#Stokessystemassembly">Stokes system assembly</a>
 <li><a href="#Temperaturematrixassembly">Temperature matrix assembly</a><a
 href="#Temperaturematrixassembly">Temperature matrix assembly</a>
 <li><a href="#Temperaturerighthandsideassembly">Temperature right hand side
 assembly</a><a href="#Temperaturerighthandsideassembly">Temperature right
 hand side assembly</a>
 </ul>
 <li><a
 href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a><a
 href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a>
 <li><a
 href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a><a
 href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a>
 <li><a
 href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a><a
 href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a>
 <li><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a><a
 href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a>
 </ul>
 <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a
 href="#Thecodemaincodefunction">The <code>main</code> function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Comparisonofresultswithstep31">Comparison of results with
 step-31</a><a href="#Comparisonofresultswithstep31">Comparison of results
 with step-31</a>
 <li><a href="#Resultsfora2dcircularshelltestcase">Results for a 2d circular
 shell testcase</a><a href="#Resultsfora2dcircularshelltestcase">Results for
 a 2d circular shell testcase</a>
 <li><a href="#Resultsfora3dsphericalshelltestcase">Results for a 3d
 spherical shell testcase</a><a
 href="#Resultsfora3dsphericalshelltestcase">Results for a 3d spherical
 shell testcase</a>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Martin Kronbichler, Wolfgang Bangerth, and Timo Heister.</em></p>
<p><em> This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology; and in a continuation by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation, The California Institute of Technology, or of The University of California &ndash; Davis.</em></p>
<p><em> The work discussed here is also presented in the following publication: <b> M. Kronbichler, T. Heister, W. Bangerth: <em>High Accuracy Mantle Convection Simulation through Modern Numerical Methods</em><b> M. Kronbichler, T. Heister, W. Bangerth: <em>High Accuracy Mantle Convection Simulation through Modern Numerical Methods</em>, Geophysical Journal International, 2012, 191, 12-29. <a href="http://dx.doi.org/10.1111/j.1365-246X.2012.05609.x">[DOI]</a><em>High Accuracy Mantle Convection Simulation through Modern Numerical Methods</em>, Geophysical Journal International, 2012, 191, 12-29. <a href="http://dx.doi.org/10.1111/j.1365-246X.2012.05609.x">[DOI]</a> </b><a href="http://dx.doi.org/10.1111/j.1365-246X.2012.05609.x">[DOI]</a> </b></em></p>
<p><em> The continuation of development of this program has led to the much larger open source code <em>ASPECT</em><em>ASPECT</em> (see <a href="http://aspect.geodynamics.org/">http://aspect.geodynamics.org/</a>) which is much more flexible in solving many kinds of related problems. </em></p>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program does pretty much exactly what <a class="el" href="step_31.html">step-31</a> already does: itsolves the Boussinesq equations that describe the motion of a fluidwhose temperature is not in equilibrium. As such, all the equations wehave described in <a class="el" href="step_31.html">step-31</a> still hold: we solve the same generalpartial differential equation (with only minor modifications to adjustfor more realism in the problem setting), using the same finiteelement scheme, the same time stepping algorithm, and more or less thesame stabilization method for the temperature advection-diffusionequation. As a consequence, you may first want to understand thatprogram &mdash; and its implementation &mdash; before you work on thecurrent one. The difference between <a class="el" href="step_31.html">step-31</a> and the current program is thathere we want to do things in parallel, using both the availability of manymachines in a cluster (with parallelization based on MPI) as well as manyprocessor cores within a single machine (with parallelization based onthreads). This program's main job is therefore to introduce the changes that arenecessary to utilize the availability of these parallel computeresources. In this regard, it builds on the <a class="el" href="step_40.html">step-40</a> program that firstintroduces the necessary classes for much of the parallelfunctionality, and on <a class="el" href="step_55.html">step-55</a> that shows how this is done for avector-valued problem. In addition to these changes, we also use a slightly differentpreconditioner, and we will have to make a number of changes that haveto do with the fact that we want to solve a <em>realistic</em> problemhere, not a model problem. The latter, in particular, will requirethat we think about scaling issues as well as what all thoseparameters and coefficients in the equations under considerationactually mean. We will discuss first the issues that affect changes inthe mathematical formulation and solver structure, then how toparallelize things, and finally the actual testcase we will consider.</p>
<p><a class="anchor" id="Usingtherightpressure"></a></p><h3>Using the "right" pressure </h3>
<p>In <a class="el" href="step_31.html">step-31</a> , we used the following Stokes model for thevelocity and pressure field: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho \; \beta \; T \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> The right hand side of the first equation appears a wee bitunmotivated. Here's how things should really be. Weneed the external forces that act on the fluid, which we assume aregiven by gravity only. In the current case, we assume that the fluiddoes expand slightly for the purposes of this gravity force, but notenough that we need to modify the incompressibility condition (thesecond equation). What this means is that for the purpose of the righthand side, we can assume that \(\rho=\rho(T)\) . An assumption that maynot be entirely justified is that we can assume that the changes ofdensity as a function of temperature are small, leading to anexpression of the form \(\rho(T) = \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})]\) , i.e., the density equals \(\rho_{\text{ref}}\) at reference temperature and decreases linearly asthe temperature increases (as the material expands). The force balanceequation then looks properly written like this: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})] \mathbf{g}. \end{eqnarray*}
</p>
<p> Now note that the gravity force results from a gravity potential as \(\mathbf g=-\nabla \varphi\) , so that we can re-write this as follows: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho_{\text{ref}} \; \beta\; T\; \mathbf{g} -\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \nabla\varphi. \end{eqnarray*}
</p>
<p> The second term on the right is time independent, and so we couldintroduce a new "dynamic" pressure \(p_{\text{dyn}}=p+\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi=p_{\text{total}}-p_{\text{static}}\) with which the Stokes equations would read: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p_{\text{dyn}} &amp;=&amp; -\rho_{\text{ref}} \; \beta \; T \; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> This is exactly the form we used in <a class="el" href="step_31.html">step-31</a> , and it wasappropriate to do so because all changes in the fluid flow are onlydriven by the dynamic pressure that results from temperaturedifferences. (In other words: Any contribution to the right hand sidethat results from taking the gradient of a scalar field have no effecton the velocity field.) On the other hand, we will here use the form of the Stokes equationsthat considers the total pressure instead: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T)\; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> There are several advantages to this:</p>
<ul>
<li>This way we can plot the pressure in our program in such a way that it actually shows the total pressure that includes the effects of temperature differences as well as the static pressure of the overlying rocks. Since the pressure does not appear any further in any of the other equations, whether to use one or the other is more a matter of taste than of correctness. The flow field is exactly the same, but we get a pressure that we can now compare with values that are given in geophysical books as those that hold at the bottom of the earth mantle, for example.</li>
<li>If we wanted to make the model even more realistic, we would have to take into account that many of the material parameters (e.g. the viscosity, the density, etc) not only depend on the temperature but also the <em>total</em> pressure.</li>
<li>The model above assumed a linear dependence \(\rho(T) = \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})]\) and assumed that \(\beta\) is small. In practice, this may not be so. In fact, realistic models are certainly not linear, and \(\beta\) may also not be small for at least part of the temperature range because the density's behavior is substantially dependent not only on thermal expansion but by phase changes.</li>
<li>A final reason to do this is discussed in the results section and concerns possible extensions to the model we use here. It has to do with the fact that the temperature equation (see below) we use here does not include a term that contains the pressure. It should, however: rock, like gas, heats up as you compress it. Consequently, material that rises up cools adiabatically, and cold material that sinks down heats adiabatically. We discuss this further below. <dl class="section note"><dt>Note</dt><dd>There is, however, a downside to this procedure. In the earth,the dynamic pressure is several orders of magnitude smaller than thetotal pressure. If we use the equations above and solve all variablesto, say, 4 digits of accuracy, then we may be able to get the velocityand the total pressure right, but we will have no accuracy at all ifwe compute the dynamic pressure by subtracting from the total pressurethe static part \(p_\text{static}=\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi\) . If, for example, the dynamicpressure is six orders of magnitude smaller than the static pressure,then we need to solve the overall pressure to at least seven digits ofaccuracy to get anything remotely accurate. That said, in practicethis turns out not to be a limiting factor.</dd></dl>
<a class="anchor" id="Thescalingofdiscretizedequations"></a><h3>The scaling of discretized equations </h3>
</li>
</ul>
<p>Remember that we want to solve the following set of equations: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T) \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
<p> augmented by appropriate boundary and initial conditions. As discussedin <a class="el" href="step_31.html">step-31</a> , we will solve this set of equations bysolving for a Stokes problem first in each time step, and then movingthe temperature equation forward by one time interval. The problem under consideration in this current section is with theStokes problem: if we discretize it as usual, we get a linear system </p><p class="formulaDsp">
\begin{eqnarray*} M \; X = \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F_U \\ 0 \end{array}\right) = F \end{eqnarray*}
</p>
<p> which in this program we will solve with a FGMRES solver. This solveriterates until the residual of these linear equations is below acertain tolerance, i.e., until </p><p class="formulaDsp">
\[ \left\| \left(\begin{array}{c} F_U - A U^{(k)} - B P^{(k)} \\ B^T U^{(k)} \end{array}\right) \right\| &lt; \text{Tol}. \]
</p>
<p> does not make any sense from the viewpoint of physical units: thequantities involved here have physical units so that the first part ofthe residual has units \(\frac{\text{Pa}}{\text{m}} \text{m}^{\text{dim}}\) (most easily established by considering theterm \((\nabla \cdot \mathbf v, p)_{\Omega}\) and considering that thepressure has units \(\text{Pa}=\frac{\text{kg}}{\text{m}\;\text{s}^2}\) andthe integration yields a factor of \(\text{m}^{\text{dim}}\) ), whereasthe second part of the residual has units \(\frac{\text{m}^{\text{dim}}}{\text{s}}\) . Taking the normof this residual vector would yield a quantity with units \(\text{m}^{\text{dim}-1} \sqrt{\left(\text{Pa}\right)^2 + \left(\frac{\text{m}}{\text{s}}\right)^2}\) . This,quite obviously, does not make sense, and we should not be surprisedthat doing so is eventually going to come back hurting us. So why is this an issue here, but not in <a class="el" href="step_31.html">step-31</a> ? Thereason back there is that everything was nicely balanced: velocitieswere on the order of one, the pressure likewise, the viscosity wasone, and the domain had a diameter of \(\sqrt{2}\) . As a result, whilenonsensical, nothing bad happened. On the other hand, as we will explainbelow, things here will not be that simply scaled: \(\eta\) will be around \(10^{21}\) , velocities on the order of \(10^{-8}\) , pressure around \(10^8\) , andthe diameter of the domain is \(10^7\) . In other words, the order of magnitudefor the first equation is going to be \(\eta\text{div}\varepsilon(\mathbf u) \approx 10^{21} \frac{10^{-8}}{(10^7)^2} \approx 10^{-1}\) , whereas the second equation will be around \(\text{div}{\mathbf u}\approx \frac{10^{-8}}{10^7} \approx 10^{-15}\) . Well, sowhat this will lead to is this: if the solver wants to make the residual small,it will almost entirely focus on the first set of equations because they areso much bigger, and ignore the divergence equation that describes massconservation. That's exactly what happens: unless we set the tolerance toextremely small values, the resulting flow field is definitely not divergencefree. As an auxiliary problem, it turns out that it is difficult to find atolerance that always works; in practice, one often ends up with a tolerancethat requires 30 or 40 iterations for most time steps, and 10,000 for someothers. So what's a numerical analyst to do in a case like this? The answer is tostart at the root and first make sure that everything is mathematicallyconsistent first. In our case, this means that if we want to solve the systemof Stokes equations jointly, we have to scale them so that they all have thesame physical dimensions. In our case, this means multiplying the secondequation by something that has units \(\frac{\text{Pa}\;\text{s}}{\text{m}}\) ; onechoice is to multiply with \(\frac{\eta}{L}\) where \(L\) is a typical lengthscalein our domain (which experiments show is best chosen to be the diameter ofplumes &mdash; around 10 km &mdash; rather than the diameter of thedomain). Using these numbers for \(\eta\) and \(L\) , this factor is around \(10^{17}\) . So, we now get this for the Stokes system: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T) \; \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> The trouble with this is that the result is not symmetric any more (we have \(\frac{\eta}{L} \nabla \cdot\) at the bottom left, but not its transposeoperator at the top right). This, however, can be cured by introducing ascaled pressure \(\hat p = \frac{L}{\eta}p\) , and we get the scaled equations </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla \left(\frac{\eta}{L} \hat p\right) &amp;=&amp; \rho(T) \; \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
<p> This is now symmetric. Obviously, we can easily recover the original pressure \(p\) from the scaled pressure \(\hat p\) that we compute as a result of thisprocedure. In the program below, we will introduce a factor <code>EquationData::pressure_scaling</code> that corresponds to \(\frac{\eta}{L}\) , and we will use this factor in the assembly of the systemmatrix and preconditioner. Because it is annoying and error prone, we willrecover the unscaled pressure immediately following the solution of the linearsystem, i.e., the solution vector's pressure component will immediately beunscaled to retrieve the physical pressure. Since the solver uses the fact thatwe can use a good initial guess by extrapolating the previous solutions, wealso have to scale the pressure immediately <em>before</em> solving.</p>
<p><a class="anchor" id="ChangestotheStokespreconditionerandsolver"></a></p><h3>Changes to the Stokes preconditioner and solver </h3>
<p>In this tutorial program, we apply a variant of the preconditioner used in <a class="el" href="step_31.html">step-31</a> . That preconditioner was built to operate on thesystem matrix \(M\) in block form such that the product matrix </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1} M = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p> is of a form that Krylov-based iterative solvers like GMRES can solve in afew iterations. We then replaced the exact inverse of \(A\) by the actionof an AMG preconditioner \(\tilde{A}\) based on a vector Laplace matrix,approximated the Schur complement \(S = B A^{-1} B^T\) by a mass matrix \(M_p\) on the pressure space and wrote an <code>InverseMatrix</code> class forimplementing the action of \(M_p^{-1}\approx S^{-1}\) on vectors. In theInverseMatrix class, we used a CG solve with an incomplete Cholesky (IC)preconditioner for performing the inner solves. An observation one can make is that we use just the action of apreconditioner for approximating the velocity inverse \(A^{-1}\) (and theouter GMRES iteration takes care of the approximate character of theinverse), whereas we use a more or less <em>exact</em> inverse for \(M_p^{-1}\) ,realized by a fully converged CG solve. This appears unbalanced, but there'ssystem to this madness: almost all the effort goes into the upper left blockto which we apply the AMG preconditioner, whereas even an exact inversion ofthe pressure mass matrix costs basically nothing. Consequently, if it helps usreduce the overall number of iterations somewhat, then this effort is wellspent. That said, even though the solver worked well for <a class="el" href="step_31.html">step-31</a> , we have a problemhere that is a bit more complicated (cells are deformed, the pressure variesby orders of magnitude, and we want to plan ahead for more complicatedphysics), and so we'll change a few things slightly:</p>
<ul>
<li>For more complex problems, it turns out that using just a single AMG V-cycle as preconditioner is not always sufficient. The outer solver converges just fine most of the time in a reasonable number of iterations (say, less than 50) but there are the occasional time step where it suddenly takes 700 or so. What exactly is going on there is hard to determine, but the problem can be avoided by using a more accurate solver for the top left block. Consequently, we'll want to use a CG iteration to invert the top left block of the preconditioner matrix, and use the AMG as a preconditioner for the CG solver.</li>
<li>The downside of this is that, of course, the Stokes preconditioner becomes much more expensive (approximately 10 times more expensive than when we just use a single V-cycle). Our strategy then is this: let's do up to 30 GMRES iterations with just the V-cycle as a preconditioner and if that doesn't yield convergence, then take the best approximation of the Stokes solution obtained after this first round of iterations and use that as the starting guess for iterations where we use the full inner solver with a rather lenient tolerance as preconditioner. In all our experiments this leads to convergence in only a few additional iterations.</li>
<li>One thing we need to pay attention to is that when using a CG with a lenient tolerance in the preconditioner, then \(y = \tilde A^{-1} r\) is no longer a linear function of \(r\) (it is, of course, if we have a very stringent tolerance in our solver, or if we only apply a single V-cycle). This is a problem since now our preconditioner is no longer a linear operator; in other words, every time GMRES uses it the preconditioner looks different. The standard GMRES solver can't deal with this, leading to slow convergence or even breakdown, but the F-GMRES variant is designed to deal with exactly this kind of situation and we consequently use it.</li>
<li>On the other hand, once we have settled on using F-GMRES we can relax the tolerance used in inverting the preconditioner for \(S\) . In <a class="el" href="step_31.html">step-31</a> , we ran a preconditioned CG method on \(\tilde S\) until the residual had been reduced by 7 orders of magnitude. Here, we can again be more lenient because we know that the outer preconditioner doesn't suffer.</li>
<li>In <a class="el" href="step_31.html">step-31</a> , we used a left preconditioner in which we first invert the top left block of the preconditioner matrix, then apply the bottom left (divergence) one, and then invert the bottom right. In other words, the application of the preconditioner acts as a lower left block triangular matrix. Another option is to use a right preconditioner that here would be upper right block triangulation, i.e., we first invert the bottom right Schur complement, apply the top right (gradient) operator and then invert the elliptic top left block. To a degree, which one to choose is a matter of taste. That said, there is one significant advantage to a right preconditioner in GMRES-type solvers: the residual with which we determine whether we should stop the iteration is the true residual, not the norm of the preconditioned equations. Consequently, it is much simpler to compare it to the stopping criterion we typically use, namely the norm of the right hand side vector. In writing this code we found that the scaling issues we discussed above also made it difficult to determine suitable stopping criteria for left-preconditioned linear systems, and consequently this program uses a right preconditioner.</li>
<li>In <a class="el" href="step_31.html">step-31</a> , we used an IC (incomplete Cholesky) preconditioner for the pressure mass matrix in the Schur complement preconditioner and for the solution of the temperature system. Here, we could in principle do the same, but we do choose an even simpler preconditioner, namely a Jacobi preconditioner for both systems. This is because here we target at massively parallel computations, where the decompositions for IC/ILU would have to be performed block-wise for the locally owned degrees of freedom on each processor. This means, that the preconditioner gets more like a Jacobi preconditioner anyway, so we rather start from that variant straight away. Note that we only use the Jacobi preconditioners for CG solvers with mass matrices, where they give optimal (<em>h</em>-independent) convergence anyway, even though they usually require about twice as many iterations as an IC preconditioner. As a final note, let us remark that in <a class="el" href="step_31.html">step-31</a> we computed theSchur complement \(S=B A^{-1} B^T\) by approximating \(-\text{div}(-\eta\Delta)^{-1}\nabla \approx \frac 1{\eta} \mathbf{1}\) . Now,however, we have re-scaled the \(B\) and \(B^T\) operators. So \(S\) should nowapproximate \(-\frac{\eta}{L}\text{div}(-\eta\Delta)^{-1}\nabla \frac{\eta}{L} \approx \left(\frac{\eta}{L}\right)^2 \frac 1{\eta} \mathbf{1}\) .We use the discrete form of the right hand side of this as our approximation \(\tilde S\) to \(S\) .</li>
</ul>
<p><a class="anchor" id="Changestotheartificialviscositystabilization"></a></p><h3>Changes to the artificial viscosity stabilization </h3>
<p>Similarly to <a class="el" href="step_31.html">step-31</a> , we will use an artificial viscosity for stabilizationbased on a residual of the equation. As a difference to <a class="el" href="step_31.html">step-31</a> , we willprovide two slightly different definitions of the stabilization parameter. For \(\alpha=1\) , we use the same definition as in <a class="el" href="step_31.html">step-31</a> : </p><p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \nu_1(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K \min\left\{ 1, \frac{\|R_1(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\} \end{eqnarray*}
</p>
<p> where we compute the viscosity from a residual \(\|R_1(T)\|_{L^\infty(K)}\) ofthe equation, limited by a diffusion proportional to the mesh size \(h_K\) inregions where the residual is large (around steep gradients). This definitionhas been shown to work well for the given case, \(\alpha = 1\) in <a class="el" href="step_31.html">step-31</a> , butit is usually less effective as the diffusion for \(\alpha=2\) . For that case, wechoose a slightly more readable definition of the viscosity, </p><p class="formulaDsp">
\begin{eqnarray*} \nu_2(T)|_K = \min (\nu_h^\mathrm{max}|_K,\nu_h^\mathrm{E}|_K) \end{eqnarray*}
</p>
<p> where the first term gives again the maximum dissipation (similarly to a firstorder upwind scheme), </p><p class="formulaDsp">
\begin{eqnarray*} \nu^\mathrm{max}_h|_K = \beta h_K \|\mathbf {u}\|_{L^\infty(K)} \end{eqnarray*}
</p>
<p> and the entropy viscosity is defined as </p><p class="formulaDsp">
\begin{eqnarray*} \nu^\mathrm{E}_h|_K = c_R \frac{h_K^2 \|R_\mathrm{2,E}(T)\|_{L^\infty(K)}} {\|E(T) - \bar{E}(T)\|_{L^\infty(\Omega)} }. \end{eqnarray*}
</p>
<p>This formula is described in the article <em>J.-L. Guermond, R. Pasquetti, &amp; B. Popov, 2011. Entropy viscosity method for nonlinear conservation laws, J. Comput. Phys., 230, 4248&ndash;4267.</em> Compared to the case \(\alpha = 1\) , theresidual is computed from the temperature entropy, \(E(T) = \frac12 (T-T_m)^2\) with \(T_m\) an average temperature (we choose the mean between the maximum andminimum temperature in the computation), which gives the following formula </p><p class="formulaDsp">
\begin{eqnarray*} R_\mathrm{E}(T) = \frac{\partial E(T)}{\partial t} + (T-T_\mathrm{m}) \left(\mathbf{u} \cdot \nabla T - \kappa \nabla^2 T - \gamma\right). \end{eqnarray*}
</p>
<p> The denominator in the formula for \(\nu^\mathrm{E}_h|_K\) is computed as theglobal deviation of the entropy from the space-averaged entropy \(\bar{E}(T) = \int_\Omega E(T) d\mathbf{x}/\int_\Omega d\mathbf{x}\) . As in <a class="el" href="step_31.html">step-31</a> , weevaluate the artificial viscosity from the temperature and velocity at twoprevious time levels, in order to avoid a nonlinearity in its definition. The above definitions of the viscosity are simple, but depend on twoparameters, namely \(\beta\) and \(c_R\) . For the current program, we want to goabout this issue a bit more systematically for both parameters in the case \(\alpha =1\) , using the same line of reasoning with which we chose two otherparameters in our discretization, \(c_k\) and \(\beta\) , in the results section of <a class="el" href="step_31.html">step-31</a> . In particular, remember that we would like to make the artificialviscosity as small as possible while keeping it as large as necessary. In thefollowing, let us describe the general strategy one may follow. Thecomputations shown here were done with an earlier version of the program andso the actual numerical values you get when running the program may no longermatch those shown here; that said, the general approach remains valid and hasbeen used to find the values of the parameters actually used in the program. To see what is happening, note that below we will imposeboundary conditions for the temperature between 973 and 4273 Kelvin,and initial conditions are also chosen in this range; for theseconsiderations, we run the program without internal heat sources or sinks,and consequently the temperature shouldalways be in this range, barring any internaloscillations. If the minimal temperature drops below 973 Kelvin, thenwe need to add stabilization by either increasing \(\beta\) ordecreasing \(c_R\) . As we did in <a class="el" href="step_31.html">step-31</a> , we first determine an optimal value of \(\beta\) by using the "traditional" formula </p><p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K, \end{eqnarray*}
</p>
<p> which we know to be stable if only \(\beta\) is large enough. Doing acouple hundred time steps (on a coarser mesh than the one shown in theprogram, and with a different viscosity that affects transportvelocities and therefore time step sizes) in 2d will produce thefollowing graph: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.beta.2d.png"/>
</div>
<p> As can be seen, values \(\beta \le 0.05\) are too small whereas \(\beta=0.052\) appears to work, at least to the time horizon shownhere. As a remark on the side, there are at least two questions onemay wonder here: First, what happens at the time when the solutionbecomes unstable? Looking at the graphical output, we can see thatwith the unreasonably coarse mesh chosen for these experiments, aroundtime \(t=10^{15}\) seconds the plumes of hot material that have beenrising towards the cold outer boundary and have then spread sidewaysare starting to get close to each other, squeezing out the coldmaterial in-between. This creates a layer of cells into which fluidsflows from two opposite sides and flows out toward a third, apparentlya scenario that then produce these instabilities without sufficientstabilization. Second: In <a class="el" href="step_31.html">step-31</a> , we used \(\beta=0.015\cdot\text{dim}\) ; why does this not work here? The answerto this is not entirely clear</p>
<ul>
<li>stabilization parameters arecertainly known to depend on things like the shape of cells, for whichwe had squares in <a class="el" href="step_31.html">step-31</a> but have trapezoids in the currentprogram. Whatever the exact cause, we at least have a value of \(\beta\) , namely 0.052 for 2d, that works for the current program.A similar set of experiments can be made in 3d where we find that \(\beta=0.078\) is a good choice &mdash; neatly leading to the formula \(\beta=0.026 \cdot \textrm{dim}\) . With this value fixed, we can go back to the original formula for theviscosity \(\nu\) and play with the constant \(c_R\) , making it as largeas possible in order to make \(\nu\) as small as possible. This gives usa picture like this: <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.beta_cr.2d.png"/>
</div>
 Consequently, \(c_R=0.1\) would appear to be the right value here. While thisgraph has been obtained for an exponent \(\alpha=1\) , in the program we use \(\alpha=2\) instead, and in that case one has to re-tune the parameter (andobserve that \(c_R\) appears in the numerator and not in the denominator). Itturns out that \(c_R=1\) works with \(\alpha=2\) .</li>
</ul>
<p><a class="anchor" id="LocallyconservativeStokesdiscretization"></a></p><h3>Locally conservative Stokes discretization </h3>
<p>The standard Taylor-Hood discretization for Stokes, using the \(Q_{k+1}^d \times Q_k\) element, is globally conservative, i.e. \(\int_{\partial\Omega} \mathbf n \cdot \mathbf u_h = 0\) . This can easily be seen: the weak form ofthe divergence equation reads \((q_h, \textrm{div}\; \mathbf u_h)=0, \forall q_h\in Q_h\) . Because the pressure space does contain the function \(q_h=1\) , weget </p><p class="formulaDsp">
\begin{align*} 0 = (1, \textrm{div}\; \mathbf u_h)_\Omega = \int_\Omega \textrm{div}\; \mathbf u_h = \int_{\partial\Omega} \mathbf n \cdot \mathbf u_h \end{align*}
</p>
<p> by the divergence theorem. This property is important: if we want to use thevelocity field \(u_h\) to transport along other quantities (such as thetemperature in the current equations, but it could also be concentrations ofchemical substances or entirely artificial tracer quantities) then theconservation property guarantees that the amount of the quantity advectedremains constant. That said, there are applications where this <em>global</em> property is notenough. Rather, we would like that it holds <em>locally</em>, on everycell. This can be achieved by using the space \(Q_{k+1}^d \times DGP_k\) for discretization, where we have replaced the<em>continuous</em> space of tensor product polynomials of degree \(k\) for thepressure by the <em>discontinuous</em> space of the complete polynomials of thesame degree. (Note that tensor product polynomials in 2d contain the functions \(1, x, y, xy\) , whereas the complete polynomials only have the functions \(1,x,y\) .)This space turns out to be stable for the Stokes equation. Because the space is discontinuous, we can now in particular choose the testfunction \(q_h(\mathbf x)=\chi_K(\mathbf x)\) , i.e. the characteristic functionof cell \(K\) . We then get in a similar fashion as above </p><p class="formulaDsp">
\begin{align*} 0 = (q_h, \textrm{div}\; \mathbf u_h)_\Omega = (1, \textrm{div}\; \mathbf u_h)_K = \int_K \textrm{div}\; \mathbf u_h = \int_{\partial K} \mathbf n \cdot \mathbf u_h, \end{align*}
</p>
<p> showing the conservation property for cell \(K\) . This clearly holds for eachcell individually. There are good reasons to use this discretization. As mentioned above, thiselement guarantees conservation of advected quantities on each cellindividually. A second advantage is that the pressure mass matrix we use as apreconditioner in place of the Schur complement becomes block diagonal andconsequently very easy to invert. However, there are also downsides. For one,there are now more pressure variables, increasing the overall size of theproblem, although this doesn't seem to cause much harm in practice. Moreimportantly, though, the fact that now the divergence integrated over eachcell is zero when it wasn't before does not guarantee that the divergence ispointwise smaller. In fact, as one can easily verify, the \(L_2\) norm of thedivergence is <em>larger</em> for this than for the standard Taylor-Hooddiscretization. (However, both converge at the same rate to zero, since it iseasy to see that \(\|\textrm{div}\; u_h\|= \|\textrm{div}\; (u-u_h)\|= \|\textrm{trace}\; \nabla (u-u_h)\|\le \|\nabla (u-u_h)\|={\cal O}(h^{k+2})\) .) It is therefore not a priori clearthat the error is indeed smaller just because we now have more degrees offreedom. Given these considerations, it remains unclear which discretization one shouldprefer. Consequently, we leave that up to the user and make it a parameter inthe input file which one to use.</p>
<p><a class="anchor" id="Higherordermappingsforcurvedboundaries"></a></p><h3>Higher order mappings for curved boundaries </h3>
<p>In the program, we will use a spherical shell as domain. This meansthat the inner and outer boundary of the domain are no longer"straight" (by which we usually mean that they are bilinear surfacesthat can be represented by the <a class="el" href="classFlatManifold.html">FlatManifold</a> class). Rather, theyare curved and it seems prudent to use a curved approximation in theprogram if we are already using higher order finite elements for thevelocity. Consequently, we will introduce a member variable of typeMappingQ thatdenotes such a mapping ( <a class="el" href="step_10.html">step-10</a> and <a class="el" href="step_11.html">step-11</a> introduce such mappingsfor the first time) and that we will use in all computations on cellsthat are adjacent to the boundary. Since this only affects arelatively small fraction of cells, the additional effort is not verylarge and we will take the luxury of using a quartic mapping for thesecells.</p>
<p><a class="anchor" id="Parallelizationonclusters"></a></p><h3>Parallelization on clusters </h3>
<p>Running convection codes in 3d with significant Rayleigh numbers requires a lotof computations &mdash; in the case of whole earth simulations on the order ofone or several hundred million unknowns. This can obviously not be done with asingle machine any more (at least not in 2010 when we started writing thiscode). Consequently, we need to parallelize it.Parallelization of scientific codes across multiple machines in a cluster ofcomputers is almost always done using the Message Passing Interface(MPI). This program is no exception to that, and it follows the general spiritof the <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> programs in this though in practice it borrows morefrom <a class="el" href="step_40.html">step-40</a> in which we first introduced the classes and strategies we usewhen we want to <em>completely</em> distribute all computations, and <a class="el" href="step_55.html">step-55</a> that shows how to do that for <a class="el" href="group__vector__valued.html">vector-valued problems</a>: including, forexample, splitting the mesh up into a number of parts so that each processoronly stores its own share plus some ghost cells, and using strategies where noprocessor potentially has enough memory to hold the entries of the combinedsolution vector locally. The goal is to run this code on hundreds or maybeeven thousands of processors, at reasonable scalability. </p><dl class="section note"><dt>Note</dt><dd>Even though it has a larger number, <a class="el" href="step_40.html">step-40</a> comes logically before thecurrent program. The same is true for <a class="el" href="step_55.html">step-55</a> . You will probably wantto look at these programs before you try to understand what we do here. MPI is a rather awkward interface to program with. It is a semi-objectoriented set of functions, and while one uses it to send data around anetwork, one needs to explicitly describe the data types because the MPIfunctions insist on getting the address of the data as <code>void*</code> objects rather than deducing the data type automatically through overloadingor templates. We've already seen in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> how to avoid almostall of MPI by putting all the communication necessary into either the deal.IIlibrary or, in those programs, into PETSc. We'll do something similar here:like in <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_55.html">step-55</a> , deal.II and the underlying p4est library are responsible forall the communication necessary for distributing the mesh, and we will let theTrilinos library (along with the wrappers in namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a>) dealwith parallelizing the linear algebra components. We have already usedTrilinos in <a class="el" href="step_31.html">step-31</a> , and will do so again here, with the difference that wewill use its parallel capabilities. Trilinos consists of a significant number of packages, implementing basicparallel linear algebra operations (the Epetra package), different solver andpreconditioner packages, and on to things that are of less importance todeal.II (e.g., optimization, uncertainty quantification, etc).deal.II's Trilinos interfaces encapsulate many of the things Trilinos offersthat are of relevance to PDE solvers, andprovides wrapper classes (in namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a>) that make theTrilinos matrix, vector, solver and preconditioner classes look very much thesame as deal.II's own implementations of this functionality. However, asopposed to deal.II's classes, they can be used in parallel if we give them thenecessary information. As a consequence, there are two Trilinos classes thatwe have to deal with directly (rather than through wrappers), both of whichare part of Trilinos' Epetra library of basic linear algebra and tool classes: <ul>
<li>
<p class="startli">The Epetra_Comm class is an abstraction of an MPI "communicator", i.e., it describes how many and which machines can communicate with each other. Each distributed object, such as a sparse matrix or a vector for which we may want to store parts on different machines, needs to have a communicator object to know how many parts there are, where they can be found, and how they can be accessed. In this program, we only really use one communicator object</p>
<ul>
<li>based on the MPI variable <code>MPI_COMM_WORLD</code></li>
<li>that encompasses <em>all</em> processes that work together. It would be perfectly legitimate to start a process on \(N\) machines but only store vectors on a subset of these by producing a communicator object that only encompasses this subset of machines; there is really no compelling reason to do so here, however. </li>
</ul>
</li>
<li>
The <a class="el" href="classIndexSet.html">IndexSet</a> class is used to describe which elements of a vector or which rows of a matrix should reside on the current machine that is part of a communicator. To create such an object, you need to know (i) the total number of elements or rows, (ii) the indices of the elements you want to store locally. We will set up these <code>partitioners</code> in the <code>BoussinesqFlowProblem::setup_dofs</code> function below and then hand it to every parallel object we create. Unlike PETSc, Trilinos makes no assumption that the elements of a vector need to be partitioned into contiguous chunks. At least in principle, we could store all elements with even indices on one processor and all odd ones on another. That's not very efficient, of course, but it's possible. Furthermore, the elements of these partitionings do not necessarily be mutually exclusive. This is important because when postprocessing solutions, we need access to all locally relevant or at least the locally active degrees of freedom (see the module on <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> for a definition, as well as the discussion in <a class="el" href="step_40.html">step-40</a> ). Which elements the Trilinos vector considers as locally owned is not important to us then. All we care about is that it stores those elements locally that we need. </li>
</ul>
There are a number of other concepts relevant to distributing the meshto a number of processors; you may want to take a look at the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> module and <a class="el" href="step_40.html">step-40</a> or <a class="el" href="step_55.html">step-55</a> before trying to understand thisprogram. The rest of the program is almost completely agnostic aboutthe fact that we don't store all objects completely locally. Therewill be a few points where we have to limit loops over all cells tothose that are locally owned, or where we need to distinguish betweenvectors that store only locally owned elements and those that storeeverything that is locally relevant (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">this glossary entry</a>), but by and large the amount of heavy liftingnecessary to make the program run in parallel is well hidden in thelibraries upon which this program builds. In any case, we will commenton these locations as we get to them in the program code.</dd></dl>
<p><a class="anchor" id="Parallelizationwithinindividualnodesofacluster"></a></p><h3>Parallelization within individual nodes of a cluster </h3>
<p>The second strategy to parallelize a program is to make use of the fact thatmost computers today have more than one processor that all have access to thesame memory. In other words, in this model, we don't explicitly have to saywhich pieces of data reside where</p>
<ul>
<li>all of the data we need is directlyaccessible and all we have to do is split <em>processing</em> this data betweenthe available processors. We will then couple this with the MPIparallelization outlined above, i.e., we will have all the processors on amachine work together to, for example, assemble the local contributions to theglobal matrix for the cells that this machine actually "owns" but not forthose cells that are owned by other machines. We will use this strategy forfour kinds of operations we frequently do in this program: assembly of theStokes and temperature matrices, assembly of the matrix that forms the Stokespreconditioner, and assembly of the right hand side of the temperature system. All of these operations essentially look as follows: we need to loop over allcells for which <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> equals the index ourmachine has within the communicator object used for all communication(i.e., <code>MPI_COMM_WORLD</code> , as explained above). The test we areactually going to use for this, and which describes in a concise way why wetest this condition, is <code>cell-&gt;is_locally_owned()</code> . On eachsuch cell we need to assemble the local contributions to the global matrix orvector, and then we have to copy each cell's contribution into the globalmatrix or vector. Note that the first part of this (the loop) defines a rangeof iterators on which something has to happen. The second part, assembly oflocal contributions is something that takes the majority of CPU time in thissequence of steps, and is a typical example of things that can be done inparallel: each cell's contribution is entirely independent of all other cells'contributions. The third part, copying into the global matrix, must not happenin parallel since we are modifying one object and so several threads can notat the same time read an existing matrix element, add their contribution, andwrite the sum back into memory without danger of producing a <a href="http://en.wikipedia.org/wiki/Race_condition">race condition</a>. deal.II has a class that is made for exactly this workflow: <a class="el" href="namespaceWorkStream.html">WorkStream</a>, firstdiscussed in <a class="el" href="step_9.html">step-9</a> and <a class="el" href="step_13.html">step-13</a> . Itsuse is also extensively documented in the module on <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> (in the sectionon <a class="el" href="group__threads.html#MTWorkStream">the WorkStream class</a>) and we won't repeat here therationale and detailed instructions laid out there, though you will want toread through this module to understand the distinction between scratch spaceand per-cell data. Suffice it to mention that we need the following:</li>
<li>An iterator range for those cells on which we are supposed to work. This is provided by the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> class which acts just like every other cell iterator in deal.II with the exception that it skips all cells that do not satisfy a particular predicate (i.e., a criterion that evaluates to true or false). In our case, the predicate is whether a cell is locally owned.</li>
<li>A function that does the work on each cell for each of the tasks identified above, i.e., functions that assemble the local contributions to Stokes matrix and preconditioner, temperature matrix, and temperature right hand side. These are the <code>BoussinesqFlowProblem::local_assemble_stokes_system</code> , <code>BoussinesqFlowProblem::local_assemble_stokes_preconditioner</code> , <code>BoussinesqFlowProblem::local_assemble_temperature_matrix</code> , and <code>BoussinesqFlowProblem::local_assemble_temperature_rhs</code> functions in the code below. These four functions can all have several instances running in parallel at the same time.</li>
<li>Functions that copy the result of the previous ones into the global object and that run sequentially to avoid race conditions. These are the <code>BoussinesqFlowProblem::copy_local_to_global_stokes_system</code> , <code>BoussinesqFlowProblem::copy_local_to_global_stokes_preconditioner</code> , <code>BoussinesqFlowProblem::copy_local_to_global_temperature_matrix</code> , and <code>BoussinesqFlowProblem::copy_local_to_global_temperature_rhs</code> functions. We will comment on a few more points in the actual code, but in generaltheir structure should be clear from the discussion in <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> . The underlying technology for <a class="el" href="namespaceWorkStream.html">WorkStream</a> identifies "tasks" that need to beworked on (e.g. assembling local contributions on a cell) and schedulesthese tasks automatically to available processors. <a class="el" href="namespaceWorkStream.html">WorkStream</a> creates thesetasks automatically, by splitting the iterator range into suitable chunks. <dl class="section note"><dt>Note</dt><dd>Using multiple threads within each MPI process only makes sense if youhave fewer MPI processes running on each node of your cluster than there areprocessor cores on this machine. Otherwise, MPI will already keep yourprocessors busy and you won't get any additional speedup from usingthreads. For example, if your cluster nodes have 8 cores as they often have atthe time of writing this, and if your batch scheduler puts 8 MPI processes oneach node, then using threads doesn't make the program anyfaster. Consequently, you probably want to either configure your deal.II withoutthreads, or set the number of threads in <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> to 1(third argument), or "export
 DEAL_II_NUM_THREADS=1" before running. That said, atthe time of writing this, we only use the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class for assembling(parts of) linear systems, while 75% or more of the run time of the program isspent in the linear solvers that are not parallelized &mdash; in other words,the best we could hope is to parallelize the remaining 25%.</dd></dl>
<a class="anchor" id="Thetestcase"></a><h3>The testcase </h3>
</li>
</ul>
<p>The setup for this program is mildly reminiscent of the problem we wanted tosolve in the first place (see the introduction of <a class="el" href="step_31.html">step-31</a> ):convection in the earth mantle. As a consequence, we choose the followingdata, all of which appears in the program in units of meters and seconds (theSI system) even if we list them here in other units. We do note,however, that these choices are essentially still only exemplary, andnot meant to result in a completely realistic description ofconvection in the earth mantle: for that, more and more difficultphysics would have to be implemented, and several other aspects arecurrently missing from this program as well. We will come back to thisissue in the results section again, but state for now that providing arealistic description is a goal of the <em>ASPECT</em> code indevelopment at the time of writing this. As a reminder, let us again state the equations we want to solve are these: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla \left( \frac{\eta}{L} \hat p\right) &amp;=&amp; \rho(T) \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
<p> augmented by boundary and initial conditions. We then have to choose data forthe following quantities: </p><ul>
<li>
The domain is an annulus (in 2d) or a spherical shell (in 3d) with inner and outer radii that match that of the earth: the total radius of the earth is 6371km, with the mantle starting at a depth of around 35km (just under the solid earth <a href="http://en.wikipedia.org/wiki/Crust_(geology)" target="_top">crust</a> composed of <a href="http://en.wikipedia.org/wiki/Continental_crust" target="_top">continental</a> and <a href="http://en.wikipedia.org/wiki/Oceanic_crust" target="_top">oceanic plates</a>) to a depth of 2890km (where the <a href="http://en.wikipedia.org/wiki/Outer_core" target="_top">outer earth core</a> starts). The radii are therefore \(R_0=(6371-2890)\text{km}, R_1=(6371-35)\text{km}\) . This domain is conveniently generated using the <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> function. </li>
<li>
<p class="startli">At the interface between crust and mantle, the temperature is between 500 and 900 degrees Celsius, whereas at its bottom it is around 4000 degrees Celsius (see, for example, <a href="http://en.wikipedia.org/wiki/Mantle_(geology)" target="_top">this Wikipedia entry</a>). In Kelvin, we therefore choose \(T_0=(4000+273)\text{K}\) , \(T_1=(500+273)\text{K}\) as boundary conditions at the inner and outer edge. In addition to this, we also have to specify some initial conditions for the temperature field. The real temperature field of the earth is quite complicated as a consequence of the convection that has been going on for more than four billion years</p>
<ul>
<li>in fact, it is the properties of this temperature distribution that we want to explore with programs like this. As a consequence, we don't really have anything useful to offer here, but we can hope that if we start with something and let things run for a while that the exact initial conditions don't matter that much any more &mdash; as is in fact suggested by looking at the pictures shown in the <a href="#Results">results section below</a>. The initial temperature field we use here is given in terms of the radius by <p class="formulaDsp">
\begin{align*} s &amp;= \frac{\|\mathbf x\|-R_0}{R_1-R_0}, \\ \varphi &amp;= \arctan \frac{y}{x}, \\ \tau &amp;= s + \frac 15 s(1-s) \sin(6\varphi) q(z), \\ T(\mathbf x) &amp;= T_0(1-\tau) + T_1\tau, \end{align*}
</p>
 where <p class="formulaDsp">
\begin{align*} q(z) = \left\{ \begin{array}{ll} 1 &amp; \text{in 2d} \\ \max\{0, \cos(\pi |z/R_1|)\} &amp; \text{in 3d} \end{array} \right. . \end{align*}
</p>
 This complicated function is essentially a perturbation of a linear profile between the inner and outer temperatures. In 2d, the function \(\tau=\tau(\mathbf x)\) looks like this (I got the picture from <a href="http://www.wolframalpha.com/input/?i=plot+%28sqrt%28x^2%2By^2%29%2B0.2*%28sqrt%28x^2%2By^2%29*%281-sqrt%28x^2%2By^2%29%29*sin%286*atan2%28x%2Cy%29%29%29%2C+x%3D-1+to+1%2C+y%3D-1+to+1">this page</a>): <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d-initial.png"/>
</div>
 The point of this profile is that if we had used \(s\) instead of \(\tau\) in the definition of \(T(\mathbf x)\) then it would simply be a linear interpolation. \(\tau\) has the same function values as \(s\) on the inner and outer boundaries (zero and one, respectively), but it stretches the temperature profile a bit depending on the angle and the \(z\) value in 3d, producing an angle-dependent perturbation of the linearly interpolating field. We will see in the results section that this is an entirely unphysical temperature field (though it will make for interesting images) as the equilibrium state for the temperature will be an almost constant temperature with boundary layers at the inner and outer boundary. </li>
</ul>
</li>
<li>
The right hand side of the temperature equation contains the rate of internal heating \(\gamma\) . The earth does heat naturally through several mechanisms: radioactive decay, chemical separation (heavier elements sink to the bottom, lighter ones rise to the top; the countercurrents dissipate energy equal to the loss of potential energy by this separation process); heat release by crystallization of liquid metal as the solid inner core of the earth grows; and heat dissipation from viscous friction as the fluid moves. Chemical separation is difficult to model since it requires modeling mantle material as multiple phases; it is also a relatively small effect. Crystallization heat is even more difficult since it is confined to areas where temperature and pressure allow for phase changes, i.e., a discontinuous process. Given the difficulties in modeling these two phenomena, we will neglect them. The other two are readily handled and, given the way we scaled the temperature equation, lead to the equation <p class="formulaDsp">
\[ \gamma(\mathbf x) = \frac{\rho q+2\eta \varepsilon(\mathbf u):\varepsilon(\mathbf u)} {\rho c_p}, \]
</p>
 where \(q\) is the radiogenic heating in \(\frac{W}{kg}\) , and the second term in the enumerator is viscous friction heating. \(\rho\) is the density and \(c_p\) is the specific heat. The literature provides the following approximate values: \(c_p=1250 \frac{J}{kg\; K}, q=7.4\cdot 10^{-12}\frac{W}{kg}\) . The other parameters are discussed elsewhere in this section. We neglect one internal heat source, namely adiabatic heating here, which will lead to a surprising temperature field. This point is commented on in detail in the results section below. </li>
<li>
For the velocity we choose as boundary conditions \(\mathbf{v}=0\) at the inner radius (i.e., the fluid sticks to the earth core) and \(\mathbf{n}\cdot\mathbf{v}=0\) at the outer radius (i.e., the fluid flows tangentially along the bottom of the earth crust). Neither of these is physically overly correct: certainly, on both boundaries, fluids can flow tangentially, but they will incur a shear stress through friction against the medium at the other side of the interface (the metallic core and the crust, respectively). Such a situation could be modeled by a Robin-type boundary condition for the tangential velocity; in either case, the normal (vertical) velocity would be zero, although even that is not entirely correct since continental plates also have vertical motion (see, for example, the phenomenon of <a href="http://en.wikipedia.org/wiki/Postglacial_rebound">post-glacial rebound</a>). But to already make things worse for the tangential velocity, the medium on the other side is in motion as well, so the shear stress would, in the simplest case, be proportional to the <em>velocity difference</em>, leading to a boundary condition of the form <p class="formulaDsp">
\begin{align*} \mathbf{n}\cdot [2\eta \varepsilon(\mathbf v)] &amp;= s \mathbf{n} \times [\mathbf v - \mathbf v_0], \\ \mathbf{n} \cdot \mathbf v &amp;= 0, \end{align*}
</p>
 with a proportionality constant \(s\) . Rather than going down this route, however, we go with the choice of zero (stick) and tangential flow boundary conditions. As a side note of interest, we may also have chosen tangential flow conditions on both inner and outer boundary. That has a significant drawback, however: it leaves the velocity not uniquely defined. The reason is that all velocity fields \(\hat{\mathbf v}\) that correspond to a solid body rotation around the center of the domain satisfy \(\mathrm{div}\; \varepsilon(\hat{\mathbf v})=0, \mathrm{div} \;\hat{\mathbf v} = 0\) , and \(\mathbf{n} \cdot \hat{\mathbf v} = 0\) . As a consequence, if \(\mathbf v\) satisfies equations and boundary conditions, then so does \(\mathbf v + \hat{\mathbf v}\) . That's certainly not a good situation that we would like to avoid. The traditional way to work around this is to pick an arbitrary point on the boundary and call this your fixed point by choosing the velocity to be zero in all components there. (In 3d one has to choose two points.) Since this program isn't meant to be too realistic to begin with, we avoid this complication by simply fixing the velocity along the entire interior boundary. </li>
<li>
<p class="startli">To first order, the gravity vector always points downward. The question for a body as big as the earth is just: where is "up". The naive answer of course is "radially inward, towards the center of the earth". So at the surface of the earth, we have </p><p class="formulaDsp">
\[ \mathbf g = -9.81 \frac{\text{m}}{\text{s}^2} \frac{\mathbf x}{\|\mathbf x\|}, \]
</p>
<p> where \(9.81 \frac{\text{m}}{\text{s}^2}\) happens to be the average gravity acceleration at the earth surface. But in the earth interior, the question becomes a bit more complicated: at the (bary-)center of the earth, for example, you have matter pulling equally hard in all directions, and so \(\mathbf g=0\) . In between, the net force is described as follows: let us define the <a href="http://en.wikipedia.org/wiki/Potential_energy#Gravitational_potential_energy" target="_top">gravity potential</a> by </p><p class="formulaDsp">
\[ \varphi(\mathbf x) = \int_{\text{earth}} -G \frac{\rho(\mathbf y)}{\|\mathbf x-\mathbf y\|} \ \text{d}y, \]
</p>
<p> then \(\mathbf g(\mathbf x) = -\nabla \varphi(\mathbf x)\) . If we assume that the density \(\rho\) is constant throughout the earth, we can produce an analytical expression for the gravity vector (don't try to integrate above equation somehow</p>
<ul>
<li>it leads to elliptic integrals; a simpler way is to notice that \(-\Delta\varphi(\mathbf x) = -4\pi G \rho \chi_{\text{earth}}(\mathbf x)\) and solving this partial differential equation in all of \({\mathbb R}^3\) exploiting the radial symmetry): <p class="formulaDsp">
\[ \mathbf g(\mathbf x) = \left\{ \begin{array}{ll} -\frac{4}{3}\pi G \rho \|\mathbf x\| \frac{\mathbf x}{\|\mathbf x\|} &amp; \text{for} \ \|\mathbf x\|&lt;R_1, \\ -\frac{4}{3}\pi G \rho R^3 \frac{1}{\|\mathbf x\|^2} \frac{\mathbf x}{\|\mathbf x\|} &amp; \text{for} \ \|\mathbf x\|\ge R_1. \end{array} \right. \]
</p>
 The factor \(-\frac{\mathbf x}{\|\mathbf x\|}\) is the unit vector pointing radially inward. Of course, within this problem, we are only interested in the branch that pertains to within the earth, i.e., \(\|\mathbf x\|&lt;R_1\) . We would therefore only consider the expression <p class="formulaDsp">
\[ \mathbf g(\mathbf x) = -\frac{4}{3}\pi G \rho \|\mathbf x\| \frac{\mathbf x}{\|\mathbf x\|} = -\frac{4}{3}\pi G \rho \mathbf x = - 9.81 \frac{\mathbf x}{R_1} \frac{\text{m}}{\text{s}^2}, \]
</p>
 where we can infer the last expression because we know Earth's gravity at the surface (where \(\|x\|=R_1\) ). One can derive a more general expression by integrating the differential equation for \(\varphi(r)\) in the case that the density distribution is radially symmetric, i.e., \(\rho(\mathbf x)=\rho(\|\mathbf x\|)=\rho(r)\) . In that case, one would get <p class="formulaDsp">
\[ \varphi(r) = 4\pi G \int_0^r \frac 1{s^2} \int_0^s t^2 \rho(t) \; dt \; ds. \]
</p>
</li>
</ul>
<p class="endli">There are two problems with this, however: (i) The Earth is not homogeneous, i.e., the density \(\rho\) depends on \(\mathbf x\) ; in fact it is not even a function that only depends on the radius \(r=\|\mathbf x\|\) . In reality, gravity therefore does not always decrease as we get deeper: because the earth core is so much denser than the mantle, gravity actually peaks at around \(10.7 \frac{\text{m}}{\text{s}^2}\) at the core mantle boundary (see <a href="http://en.wikipedia.org/wiki/Earth&apos;s_gravity" target="_top">this article</a>). (ii) The density, and by consequence the gravity vector, is not even constant in time: after all, the problem we want to solve is the time dependent upwelling of hot, less dense material and the downwelling of cold dense material. This leads to a gravity vector that varies with space and time, and does not always point straight down. In order to not make the situation more complicated than necessary, we could use the approximation that at the inner boundary of the mantle, gravity is \(10.7 \frac{\text{m}}{\text{s}^2}\) and at the outer boundary it is \(9.81 \frac{\text{m}}{\text{s}^2}\) , in each case pointing radially inward, and that in between gravity varies linearly with the radial distance from the earth center. That said, it isn't that hard to actually be slightly more realistic and assume (as we do below) that the earth mantle has constant density. In that case, the equation above can be integrated and we get an expression for \(\|\mathbf{g}\|\) where we can fit constants to match the gravity at the top and bottom of the earth mantle to obtain </p><p class="formulaDsp">
\[ \|\mathbf{g}\| = 1.245\cdot 10^{-6} \frac{1}{\textrm{s}^2} r + 7.714\cdot 10^{13} \frac{\textrm{m}^3}{\textrm{s}^2}\frac{1}{r^2}. \]
</p>
 </li>
<li>
The density of the earth mantle varies spatially, but not by very much. \(\rho_{\text{ref}}=3300 \frac{\text{kg}}{\text{m}^3}\) is a relatively good average value for the density at reference temperature \(T_{\text{ref}}=293\) Kelvin. </li>
<li>
The thermal expansion coefficient \(\beta\) also varies with depth (through its dependence on temperature and pressure). Close to the surface, it appears to be on the order of \(\beta=45\cdot 10^{-6} \frac 1{\text{K}}\) , whereas at the core mantle boundary, it may be closer to \(\beta=10\cdot 10^{-6} \frac 1{\text{K}}\) . As a reasonable value, let us choose \(\beta=2\cdot 10^{-5} \frac 1{\text{K}}\) . The density as a function of temperature is then \(\rho(T)=[1-\beta(T-T_{\text{ref}})]\rho_{\text{ref}}\) . </li>
<li>
The second to last parameter we need to specify is the viscosity \(\eta\) . This is a tough one, because rocks at the temperatures and pressure typical for the earth mantle flow so slowly that the viscosity can not be determined accurately in the laboratory. So how do we know about the viscosity of the mantle? The most commonly used route is to consider that during and after ice ages, ice shields form and disappear on time scales that are shorter than the time scale of flow in the mantle. As a consequence, continents slowly sink into the earth mantle under the added weight of an ice shield, and they rise up again slowly after the ice shield has disappeared again (this is called <a href="http://en.wikipedia.org/wiki/Postglacial_rebound" target="_top"><em>postglacial rebound</em><em>postglacial rebound</em></a>). By measuring the speed of this rebound, we can infer the viscosity of the material that flows into the area vacated under the rebounding continental plates. Using this technique, values around \(\eta=10^{21} \text{Pa}\;\text{s} = 10^{21} \frac{\text{N}\;\text{s}}{\text{m}^2} = 10^{21} \frac{\text{kg}}{\text{m}\;\text{s}}\) have been found as the most likely, though the error bar on this is at least one order of magnitude. While we will use this value, we again have to caution that there are many physical reasons to assume that this is not the correct value. First, it should really be made dependent on temperature: hotter material is most likely to be less viscous than colder material. In reality, however, the situation is even more complex. Most rocks in the mantle undergo phase changes as temperature and pressure change: depending on temperature and pressure, different crystal configurations are thermodynamically favored over others, even if the chemical composition of the mantle were homogeneous. For example, the common mantle material MgSiO<sub>3</sub> exists in its <a href="http://en.wikipedia.org/wiki/Perovskite_(structure)" target="_top">perovskite structure</a> throughout most of the mantle, but in the lower mantle the same substance is stable only as <a href="http://en.wikipedia.org/wiki/Postperovskite" targe="_top">post-perovskite</a>. Clearly, to compute realistic viscosities, we would not only need to know the exact chemical composition of the mantle and the viscosities of all materials, but we would also have to compute the thermodynamically most stable configurations for all materials at each quadrature point. This is at the time of writing this program not a feasible suggestion. </li>
<li>
Our last material parameter is the thermal diffusivity \(\kappa\) , which is defined as \(\kappa=\frac{k}{\rho c_p}\) where \(k\) is the thermal conductivity, \(\rho\) the density, and \(c_p\) the specific heat. For this, the literature indicates that it increases from around \(0.7\) in the upper mantle to around \(1.7 \frac{\text{mm}^2}{\text{s}}\) in the lower mantle, though the exact value is not really all that important: heat transport through convection is several orders of magnitude more important than through thermal conduction. It may be of interest to know that perovskite, the most abundant material in the earth mantle, appears to become transparent at pressures above around 120 GPa (see, for example, J. Badro et al., Science 305, 383-386 (2004)); in the lower mantle, it may therefore be that heat transport through radiative transfer is more efficient than through thermal conduction. In view of these considerations, let us choose \(\kappa=1 \frac{\text{mm}^2}{\text{s}} =10^{-6} \frac{\text{m}^2}{\text{s}}\) for the purpose of this program. </li>
</ul>
<p>All of these pieces of equation data are defined in the program in the <code>EquationData</code> namespace. When run, the program produceslong-term maximal velocities around 10-40 centimeters per year (seethe results section below), approximately the physically correct orderof magnitude. We will set the end time to 1 billion years. </p><dl class="section note"><dt>Note</dt><dd>The choice of the constants and material parameters above follows inlarge part the comprehensive book "Mantle Convection in the Earth and
 Planets,Part 1" by G. Schubert and D. L. Turcotte and P. Olson (Cambridge, 2001). Itcontains extensive discussion of ways to make the program more realistic.</dd></dl>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details </h3>
<p>Compared to <a class="el" href="step_31.html">step-31</a> , this program has a number of noteworthy differences:</p>
<ul>
<li>The <code>EquationData</code> namespace is significantly larger, reflecting the fact that we now have much more physics to deal with. That said, most of this additional physical detail is rather self-contained in functions in this one namespace, and does not proliferate throughout the rest of the program.</li>
<li>Of more obvious visibility is the fact that we have put a good number of parameters into an input file handled by the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class (see, for example, <a class="el" href="step_29.html">step-29</a> , for ways to set up run-time parameter files with this class). This often makes sense when one wants to avoid re-compiling the program just because one wants to play with a single parameter (think, for example, of parameter studies determining the best values of the stabilization constants discussed above), in particular given that it takes a nontrivial amount of time to re-compile programs of the current size. To just give an overview of the kinds of parameters we have moved from fixed values into the input file, here is a listing of a typical <code>step-32.prm</code> file : <div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line"></div><div class="line">---------------------</div><div class="line"><span class="preprocessor"># The end time of the simulation in years.</span></div><div class="line"><span class="keyword">set</span> End time                            = 1e8</div><div class="line"></div><div class="line"><span class="preprocessor"># Whether graphical output is to be generated or not. You may not want to get</span></div><div class="line"><span class="preprocessor"># graphical output if the number of processors is large.</span></div><div class="line"><span class="keyword">set</span> Generate graphical output           = <span class="keyword">false</span></div><div class="line"></div><div class="line"><span class="preprocessor"># The number of adaptive refinement steps performed after initial global</span></div><div class="line"><span class="preprocessor"># refinement.</span></div><div class="line"><span class="keyword">set</span> Initial adaptive refinement         = 1</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of global refinement steps performed on the initial coarse mesh,</span></div><div class="line"><span class="preprocessor"># before the problem is first solved there.</span></div><div class="line"><span class="keyword">set</span> Initial global refinement           = 1</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of time steps between each generation of graphical output files.</span></div><div class="line"><span class="keyword">set</span> Time steps between graphical output = 50</div><div class="line"></div><div class="line"><span class="preprocessor"># The number of time steps after which the mesh is to be adapted based on</span></div><div class="line"><span class="preprocessor"># computed error indicators.</span></div><div class="line"><span class="keyword">set</span> Time steps between mesh refinement  = 10</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Discretization</div><div class="line"><span class="preprocessor"># The polynomial degree to use for the velocity variables in the Stokes</span></div><div class="line"><span class="preprocessor"># system.</span></div><div class="line"><span class="keyword">set</span> Stokes velocity polynomial degree       = 2</div><div class="line"></div><div class="line"><span class="preprocessor"># The polynomial degree to use for the temperature variable.</span></div><div class="line"><span class="keyword">set</span> Temperature polynomial degree           = 2</div><div class="line"></div><div class="line"><span class="preprocessor"># Whether to use a Stokes discretization that is locally conservative at the</span></div><div class="line"><span class="preprocessor"># expense of a larger number of degrees of freedom, or to go with a cheaper</span></div><div class="line"><span class="preprocessor"># discretization that does not locally conserve mass (although it is</span></div><div class="line"><span class="preprocessor"># globally conservative.</span></div><div class="line"><span class="keyword">set</span> Use locally conservative discretization = <span class="keyword">true</span></div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Stabilization parameters</div><div class="line"><span class="preprocessor"># The exponent in the entropy viscosity stabilization.</span></div><div class="line"><span class="keyword">set</span> alpha = 2</div><div class="line"></div><div class="line"><span class="preprocessor"># The beta factor in the artificial viscosity stabilization. An appropriate</span></div><div class="line"><span class="preprocessor"># value for 2d is 0.052 and 0.078 for 3d.</span></div><div class="line"><span class="keyword">set</span> beta  = 0.078</div><div class="line"></div><div class="line"># The c_R factor in the entropy viscosity stabilization.</div><div class="line">set c_R   = 0.5</div><div class="line">end</div></div><!-- fragment --></li>
<li>There are, obviously, a good number of changes that have to do with the fact that we want to run our program on a possibly very large number of machines. Although one may suspect that this requires us to completely re-structure our code, that isn't in fact the case (although the classes that implement much of this functionality in deal.II certainly look very different from an implementation viewpoint, but this doesn't reflect in their public interface). Rather, the changes are mostly subtle, and the overall structure of the main class is pretty much unchanged. That said, the devil is in the detail: getting parallel computing right, without deadlocks, ensuring that the right data is available at the right place (see, for example, the discussion on fully distributed vectors vs. vectors with ghost elements), and avoiding bottlenecks is difficult and discussions on this topic will appear in a good number of places in this program.</li>
</ul>
<p><a class="anchor" id="Outlook"></a></p><h3>Outlook </h3>
<p>This is a tutorial program. That means that at least most of its focus needsto lie on demonstrating ways of using deal.II and associated libraries, andnot diluting this teaching lesson by focusing overly much on physicaldetails. Despite the lengthy section above on the choice of physicalparameters, the part of the program devoted to this is actually quite shortand self contained. That said, both <a class="el" href="step_31.html">step-31</a> and the current <a class="el" href="step_32.html">step-32</a> have not come about by chancebut are certainly meant as wayposts along the path to a more comprehensiveprogram that will simulate convection in the earth mantle. We call this code<em>ASPECT</em> (short for <em>Advanced Solver for Problems in Earth's ConvecTion</em>); its development is funded bythe <a href="http://www.geodynamics.org">Computational Infrastructure in Geodynamics</a> initiative with support from the National ScienceFoundation. More information on <em>ASPECT</em> is available atits <a href="https://aspect.geodynamics.org/">homepage</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first task as usual is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="filtered__iterator_8h.html">deal.II/grid/filtered_iterator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgp_8h.html">deal.II/fe/fe_dgp.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;locale&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --><p>This is the only include file that is new: It introduces the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> equivalent of the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class to take a solution from on mesh to the next one upon mesh refinement, but in the case of parallel distributed triangulations:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --><p>The following classes are used in parallel distributed computations and have all already been introduced in <a class="el" href="step_40.html">step-40</a> :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div></div><!-- fragment --><p>The next step is like in all previous tutorial programs: We put everything into a namespace of its own and then import the deal.II classes and functions into it:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step32</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>In the following namespace, we define the various pieces of equation data that describe the problem. This corresponds to the various aspects of making the problem at least slightly realistic and that were exhaustively discussed in the description of the testcase in the introduction. We start with a few coefficients that have constant values (the comment after the value indicates its physical units):</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">double</span> eta                   = 1e21;    <span class="comment">// Pa s</span></div><div class="line">  constexpr <span class="keywordtype">double</span> kappa                 = 1e-6;    <span class="comment">// m^2 / s</span></div><div class="line">  constexpr <span class="keywordtype">double</span> reference_density     = 3300;    <span class="comment">// kg / m^3</span></div><div class="line">  constexpr <span class="keywordtype">double</span> reference_temperature = 293;     <span class="comment">// K</span></div><div class="line">  constexpr <span class="keywordtype">double</span> expansion_coefficient = 2e-5;    <span class="comment">// 1/K</span></div><div class="line">  constexpr <span class="keywordtype">double</span> specific_heat         = 1250;    <span class="comment">// J / K / kg</span></div><div class="line">  constexpr <span class="keywordtype">double</span> radiogenic_heating    = 7.4e-12; <span class="comment">// W / kg</span></div><div class="line"></div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> R0 = 6371000.</div><div class="line"></div><div class="line">- 2890000.; <span class="comment">// m</span></div><div class="line">  constexpr <span class="keywordtype">double</span> R1 = 6371000.</div><div class="line"></div><div class="line">- 35000.;   <span class="comment">// m</span></div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> T0 = 4000 + 273; <span class="comment">// K</span></div><div class="line">  constexpr <span class="keywordtype">double</span> T1 = 700 + 273;  <span class="comment">// K</span></div></div><!-- fragment --><p>The next set of definitions are for functions that encode the density as a function of temperature, the gravity vector, and the initial values for the temperature. Again, all of these (along with the values they compute) are discussed in the introduction:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> density(<span class="keyword">const</span> <span class="keywordtype">double</span> temperature)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> (</div><div class="line">      reference_density</div><div class="line">      (1</div><div class="line"></div><div class="line">- expansion_coefficient (temperature</div><div class="line"></div><div class="line">- reference_temperature)));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> gravity_vector(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">    <span class="keywordflow">return</span></div><div class="line"></div><div class="line">-(1.245e-6 r + 7.714e13 / r / r) p / r;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TemperatureInitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TemperatureInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h = R1</div><div class="line"></div><div class="line">- R0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> s = (r</div><div class="line"></div><div class="line">- R0) / h;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> q =</div><div class="line">      (dim == 3) ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(0.0, <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> <a class="code" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">abs</a>(p(2) / R1))) : 1.0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(p(0), p(1));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> tau = s + 0.2 s (1</div><div class="line"></div><div class="line">- s) <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(6 phi) q;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> T0 (1.0</div><div class="line"></div><div class="line">- tau) + T1 tau;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  TemperatureInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div></div><!-- fragment --><p>As mentioned in the introduction we need to rescale the pressure to avoid the relative ill-conditioning of the momentum and mass conservation equations. The scaling factor is \(\frac{\eta}{L}\) where \(L\) was a typical length scale. By experimenting it turns out that a good length scale is the diameter of plumes, which is around 10 km:</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">double</span> pressure_scaling = eta / 10000;</div></div><!-- fragment --><p>The final number in this namespace is a constant that denotes the number of seconds per (average, tropical) year. We use this only when generating screen output: internally, all computations of this program happen in SI units (kilogram, meter, seconds) but writing geological times in seconds yields numbers that one can't relate to reality, and so we convert to years using the factor defined here:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> year_in_seconds = 60 60 24 365.2425;</div><div class="line"></div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --><p><a class="anchor" id="PreconditioningtheStokessystem"></a> </p><h3>Preconditioning the Stokes system</h3>
<p>This namespace implements the preconditioner. As discussed in the introduction, this preconditioner differs in a number of key portions from the one used in <a class="el" href="step_31.html">step-31</a> . Specifically, it is a right preconditioner, implementing the matrix</p>
<p class="formulaDsp">
\begin{align*} \left(\begin{array}{cc}A^{-1} &amp; B^T \\0 &amp; S^{-1} \end{array}\right) \end{align*}
</p>
<p> where the two inverse matrix operations are approximated by linear solvers or, if the right flag is given to the constructor of this class, by a single AMG V-cycle for the velocity block. The three code blocks of the <code>vmult</code> function implement the multiplications with the three blocks of this preconditioner matrix and should be self explanatory if you have read through <a class="el" href="step_31.html">step-31</a> or the discussion of composing solvers in <a class="el" href="step_20.html">step-20</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;Spre,</div><div class="line">                             <span class="keyword">const</span> PreconditionerTypeMp &amp;Mppreconditioner,</div><div class="line">                             <span class="keyword">const</span> PreconditionerTypeA &amp; Apreconditioner,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">bool</span>                  do_solve_A)</div><div class="line">      : stokes_matrix(&amp;S)</div><div class="line">      , stokes_preconditioner_matrix(&amp;Spre)</div><div class="line">      , mp_preconditioner(Mppreconditioner)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , do_solve_A(do_solve_A)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> utmp(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, 1e-6 src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).l2_norm());</div><div class="line"></div><div class="line">        <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">        solver.solve(stokes_preconditioner_matrix-&gt;block(1, 1),</div><div class="line">                     dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                     src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                     mp_preconditioner);</div><div class="line"></div><div class="line">        dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1)=</div><div class="line"></div><div class="line">-1.0;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        stokes_matrix-&gt;block(0, 1).vmult(utmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">        utmp=</div><div class="line"></div><div class="line">-1.0;</div><div class="line">        utmp.add(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (do_solve_A == <span class="keyword">true</span>)</div><div class="line">        {</div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, utmp.l2_norm() 1e-2);</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1SolverCG.html">TrilinosWrappers::SolverCG</a> solver(solver_control);</div><div class="line">          solver.solve(stokes_matrix-&gt;block(0, 0),</div><div class="line">                       dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0),</div><div class="line">                       utmp,</div><div class="line">                       a_preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">      stokes_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">                                stokes_preconditioner_matrix;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeMp &amp;mp_preconditioner;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp; a_preconditioner;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>                  do_solve_A;</div><div class="line">  };</div><div class="line">} <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --><p><a class="anchor" id="Definitionofassemblydatastructures"></a> </p><h3>Definition of assembly data structures</h3>
<p>As described in the introduction, we will use the <a class="el" href="namespaceWorkStream.html">WorkStream</a> mechanism discussed in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> module to parallelize operations among the processors of a single machine. The <a class="el" href="namespaceWorkStream.html">WorkStream</a> class requires that data is passed around in two kinds of data structures, one for scratch data and one to pass data from the assembly function to the function that copies local contributions into global objects. The following namespace (and the two sub-namespaces) contains a collection of data structures that serve this purpose, one pair for each of the four operations discussed in the introduction that we will want to parallelize. Each assembly routine gets two sets of data: a Scratch array that collects all the classes and arrays that are used for the calculation of the cell contribution, and a CopyData array that keeps local matrices and vectors which will be written into the global matrix. Whereas CopyData is a container for the final data that is written into the global matrices and vector (and, thus, absolutely necessary), the Scratch arrays are merely there for performance reasons &mdash; it would be much more expensive to set up a <a class="el" href="classFEValues.html">FEValues</a> object on each cell, than creating it only once and updating some derivative data. <a class="el" href="step_31.html">step-31</a> had four assembly routines: One for the preconditioner matrix of the Stokes system, one for the Stokes matrix and right hand side, one for the temperature matrices and one for the right hand side of the temperature equation. We here organize the scratch arrays and CopyData objects for each of those four assembly components using a <code>struct</code> environment (since we consider these as temporary objects we pass around, rather than classes that implement functionality of their own, though this is a more subjective point of view to distinguish between <code>struct</code>s and <code>class</code> es). Regarding the Scratch objects, each struct is equipped with a constructor that creates an <a class="el" href="classFEValues.html">FEValues</a> object using the <a class="el" href="classFiniteElement.html">FiniteElement</a> , <a class="el" href="classQuadrature.html">Quadrature</a>, <a class="el" href="classMapping.html">Mapping</a> (which describes the interpolation of curved boundaries), and <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> instances. Moreover, we manually implement a copy constructor (since the <a class="el" href="classFEValues.html">FEValues</a> class is not copyable by itself), and provide some additional vector fields that are used to hold intermediate data during the computation of local contributions. Let us start with the scratch arrays and, specifically, the one used for assembly of the Stokes preconditioner:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Assembly</div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span>Scratch</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">    {</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags);</div><div class="line"></div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> stokes_fe_values;</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u;</div><div class="line">      std::vector&lt;double&gt;         phi_p;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">      : stokes_fe_values(mapping, stokes_fe, stokes_quadrature, update_flags)</div><div class="line">      , grad_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">      , phi_p(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> StokesPreconditioner &amp;scratch)</div><div class="line">      : stokes_fe_values(scratch.stokes_fe_values.get_mapping(),</div><div class="line">                         scratch.stokes_fe_values.get_fe(),</div><div class="line">                         scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                         scratch.stokes_fe_values.get_update_flags())</div><div class="line">      , grad_phi_u(scratch.grad_phi_u)</div><div class="line">      , phi_p(scratch.phi_p)</div><div class="line">    {}</div></div><!-- fragment --><p>The next one is the scratch object used for the assembly of the full Stokes system. Observe that we derive the StokesSystem scratch class from the StokesPreconditioner class above. We do this because all the objects that are necessary for the assembly of the preconditioner are also needed for the actual matrix system and right hand side, plus some extra data. This makes the program more compact. Note also that the assembly of the Stokes system and the temperature right hand side further down requires data from temperature and velocity, respectively, so we actually need two <a class="el" href="classFEValues.html">FEValues</a> objects for those two cases.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">{</div><div class="line">  StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags);</div><div class="line"></div><div class="line">  StokesSystem(<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u;</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u;</div><div class="line">  std::vector&lt;double&gt;                  div_phi_u;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_temperature_values;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesSystem&lt;dim&gt;::StokesSystem(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags)</div><div class="line">  : StokesPreconditioner&lt;dim&gt;(stokes_fe,</div><div class="line">                              stokes_quadrature,</div><div class="line">                              mapping,</div><div class="line">                              stokes_update_flags)</div><div class="line">  , temperature_fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          stokes_quadrature,</div><div class="line">                          temperature_update_flags)</div><div class="line">  , phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , grads_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , div_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , old_temperature_values(stokes_quadrature.size())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesSystem&lt;dim&gt;::StokesSystem(<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;scratch)</div><div class="line">  : StokesPreconditioner&lt;dim&gt;(scratch)</div><div class="line">  , temperature_fe_values(</div><div class="line">      scratch.temperature_fe_values.get_mapping(),</div><div class="line">      scratch.temperature_fe_values.get_fe(),</div><div class="line">      scratch.temperature_fe_values.get_quadrature(),</div><div class="line">      scratch.temperature_fe_values.get_update_flags())</div><div class="line">  , phi_u(scratch.phi_u)</div><div class="line">  , grads_phi_u(scratch.grads_phi_u)</div><div class="line">  , div_phi_u(scratch.div_phi_u)</div><div class="line">  , old_temperature_values(scratch.old_temperature_values)</div><div class="line">{}</div></div><!-- fragment --><p>After defining the objects used in the assembly of the Stokes system, we do the same for the assembly of the matrices necessary for the temperature system. The general structure is very similar:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>TemperatureMatrix</div><div class="line">{</div><div class="line">  TemperatureMatrix(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   temperature_quadrature);</div><div class="line"></div><div class="line">  TemperatureMatrix(<span class="keyword">const</span> TemperatureMatrix &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         phi_T;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   temperature_quadrature)</div><div class="line">  : temperature_fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          temperature_quadrature,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">  , phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">  , grad_phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">  <span class="keyword">const</span> TemperatureMatrix &amp;scratch)</div><div class="line">  : temperature_fe_values(</div><div class="line">      scratch.temperature_fe_values.get_mapping(),</div><div class="line">      scratch.temperature_fe_values.get_fe(),</div><div class="line">      scratch.temperature_fe_values.get_quadrature(),</div><div class="line">      scratch.temperature_fe_values.get_update_flags())</div><div class="line">  , phi_T(scratch.phi_T)</div><div class="line">  , grad_phi_T(scratch.grad_phi_T)</div><div class="line">{}</div></div><!-- fragment --><p>The final scratch object is used in the assembly of the right hand side of the temperature system. This object is significantly larger than the ones above because a lot more quantities enter the computation of the right hand side of the temperature equation. In particular, the temperature values and gradients of the previous two time steps need to be evaluated at the quadrature points, as well as the velocities and the strain rates (i.e. the symmetric gradients of the velocity) that enter the right hand side as friction heating terms. Despite the number of terms, the following should be rather self explanatory:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>TemperatureRHS</div><div class="line">  {</div><div class="line">    TemperatureRHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line"></div><div class="line">    TemperatureRHS(<span class="keyword">const</span> TemperatureRHS &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> stokes_fe_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values;</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_strain_rates;</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_old_strain_rates;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         old_temperature_values;</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads;</div><div class="line">    std::vector&lt;double&gt;         old_temperature_laplacians;</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_laplacians;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TemperatureRHS&lt;dim&gt;::TemperatureRHS(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">    : temperature_fe_values(mapping,</div><div class="line">                            temperature_fe,</div><div class="line">                            quadrature,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    , stokes_fe_values(mapping,</div><div class="line">                       stokes_fe,</div><div class="line">                       quadrature,</div><div class="line">                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div><div class="line">    , phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">    , grad_phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_velocity_values(quadrature.size())</div><div class="line">    , old_old_velocity_values(quadrature.size())</div><div class="line">    , old_strain_rates(quadrature.size())</div><div class="line">    , old_old_strain_rates(quadrature.size())</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_temperature_values(quadrature.size())</div><div class="line">    , old_old_temperature_values(quadrature.size())</div><div class="line">    , old_temperature_grads(quadrature.size())</div><div class="line">    , old_old_temperature_grads(quadrature.size())</div><div class="line">    , old_temperature_laplacians(quadrature.size())</div><div class="line">    , old_old_temperature_laplacians(quadrature.size())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TemperatureRHS&lt;dim&gt;::TemperatureRHS(<span class="keyword">const</span> TemperatureRHS &amp;scratch)</div><div class="line">    : temperature_fe_values(</div><div class="line">        scratch.temperature_fe_values.get_mapping(),</div><div class="line">        scratch.temperature_fe_values.get_fe(),</div><div class="line">        scratch.temperature_fe_values.get_quadrature(),</div><div class="line">        scratch.temperature_fe_values.get_update_flags())</div><div class="line">    , stokes_fe_values(scratch.stokes_fe_values.get_mapping(),</div><div class="line">                       scratch.stokes_fe_values.get_fe(),</div><div class="line">                       scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                       scratch.stokes_fe_values.get_update_flags())</div><div class="line">    , phi_T(scratch.phi_T)</div><div class="line">    , grad_phi_T(scratch.grad_phi_T)</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_velocity_values(scratch.old_velocity_values)</div><div class="line">    , old_old_velocity_values(scratch.old_old_velocity_values)</div><div class="line">    , old_strain_rates(scratch.old_strain_rates)</div><div class="line">    , old_old_strain_rates(scratch.old_old_strain_rates)</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_temperature_values(scratch.old_temperature_values)</div><div class="line">    , old_old_temperature_values(scratch.old_old_temperature_values)</div><div class="line">    , old_temperature_grads(scratch.old_temperature_grads)</div><div class="line">    , old_old_temperature_grads(scratch.old_old_temperature_grads)</div><div class="line">    , old_temperature_laplacians(scratch.old_temperature_laplacians)</div><div class="line">    , old_old_temperature_laplacians(scratch.old_old_temperature_laplacians)</div><div class="line">  {}</div><div class="line">} <span class="comment">// namespace Scratch</span></div></div><!-- fragment --><p>The CopyData objects are even simpler than the Scratch objects as all they have to do is to store the results of local computations until they can be copied into the global matrix or vector objects. These structures therefore only need to provide a constructor, a copy operation, and some arrays for local matrix, local vectors and the relation between local and global degrees of freedom (a.k.a. <code>local_dof_indices</code> ). Again, we have one such structure for each of the four operations we will parallelize using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class:</p>
<div class="fragment"><div class="line">  <span class="keyword">namespace </span>CopyData</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">    {</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line">      StokesPreconditioner &amp;operator=(<span class="keyword">const</span> StokesPreconditioner &amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_matrix;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">      : local_matrix(stokes_fe.n_dofs_per_cell(), stokes_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> StokesPreconditioner &amp;data)</div><div class="line">      : local_matrix(data.local_matrix)</div><div class="line">      , local_dof_indices(data.local_dof_indices)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">    {</div><div class="line">      StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesSystem&lt;dim&gt;::StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">      : StokesPreconditioner&lt;dim&gt;(stokes_fe)</div><div class="line">      , local_rhs(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>TemperatureMatrix</div><div class="line">    {</div><div class="line">      TemperatureMatrix(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_mass_matrix;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_stiffness_matrix;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">      : local_mass_matrix(temperature_fe.n_dofs_per_cell(),</div><div class="line">                          temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_stiffness_matrix(temperature_fe.n_dofs_per_cell(),</div><div class="line">                               temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(temperature_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>TemperatureRHS</div><div class="line">    {</div><div class="line">      TemperatureRHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       local_rhs;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   matrix_for_bc;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureRHS&lt;dim&gt;::TemperatureRHS(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">      : local_rhs(temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(temperature_fe.n_dofs_per_cell())</div><div class="line">      , matrix_for_bc(temperature_fe.n_dofs_per_cell(),</div><div class="line">                      temperature_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line">  } <span class="comment">// namespace CopyData</span></div><div class="line">}   <span class="comment">// namespace Assembly</span></div></div><!-- fragment --><p><a class="anchor" id="ThecodeBoussinesqFlowProblemcodeclasstemplate"></a> </p><h3>The <code>BoussinesqFlowProblem</code> class template</h3>
<p>This is the declaration of the main class. It is very similar to <a class="el" href="step_31.html">step-31</a> but there are a number differences we will comment on below. The top of the class is essentially the same as in <a class="el" href="step_31.html">step-31</a> , listing the public methods and a set of private functions that do the heavy lifting. Compared to <a class="el" href="step_31.html">step-31</a> there are only two additions to this section: the function <code>get_cfl_number()</code> that computes the maximum CFL number over all cells which we then compute the global time step from, and the function <code>get_entropy_variation()</code> that is used in the computation of the entropy stabilization. It is akin to the <code>get_extrapolated_temperature_range()</code> we have used in <a class="el" href="step_31.html">step-31</a> for this purpose, but works on the entropy instead of the temperature instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">struct </span>Parameters;</div><div class="line">  BoussinesqFlowProblem(Parameters &amp;parameters);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_cfl_number() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_entropy_variation(<span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature) <span class="keyword">const</span>;</div><div class="line">  std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      solve();</div><div class="line">  <span class="keywordtype">void</span>                      output_results();</div><div class="line">  <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_strain_rates,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_old_strain_rates,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                average_temperature,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_entropy_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p>The first significant new component is the definition of a struct for the parameters according to the discussion in the introduction. This structure is initialized by reading from a parameter file during construction of this object.</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>Parameters</div><div class="line">  {</div><div class="line">    Parameters(<span class="keyword">const</span> std::string &amp;parameter_filename);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    <span class="keywordtype">void</span>        parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_global_refinement;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_adaptive_refinement;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span>         generate_graphical_output;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> graphical_output_interval;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> adaptive_refinement_interval;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> stabilization_alpha;</div><div class="line">    <span class="keywordtype">double</span> stabilization_c_R;</div><div class="line">    <span class="keywordtype">double</span> stabilization_beta;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_velocity_degree;</div><div class="line">    <span class="keywordtype">bool</span>         use_locally_conservative_discretization;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temperature_degree;</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Parameters &amp;parameters;</div></div><!-- fragment --><p>The <code>pcout</code> (for <em>parallel <code>std::cout</code></em>) object is used to simplify writing output: each MPI process can use this to generate output as usual, but since each of these processes will (hopefully) produce the same output it will just be replicated many times over; with the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> class, only the output generated by one MPI process will actually be printed to screen, whereas the output by all the other threads will simply be forgotten.</p>
<div class="fragment"><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div></div><!-- fragment --><p>The following member variables will then again be similar to those in <a class="el" href="step_31.html">step-31</a> (and to other tutorial programs). As mentioned in the introduction, we fully distribute computations, so we will have to use the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see <a class="el" href="step_40.html">step-40</a> ) but the remainder of these variables is rather standard with two exceptions:</p>
<ul>
<li>The <code>mapping</code> variable is used to denote a higher-order polynomial mapping. As mentioned in the introduction, we use this mapping when forming integrals through quadrature for all cells that are adjacent to either the inner or outer boundaries of our domain where the boundary is curved.</li>
<li>In a bit of naming confusion, you will notice below that some of the variables from namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> are taken from namespace <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">TrilinosWrappers::MPI</a> (such as the right hand side vectors) whereas others are not (such as the various matrices). This is due to legacy reasons. We will frequently have to query velocities and temperatures at arbitrary quadrature points; consequently, rather than importing ghost information of a vector whenever we need access to degrees of freedom that are relevant locally but owned by another processor, we solve linear systems in parallel but then immediately initialize a vector including ghost entries of the solution for further processing. The various <code>*_solution</code> vectors are therefore filled immediately after solving their respective linear system in parallel and will always contain values for all <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant degrees of freedom</a>; the fully distributed vectors that we obtain from the solution process and that only ever contain the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned degrees of freedom</a> are destroyed immediately after the solution process and after we have copied the relevant values into the member variable vectors.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keywordtype">double</span>                                    global_Omega_diameter;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>       stokes_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time_step;</div><div class="line"><span class="keywordtype">double</span>       old_time_step;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt;    Amg_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; Mp_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; T_preconditioner;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line"><span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line"><span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line"><span class="keywordtype">bool</span> rebuild_temperature_preconditioner;</div></div><!-- fragment --><p>The next member variable, <code>computing_timer</code> is used to conveniently account for compute time spent in certain "sections" of the code that are repeatedly entered. For example, we will enter (and leave) sections for Stokes matrix assembly and would like to accumulate the run time spent in this section over all time steps. Every so many time steps as well as at the end of the program (through the destructor of the <a class="el" href="classTimerOutput.html">TimerOutput</a> class) we will then produce a nice summary of the times spent in the different sections into which we categorize the run-time of this program.</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div></div><!-- fragment --><p>After these member variables we have a number of auxiliary functions that have been broken out of the ones listed above. Specifically, there are first three functions that we call from <code>setup_dofs</code> and then the ones that do the assembling of linear systems:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_stokes_matrix(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line"><span class="keywordtype">void</span> setup_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line"><span class="keywordtype">void</span> setup_temperature_matrices(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioning,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioning);</div></div><!-- fragment --><p>Following the <a class="el" href="group__threads.html#MTWorkStream">task-based parallelization</a> paradigm, we split all the assembly routines into two parts: a first part that can do all the calculations on a certain cell without taking care of other threads, and a second part (which is writing the local data into the global matrices and vectors) which can be entered by only one thread at a time. In order to implement that, we provide functions for each of those two steps for all the four assembly routines that we use in this program. The following eight functions do exactly this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> local_assemble_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">  Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_stokes_system(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">  Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_stokes_system(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">  Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_velocity,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">  Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data);</div></div><!-- fragment --><p>Finally, we forward declare a member class that we will define later on and that will be used to compute a number of quantities from our solution vectors that we'd like to put into the output files for visualization.</p>
<div class="fragment"><div class="line">  <span class="keyword">class </span>Postprocessor;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemclassimplementation"></a> </p><h3>BoussinesqFlowProblem class implementation</h3>
<p><a class="anchor" id="BoussinesqFlowProblemParameters"></a> </p><h4>BoussinesqFlowProblem::Parameters</h4>
<p>Here comes the definition of the parameters for the Stokes problem. We allow to set the end time for the simulation, the level of refinements (both global and adaptive, which in the sum specify what maximum level the cells are allowed to have), and the interval between refinements in the time stepping. Then, we let the user specify constants for the stabilization parameters (as discussed in the introduction), the polynomial degree for the Stokes velocity space, whether to use the locally conservative discretization based on <a class="el" href="classFE__DGP.html">FE_DGP</a> elements for the pressure or not (<a class="el" href="classFE__Q.html">FE_Q</a> elements for pressure), and the polynomial degree for the temperature interpolation. The constructor checks for a valid input file (if not, a file with default parameters for the quantities is written), and eventually parses the parameters.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Parameters::Parameters(</div><div class="line">  <span class="keyword">const</span> std::string &amp;parameter_filename)</div><div class="line">  : end_time(1e8)</div><div class="line">  , initial_global_refinement(2)</div><div class="line">  , initial_adaptive_refinement(2)</div><div class="line">  , adaptive_refinement_interval(10)</div><div class="line">  , stabilization_alpha(2)</div><div class="line">  , stabilization_c_R(0.11)</div><div class="line">  , stabilization_beta(0.078)</div><div class="line">  , stokes_velocity_degree(2)</div><div class="line">  , use_locally_conservative_discretization(true)</div><div class="line">  , temperature_degree(2)</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters(prm);</div><div class="line"></div><div class="line">  std::ifstream parameter_file(parameter_filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!parameter_file)</div><div class="line">    {</div><div class="line">      parameter_file.close();</div><div class="line"></div><div class="line">      std::ofstream parameter_out(parameter_filename);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(parameter_out, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">        <span class="keyword">false</span>,</div><div class="line">        <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">          <span class="stringliteral">&quot;Input parameter file &lt;&quot;</span> + parameter_filename +</div><div class="line">          <span class="stringliteral">&quot;&gt; not found. Creating a template file of the same name.&quot;</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">  parse_parameters(prm);</div><div class="line">}</div></div><!-- fragment --><p>Next we have a function that declares the parameters that we expect in the input file, together with their data types, default values and a description:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters(</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;End time&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;1e8&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The end time of the simulation in years.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Initial global refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The number of global refinement steps performed on &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;the initial coarse mesh, before the problem is first &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;solved there.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The number of adaptive refinement steps performed after &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;initial global refinement.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;The number of time steps after which the mesh is to be &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;adapted based on computed error indicators.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Generate graphical output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Whether graphical output is to be generated or not. &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;You may not want to get graphical output if the number &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;of processors is large.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;50&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;The number of time steps between each generation of &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;graphical output files.&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;alpha&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(1, 2),</div><div class="line">                      <span class="stringliteral">&quot;The exponent in the entropy viscosity stabilization.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c_R&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.11&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The c_R factor in the entropy viscosity &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;stabilization.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;beta&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.078&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The beta factor in the artificial viscosity &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;stabilization. An appropriate value for 2d is 0.052 &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;and 0.078 for 3d.&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">      <span class="stringliteral">&quot;The polynomial degree to use for the velocity variables &quot;</span></div><div class="line">      <span class="stringliteral">&quot;in the Stokes system.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">      <span class="stringliteral">&quot;The polynomial degree to use for the temperature variable.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">      <span class="stringliteral">&quot;Whether to use a Stokes discretization that is locally &quot;</span></div><div class="line">      <span class="stringliteral">&quot;conservative at the expense of a larger number of degrees &quot;</span></div><div class="line">      <span class="stringliteral">&quot;of freedom, or to go with a cheaper discretization &quot;</span></div><div class="line">      <span class="stringliteral">&quot;that does not locally conserve mass (although it is &quot;</span></div><div class="line">      <span class="stringliteral">&quot;globally conservative.&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p>And then we need a function that reads the contents of the <a class="el" href="classParameterHandler.html">ParameterHandler</a> object we get by reading the input file and puts the results into variables that store the values of the parameters we have previously declared:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Parameters::parse_parameters(</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  end_time                  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">  initial_global_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Initial global refinement&quot;</span>);</div><div class="line">  initial_adaptive_refinement =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>);</div><div class="line"></div><div class="line">  adaptive_refinement_interval =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>);</div><div class="line"></div><div class="line">  generate_graphical_output = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Generate graphical output&quot;</span>);</div><div class="line">  graphical_output_interval =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">  {</div><div class="line">    stabilization_alpha = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;alpha&quot;</span>);</div><div class="line">    stabilization_c_R   = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c_R&quot;</span>);</div><div class="line">    stabilization_beta  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;beta&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">  {</div><div class="line">    stokes_velocity_degree =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>);</div><div class="line">    temperature_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>);</div><div class="line">    use_locally_conservative_discretization =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemBoussinesqFlowProblem"></a> </p><h4>BoussinesqFlowProblem::BoussinesqFlowProblem</h4>
<p>The constructor of the problem is very similar to the constructor in <a class="el" href="step_31.html">step-31</a> . What is different is the parallel communication: Trilinos uses a message passing interface (MPI) for data distribution. When entering the BoussinesqFlowProblem class, we have to decide how the parallelization is to be done. We choose a rather simple strategy and let all processors that are running the program work together, specified by the communicator <code>MPI_COMM_WORLD</code> . Next, we create the output stream (as we already did in <a class="el" href="step_18.html">step-18</a> ) that only generates output on the first MPI process and is completely forgetful on all others. The implementation of this idea is to check the process number when <code>pcout</code> gets a true argument, and it uses the <code>std::cout</code> stream for output. If we are one processor five, for instance, then we will give a <code>false</code> argument to <code>pcout</code> , which means that the output of that processor will not be printed. With the exception of the mapping object (for which we use polynomials of degree 4) all but the final member variable are exactly the same as in <a class="el" href="step_31.html">step-31</a> . This final object, the <a class="el" href="classTimerOutput.html">TimerOutput</a> object, is then told to restrict output to the <code>pcout</code> stream (processor 0), and then we specify that we want to get a summary table at the end of the program which shows us wallclock times (as opposed to CPU times). We will manually also request intermediate summaries every so many time steps in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem(Parameters &amp;parameters_)</div><div class="line">  : parameters(parameters_)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0))</div><div class="line">  ,</div><div class="line"></div><div class="line">  triangulation(MPI_COMM_WORLD,</div><div class="line">                typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing(</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening))</div><div class="line">  ,</div><div class="line"></div><div class="line">  global_Omega_diameter(0.)</div><div class="line">  ,</div><div class="line"></div><div class="line">  mapping(4)</div><div class="line">  ,</div><div class="line"></div><div class="line">  stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree),</div><div class="line">            dim,</div><div class="line">            (parameters.use_locally_conservative_discretization ?</div><div class="line">               static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;(</div><div class="line">                 <a class="code" href="classFE__DGP.html">FE_DGP</a>&lt;dim&gt;(parameters.stokes_velocity_degree</div><div class="line"></div><div class="line">- 1)) :</div><div class="line">               static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;(</div><div class="line">                 <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree</div><div class="line"></div><div class="line">- 1))),</div><div class="line">            1)</div><div class="line">  ,</div><div class="line"></div><div class="line">  stokes_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  temperature_fe(parameters.temperature_degree)</div><div class="line">  , temperature_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , rebuild_stokes_matrix(true)</div><div class="line">  , rebuild_stokes_preconditioner(true)</div><div class="line">  , rebuild_temperature_matrices(true)</div><div class="line">  , rebuild_temperature_preconditioner(true)</div><div class="line">  ,</div><div class="line"></div><div class="line">  computing_timer(MPI_COMM_WORLD,</div><div class="line">                  pcout,</div><div class="line">                  <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                  <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemhelperfunctions"></a> </p><h4>The BoussinesqFlowProblem helper functions</h4>
<p><a class="anchor" id="BoussinesqFlowProblemget_maximal_velocity"></a> </p><h5>BoussinesqFlowProblem::get_maximal_velocity</h5>
<p>Except for two small details, the function to compute the global maximum of the velocity is the same as in <a class="el" href="step_31.html">step-31</a> . The first detail is actually common to all functions that implement loops over all cells in the triangulation: When operating in parallel, each processor can only work on a chunk of cells since each processor only has a certain part of the entire triangulation. This chunk of cells that we want to work on is identified via a so-called <code>subdomain_id</code> , as we also did in <a class="el" href="step_18.html">step-18</a> . All we need to change is hence to perform the cell-related operations only on cells that are owned by the current process (as opposed to ghost or artificial cells), i.e. for which the subdomain id equals the number of the process ID. Since this is a commonly used operation, there is a shortcut for this operation: we can ask whether the cell is owned by the current processor using <code>cell-&gt;is_locally_owned()</code> . The second difference is the way we calculate the maximum value. Before, we could simply have a <code>double</code> variable that we checked against on each quadrature point for each cell. Now, we have to be a bit more careful since each processor only operates on a subset of cells. What we do is to first let each processor calculate the maximum among its cells, and then do a global communication operation <code><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a></code> that computes the maximum value among all the maximum values of the individual processors. MPI provides such a call, but it's even simpler to use the respective function in namespace <a class="el" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a> using the MPI communicator object since that will do the right thing even if we work without MPI and on a single machine only. The call to <code><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a></code> needs two arguments, namely the local maximum (input) and the MPI communicator, which is MPI_COMM_WORLD in this example.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.stokes_velocity_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(mapping,</div><div class="line">                          stokes_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_local_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_local_velocity =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_local_velocity, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_cfl_number"></a> </p><h5>BoussinesqFlowProblem::get_cfl_number</h5>
<p>The next function does something similar, but we now compute the CFL number, i.e., maximal velocity on a cell divided by the cell diameter. This number is necessary to determine the time step size, as we use a semi-explicit time stepping scheme for the temperature equation (see <a class="el" href="step_31.html">step-31</a> for a discussion). We compute it in the same way as above: Compute the local maximum over all locally owned cells, then exchange it via MPI to find the global maximum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_cfl_number()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.stokes_velocity_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(mapping,</div><div class="line">                          stokes_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_local_cfl = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> max_local_velocity = 1e-10;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_local_velocity =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">        max_local_cfl =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_cfl, max_local_velocity / cell-&gt;diameter());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_local_cfl, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_entropy_variation"></a> </p><h5>BoussinesqFlowProblem::get_entropy_variation</h5>
<p>Next comes the computation of the global entropy variation \(\|E(T)-\bar{E}(T)\|_\infty\) where the entropy \(E\) is defined as discussed in the introduction. This is needed for the evaluation of the stabilization in the temperature equation as explained in the introduction. The entropy variation is actually only needed if we use \(\alpha=2\) as a power in the residual computation. The infinity norm is computed by the maxima over quadrature points, as usual in discrete computations. In order to compute this quantity, we first have to find the space-average \(\bar{E}(T)\) and then evaluate the maximum. However, that means that we would need to perform two loops. We can avoid the overhead by noting that \(\|E(T)-\bar{E}(T)\|_\infty = \max\big(E_{\textrm{max}}(T)-\bar{E}(T), \bar{E}(T)-E_{\textrm{min}}(T)\big)\) , i.e., the maximum out of the deviation from the average entropy in positive and negative directions. The four quantities we need for the latter formula (maximum entropy, minimum entropy, average entropy, area) can all be evaluated in the same loop over all cells, so we choose this simpler variant.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_entropy_variation(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (parameters.stabilization_alpha != 2)</div><div class="line">    <span class="keywordflow">return</span> 1.;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(parameters.temperature_degree + 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>       fe_values(temperature_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div></div><!-- fragment --><p>In the two functions above we computed the maximum of numbers that were all non-negative, so we knew that zero was certainly a lower bound. On the other hand, here we need to find the maximum deviation from the average value, i.e., we will need to know the maximal and minimal values of the entropy for which we don't a priori know the sign. To compute it, we can therefore start with the largest and smallest possible values we can store in a double precision number: The minimum is initialized with a bigger and the maximum with a smaller number than any one that is going to appear. We are then guaranteed that these numbers will be overwritten in the loop on the first cell or, if this processor does not own any cells, in the communication step at the latest. The following loop then computes the minimum and maximum local entropy as well as keeps track of the area/volume of the part of the domain we locally own and the integral over the entropy on it:</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> min_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">         max_entropy =</div><div class="line"></div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(), area = 0,</div><div class="line">         entropy_integrated = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                      old_temperature_values);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                      old_old_temperature_values);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> T =</div><div class="line">              (old_temperature_values[q] + old_old_temperature_values[q]) / 2;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> entropy =</div><div class="line">              ((T</div><div class="line"></div><div class="line">- average_temperature) (T</div><div class="line"></div><div class="line">- average_temperature));</div><div class="line"></div><div class="line">            min_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_entropy, entropy);</div><div class="line">            max_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_entropy, entropy);</div><div class="line">            area += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            entropy_integrated += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) entropy;</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>Now we only need to exchange data between processors: we need to sum the two integrals ( <code>area</code>, <code>entropy_integrated</code> ), and get the extrema for maximum and minimum. We could do this through four different data exchanges, but we can it with two: <a class="el" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> also exists in a variant that takes an array of values that are all to be summed up. And we can also utilize the <a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> function by realizing that forming the minimum over the minimal entropies equals forming the negative of the maximum over the negative of the minimal entropies; this maximum can then be combined with forming the maximum over the maximal entropies.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> local_sums[2]   = {entropy_integrated, area},</div><div class="line">             local_maxima[2] = {-min_entropy, max_entropy};</div><div class="line"><span class="keywordtype">double</span> global_sums[2], global_maxima[2];</div><div class="line"></div><div class="line"><a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(local_sums, MPI_COMM_WORLD, global_sums);</div><div class="line"><a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(local_maxima, MPI_COMM_WORLD, global_maxima);</div></div><!-- fragment --><p>Having computed everything this way, we can then compute the average entropy and find the \(L^\infty\) norm by taking the larger of the deviation of the maximum or minimum from the average:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_entropy = global_sums[0] / global_sums[1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> entropy_diff    = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(global_maxima[1]</div><div class="line"></div><div class="line">- average_entropy,</div><div class="line">                                       average_entropy</div><div class="line"></div><div class="line">- (-global_maxima[0]));</div><div class="line">  <span class="keywordflow">return</span> entropy_diff;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_extrapolated_temperature_range"></a> </p><h5>BoussinesqFlowProblem::get_extrapolated_temperature_range</h5>
<p>The next function computes the minimal and maximal value of the extrapolated temperature over the entire domain. Again, this is only a slightly modified version of the respective function in <a class="el" href="step_31.html">step-31</a> . As in the function above, we collect local minima and maxima and then compute the global extrema using the same trick as above. As already discussed in <a class="el" href="step_31.html">step-31</a> , the function needs to distinguish between the first and all following time steps because it uses a higher order temperature extrapolation scheme when at least two previous time steps are available.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.temperature_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>       fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> min_local_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">         max_local_temperature =</div><div class="line"></div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                          old_old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                  (1. + time_step / old_time_step)</div><div class="line">                    old_temperature_values[q]</div><div class="line"></div><div class="line">-</div><div class="line">                  time_step / old_time_step old_old_temperature_values[q];</div><div class="line"></div><div class="line">                min_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_local_temperature, temperature);</div><div class="line">                max_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                min_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_local_temperature, temperature);</div><div class="line">                max_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> local_extrema[2] = {-min_local_temperature, max_local_temperature};</div><div class="line">  <span class="keywordtype">double</span> global_extrema[2];</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(local_extrema, MPI_COMM_WORLD, global_extrema);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> std::make_pair(-global_extrema[0], global_extrema[1]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemcompute_viscosity"></a> </p><h5>BoussinesqFlowProblem::compute_viscosity</h5>
<p>The function that calculates the viscosity is purely local and so needs no communication at all. It is mostly the same as in <a class="el" href="step_31.html">step-31</a> but with an updated formulation of the viscosity if \(\alpha=2\) is chosen:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_strain_rates,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_old_strain_rates,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_u_infty,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_T_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                average_temperature,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">    <span class="keywordflow">return</span> 5e-3 cell_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">  <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">        (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_rate =</div><div class="line">        (old_strain_rates[q] + old_old_strain_rates[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> T = (old_temperature[q] + old_old_temperature[q]) / 2;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">        (old_temperature[q]</div><div class="line"></div><div class="line">- old_old_temperature[q]) / old_time_step;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">        u (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">        EquationData::kappa</div><div class="line">        (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">        2;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma =</div><div class="line">        ((EquationData::radiogenic_heating EquationData::density(T) +</div><div class="line">          2 EquationData::eta strain_rate strain_rate) /</div><div class="line">         (EquationData::density(T) EquationData::specific_heat));</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> residual = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(dT_dt + u_grad_T</div><div class="line"></div><div class="line">- kappa_Delta_T</div><div class="line"></div><div class="line">- gamma);</div><div class="line">      <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">        residual= <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(T</div><div class="line"></div><div class="line">- average_temperature);</div><div class="line"></div><div class="line">      max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">      max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u u), max_velocity);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_viscosity =</div><div class="line">    (parameters.stabilization_beta max_velocity cell_diameter);</div><div class="line">  <span class="keywordflow">if</span> (timestep_number == 0)</div><div class="line">    <span class="keywordflow">return</span> max_viscosity;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(old_time_step &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> entropy_viscosity;</div><div class="line">      <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">        entropy_viscosity =</div><div class="line">          (parameters.stabilization_c_R cell_diameter cell_diameter</div><div class="line">           max_residual / global_entropy_variation);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        entropy_viscosity =</div><div class="line">          (parameters.stabilization_c_R cell_diameter</div><div class="line">           global_Omega_diameter max_velocity max_residual /</div><div class="line">           (global_u_infty global_T_variation));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(max_viscosity, entropy_viscosity);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemsetupfunctions"></a> </p><h4>The BoussinesqFlowProblem setup functions</h4>
<p>The following three functions set up the Stokes matrix, the matrix used for the Stokes preconditioner, and the temperature matrix. The code is mostly the same as in <a class="el" href="step_31.html">step-31</a> , but it has been broken out into three functions of their own for simplicity. The main functional difference between the code here and that in <a class="el" href="step_31.html">step-31</a> is that the matrices we want to set up are distributed across multiple processors. Since we still want to build up the sparsity pattern first for efficiency reasons, we could continue to build the <em>entire</em> sparsity pattern as a <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>, as we did in <a class="el" href="step_31.html">step-31</a> . However, that would be inefficient: every processor would build the same sparsity pattern, but only initialize a small part of the matrix using it. It also violates the principle that every processor should only work on those cells it owns (and, if necessary the layer of ghost cells around it). Rather, we use an object of type <a class="el" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a>, which is (obviously) a wrapper around a sparsity pattern object provided by Trilinos. The advantage is that the Trilinos sparsity pattern class can communicate across multiple processors: if this processor fills in all the nonzero entries that result from the cells it owns, and every other processor does so as well, then at the end after some MPI communication initiated by the <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> call, we will have the globally assembled sparsity pattern available with which the global matrix can be initialized. There is one important aspect when initializing Trilinos sparsity patterns in parallel: In addition to specifying the locally owned rows and columns of the matrices via the <code>stokes_partitioning</code> index set, we also supply information about all the rows we are possibly going to write into when assembling on a certain processor. The set of locally relevant rows contains all such rows (possibly also a few unnecessary ones, but it is difficult to find the exact row indices before actually getting indices on all cells and resolving constraints). This additional information allows to exactly determine the structure for the off-processor data found during assembly. While Trilinos matrices are able to collect this information on the fly as well (when initializing them from some other reinit method), it is less efficient and leads to problems when assembling matrices with multiple threads. In this program, we pessimistically assume that only one processor at a time can write into the matrix while assembly (whereas the computation is parallel), which is fine for Trilinos matrices. In practice, one can do better by hinting <a class="el" href="namespaceWorkStream.html">WorkStream</a> at cells that do not share vertices, allowing for parallelism among those cells (see the graph coloring algorithms and <a class="el" href="namespaceWorkStream.html">WorkStream</a> with colored iterators argument). However, that only works when only one MPI processor is present because Trilinos' internal data structures for accumulating off-processor data on the fly are not thread safe. With the initialization presented here, there is no such problem and one could safely introduce graph coloring for this algorithm. The only other change we need to make is to tell the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function that it is only supposed to work on a subset of cells, namely the ones whose <code>subdomain_id</code> equals the number of the current processor, and to ignore all other cells. This strategy is replicated across all three of the following functions. Note that Trilinos matrices store the information contained in the sparsity patterns, so we can safely release the <code>sp</code> variable once the matrix has been given the sparsity structure.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_stokes_matrix(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">{</div><div class="line">  stokes_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning,</div><div class="line">                                            stokes_partitioning,</div><div class="line">                                            stokes_relevant_partitioning,</div><div class="line">                                            MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(stokes_dof_handler,</div><div class="line">                                  coupling,</div><div class="line">                                  sp,</div><div class="line">                                  stokes_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  stokes_matrix.reinit(sp);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">{</div><div class="line">  Amg_preconditioner.reset();</div><div class="line">  Mp_preconditioner.reset();</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning,</div><div class="line">                                            stokes_partitioning,</div><div class="line">                                            stokes_relevant_partitioning,</div><div class="line">                                            MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(stokes_dof_handler,</div><div class="line">                                  coupling,</div><div class="line">                                  sp,</div><div class="line">                                  stokes_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.reinit(sp);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_temperature_matrices(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioner,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioner)</div><div class="line">{</div><div class="line">  T_preconditioner.reset();</div><div class="line">  temperature_mass_matrix.clear();</div><div class="line">  temperature_stiffness_matrix.clear();</div><div class="line">  temperature_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(temperature_partitioner,</div><div class="line">                                       temperature_partitioner,</div><div class="line">                                       temperature_relevant_partitioner,</div><div class="line">                                       MPI_COMM_WORLD);</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                  sp,</div><div class="line">                                  temperature_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  temperature_matrix.reinit(sp);</div><div class="line">  temperature_mass_matrix.reinit(sp);</div><div class="line">  temperature_stiffness_matrix.reinit(sp);</div><div class="line">}</div></div><!-- fragment --><p>The remainder of the setup function (after splitting out the three functions above) mostly has to deal with the things we need to do for parallelization across processors. Because setting all of this up is a significant compute time expense of the program, we put everything we do here into a timer group so that we can get summary information about the fraction of time spent in this part of the program at its end. At the top as usual we enumerate degrees of freedom and sort them by component/block, followed by writing their numbers to the screen from processor zero. The DoFHandler::distributed_dofs() function, when applied to a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, sorts degrees of freedom in such a way that all degrees of freedom associated with subdomain zero come before all those associated with subdomain one, etc. For the Stokes part, this entails, however, that velocities and pressures become intermixed, but this is trivially solved by sorting again by blocks; it is worth noting that this latter operation leaves the relative ordering of all velocities and pressures alone, i.e. within the velocity block we will still have all those associated with subdomain zero before all velocities associated with subdomain one, etc. This is important since we store each of the blocks of this matrix distributed across all processors and want this to be done in such a way that each processor stores that part of the matrix that is roughly equal to the degrees of freedom located on those cells that it will actually work on. When printing the numbers of degrees of freedom, note that these numbers are going to be large if we use many processors. Consequently, we let the stream put a comma separator in between every three digits. The state of the stream, using the locale, is saved from before to after this operation. While slightly opaque, the code works because the default locale (which we get using the constructor call <code>std::locale("")</code> ) implies printing numbers with a comma separator for every third digit (i.e., thousands, millions, billions). In this function as well as many below, we measure how much time we spend here and collect that in a section called "Setup dof systems" across function invocations. This is done using an <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> object that gets a timer going in the section with above name of the <code>computing_timer</code> object upon construction of the local variable; the timer is stopped again when the destructor of the <code>timing_section</code> variable is called. This, of course, happens either at the end of the function, or if we leave the function through a <code>return</code> statement or when an exception is thrown somewhere</p>
<ul>
<li>in other words, whenever we leave this function in any way. The use of such "scope" objects therefore makes sure that we do not have to manually add code that tells the timer to stop at every location where this function may be left.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timing_section(computing_timer, <span class="stringliteral">&quot;Setup dof systems&quot;</span>);</div><div class="line"></div><div class="line">  stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">  stokes_sub_blocks[dim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                     n_p = stokes_dofs_per_block[1],</div><div class="line">                     n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::locale s = pcout.get_stream().getloc();</div><div class="line">  pcout.get_stream().imbue(std::locale(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u</div><div class="line">        &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">  pcout.get_stream().imbue(s);</div></div><!-- fragment --><p>After this, we have to set up the various partitioners (of type <code><a class="el" href="classIndexSet.html">IndexSet</a></code> , see the introduction) that describe which parts of each matrix or vector will be stored where, then call the functions that actually set up the matrices, and at the end also resize the various vectors we keep around in this program.</p>
<div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; stokes_partitioning, stokes_relevant_partitioning;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>              temperature_partitioning(n_T),</div><div class="line">  temperature_relevant_partitioning(n_T);</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> stokes_relevant_set;</div><div class="line">{</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> stokes_index_set = stokes_dof_handler.locally_owned_dofs();</div><div class="line">  stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u));</div><div class="line">  stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(stokes_dof_handler,</div><div class="line">                                          stokes_relevant_set);</div><div class="line">  stokes_relevant_partitioning.push_back(</div><div class="line">    stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u));</div><div class="line">  stokes_relevant_partitioning.push_back(</div><div class="line">    stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p));</div><div class="line"></div><div class="line">  temperature_partitioning = temperature_dof_handler.locally_owned_dofs();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(</div><div class="line">    temperature_dof_handler, temperature_relevant_partitioning);</div><div class="line">}</div></div><!-- fragment --><p>Following this, we can compute constraints for the solution vectors, including hanging node constraints and homogeneous and inhomogeneous boundary values for the Stokes and temperature fields. Note that as for everything else, the constraint objects can not hold <em>all</em> constraints on every processor. Rather, each processor needs to store only those that are actually necessary for correctness given that it only assembles linear systems on cells it owns. As discussed in the <a class="el" href="DEALGlossary.html#distributed_paper">this paper</a>, the set of constraints we need to know about is exactly the set of constraints on all locally relevant degrees of freedom, so this is what we use to initialize the constraint objects.</p>
<div class="fragment"><div class="line">{</div><div class="line">  stokes_constraints.clear();</div><div class="line">  stokes_constraints.reinit(stokes_relevant_set);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                          stokes_constraints);</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity_components(0);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    stokes_dof_handler,</div><div class="line">    0,</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1),</div><div class="line">    stokes_constraints,</div><div class="line">    stokes_fe.component_mask(velocity_components));</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">  no_normal_flux_boundaries.insert(1);</div><div class="line">  <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                  0,</div><div class="line">                                                  no_normal_flux_boundaries,</div><div class="line">                                                  stokes_constraints,</div><div class="line">                                                  mapping);</div><div class="line">  stokes_constraints.close();</div><div class="line">}</div><div class="line">{</div><div class="line">  temperature_constraints.clear();</div><div class="line">  temperature_constraints.reinit(temperature_relevant_partitioning);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                          temperature_constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    temperature_dof_handler,</div><div class="line">    0,</div><div class="line">    EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">    temperature_constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    temperature_dof_handler,</div><div class="line">    1,</div><div class="line">    EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">    temperature_constraints);</div><div class="line">  temperature_constraints.close();</div><div class="line">}</div></div><!-- fragment --><p>All this done, we can then initialize the various matrix and vector objects to their proper sizes. At the end, we also record that all matrices and preconditioners have to be re-computed at the beginning of the next time step. Note how we initialize the vectors for the Stokes and temperature right hand sides: These are writable vectors (last boolean argument set to <code>true</code>) that have the correct one-to-one partitioning of locally owned elements but are still given the relevant partitioning for means of figuring out the vector entries that are going to be set right away. As for matrices, this allows for writing local contributions into the vector with multiple threads (always assuming that the same vector entry is not accessed by multiple threads at the same time). The other vectors only allow for read access of individual elements, including ghosts, but are not suitable for solvers.</p>
<div class="fragment"><div class="line">  setup_stokes_matrix(stokes_partitioning, stokes_relevant_partitioning);</div><div class="line">  setup_stokes_preconditioner(stokes_partitioning,</div><div class="line">                              stokes_relevant_partitioning);</div><div class="line">  setup_temperature_matrices(temperature_partitioning,</div><div class="line">                             temperature_relevant_partitioning);</div><div class="line"></div><div class="line">  stokes_rhs.reinit(stokes_partitioning,</div><div class="line">                    stokes_relevant_partitioning,</div><div class="line">                    MPI_COMM_WORLD,</div><div class="line">                    <span class="keyword">true</span>);</div><div class="line">  stokes_solution.reinit(stokes_relevant_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_stokes_solution.reinit(stokes_solution);</div><div class="line"></div><div class="line">  temperature_rhs.reinit(temperature_partitioning,</div><div class="line">                         temperature_relevant_partitioning,</div><div class="line">                         MPI_COMM_WORLD,</div><div class="line">                         <span class="keyword">true</span>);</div><div class="line">  temperature_solution.reinit(temperature_relevant_partitioning,</div><div class="line">                              MPI_COMM_WORLD);</div><div class="line">  old_temperature_solution.reinit(temperature_solution);</div><div class="line">  old_old_temperature_solution.reinit(temperature_solution);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix              = <span class="keyword">true</span>;</div><div class="line">  rebuild_stokes_preconditioner      = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_matrices       = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheBoussinesqFlowProblemassemblyfunctions"></a> </p><h4>The BoussinesqFlowProblem assembly functions</h4>
<p>Following the discussion in the introduction and in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> module, we split the assembly functions into different parts: </p><ul>
<li>
The local calculations of matrices and right hand sides, given a certain cell as input (these functions are named <code>local_assemble_*</code> below). The resulting function is, in other words, essentially the body of the loop over all cells in <a class="el" href="step_31.html">step-31</a> . Note, however, that these functions store the result from the local calculations in variables of classes from the CopyData namespace. </li>
<li>
These objects are then given to the second step which writes the local data into the global data structures (these functions are named <code>copy_local_to_global_*</code> below). These functions are pretty trivial. </li>
<li>
These two subfunctions are then used in the respective assembly routine (called <code>assemble_*</code> below), where a <a class="el" href="namespaceWorkStream.html">WorkStream</a> object is set up and runs over all the cells that belong to the processor's subdomain. </li>
</ul>
<p><a class="anchor" id="Stokespreconditionerassembly"></a> </p><h5>Stokes preconditioner assembly</h5>
<p>Let us start with the functions that builds the Stokes preconditioner. The first two of these are pretty trivial, given the discussion above. Note in particular that the main point in using the scratch data object is that we want to avoid allocating any objects on the free space each time we visit a new cell. As a consequence, the assembly function below only has automatic local variables, and everything else is accessed through the scratch data object, which is allocated only once before we start the loop over all cells:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">  Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values.reinit(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  data.local_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.grad_phi_u[k] =</div><div class="line">            scratch.stokes_fe_values[velocities].gradient(k, q);</div><div class="line">          scratch.phi_p[k] = scratch.stokes_fe_values[pressure].value(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          data.local_matrix(i, j) +=</div><div class="line">            (EquationData::eta</div><div class="line">               <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(scratch.grad_phi_u[i], scratch.grad_phi_u[j]) +</div><div class="line">             (1. / EquationData::eta) EquationData::pressure_scaling</div><div class="line">               EquationData::pressure_scaling</div><div class="line">               (scratch.phi_p[i] scratch.phi_p[j]))</div><div class="line">            scratch.stokes_fe_values.JxW(q);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  stokes_constraints.distribute_local_to_global(data.local_matrix,</div><div class="line">                                                data.local_dof_indices,</div><div class="line">                                                stokes_preconditioner_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Now for the function that actually puts things together, using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> functions. <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> needs a start and end iterator to enumerate the cells it is supposed to work on. Typically, one would use <a class="el" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">DoFHandler::begin_active()</a> and <a class="el" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">DoFHandler::end()</a> for that but here we actually only want the subset of cells that in fact are owned by the current processor. This is where the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> class comes into play: you give it a range of cells and it provides an iterator that only iterates over that subset of cells that satisfy a certain predicate (a predicate is a function of one argument that either returns true or false). The predicate we use here is <a class="el" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>, i.e., it returns true exactly if the cell is owned by the current processor. The resulting iterator range is then exactly what we need. With this obstacle out of the way, we call the <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> function with this set of cells, scratch and copy objects, and with pointers to two functions: the local assembly and copy-local-to-global function. These functions need to have very specific signatures: three arguments in the first and one argument in the latter case (see the documentation of the <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> function for the meaning of these arguments). Note how we use a lambda functions to create a function object that satisfies this requirement. It uses function arguments for the local assembly function that specify cell, scratch data, and copy data, as well as function argument for the copy function that expects the data to be written into the global matrix (also see the discussion in <a class="el" href="step_13.html">step-13</a> 's <code>assemble_linear_system()</code> function). On the other hand, the implicit zeroth argument of member functions (namely the <code>this</code> pointer of the object on which that member function is to operate on) is <em>bound</em> to the <code>this</code> pointer of the current function and is captured. The <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> function, as a consequence, does not need to know anything about the object these functions work on. When the <a class="el" href="namespaceWorkStream.html">WorkStream</a> is executed, it will create several local assembly routines of the first kind for several cells and let some available processors work on them. The function that needs to be synchronized, i.e., the write operation into the global matrix, however, is executed by only one thread at a time in the prescribed order. Of course, this only holds for the parallelization on a single MPI process. Different MPI processes will have their own <a class="el" href="namespaceWorkStream.html">WorkStream</a> objects and do that work completely independently (and in different memory spaces). In a distributed calculation, some data will accumulate at degrees of freedom that are not owned by the respective processor. It would be inefficient to send data around every time we encounter such a dof. What happens instead is that the Trilinos sparse matrix will keep that data and send it to the owner at the end of assembly, by calling the <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> command.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">{</div><div class="line">  stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">           Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data) {</div><div class="line">      this-&gt;local_assemble_stokes_preconditioner(cell, scratch, data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_stokes_preconditioner(data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             stokes_dof_handler.begin_active()),</div><div class="line">                  CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             stokes_dof_handler.end()),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  Assembly::Scratch::StokesPreconditioner&lt;dim&gt;(</div><div class="line">                    stokes_fe,</div><div class="line">                    quadrature_formula,</div><div class="line">                    mapping,</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>),</div><div class="line">                  Assembly::CopyData::StokesPreconditioner&lt;dim&gt;(stokes_fe));</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p>The final function in this block initiates assembly of the Stokes preconditioner matrix and then in fact builds the Stokes preconditioner. It is mostly the same as in the serial case. The only difference to <a class="el" href="step_31.html">step-31</a> is that we use a Jacobi preconditioner for the pressure mass matrix instead of IC, as discussed in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Build Stokes preconditioner&quot;</span>);</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                   stokes_fe.component_mask(</div><div class="line">                                     velocity_components),</div><div class="line">                                   constant_modes);</div><div class="line"></div><div class="line">  Mp_preconditioner =</div><div class="line">    std::make_shared&lt;TrilinosWrappers::PreconditionJacobi&gt;();</div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> Amg_data;</div><div class="line">  Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">  Amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">  Amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">  Amg_data.smoother_sweeps       = 2;</div><div class="line">  Amg_data.aggregation_threshold = 0.02;</div><div class="line"></div><div class="line">  Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line">  Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                 Amg_data);</div><div class="line"></div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Stokessystemassembly"></a> </p><h5>Stokes system assembly</h5>
<p>The next three functions implement the assembly of the Stokes system, again split up into a part performing local calculations, one for writing the local data into the global matrix and vector, and one for actually running the loop over all cells with the help of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class. Note that the assembly of the Stokes matrix needs only to be done in case we have changed the mesh. Otherwise, just the (temperature-dependent) right hand side needs to be calculated here. Since we are working with distributed matrices and vectors, we have to call the respective <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> functions in the end of the assembly in order to send non-local data to the owner process.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_stokes_system(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">  Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.stokes_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> temperature_cell(</div><div class="line">    &amp;triangulation, cell-&gt;level(), cell-&gt;index(), &amp;temperature_dof_handler);</div><div class="line">  scratch.temperature_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(temperature_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">    data.local_matrix = 0;</div><div class="line">  data.local_rhs = 0;</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_temperature_solution, scratch.old_temperature_values);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = scratch.old_temperature_values[q];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value(k, q);</div><div class="line">          <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">            {</div><div class="line">              scratch.grads_phi_u[k] =</div><div class="line">                scratch.stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">              scratch.div_phi_u[k] =</div><div class="line">                scratch.stokes_fe_values[velocities].divergence(k, q);</div><div class="line">              scratch.phi_p[k] =</div><div class="line">                scratch.stokes_fe_values[pressure].value(k, q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            data.local_matrix(i, j) +=</div><div class="line">              (EquationData::eta 2</div><div class="line">                 (scratch.grads_phi_u[i] scratch.grads_phi_u[j])</div><div class="line"></div><div class="line">-</div><div class="line">               (EquationData::pressure_scaling scratch.div_phi_u[i]</div><div class="line">                scratch.phi_p[j])</div><div class="line"></div><div class="line">-</div><div class="line">               (EquationData::pressure_scaling scratch.phi_p[i]</div><div class="line">                scratch.div_phi_u[j]))</div><div class="line">              scratch.stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> gravity = EquationData::gravity_vector(</div><div class="line">        scratch.stokes_fe_values.quadrature_point(q));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        data.local_rhs(i) += (EquationData::density(old_temperature)</div><div class="line">                              gravity scratch.phi_u[i])</div><div class="line">                             scratch.stokes_fe_values.JxW(q);</div><div class="line">    }</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_stokes_system(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_constraints.distribute_local_to_global(data.local_matrix,</div><div class="line">                                                  data.local_rhs,</div><div class="line">                                                  data.local_dof_indices,</div><div class="line">                                                  stokes_matrix,</div><div class="line">                                                  stokes_rhs);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    stokes_constraints.distribute_local_to_global(data.local_rhs,</div><div class="line">                                                  data.local_dof_indices,</div><div class="line">                                                  stokes_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Assemble Stokes system&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix = 0;</div><div class="line"></div><div class="line">  stokes_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               stokes_dof_handler.begin_active()),</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(), stokes_dof_handler.end()),</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">           Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data) {</div><div class="line">      this-&gt;local_assemble_stokes_system(cell, scratch, data);</div><div class="line">    },</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_stokes_system(data);</div><div class="line">    },</div><div class="line">    Assembly::Scratch::StokesSystem&lt;dim&gt;(</div><div class="line">      stokes_fe,</div><div class="line">      mapping,</div><div class="line">      quadrature_formula,</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">       (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0))),</div><div class="line">      temperature_fe,</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>),</div><div class="line">    Assembly::CopyData::StokesSystem&lt;dim&gt;(stokes_fe));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  stokes_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Temperaturematrixassembly"></a> </p><h5>Temperature matrix assembly</h5>
<p>The task to be performed by the next three functions is to calculate a mass matrix and a Laplace matrix on the temperature system. These will be combined in order to yield the semi-implicit time stepping matrix that consists of the mass matrix plus a time step- dependent weight factor times the Laplace matrix. This function is again essentially the body of the loop over all cells from <a class="el" href="step_31.html">step-31</a> . The two following functions perform similar services as the ones above.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">  Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.temperature_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.reinit(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  data.local_mass_matrix      = 0;</div><div class="line">  data.local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.grad_phi_T[k] =</div><div class="line">            scratch.temperature_fe_values.shape_grad(k, q);</div><div class="line">          scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          {</div><div class="line">            data.local_mass_matrix(i, j) +=</div><div class="line">              (scratch.phi_T[i] scratch.phi_T[j]</div><div class="line">               scratch.temperature_fe_values.JxW(q));</div><div class="line">            data.local_stiffness_matrix(i, j) +=</div><div class="line">              (EquationData::kappa scratch.grad_phi_T[i]</div><div class="line">               scratch.grad_phi_T[j] scratch.temperature_fe_values.JxW(q));</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  temperature_constraints.distribute_local_to_global(data.local_mass_matrix,</div><div class="line">                                                     data.local_dof_indices,</div><div class="line">                                                     temperature_mass_matrix);</div><div class="line">  temperature_constraints.distribute_local_to_global(</div><div class="line">    data.local_stiffness_matrix,</div><div class="line">    data.local_dof_indices,</div><div class="line">    temperature_stiffness_matrix);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Assemble temperature matrices&quot;</span>);</div><div class="line">  temperature_mass_matrix      = 0;</div><div class="line">  temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree + 2);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               temperature_dof_handler.begin_active()),</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               temperature_dof_handler.end()),</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">           Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data) {</div><div class="line">      this-&gt;local_assemble_temperature_matrix(cell, scratch, data);</div><div class="line">    },</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_temperature_matrix(data);</div><div class="line">    },</div><div class="line">    Assembly::Scratch::TemperatureMatrix&lt;dim&gt;(temperature_fe,</div><div class="line">                                              mapping,</div><div class="line">                                              quadrature_formula),</div><div class="line">    Assembly::CopyData::TemperatureMatrix&lt;dim&gt;(temperature_fe));</div><div class="line"></div><div class="line">  temperature_mass_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  temperature_stiffness_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  rebuild_temperature_matrices       = <span class="keyword">false</span>;</div><div class="line">  rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Temperaturerighthandsideassembly"></a> </p><h5>Temperature right hand side assembly</h5>
<p>This is the last assembly function. It calculates the right hand side of the temperature system, which includes the convection and the stabilization terms. It includes a lot of evaluations of old solutions at the quadrature points (which are necessary for calculating the artificial viscosity of stabilization), but is otherwise similar to the other assembly functions. Notice, once again, how we resolve the dilemma of having inhomogeneous boundary conditions, by just making a right hand side at this point (compare the comments for the <code><a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project()</a></code> function above): We create some matrix columns with exactly the values that would be entered for the temperature stiffness matrix, in case we have inhomogeneously constrained dofs. That will account for the correct balance of the right hand side vector with the matrix system of temperature.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_velocity,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">  Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.temperature_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  data.local_rhs     = 0;</div><div class="line">  data.matrix_for_bc = 0;</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> stokes_cell(</div><div class="line">    &amp;triangulation, cell-&gt;level(), cell-&gt;index(), &amp;stokes_dof_handler);</div><div class="line">  scratch.stokes_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(stokes_cell);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_temperature_solution, scratch.old_temperature_values);</div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_values);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_gradients(</div><div class="line">    old_temperature_solution, scratch.old_temperature_grads);</div><div class="line">  scratch.temperature_fe_values.get_function_gradients(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_grads);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_laplacians(</div><div class="line">    old_temperature_solution, scratch.old_temperature_laplacians);</div><div class="line">  scratch.temperature_fe_values.get_function_laplacians(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_laplacians);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values[velocities].get_function_values(</div><div class="line">    stokes_solution, scratch.old_velocity_values);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_values(</div><div class="line">    old_stokes_solution, scratch.old_old_velocity_values);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_symmetric_gradients(</div><div class="line">    stokes_solution, scratch.old_strain_rates);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_symmetric_gradients(</div><div class="line">    old_stokes_solution, scratch.old_old_strain_rates);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">    compute_viscosity(scratch.old_temperature_values,</div><div class="line">                      scratch.old_old_temperature_values,</div><div class="line">                      scratch.old_temperature_grads,</div><div class="line">                      scratch.old_old_temperature_grads,</div><div class="line">                      scratch.old_temperature_laplacians,</div><div class="line">                      scratch.old_old_temperature_laplacians,</div><div class="line">                      scratch.old_velocity_values,</div><div class="line">                      scratch.old_old_velocity_values,</div><div class="line">                      scratch.old_strain_rates,</div><div class="line">                      scratch.old_old_strain_rates,</div><div class="line">                      global_max_velocity,</div><div class="line">                      global_T_range.second</div><div class="line"></div><div class="line">- global_T_range.first,</div><div class="line">                      0.5 (global_T_range.second + global_T_range.first),</div><div class="line">                      global_entropy_variation,</div><div class="line">                      cell-&gt;diameter());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);</div><div class="line">          scratch.grad_phi_T[k] =</div><div class="line">            scratch.temperature_fe_values.shape_grad(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_temperature_values[q]</div><div class="line">              (1 + time_step / old_time_step)</div><div class="line"></div><div class="line">-</div><div class="line">            scratch.old_old_temperature_values[q] (time_step time_step) /</div><div class="line">              (old_time_step (time_step + old_time_step))) :</div><div class="line">           scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> ext_T =</div><div class="line">        (use_bdf2_scheme ? (scratch.old_temperature_values[q]</div><div class="line">                              (1 + time_step / old_time_step)</div><div class="line"></div><div class="line">-</div><div class="line">                            scratch.old_old_temperature_values[q]</div><div class="line">                              time_step / old_time_step) :</div><div class="line">                           scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">        (use_bdf2_scheme ? (scratch.old_temperature_grads[q]</div><div class="line">                              (1 + time_step / old_time_step)</div><div class="line"></div><div class="line">-</div><div class="line">                            scratch.old_old_temperature_grads[q] time_step /</div><div class="line">                              old_time_step) :</div><div class="line">                           scratch.old_temperature_grads[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_velocity_values[q] (1 + time_step / old_time_step)</div><div class="line"></div><div class="line">-</div><div class="line">            scratch.old_old_velocity_values[q] time_step / old_time_step) :</div><div class="line">           scratch.old_velocity_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> extrapolated_strain_rate =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_strain_rates[q] (1 + time_step / old_time_step)</div><div class="line"></div><div class="line">-</div><div class="line">            scratch.old_old_strain_rates[q] time_step / old_time_step) :</div><div class="line">           scratch.old_strain_rates[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma =</div><div class="line">        ((EquationData::radiogenic_heating EquationData::density(ext_T) +</div><div class="line">          2 EquationData::eta extrapolated_strain_rate</div><div class="line">            extrapolated_strain_rate) /</div><div class="line">         (EquationData::density(ext_T) EquationData::specific_heat));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          data.local_rhs(i) +=</div><div class="line">            (T_term_for_rhs scratch.phi_T[i]</div><div class="line"></div><div class="line">-</div><div class="line">             time_step extrapolated_u ext_grad_T scratch.phi_T[i]</div><div class="line"></div><div class="line">-</div><div class="line">             time_step nu ext_grad_T scratch.grad_phi_T[i] +</div><div class="line">             time_step gamma scratch.phi_T[i])</div><div class="line">            scratch.temperature_fe_values.JxW(q);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (temperature_constraints.is_inhomogeneously_constrained(</div><div class="line">                data.local_dof_indices[i]))</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                data.matrix_for_bc(j, i) +=</div><div class="line">                  (scratch.phi_T[i] scratch.phi_T[j]</div><div class="line">                     (use_bdf2_scheme ? ((2 time_step + old_time_step) /</div><div class="line">                                         (time_step + old_time_step)) :</div><div class="line">                                        1.) +</div><div class="line">                   scratch.grad_phi_T[i] scratch.grad_phi_T[j]</div><div class="line">                     EquationData::kappa time_step)</div><div class="line">                  scratch.temperature_fe_values.JxW(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  temperature_constraints.distribute_local_to_global(data.local_rhs,</div><div class="line">                                                     data.local_dof_indices,</div><div class="line">                                                     temperature_rhs,</div><div class="line">                                                     data.matrix_for_bc);</div><div class="line">}</div></div><!-- fragment --><p>In the function that runs the <a class="el" href="namespaceWorkStream.html">WorkStream</a> for actually calculating the right hand side, we also generate the final matrix. As mentioned above, it is a sum of the mass matrix and the Laplace matrix, times some time step- dependent weight. This weight is specified by the BDF-2 time integration scheme, see the introduction in <a class="el" href="step_31.html">step-31</a> . What is new in this tutorial program (in addition to the use of MPI parallelization and the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class), is that we now precompute the temperature preconditioner as well. The reason is that the setup of the Jacobi preconditioner takes a noticeable time compared to the solver because we usually only need between 10 and 20 iterations for solving the temperature system (this might sound strange, as Jacobi really only consists of a diagonal, but in Trilinos it is derived from more general framework for point relaxation preconditioners which is a bit inefficient). Hence, it is more efficient to precompute the preconditioner, even though the matrix entries may slightly change because the time step might change. This is not too big a problem because we remesh every few time steps (and regenerate the preconditioner then).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix=</div><div class="line">        (2 time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_preconditioner == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      T_preconditioner =</div><div class="line">        std::make_shared&lt;TrilinosWrappers::PreconditionJacobi&gt;();</div><div class="line">      T_preconditioner-&gt;initialize(temperature_matrix);</div><div class="line">      rebuild_temperature_preconditioner = <span class="keyword">false</span>;</div><div class="line">    }</div></div><!-- fragment --><p>The next part is computing the right hand side vectors. To do so, we first compute the average temperature \(T_m\) that we use for evaluating the artificial viscosity stabilization through the residual \(E(T) = (T-T_m)^2\) . We do this by defining the midpoint between maximum and minimum temperature as average temperature in the definition of the entropy viscosity. An alternative would be to use the integral average, but the results are not very sensitive to this choice. The rest then only requires calling <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> again, binding the arguments to the <code>local_assemble_temperature_rhs</code> function that are the same in every call to the correct values:</p>
<div class="fragment"><div class="line">  temperature_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree + 2);</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">    get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature =</div><div class="line">    0.5 (global_T_range.first + global_T_range.second);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_entropy_variation =</div><div class="line">    get_entropy_variation(average_temperature);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>, global_T_range, maximal_velocity, global_entropy_variation](</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">      Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data) {</div><div class="line">      this-&gt;local_assemble_temperature_rhs(global_T_range,</div><div class="line">                                           maximal_velocity,</div><div class="line">                                           global_entropy_variation,</div><div class="line">                                           cell,</div><div class="line">                                           scratch,</div><div class="line">                                           data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data) {</div><div class="line">    this-&gt;copy_local_to_global_temperature_rhs(data);</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             temperature_dof_handler.begin_active()),</div><div class="line">                  CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             temperature_dof_handler.end()),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  Assembly::Scratch::TemperatureRHS&lt;dim&gt;(</div><div class="line">                    temperature_fe, stokes_fe, mapping, quadrature_formula),</div><div class="line">                  Assembly::CopyData::TemperatureRHS&lt;dim&gt;(temperature_fe));</div><div class="line"></div><div class="line">  temperature_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsolve"></a> </p><h4>BoussinesqFlowProblem::solve</h4>
<p>This function solves the linear systems in each time step of the Boussinesq problem. First, we work on the Stokes system and then on the temperature system. In essence, it does the same things as the respective function in <a class="el" href="step_31.html">step-31</a> . However, there are a few changes here. The first change is related to the way we store our solution: we keep the vectors with locally owned degrees of freedom plus ghost nodes on each MPI node. When we enter a solver which is supposed to perform matrix-vector products with a distributed matrix, this is not the appropriate form, though. There, we will want to have the solution vector to be distributed in the same way as the matrix, i.e. without any ghosts. So what we do first is to generate a distributed vector called <code>distributed_stokes_solution</code> and put only the locally owned dofs into that, which is neatly done by the <code>operator=</code> of the Trilinos vector. Next, we scale the pressure solution (or rather, the initial guess) for the solver so that it matches with the length scales in the matrices, as discussed in the introduction. We also immediately scale the pressure solution back to the correct units after the solution is completed. We also need to set the pressure values at hanging nodes to zero. This we also did in <a class="el" href="step_31.html">step-31</a> in order not to disturb the Schur complement by some vector entries that actually are irrelevant during the solve stage. As a difference to <a class="el" href="step_31.html">step-31</a> , here we do it only for the locally owned pressure dofs. After solving for the Stokes solution, each processor copies the distributed solution back into the solution vector that also includes ghost elements. The third and most obvious change is that we have two variants for the Stokes solver: A fast solver that sometimes breaks down, and a robust solver that is slower. This is what we already discussed in the introduction. Here is how we realize it: First, we perform 30 iterations with the fast solver based on the simple preconditioner based on the AMG V-cycle instead of an approximate solve (this is indicated by the <code>false</code> argument to the <code>LinearSolvers::BlockSchurPreconditioner</code> object). If we converge, everything is fine. If we do not converge, the solver control object will throw an exception <a class="el" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a>. Usually, this would abort the program because we don't catch them in our usual <code>solve()</code> functions. This is certainly not what we want to happen here. Rather, we want to switch to the strong solver and continue the solution process with whatever vector we got so far. Hence, we catch the exception with the C++ try/catch mechanism. We then simply go through the same solver sequence again in the <code>catch</code> clause, this time passing the <code>true</code> flag to the preconditioner for the strong solver, signaling an approximate CG solve.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Solve Stokes system&quot;</span>);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solving Stokes system... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes_solution(</div><div class="line">      stokes_rhs);</div><div class="line">    distributed_stokes_solution = stokes_solution;</div><div class="line"></div><div class="line">    distributed_stokes_solution.block(1) /= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">      start = (distributed_stokes_solution.block(0).size() +</div><div class="line">               distributed_stokes_solution.block(1).local_range().first),</div><div class="line">      end   = (distributed_stokes_solution.block(0).size() +</div><div class="line">             distributed_stokes_solution.block(1).local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = start; i &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++i)</div><div class="line">      <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">        distributed_stokes_solution(i) = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classPrimitiveVectorMemory.html">PrimitiveVectorMemory&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> mem;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_iterations     = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>  solver_tolerance = 1e-8 stokes_rhs.l2_norm();</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(30, solver_tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">          preconditioner(stokes_matrix,</div><div class="line">                         stokes_preconditioner_matrix,</div><div class="line">                        Mp_preconditioner,</div><div class="line">                        Amg_preconditioner,</div><div class="line">                         <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> solver(</div><div class="line">          solver_control,</div><div class="line">          mem,</div><div class="line">          <a class="code" href="structSolverFGMRES_1_1AdditionalData.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            30));</div><div class="line">        solver.solve(stokes_matrix,</div><div class="line">                     distributed_stokes_solution,</div><div class="line">                     stokes_rhs,</div><div class="line">                     preconditioner);</div><div class="line"></div><div class="line">        n_iterations = solver_control.last_step();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">catch</span> (<a class="code" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a> &amp;)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">          preconditioner(stokes_matrix,</div><div class="line">                         stokes_preconditioner_matrix,</div><div class="line">                        Mp_preconditioner,</div><div class="line">                        Amg_preconditioner,</div><div class="line">                         <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control_refined(stokes_matrix.m(),</div><div class="line">                                             solver_tolerance);</div><div class="line">        <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> solver(</div><div class="line">          solver_control_refined,</div><div class="line">          mem,</div><div class="line">          <a class="code" href="structSolverFGMRES_1_1AdditionalData.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            50));</div><div class="line">        solver.solve(stokes_matrix,</div><div class="line">                     distributed_stokes_solution,</div><div class="line">                     stokes_rhs,</div><div class="line">                     preconditioner);</div><div class="line"></div><div class="line">        n_iterations =</div><div class="line">          (solver_control.last_step() + solver_control_refined.last_step());</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    stokes_constraints.distribute(distributed_stokes_solution);</div><div class="line"></div><div class="line">    distributed_stokes_solution.block(1)= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">    stokes_solution = distributed_stokes_solution;</div><div class="line">    pcout &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>Now let's turn to the temperature part: First, we compute the time step size. We found that we need smaller time steps for 3D than for 2D for the shell geometry. This is because the cells are more distorted in that case (it is the smallest edge length that determines the CFL number). Instead of computing the time step from maximum velocity and minimal mesh size as in <a class="el" href="step_31.html">step-31</a> , we compute local CFL numbers, i.e., on each cell we compute the maximum velocity times the mesh size, and compute the maximum of them. Hence, we need to choose the factor in front of the time step slightly smaller. After temperature right hand side assembly, we solve the linear system for temperature (with fully distributed vectors without any ghosts), apply constraints and copy the vector back to one with ghosts. In the end, we extract the temperature range similarly to <a class="el" href="step_31.html">step-31</a> to produce some output (for example in order to help us choose the stabilization constants, as discussed in the introduction). The only difference is that we need to exchange maxima over all processors.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Assemble temperature rhs&quot;</span>);</div><div class="line"></div><div class="line">    old_time_step = time_step;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> scaling = (dim == 3 ? 0.25 : 1.0);</div><div class="line">    time_step            = (scaling / (2.1 dim <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. dim)) /</div><div class="line">                 (parameters.temperature_degree get_cfl_number()));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Maximal velocity: &quot;</span></div><div class="line">          &lt;&lt; maximal_velocity EquationData::year_in_seconds 100</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; cm/year&quot;</span> &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step / EquationData::year_in_seconds</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; years&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    temperature_solution = old_temperature_solution;</div><div class="line">    assemble_temperature_system(maximal_velocity);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Solve temperature system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                                 1e-12 temperature_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temperature_solution(</div><div class="line">      temperature_rhs);</div><div class="line">    distributed_temperature_solution = temperature_solution;</div><div class="line"></div><div class="line">    cg.solve(temperature_matrix,</div><div class="line">             distributed_temperature_solution,</div><div class="line">             temperature_rhs,</div><div class="line">            T_preconditioner);</div><div class="line"></div><div class="line">    temperature_constraints.distribute(distributed_temperature_solution);</div><div class="line">    temperature_solution = distributed_temperature_solution;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> temperature[2] = {<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>()};</div><div class="line">    <span class="keywordtype">double</span> global_temperature[2];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =</div><div class="line">           distributed_temperature_solution.local_range().first;</div><div class="line">         i &lt; distributed_temperature_solution.local_range().second;</div><div class="line">         ++i)</div><div class="line">      {</div><div class="line">        temperature[0] =</div><div class="line">          std::min&lt;double&gt;(temperature[0],</div><div class="line">                           distributed_temperature_solution(i));</div><div class="line">        temperature[1] =</div><div class="line">          std::max&lt;double&gt;(temperature[1],</div><div class="line">                           distributed_temperature_solution(i));</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature[0]=</div><div class="line"></div><div class="line">-1.0;</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(temperature, MPI_COMM_WORLD, global_temperature);</div><div class="line">    global_temperature[0]=</div><div class="line"></div><div class="line">-1.0;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; global_temperature[0] &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">          &lt;&lt; global_temperature[1] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemoutput_results"></a> </p><h4>BoussinesqFlowProblem::output_results</h4>
<p>Next comes the function that generates the output. The quantities to output could be introduced manually like we did in <a class="el" href="step_31.html">step-31</a> . An alternative is to hand this task over to a class PostProcessor that inherits from the class <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>, which can be attached to <a class="el" href="classDataOut.html">DataOut</a>. This allows us to output derived quantities from the solution, like the friction heating included in this example. It overloads the virtual function <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a>, which is then internally called from <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. We have to give it values of the numerical solution, its derivatives, normals to the cell, the actual evaluation points and any additional quantities. This follows the same procedure as discussed in <a class="el" href="step_29.html">step-29</a> and other programs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem&lt;dim&gt;::Postprocessor</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="classDataPostprocessor.html">DataPostprocessor</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Postprocessor(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> minimal_pressure);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::vector&lt;std::string&gt; <a class="code" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::vector&lt;</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">  <a class="code" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">get_data_component_interpretation</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="code" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::Postprocessor(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure)</div><div class="line">  : partition(partition)</div><div class="line">  , minimal_pressure(minimal_pressure)</div><div class="line">{}</div></div><!-- fragment --><p>Here we define the names for the variables we want to output. These are the actual solution values for velocity, pressure, and temperature, as well as the friction heating and to each cell the number of the processor that owns it. This allows us to visualize the partitioning of the domain among the processors. Except for the velocity, which is vector-valued, all other quantities are scalar.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;std::string&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_names()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;friction_heating&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;partition&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> solution_names;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_data_component_interpretation()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    interpretation(dim,</div><div class="line">                   <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> interpretation;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_needed_update_flags()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>;</div><div class="line">}</div></div><!-- fragment --><p>Now we implement the function that computes the derived quantities. As we also did for the output, we rescale the velocity from its SI units to something more readable, namely cm/year. Next, the pressure is scaled to be between 0 and the maximum pressure. This makes it more easily comparable</p>
<ul>
<li>in essence making all pressure variables positive or zero. Temperature is taken as is, and the friction heating is computed as \(2 \eta \varepsilon(\mathbf{u}) \cdot \varepsilon(\mathbf{u})\) . The quantities we output here are more for illustration, rather than for actual scientific value. We come back to this briefly in the results section of this program and explain what one may in fact be interested in.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::evaluate_vector_field(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_quadrature_points = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size();</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>.size() == n_quadrature_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == n_quadrature_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[0].size() == dim + 2, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        computed_quantities[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) = (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                                     EquationData::year_in_seconds 100);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> pressure =</div><div class="line">        (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim)</div><div class="line"></div><div class="line">- minimal_pressure);</div><div class="line">      computed_quantities[q](dim) = pressure;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> temperature        = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim + 1);</div><div class="line">      computed_quantities[q](dim + 1) = temperature;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> grad_u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        grad_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>[q][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_rate = <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(grad_u);</div><div class="line">      computed_quantities[q](dim + 2) =</div><div class="line">        2 EquationData::eta strain_rate strain_rate;</div><div class="line"></div><div class="line">      computed_quantities[q](dim + 3) = <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The <code>output_results()</code> function has a similar task to the one in <a class="el" href="step_31.html">step-31</a> . However, here we are going to demonstrate a different technique on how to merge output from different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The way we're going to achieve this recombination is to create a joint <a class="el" href="classDoFHandler.html">DoFHandler</a> that collects both components, the Stokes solution and the temperature solution. This can be nicely done by combining the finite elements from the two systems to form one <a class="el" href="classFESystem.html">FESystem</a>, and let this collective system define a new <a class="el" href="classDoFHandler.html">DoFHandler</a> object. To be sure that everything was done correctly, we perform a sanity check that ensures that we got all the dofs from both Stokes and temperature even in the combined system. We then combine the data vectors. Unfortunately, there is no straight-forward relation that tells us how to sort Stokes and temperature vector into the joint vector. The way we can get around this trouble is to rely on the information collected in the <a class="el" href="classFESystem.html">FESystem</a>. For each dof on a cell, the joint finite element knows to which equation component (velocity component, pressure, or temperature) it belongs – that's the information we need! So we step through all cells (with iterators into all three DoFHandlers moving in sync), and for each joint cell dof, we read out that component using the <a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">FiniteElement::system_to_base_index</a> function (see there for a description of what the various parts of its return value contain). We also need to keep track whether we're on a Stokes dof or a temperature dof, which is contained in joint_fe.system_to_base_index(i).first.first. Eventually, the dof_indices data structures on either of the three systems tell us how the relation between global vector and local dofs looks like on the present cell, which concludes this tedious work. We make sure that each processor only works on the subdomain it owns locally (and not on ghost or artificial cells) when building the joint solution vector. The same will then have to be done in <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>, but that function does so automatically. What we end up with is a set of patches that we can write using the functions in <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> in a variety of output formats. Here, we then have to pay attention that what each processor writes is really only its own part of the domain, i.e. we will want to write each processor's contribution into a separate file. This we do by adding an additional number to the filename when we write the solution. This is not really new, we did it similarly in <a class="el" href="step_40.html">step-40</a> . Note that we write in the compressed format <code></code>.vtu instead of plain vtk files, which saves quite some storage. All the rest of the work is done in the PostProcessor class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer, <span class="stringliteral">&quot;Postprocessing&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(stokes_fe, 1, temperature_fe, 1);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> joint_dof_handler(triangulation);</div><div class="line">  joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">           stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> joint_solution;</div><div class="line">  joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(joint_dof_handler.locally_owned_dofs(),</div><div class="line">                        MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">      joint_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_stokes_dof_indices(</div><div class="line">      stokes_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_temperature_dof_indices(</div><div class="line">      temperature_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      joint_cell       = joint_dof_handler.begin_active(),</div><div class="line">      joint_endc       = joint_dof_handler.end(),</div><div class="line">      stokes_cell      = stokes_dof_handler.begin_active(),</div><div class="line">      temperature_cell = temperature_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">         ++joint_cell, ++stokes_cell, ++temperature_cell)</div><div class="line">      <span class="keywordflow">if</span> (joint_cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">          stokes_cell-&gt;get_dof_indices(local_stokes_dof_indices);</div><div class="line">          temperature_cell-&gt;get_dof_indices(local_temperature_dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_stokes_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                joint_solution(local_joint_dof_indices[i]) = stokes_solution(</div><div class="line">                  local_stokes_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                             .second]);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_temperature_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                  temperature_solution(</div><div class="line">                    local_temperature_dof_indices</div><div class="line">                      [joint_fe.system_to_base_index(i).second]);</div><div class="line">              }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  joint_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_joint_dofs(joint_dof_handler.n_dofs());</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(joint_dof_handler,</div><div class="line">                                          locally_relevant_joint_dofs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_joint_solution;</div><div class="line">  locally_relevant_joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(locally_relevant_joint_dofs,</div><div class="line">                                         MPI_COMM_WORLD);</div><div class="line">  locally_relevant_joint_solution = joint_solution;</div><div class="line"></div><div class="line">  Postprocessor postprocessor(<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                MPI_COMM_WORLD),</div><div class="line">                              stokes_solution.block(1).min());</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">  data_out.add_data_vector(locally_relevant_joint_solution, postprocessor);</div><div class="line">  data_out.build_patches();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> out_index = 0;</div><div class="line">  data_out.write_vtu_with_pvtu_record(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, out_index, MPI_COMM_WORLD, 5);</div><div class="line"></div><div class="line">  out_index++;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrefine_mesh"></a> </p><h4>BoussinesqFlowProblem::refine_mesh</h4>
<p>This function isn't really new either. Since the <code>setup_dofs</code> function that we call in the middle has its own timer section, we split timing this function into two sections. It will also allow us to easily identify which of the two is more expensive. One thing of note, however, is that we only want to compute error indicators on the locally owned subdomain. In order to achieve this, we pass one additional argument to the <a class="el" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator::estimate</a> function. Note that the vector for error estimates is resized to the number of active cells present on the current process, which is less than the total number of active cells on all processors (but more than the number of locally owned active cells); each processor only has a few coarse cells around the locally owned ones, as also explained in <a class="el" href="step_40.html">step-40</a> . The local error estimates are then handed to a parallel version of <a class="el" href="namespaceGridRefinement.html">GridRefinement</a> (in namespace <a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html">parallel::distributed::GridRefinement</a>, see also <a class="el" href="step_40.html">step-40</a> ) which looks at the errors and finds the cells that need refinement by comparing the error values across processors. As in <a class="el" href="step_31.html">step-31</a> , we want to limit the maximum grid level. So in case some cells have been marked that are already at the finest level, we simply clear the refine flags.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">    temperature_trans(temperature_dof_handler);</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt;dim,</div><div class="line">                                          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>&gt;</div><div class="line">    stokes_trans(stokes_dof_handler);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;Refine mesh structure, part 1&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      temperature_dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt;(parameters.temperature_degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">      temperature_solution,</div><div class="line">      estimated_error_per_cell,</div><div class="line">      <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">      <span class="keyword">nullptr</span>,</div><div class="line">      0,</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction</a>(</div><div class="line">      triangulation, estimated_error_per_cell, 0.3, 0.1);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">             triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(max_grid_level);</div><div class="line">           cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">           ++cell)</div><div class="line">        cell-&gt;clear_refine_flag();</div></div><!-- fragment --><p>With all flags marked as necessary, we can then tell the <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> objects to get ready to transfer data from one mesh to the next, which they will do when notified by <a class="el" href="classTriangulation.html">Triangulation</a> as part of the <code>execute_coarsening_and_refinement()</code> call. The syntax is similar to the non-parallel solution transfer (with the exception that here a pointer to the vector entries is enough). The remainder of the function further down below is then concerned with setting up the data structures again after mesh refinement and restoring the solution vectors on the new mesh.</p>
<div class="fragment"><div class="line">  std::vector&lt;const TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div><div class="line">  x_temperature[0] = &amp;temperature_solution;</div><div class="line">  x_temperature[1] = &amp;old_temperature_solution;</div><div class="line">  std::vector&lt;const TrilinosWrappers::MPI::BlockVector&gt; x_stokes(2);</div><div class="line">  x_stokes[0] = &amp;stokes_solution;</div><div class="line">  x_stokes[1] = &amp;old_stokes_solution;</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">  stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div><div class="line"></div><div class="line">setup_dofs();</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;Refine mesh structure, part 2&quot;</span>);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp1(temperature_rhs);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp2(temperature_rhs);</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div><div class="line">    tmp[0] = &amp;(distributed_temp1);</div><div class="line">    tmp[1] = &amp;(distributed_temp2);</div><div class="line">    temperature_trans.interpolate(tmp);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">  temperature_constraints.distribute(distributed_temp1);</div><div class="line">  temperature_constraints.distribute(distributed_temp2);</div><div class="line"></div><div class="line">  temperature_solution     = distributed_temp1;</div><div class="line">  old_temperature_solution = distributed_temp2;</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes(stokes_rhs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_distributed_stokes(stokes_rhs);</div><div class="line"></div><div class="line">  std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; stokes_tmp(2);</div><div class="line">  stokes_tmp[0] = &amp;(distributed_stokes);</div><div class="line">  stokes_tmp[1] = &amp;(old_distributed_stokes);</div><div class="line"></div><div class="line">  stokes_trans.interpolate(stokes_tmp);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">      stokes_constraints.distribute(distributed_stokes);</div><div class="line">      stokes_constraints.distribute(old_distributed_stokes);</div><div class="line"></div><div class="line">      stokes_solution     = distributed_stokes;</div><div class="line">      old_stokes_solution = old_distributed_stokes;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrun"></a> </p><h4>BoussinesqFlowProblem::run</h4>
<p>This is the final and controlling function in this class. It, in fact, runs the entire rest of the program and is, once more, very similar to <a class="el" href="step_31.html">step-31</a> . The only substantial difference is that we use a different mesh now (a <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> instead of a simple cube geometry).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(triangulation,</div><div class="line">                             <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(),</div><div class="line">                             EquationData::R0,</div><div class="line">                             EquationData::R1,</div><div class="line">                             (dim == 3) ? 96 : 12,</div><div class="line">                             <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(parameters.initial_global_refinement);</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">start_time_iteration:</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution(</div><div class="line">      temperature_dof_handler.locally_owned_dofs());</div></div><!-- fragment --><p><a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> supports parallel vector classes with most standard finite elements via deal.II's own native <a class="el" href="classMatrixFree.html">MatrixFree</a> framework: since we use standard Lagrange elements of moderate order this function works well here.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                     temperature_constraints,</div><div class="line">                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(parameters.temperature_degree + 2),</div><div class="line">                     EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                     solution);</div></div><!-- fragment --><p>Having so computed the current temperature field, let us set the member variable that holds the temperature nodes. Strictly speaking, we really only need to set <code>old_temperature_solution</code> since the first thing we will do is to compute the Stokes solution that only requires the previous time step's temperature field. That said, nothing good can come from not initializing the other vectors as well (especially since it's a relatively cheap operation and we only have to do it once at the beginning of the program) if we ever want to extend our numerical method or physical model, and so we initialize <code>old_temperature_solution</code> and <code>old_old_temperature_solution</code> as well. The assignment makes sure that the vectors on the left hand side (which where initialized to contain ghost elements as well) also get the correct ghost elements. In other words, the assignment here requires communication between processors:</p>
<div class="fragment"><div class="line">  temperature_solution         = solution;</div><div class="line">  old_temperature_solution     = solution;</div><div class="line">  old_old_temperature_solution = solution;</div><div class="line">}</div><div class="line"></div><div class="line">timestep_number = 0;</div><div class="line">time_step = old_time_step = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time / EquationData::year_in_seconds &lt;&lt; <span class="stringliteral">&quot; years&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_stokes_system();</div><div class="line">    build_stokes_preconditioner();</div><div class="line">    assemble_temperature_matrix();</div><div class="line"></div><div class="line">    solve();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">        (pre_refinement_step &lt; parameters.initial_adaptive_refinement))</div><div class="line">      {</div><div class="line">        refine_mesh(parameters.initial_global_refinement +</div><div class="line">                    parameters.initial_adaptive_refinement);</div><div class="line">        ++pre_refinement_step;</div><div class="line">        <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp;</div><div class="line">             (timestep_number % parameters.adaptive_refinement_interval ==</div><div class="line">              0))</div><div class="line">      refine_mesh(parameters.initial_global_refinement +</div><div class="line">                  parameters.initial_adaptive_refinement);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">        (timestep_number % parameters.graphical_output_interval == 0))</div><div class="line">      output_results();</div></div><!-- fragment --><p>In order to speed up linear solvers, we extrapolate the solutions from the old time levels to the new one. This gives a very good initial guess, cutting the number of iterations needed in solvers by more than one half. We do not need to extrapolate in the last iteration, so if we reached the final time, we stop here. As the last thing during a time step (before actually bumping up the number of the time step), we check whether the current time step number is divisible by 100, and if so we let the computing timer print a summary of CPU times spent so far.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (time &gt; parameters.end_time EquationData::year_in_seconds)</div><div class="line">  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_old_stokes_solution;</div><div class="line">old_old_stokes_solution      = old_stokes_solution;</div><div class="line">old_stokes_solution          = stokes_solution;</div><div class="line">old_old_temperature_solution = old_temperature_solution;</div><div class="line">old_temperature_solution     = temperature_solution;</div><div class="line"><span class="keywordflow">if</span> (old_time_step &gt; 0)</div><div class="line">  {</div></div><!-- fragment --><p>Trilinos sadd does not like ghost vectors even as input. Copy into distributed vectors for now:</p>
<div class="fragment"><div class="line">          {</div><div class="line">            <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_solution(stokes_rhs);</div><div class="line">            distr_solution = stokes_solution;</div><div class="line">            <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_old_solution(stokes_rhs);</div><div class="line">            distr_old_solution = old_old_stokes_solution;</div><div class="line">            distr_solution.<a class="code" href="classBlockVectorBase.html#a71b0ab8295e98caf3dfe1ef14ae6b6c1">sadd</a>(1. + time_step / old_time_step,</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-time_step / old_time_step,</div><div class="line">                                distr_old_solution);</div><div class="line">            stokes_solution = distr_solution;</div><div class="line">          }</div><div class="line">          {</div><div class="line">            <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_solution(temperature_rhs);</div><div class="line">            distr_solution = temperature_solution;</div><div class="line">            <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_old_solution(temperature_rhs);</div><div class="line">            distr_old_solution = old_old_temperature_solution;</div><div class="line">            distr_solution.sadd(1. + time_step / old_time_step,</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-time_step / old_time_step,</div><div class="line">                                distr_old_solution);</div><div class="line">            temperature_solution = distr_solution;</div><div class="line">          }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 100 == 0))</div><div class="line">        computing_timer.print_summary();</div><div class="line"></div><div class="line">      time += time_step;</div><div class="line">      ++timestep_number;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">while</span> (<span class="keyword">true</span>);</div></div><!-- fragment --><p>If we are generating graphical output, do so also for the last time step unless we had just done so before we left the do-while loop</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">      !((timestep_number</div><div class="line"></div><div class="line">- 1) % parameters.graphical_output_interval == 0))</div><div class="line">    output_results();</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step32</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function is short as usual and very similar to the one in <a class="el" href="step_31.html">step-31</a> . Since we use a parameter file which is specified as an argument in the command line, we have to read it in here and pass it on to the Parameters class for parsing. If no filename is given in the command line, we simply use the <code>step-32.prm</code> file which is distributed together with the program.</p>
<p>Because 3d computations are simply very slow unless you throw a lot of processors at them, the program defaults to 2d. You can get the 3d version by changing the constant dimension below to 3.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>Step32;</div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">      argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">    std::string parameter_filename;</div><div class="line">    <span class="keywordflow">if</span> (argc &gt;= 2)</div><div class="line">      parameter_filename = argv[1];</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      parameter_filename = <span class="stringliteral">&quot;step-32.prm&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>                              dim = 2;</div><div class="line">    BoussinesqFlowProblem&lt;dim&gt;::Parameters parameters(parameter_filename);</div><div class="line">    BoussinesqFlowProblem&lt;dim&gt;             flow_problem(parameters);</div><div class="line">    flow_problem.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When run, the program simulates convection in 3d in much the same wayas <a class="el" href="step_31.html">step-31</a> did, though with an entirely different testcase.</p>
<p><a class="anchor" id="Comparisonofresultswithstep31"></a></p><h3>Comparison of results with step-31</h3>
<p>Before we go to this testcase, however, let us show a few results from aslightly earlier version of this program that was solving exactly thetestcase we used in <a class="el" href="step_31.html">step-31</a> , just that we now solve it in parallel and withmuch higher resolution. We show these results mainly for comparison. Here are two images that show this higher resolution if we choose a 3dcomputation in <code>main()</code> and if we set <code>initial_refinement=3</code> and <code>n_pre_refinement_steps=4</code> . At the time steps shown, themeshes had around 72,000 and 236,000 cells, for a total of 2,680,000and 8,250,000 degrees of freedom, respectively, more than an order ofmagnitude more than we had available in <a class="el" href="step_31.html">step-31</a> : </p><table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d.cube.0.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d.cube.1.png"/>
</div>
   </td></tr>
</table>
<p>The computation was done on a subset of 50 processors of the Brazoscluster at Texas A&amp;M University.</p>
<p><a class="anchor" id="Resultsfora2dcircularshelltestcase"></a></p><h3>Results for a 2d circular shell testcase</h3>
<p>Next, we will run <a class="el" href="step_32.html">step-32</a> with the parameter file in the directory with onechange: we increase the final time to 1e9. Here we are using 16 processors. Thecommand to launch is (note that <a class="el" href="step_32.html">step-32</a> .prm is the default): <code></p><pre>\ \( mpirun -np 16 ./step-32 &lt;/pre&gt; &lt;/code&gt; Note that running a job on a cluster typically requires going through a job scheduler, which we won&#39;t discuss here. The output will look roughly like this: &lt;code&gt; &lt;pre&gt; $ mpirun - p 16 ./ @ref step_32 &quot;step-32&quot; Number of active cells: 12,288 (on 6 levels)Number of degrees of freedom: 186,624 (99,840+36,864+49,920) Timestep 0: t=0 years Rebuilding Stokes preconditioner... Solving Stokes system... 41 iterations. Maximal velocity: 60.4935 cm/year Time step: 18166.9 years 17 CG iterations for temperature Temperature range: 973 4273.16 Number of active cells: 15,921 (on 7 levels)Number of degrees of freedom: 252,723 (136,640+47,763+68,320) Timestep 0: t=0 years Rebuilding Stokes preconditioner... Solving Stokes system... 50 iterations. Maximal velocity: 60.3223 cm/year Time step: 10557.6 years 19 CG iterations for temperature Temperature range: 973 4273.16 Number of active cells: 19,926 (on 8 levels)Number of degrees of freedom: 321,246 (174,312+59,778+87,156) Timestep 0: t=0 years Rebuilding Stokes preconditioner... Solving Stokes system... 50 iterations. Maximal velocity: 57.8396 cm/year Time step: 5453.78 years 18 CG iterations for temperature Temperature range: 973 4273.16 Timestep 1: t=5453.78 years Solving Stokes system... 49 iterations. Maximal velocity: 59.0231 cm/year Time step: 5345.86 years 18 CG iterations for temperature Temperature range: 973 4273.16 Timestep 2: t=10799.6 years Solving Stokes system... 24 iterations. Maximal velocity: 60.2139 cm/year Time step: 5241.51 years 17 CG iterations for temperature Temperature range: 973 4273.16 [...] Timestep 100: t=272151 years Solving Stokes system... 21 iterations. Maximal velocity: 161.546 cm/year Time step: 1672.96 years 17 CG iterations for temperature Temperature range: 973 4282.57 Number of active cells: 56,085 (on 8 levels)Number of degrees of freedom: 903,408 (490,102+168,255+245,051) +---------------------------------------------+------------+------------+| Total wallclock time elapsed since start | 115s | || | | || Section | no. calls | wall time | % of total |+---------------------------------+-----------+------------+------------+| Assemble Stokes system | 103 | 2.82s | 2.5% || Assemble temperature matrices | 12 | 0.452s | 0.39% || Assemble temperature rhs | 103 | 11.5s | 10% || Build Stokes preconditioner | 12 | 2.09s | 1.8% || Solve Stokes system | 103 | 90.4s | 79% || Solve temperature system | 103 | 1.53s | 1.3% || Postprocessing | 3 | 0.532s | 0.46% || Refine mesh structure, part 1 | 12 | 0.93s | 0.81% || Refine mesh structure, part 2 | 12 | 0.384s | 0.33% || Setup dof systems | 13 | 2.96s | 2.6% |+---------------------------------+-----------+------------+------------+ [...] +---------------------------------------------+------------+------------+| Total wallclock time elapsed since start | 9.14e+04s | || | | || Section | no. calls | wall time | % of total |+---------------------------------+-----------+------------+------------+| Assemble Stokes system | 47045 | 2.05e+03s | 2.2% || Assemble temperature matrices | 4707 | 310s | 0.34% || Assemble temperature rhs | 47045 | 8.7e+03s | 9.5% || Build Stokes preconditioner | 4707 | 1.48e+03s | 1.6% || Solve Stokes system | 47045 | 7.34e+04s | 80% || Solve temperature system | 47045 | 1.46e+03s | 1.6% || Postprocessing | 1883 | 222s | 0.24% || Refine mesh structure, part 1 | 4706 | 641s | 0.7% || Refine mesh structure, part 2 | 4706 | 259s | 0.28% || Setup dof systems | 4707 | 1.86e+03s | 2% |+---------------------------------+-----------+------------+------------+&lt;/pre&gt;&lt;/code&gt; The simulation terminates when the time reaches the 1 billion yearsselected in the input file. You can extrapolate from this how long asimulation would take for a different final time (the time step sizeultimately settles on somewhere around 20,000 years, so computing fortwo billion years will take 100,000 time steps, give or take 20%). Ascan be seen here, we spend most of the compute time in assemblinglinear systems and &mdash; above all &mdash; in solving Stokessystems. To demonstrate the output we show the output from every 1250th time step here: &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-000.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-050.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-100.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-150.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-200.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-250.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-300.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-350.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-400.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-450.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-500.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-550.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-600.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-cells.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-partition.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; The last two images show the grid as well as the partitioning of the mesh forthe same computation with 16 subdomains and 16 processors. The full dynamics ofthis simulation are really only visible by looking at an animation, for examplethe one &lt;a href=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-temperature.webm&quot;&gt;shown on this site&lt;/a&gt;. This image is well worth watching due to its artistic qualityand entrancing depiction of the evolution of the magma plumes. If you watch the movie, you&#39;ll see that the convection pattern goesthrough several stages: First, it gets rid of the instable temperaturelayering with the hot material overlain by the dense coldmaterial. After this great driver is removed and we have a sort ofstable situation, a few blobs start to separate from the hot boundarylayer at the inner ring and rise up, with a few cold fingers alsodropping down from the outer boundary layer. During this phase, the solutionremains mostly symmetric, reflecting the 12-fold symmetry of theoriginal mesh. In a final phase, the fluid enters vigorous chaoticstirring in which all symmetries are lost. This is a pattern that thencontinues to dominate flow. These different phases can also be identified if we look at themaximal velocity as a function of time in the simulation: &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32.2d.t_vs_vmax.png&quot; alt=&quot;&quot;&gt; Here, the velocity (shown in centimeters per year) becomes very large,to the order of several meters per year) at the beginning when thetemperature layering is instable. It then calms down to relativelysmall values before picking up again in the chaotic stirringregime. There, it remains in the range of 10-40 centimeters per year,quite within the physically expected region. &lt;a name=&quot;Resultsfora3dsphericalshelltestcase&quot;&gt;&lt;/a&gt;&lt;h3&gt;Results for a 3d spherical shell testcase&lt;/h3&gt; 3d computations are very expensive computationally. Furthermore, asseen above, interesting behavior only starts after quite a long timerequiring more CPU hours than is available on a typicalcluster. Consequently, rather than showing a complete simulation here,let us simply show a couple of pictures we have obtained using thesuccessor to this program, called &lt;i&gt;ASPECT&lt;/i&gt; (short for &lt;i&gt;Advanced %Solver for Problems in Earth&#39;s ConvecTion&lt;/i&gt;), that is beingdeveloped independently of deal.II and that already incorporates someof the extensions discussed below. The following two pictures showisocontours of the temperature and the partition of the domain (alongwith the mesh) onto 512 processors: &lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32.3d-sphere.solution.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32.3d-sphere.partition.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt; &lt;a name=&quot;extensions&quot;&gt;&lt;/a&gt;&lt;a name=&quot;Possibilitiesforextensions&quot;&gt;&lt;/a&gt;&lt;h3&gt;Possibilities for extensions&lt;/h3&gt; There are many directions in which this program could be extended. Asmentioned at the end of the introduction, most of these are under activedevelopment in the &lt;i&gt;ASPECT&lt;/i&gt; (short for &lt;i&gt;Advanced %Solver for Problems in Earth&#39;s ConvecTion&lt;/i&gt;) code at the time this tutorial program is beingfinished. Specifically, the following are certainly topics that one shouldaddress to make the program more useful: &lt;ul&gt; &lt;li&gt; &lt;b&gt;Adiabatic heating/cooling:&lt;/b&gt; The temperature field we get in our simulations after a while is mostly constant with boundary layers at the inner and outer boundary, and streamers of cold and hot material mixing everything. Yet, this doesn&#39;t match our expectation that things closer to the earth core should be hotter than closer to the surface. The reason is that the energy equation we have used does not include a term that describes adiabatic cooling and heating: rock, like gas, heats up as you compress it. Consequently, material that rises up cools adiabatically, and cold material that sinks down heats adiabatically. The correct temperature equation would therefore look somewhat like this: @f{eqnarray*} \frac{D T}{Dt} - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma + \tau\frac{Dp}{Dt}, @f} or, expanding the advected derivative \){D}{Dt} =
 {}{ t} +  u   \( : @f{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma + \tau\left\{\frac{\partial p}{\partial t} + \mathbf u \cdot \nabla p \right\}. @f} In other words, as pressure increases in a rock volume ( \){Dp}{Dt}&gt;0 \( ) we get an additional heat source, and vice versa. The time derivative of the pressure is a bit awkward to implement. If necessary, one could approximate using the fact outlined in the introduction that the pressure can be decomposed into a dynamic component due to temperature differences and the resulting flow, and a static component that results solely from the static pressure of the overlying rock. Since the latter is much bigger, one may approximate \)
 p_{{static}}=-{{ref}} [1+ T_{{ref}}]  \( , and consequently \){Dp}{Dt}  \{-  u  
 {{ref}} [1+ T_{{ref}}]\} =
 {{ref}} [1+ T_{{ref}}]  u   g \( . In other words, if the fluid is moving in the direction of gravity (downward) it will be compressed and because in that case \) u
   g &gt; 0 \( we get a positive heat source. Conversely, the fluid will cool down if it moves against the direction of gravity. &lt;li&gt; &lt;b&gt;Compressibility:&lt;/b&gt; As already hinted at in the temperature model above, mantle rocks are not incompressible. Rather, given the enormous pressures in the earth mantle (at the core-mantle boundary, the pressure is approximately 140 GPa, equivalent to 1,400,000 times atmospheric pressure), rock actually does compress to something around 1.5 times the density it would have at surface pressure. Modeling this presents any number of difficulties. Primarily, the mass conservation equation is no longer \){div}\; u=0 \( but should read \){div}( u)=0 \( where the density \) \( is now no longer spatially constant but depends on temperature and pressure. A consequence is that the model is now no longer linear; a linearized version of the Stokes equation is also no longer symmetric requiring us to rethink preconditioners and, possibly, even the discretization. We won&#39;t go into detail here as to how this can be resolved. &lt;li&gt; &lt;b&gt;Nonlinear material models:&lt;/b&gt; As already hinted at in various places, material parameters such as the density, the viscosity, and the various thermal parameters are not constant throughout the earth mantle. Rather, they nonlinearly depend on the pressure and temperature, and in the case of the viscosity on the strain rate \)( u)</pre><p></code></p>
<p><code></p><pre>This tutorial depends on <a class="el" href="step_31.html">step-31</a>, <a class="el" href="step_55.html">step-55</a>.</pre><p></code></p>
<p><code></p><pre> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Usingtherightpressure"> Using the "right" pressure </a>
        <li><a href="#Thescalingofdiscretizedequations"> The scaling of discretized equations </a>
        <li><a href="#ChangestotheStokespreconditionerandsolver"> Changes to the Stokes preconditioner and solver </a>
        <li><a href="#Changestotheartificialviscositystabilization"> Changes to the artificial viscosity stabilization </a>
        <li><a href="#LocallyconservativeStokesdiscretization"> Locally conservative Stokes discretization </a>
        <li><a href="#Higherordermappingsforcurvedboundaries"> Higher order mappings for curved boundaries </a>
        <li><a href="#Parallelizationonclusters"> Parallelization on clusters </a>
        <li><a href="#Parallelizationwithinindividualnodesofacluster"> Parallelization within individual nodes of a cluster </a>
        <li><a href="#Thetestcase"> The testcase </a>
        <li><a href="#Implementationdetails"> Implementation details </a>
        <li><a href="#Outlook"> Outlook </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#PreconditioningtheStokessystem">Preconditioning the Stokes system</a>
        <li><a href="#Definitionofassemblydatastructures">Definition of assembly data structures</a>
        <li><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a>
        <li><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemParameters">BoussinesqFlowProblem::Parameters</a>
        <li><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a>
        <li><a href="#TheBoussinesqFlowProblemhelperfunctions">The BoussinesqFlowProblem helper functions</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a>
        <li><a href="#BoussinesqFlowProblemget_cfl_number">BoussinesqFlowProblem::get_cfl_number</a>
        <li><a href="#BoussinesqFlowProblemget_entropy_variation">BoussinesqFlowProblem::get_entropy_variation</a>
        <li><a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a>
        <li><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a>
      </ul>
        <li><a href="#TheBoussinesqFlowProblemsetupfunctions">The BoussinesqFlowProblem setup functions</a>
        <li><a href="#TheBoussinesqFlowProblemassemblyfunctions">The BoussinesqFlowProblem assembly functions</a>
      <ul>
        <li><a href="#Stokespreconditionerassembly">Stokes preconditioner assembly</a>
        <li><a href="#Stokessystemassembly">Stokes system assembly</a>
        <li><a href="#Temperaturematrixassembly">Temperature matrix assembly</a>
        <li><a href="#Temperaturerighthandsideassembly">Temperature right hand side assembly</a>
      </ul>
        <li><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a>
        <li><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a>
        <li><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a>
        <li><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Comparisonofresultswithstep31">Comparison of results with step-31</a>
        <li><a href="#Resultsfora2dcircularshelltestcase">Results for a 2d circular shell testcase</a>
        <li><a href="#Resultsfora3dsphericalshelltestcase">Results for a 3d spherical shell testcase</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>

examples/step-32/doc/intro.dox</pre><p></code></p>
<p><code></p><pre> <br />
</pre><p></code></p>
<p><code></p><pre><em>This program was contributed by Martin Kronbichler, Wolfgang
Bangerth, and Timo Heister.</em></pre><p></code></p>
<p><code></p><pre><em>This material is based upon work partly supported by the National
Science Foundation under Award No. EAR-0426271 and The California Institute of
Technology; and in a continuation by the National Science
Foundation under Award No. EAR-0949446 and The University of California
&ndash; Davis. Any opinions, findings, and conclusions or recommendations
expressed in this publication are those of the author and do not
necessarily reflect the views of the National Science Foundation, The
California Institute of Technology, or of The University of California
&ndash; Davis.</em></pre><p></code></p>
<p><code></p><pre><em>The work discussed here is also presented in the following publication:
<b>
  M. Kronbichler, T. Heister, W. Bangerth:
  <em>High Accuracy Mantle Convection Simulation through Modern Numerical
  Methods</em><b>
  M. Kronbichler, T. Heister, W. Bangerth:
  <em>High Accuracy Mantle Convection Simulation through Modern Numerical
  Methods</em>, Geophysical Journal International, 2012, 191, 12-29.
  <a href="http://dx.doi.org/10.1111/j.1365-246X.2012.05609.x">[DOI]</a><em>High Accuracy Mantle Convection Simulation through Modern Numerical
  Methods</em>, Geophysical Journal International, 2012, 191, 12-29.
  <a href="http://dx.doi.org/10.1111/j.1365-246X.2012.05609.x">[DOI]</a>
</b><a href="http://dx.doi.org/10.1111/j.1365-246X.2012.05609.x">[DOI]</a>
</b></em></pre><p></code></p>
<p><code></p><pre><em>The continuation of development of this program has led to the much larger open
source code <em>ASPECT</em><em>ASPECT</em> (see <a href="http://aspect.geodynamics.org/">http://aspect.geodynamics.org/</a>) which is much
more flexible in solving many kinds of related problems.
</em></pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Intro"></a></pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Introduction"></a><h1>Introduction</h1>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>这个程序所做的事情与<a class="el" href="step_31.html">step-31</a>已经做的差不多：它解决了描述温度不平衡的流体运动的Boussinesq方程。因此，我们在<a class="el" href="step_31.html">step-31</a>中描述的所有方程仍然成立：我们使用相同的有限元方案、相同的时间步进算法和或多或少相同的温度平流-扩散方程的稳定方法来解决相同的一般偏微分方程（只做了些许修改，以适应问题设置的更多现实性）。因此，你可能首先要了解那个程序和它的实现，然后再研究当前的程序。</pre><p></code></p>
<p><code></p><pre><a class="el" href="step_31.html">step-31</a>和当前程序的不同之处在于，在这里，我们想以并行的方式做事，既利用集群中许多机器的可用性（基于MPI的并行化），也利用一台机器中的许多处理器核心（基于线程的并行化）。因此，本程序的主要工作是引入必要的变化，以利用这些并行计算资源的可用性。在这方面，它建立在第40步程序的基础上，该程序首先为大部分的并行功能介绍了必要的类，而第55步则展示了如何为一个矢量值的问题做这件事。</pre><p></code></p>
<p><code></p><pre>除了这些变化之外，我们还使用了一个略微不同的预处理程序，而且我们将不得不做出一些改变，这与我们在这里想要解决一个<em>realistic</em>问题，而不是一个模型问题有关。特别是后者，将要求我们考虑比例问题，以及所考虑的方程中所有这些参数和系数的实际含义。我们将首先讨论影响数学公式和求解器结构变化的问题，然后讨论如何将事情并行化，最后讨论我们将考虑的实际测试案例。</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Usingtherightpressure"></a><h3>Using the "right" pressure </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>在步骤31中，我们对速度和压力场使用了以下斯托克斯模型。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho \; \beta \; T \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>第一个等式的右手边显得有点无动于衷。事情其实应该是这样的。我们需要作用在流体上的外力，我们假设这些外力只是由重力给出的。在目前的情况下，我们假设流体确实为了这个重力的目的而轻微膨胀，但还不足以让我们需要修改不可压缩性条件（第二个方程）。这意味着，为了右手边的目的，我们可以假设 \(\rho=\rho(T)\)  。一个可能不完全合理的假设是，我们可以假设密度作为温度的函数的变化很小，导致形式为 \(\rho(T) = \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})]\)  的表达，即在参考温度下密度等于 \(\rho_{\text{ref}}\) ，并且随着温度的升高（随着材料的膨胀）线性下降。然后，力平衡方程看起来正确地写成这样。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})] \mathbf{g}. \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>现在注意到，引力是由重力势产生的，如 \(\mathbf g=-\nabla \varphi\)  ，因此我们可以将其重新写成如下。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho_{\text{ref}} \; \beta\; T\; \mathbf{g} -\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \nabla\varphi. \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>右边的第二个项是与时间无关的，因此我们可以引入一个新的 "动态 "压力 \(p_{\text{dyn}}=p+\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi=p_{\text{total}}-p_{\text{static}}\) ，用它来表示斯托克斯方程。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p_{\text{dyn}} &amp;=&amp; -\rho_{\text{ref}} \; \beta \; T \; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>这正是我们在第31步中使用的形式，这样做是合适的，因为流体流动的所有变化只由温度差异导致的动态压力驱动。(换句话说。任何因取标量场的梯度而导致的对右手边的贡献都对速度场没有影响）。)</pre><p></code></p>
<p><code></p><pre>另一方面，我们在这里将使用考虑总压力的斯托克斯方程的形式来代替。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T)\; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>这有几个好处。</pre><p></code></p>
<p><code></p><pre><ul>
<li>这样我们就可以在我们的程序中绘制压力图，它实际上显示的是包括温差影响以及上覆岩石的静压力在内的总压力。由于压力没有进一步出现在任何其他方程中，因此使用一个还是另一个，更多的是口味问题，而不是正确性问题。流动场是完全相同的，但我们得到的压力现在可以与地球物理书籍中给出的数值进行比较，例如，在地幔底部的压力。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>如果我们想让这个模型更加真实，我们就必须考虑到许多材料参数（如粘度、密度等）不仅取决于温度，而且还取决于<em>total</em>压力。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>上面的模型假设了一个线性依赖 \(\rho(T) = \rho_{\text{ref}} [1-\beta(T-T_{\text{ref}})]\) ，并假定 \(\beta\) 很小。在实践中，情况可能并非如此。事实上，现实的模型肯定不是线性的，而且 \(\beta\) 至少在部分温度范围内也可能不小，因为密度的行为不仅大大取决于热膨胀，而且取决于相变。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li><p class="startli">这样做的最后一个原因将在结果部分讨论，涉及到对我们在这里使用的模型的可能扩展。这与我们在这里使用的温度方程（见下文）不包括包含压力的条款这一事实有关。然而，它应该包括：岩石，像气体一样，在你压缩它的时候会升温。因此，上升的物质以绝热方式冷却，而下沉的冷物质以绝热方式升温。我们在下面进一步讨论这个问题。</p>
<dl class="section note"><dt>Note</dt><dd>然而，这个程序有一个缺点。在地球上，动压比总压要小几个数量级。如果我们使用上述方程并解决所有变量，例如，4位数的精度，那么我们可能会得到正确的速度和总压力，但如果我们通过从总压力中减去静态部分来计算动态压力，我们将完全没有精度 \(p_\text{static}=\rho_{\text{ref}} [1+\beta T_{\text{ref}}] \varphi\)  。例如，如果动压比静压小六个数量级，那么我们就需要将总压解到至少七位数的精度，才能得到任何精确的结果。也就是说，在实践中，这并不是一个限制性因素。</dd></dl>
<p><a class="anchor" id="Thescalingofdiscretizedequations"></a></p><h3>The scaling of discretized equations </h3>
</li>
</ul>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>请记住，我们要解决以下方程组。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T) \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>用适当的边界条件和初始条件加以补充。正如第31步所讨论的，我们将通过在每个时间步长中首先求解斯托克斯问题，然后将温度方程向前移动一个时间间隔来解决这组方程。</pre><p></code></p>
<p><code></p><pre>本节所考虑的问题是斯托克斯问题：如果我们像往常一样对其进行离散化，我们会得到一个线性系统</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} M \; X = \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \left(\begin{array}{c} U \\ P \end{array}\right) = \left(\begin{array}{c} F_U \\ 0 \end{array}\right) = F \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>在这个程序中，我们将用FGMRES求解器来解决这些问题。这个求解器一直迭代到这些线性方程的残差低于某个公差，也就是说，直到</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\[ \left\| \left(\begin{array}{c} F_U - A U^{(k)} - B P^{(k)} \\ B^T U^{(k)} \end{array}\right) \right\| &lt; \text{Tol}. \]
</p>
</pre><p></code></p>
<p><code></p><pre>从物理单位的角度来看，这没有任何意义：这里涉及的量有物理单位，所以残差的第一部分有单位 \(\frac{\text{Pa}}{\text{m}} \text{m}^{\text{dim}}\) （通过考虑术语 \((\nabla \cdot \mathbf v, p)_{\Omega}\) 和考虑压力有单位 \(\text{Pa}=\frac{\text{kg}}{\text{m}\;\text{s}^2}\) 以及积分得到的系数 \(\text{m}^{\text{dim}}\) 最容易确定），而残差的第二部分有单位 \(\frac{\text{m}^{\text{dim}}}{\text{s}}\)  。取这个残差向量的常数将得到一个单位为 \(\text{m}^{\text{dim}-1} \sqrt{\left(\text{Pa}\right)^2 + \left(\frac{\text{m}}{\text{s}}\right)^2}\)  的量。很明显，这样做是没有意义的，而且我们不应该惊讶这样做最终会伤害到我们。</pre><p></code></p>
<p><code></p><pre>那么，为什么这在这里是个问题，而在第31步却不是呢？原因是一切都很平衡：速度是1，压力也是1，粘度是1，域的直径是 \(\sqrt{2}\)  。结果是，虽然不符合逻辑，但没有发生什么坏事。另一方面，正如我们将在下面解释的那样，这里的事情不会是那么简单的缩放。 \(\eta\) 将在 \(10^{21}\) 左右，速度在 \(10^{-8}\) 的数量级，压力在 \(10^8\) 左右，域的直径是 \(10^7\) 。换句话说，第一个方程的数量级将是 \(\eta\text{div}\varepsilon(\mathbf u) \approx 10^{21} \frac{10^{-8}}{(10^7)^2} \approx 10^{-1}\)  ，而第二个方程将是 \(\text{div}{\mathbf u}\approx \frac{10^{-8}}{10^7} \approx 10^{-15}\)  左右。那么，这将导致这样的结果：如果求解器想使残差变小，它几乎会完全集中在第一组方程上，因为它们大得多，而忽略描述质量守恒的发散方程。这正是发生的情况：除非我们将公差设置为极小的值，否则所得到的流场肯定不是无发散的。作为一个辅助问题，事实证明，很难找到一个始终有效的公差；在实践中，人们往往最终得到一个公差，在大多数时间步骤中需要30或40次迭代，而在其他一些时间步骤中需要10,000次。</pre><p></code></p>
<p><code></p><pre>那么，在这样的情况下，数字分析员该怎么做呢？答案是要从根本上入手，首先确保一切在数学上是一致的。在我们的例子中，这意味着如果我们想联合解决斯托克斯方程组，我们必须对它们进行缩放，使它们都有相同的物理尺寸。在我们的例子中，这意味着将第二个方程乘以具有单位 \(\frac{\text{Pa}\;\text{s}}{\text{m}}\) 的东西；一种选择是乘以 \(\frac{\eta}{L}\) ，其中 \(L\) 是我们领域的典型长度尺度（实验表明最好选择羽流的直径&amp;mdash；大约10公里&amp;mdash；而不是领域的直径）。使用 \(\eta\) 和 \(L\) 的这些数，这个系数约为 \(10^{17}\) 。因此，我们现在对斯托克斯系统得到这个。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; \rho(T) \; \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>这样做的问题是，结果不再是对称的（我们在左下方有 \(\frac{\eta}{L} \nabla \cdot\) ，但在右上方没有它的转置算子）。然而，这可以通过引入一个按比例的压力 \(\hat p = \frac{L}{\eta}p\) 来解决，我们得到按比例的方程式</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla \left(\frac{\eta}{L} \hat p\right) &amp;=&amp; \rho(T) \; \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0. \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>这现在是对称的。很明显，我们可以很容易地从我们作为这个程序的结果计算的比例压力 \(\hat p\) 中恢复原始压力 \(p\) 。</pre><p></code></p>
<p><code></p><pre>在下面的程序中，我们将引入一个与 <code>EquationData::pressure_scaling</code> 相对应的因子，我们将在系统矩阵和预处理程序的装配中使用这个因子。因为这很烦人而且容易出错，我们将在线性系统的解之后立即恢复未标定的压力，也就是说，解矢量的压力分量将立即被取消标定以检索物理压力。由于求解器使用的是我们可以通过推断以前的解来使用一个好的初始猜测，所以我们也要立即对压力进行缩放<em>before</em>求解。</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="ChangestotheStokespreconditionerandsolver"></a><h3>Changes to the Stokes preconditioner and solver </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>在这个教程程序中，我们应用了步骤31中使用的预处理程序的一个变体。该预处理程序是以块状形式对系统矩阵 \(M\) 进行操作，从而使乘积矩阵</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} P^{-1} M = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>其形式是基于Krylov的迭代求解器，如GMRES，可以在几次迭代中解决。然后，我们用基于矢量拉普拉斯矩阵的AMG预处理程序 \(\tilde{A}\) 的作用取代了 \(A\) 的精确逆，用压力空间上的质量矩阵 \(M_p\) 来逼近舒尔补码 \(S = B A^{-1} B^T\) ，并编写了一个<code>InverseMatrix</code>类，用于实现 \(M_p^{-1}\approx S^{-1}\) 对矢量的作用。在InverseMatrix类中，我们使用了带有不完全Cholesky（IC）预处理的CG求解器来进行内部求解。</pre><p></code></p>
<p><code></p><pre>我们可以观察到，我们仅仅使用了预处理程序的作用来逼近速度逆 \(A^{-1}\) （外部GMRES迭代处理了逆的近似特性），而我们对 \(M_p^{-1}\) 使用了或多或少的<em>exact</em>逆，由完全收敛的CG解实现。这似乎是不平衡的，但这种疯狂是有系统的：几乎所有的努力都用在了左上角的区块上，我们将AMG预处理程序应用于此，而即使是压力质量矩阵的精确反转也基本上不需要花费什么。因此，如果它能帮助我们在一定程度上减少总的迭代次数，那么这种努力是值得的。</pre><p></code></p>
<p><code></p><pre>也就是说，尽管求解器对<a class="el" href="step_31.html">step-31</a>工作得很好，但我们这里的问题有点复杂（细胞是变形的，压力有数量级的变化，我们要为更复杂的物理学提前做计划），所以我们要稍微改变一些东西。</pre><p></code></p>
<p><code></p><pre><ul>
<li>对于更复杂的问题，事实证明，仅仅使用单一的AMG V-循环作为预处理器并不总是足够的。外围求解器在大多数时候都能在合理的迭代次数内收敛（例如，少于50次），但偶尔会出现突然需要700次左右的时间步骤。到底发生了什么，很难确定，但这个问题可以通过对左上角的块使用更精确的求解器来避免。因此，我们要使用CG迭代来反转预处理矩阵的左上块，并使用AMG作为CG求解器的预处理。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>这样做的缺点是，当然，斯托克斯预处理程序变得更加昂贵（比我们只使用单个V型循环时大约昂贵10倍）。我们的策略是这样的：让我们只用V型循环作为预处理程序做多达30次的GMRES迭代，如果没有收敛，那么在这第一轮迭代后得到的斯托克斯解的最佳近似值，并将其作为我们使用具有相当宽松容忍度的完整内部求解器作为预处理程序的迭代的起始猜测。在我们所有的实验中，这只导致了少数额外迭代的收敛。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>我们需要注意的一点是，当在前置条件器中使用具有宽松容忍度的CG时，那么 \(y = \tilde A^{-1} r\) 就不再是 \(r\) 的线性函数（当然，如果我们的求解器中具有非常严格的容忍度，或者我们只应用单一的V型循环，它就是如此）。这是一个问题，因为现在我们的预处理程序不再是一个线性算子；换句话说，每次GMRES使用它时，预处理程序看起来都不一样。标准的GMRES求解器无法处理这个问题，导致收敛缓慢甚至崩溃，但F-GMRES变体正是为了处理这种情况而设计的，我们因此使用了它。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>另一方面，一旦我们确定使用F-GMRES，我们就可以放宽在倒置 \(S\) 的预处理时使用的容忍度。在第31步中，我们对 \(\tilde S\) 运行了一个预处理的CG方法，直到残差减少了7个数量级。在这里，我们可以再次宽松一些，因为我们知道外部预处理程序不会受到影响。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>在第31步中，我们使用了一个左边的预处理程序，首先反转预处理矩阵的左上块，然后应用左下块（发散）的，再反转右下块。换句话说，预处理器的应用起到了左下块三角矩阵的作用。另一种选择是使用右预处理器，这里将是右上块三角化，即我们首先反转右下舒尔补码，应用右上（梯度）算子，然后反转椭圆的左上块。在某种程度上，选择哪一个是一个品味的问题。也就是说，在GMRES类型的求解器中，右预处理有一个明显的优势：我们决定是否应该停止迭代的残差是真正的残差，而不是预处理方程的规范。因此，将其与我们通常使用的停止标准，即右手边向量的规范进行比较要简单得多。在编写这段代码时，我们发现上面讨论的缩放问题也使我们难以确定适合于左预处理线性系统的停止准则，因此本程序使用了右预处理器。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>在第31步中，我们对舒尔补码预处理中的压力质量矩阵和温度系统的解使用了IC（不完全Cholesky）预处理。在这里，我们原则上也可以这样做，但我们确实选择了一个更简单的预处理程序，即两个系统的雅可比预处理程序。这是因为在这里我们的目标是大规模的并行计算，IC/ILU的分解必须在每个处理器上对本地拥有的自由度逐块执行。这意味着，无论如何，预处理程序会变得更像一个雅可比预处理程序，所以我们宁愿直接从这个变体开始。请注意，我们只对有质量矩阵的CG求解器使用Jacobi预处理，无论如何它们都能提供最佳的（<em>h</em>独立的）收敛性，尽管它们通常需要两倍于IC预处理的迭代次数。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre>最后，让我们指出，在第31步中，我们通过逼近 \(-\text{div}(-\eta\Delta)^{-1}\nabla \approx \frac 1{\eta} \mathbf{1}\) 来计算舒尔补数 \(S=B A^{-1} B^T\) 。然而现在，我们已经对 \(B\) 和 \(B^T\) 算子进行了重新缩放。所以 \(S\) 现在应该近似于 \(-\frac{\eta}{L}\text{div}(-\eta\Delta)^{-1}\nabla \frac{\eta}{L} \approx \left(\frac{\eta}{L}\right)^2 \frac 1{\eta} \mathbf{1}\)  。我们用这个的右手边的离散形式作为我们对 \(\tilde S\) 的近似 \(S\) 。</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Changestotheartificialviscositystabilization"></a><h3>Changes to the artificial viscosity stabilization </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>与第31步类似，我们将使用一个基于方程残差的人工黏度进行稳定。  作为与步骤-31的不同之处，我们将提供两个略有不同的稳定参数的定义。对于 \(\alpha=1\) ，我们使用与步骤31相同的定义。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \nu_1(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K \min\left\{ 1, \frac{\|R_1(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\} \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>我们从方程的残差 \(\|R_1(T)\|_{L^\infty(K)}\) 中计算粘度，在残差较大的区域（陡峭的梯度周围），由与网格大小 \(h_K\) 成比例的扩散来限制粘度。这个定义已被证明对给定的情况， \(\alpha = 1\) 在<a class="el" href="step_31.html">step-31</a>中效果很好，但它通常不如 \(\alpha=2\) 的扩散有效。对于这种情况，我们选择一个稍微可读的粘度定义。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} \nu_2(T)|_K = \min (\nu_h^\mathrm{max}|_K,\nu_h^\mathrm{E}|_K) \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>其中第一项又给出了最大耗散量（类似于一阶上风方案）。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} \nu^\mathrm{max}_h|_K = \beta h_K \|\mathbf {u}\|_{L^\infty(K)} \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>而熵粘度的定义为</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} \nu^\mathrm{E}_h|_K = c_R \frac{h_K^2 \|R_\mathrm{2,E}(T)\|_{L^\infty(K)}} {\|E(T) - \bar{E}(T)\|_{L^\infty(\Omega)} }. \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>这个公式在<em>J.-L. Guermond, R. Pasquetti, &amp;
B. Popov, 2011.  Entropy viscosity method for nonlinear conservation laws, J.
Comput. Phys., 230, 4248&ndash;4267.</em>一文中有描述。与 \(\alpha = 1\) 的情况相比，残差是由温度熵计算出来的， \(T_m\) 是平均温度（我们在计算中选择最高和最低温度之间的平均值），这就得到了以下公式</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} R_\mathrm{E}(T) = \frac{\partial E(T)}{\partial t} + (T-T_\mathrm{m}) \left(\mathbf{u} \cdot \nabla T - \kappa \nabla^2 T - \gamma\right). \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre> \(\nu^\mathrm{E}_h|_K\) 公式中的分母被计算为熵与空间平均熵的整体偏差 \(\bar{E}(T) = \int_\Omega E(T) d\mathbf{x}/\int_\Omega d\mathbf{x}\)  。如同在步骤31中，我们根据前两个时间层次的温度和速度来评估人工黏度，以避免其定义中的非线性。</pre><p></code></p>
<p><code></p><pre>上述粘度的定义很简单，但取决于两个参数，即 \(\beta\)  和 \(c_R\)  。  对于目前的程序，我们想在 \(\alpha =1\) 的情况下对这两个参数更系统地去解决这个问题，使用我们在步骤31的结果部分选择离散化的另外两个参数 \(c_k\) 和 \(\beta\) 的相同推理。特别是，请记住，我们希望使人工粘度尽可能小，同时保持必要的大。在下文中，让我们描述一下人们可能遵循的一般策略。这里显示的计算是用程序的早期版本完成的，因此你在运行程序时得到的实际数值可能不再与这里显示的数值一致；尽管如此，一般的方法仍然有效，并已被用于寻找程序中实际使用的参数值。</pre><p></code></p>
<p><code></p><pre>为了了解发生了什么，请注意，下面我们将对973和4273开尔文之间的温度施加边界条件，初始条件也选择在这个范围内；出于这些考虑，我们在没有内部热源或散热器的情况下运行程序，因此温度应该总是在这个范围内，排除任何内部振荡。如果最低温度下降到973开尔文以下，那么我们需要通过增加 \(\beta\) 或减少 \(c_R\) 来增加稳定度。</pre><p></code></p>
<p><code></p><pre>正如我们在第31步所做的那样，我们首先通过使用 "传统 "公式确定 \(\beta\) 的最佳值</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K, \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>我们知道，只要 \(\beta\) 足够大，它就是稳定的。在2d中做几百个时间步数（在比程序中显示的网格更粗的网格上，用不同的粘度影响传输速度，从而影响时间步数大小），将产生以下图表。</pre><p></code></p>
<p><code></p><pre> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.beta.2d.png"/>
</div>
</pre><p></code></p>
<p><code></p><pre>可以看出， \(\beta \le 0.05\) 的数值太小，而 \(\beta=0.052\) 似乎是有效的，至少在这里显示的时间范围内。顺便说一句，这里至少有两个问题是人们可能想知道的。首先，当解决方案变得不稳定时，会发生什么？看一下图形输出，我们可以看到，在这些实验所选择的不合理的粗大网格下，大约在 \(t=10^{15}\) 秒的时间里，一直向冷的外部边界上升，然后向侧面扩散的热物质羽流开始相互靠近，将中间的冷物质挤出去。这就形成了一个细胞层，流体从两个相对的侧面流入，并向第三个侧面流出，显然，这种情况会在没有足够稳定的情况下产生这些不稳定性。第二：在步骤31中，我们使用了 \(\beta=0.015\cdot\text{dim}\) ；为什么这在这里不起作用？这个问题的答案并不完全清楚&ndash;稳定参数肯定取决于单元格的形状等因素，在第31步中我们使用的是正方形，而在当前程序中则是梯形。不管具体原因是什么，我们至少有一个 \(\beta\) 的值，即2d的0.052，对当前程序有效。在3d中也可以做类似的实验，我们发现 \(\beta=0.078\) 是一个很好的选择&mdash; 整齐地引出公式 \(\beta=0.026 \cdot \textrm{dim}\)  。</pre><p></code></p>
<p><code></p><pre>有了这个值，我们就可以回到粘度的原始公式 \(\nu\) ，并玩弄常数 \(c_R\) ，使其尽可能大，以便使 \(\nu\) 尽可能小。这样我们就得到了这样的画面。</pre><p></code></p>
<p><code></p><pre> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.beta_cr.2d.png"/>
</div>
</pre><p></code></p>
<p><code></p><pre>因此， \(c_R=0.1\) 似乎是这里的正确值。虽然这个图形是针对指数 \(\alpha=1\) 得到的，但在程序中我们用 \(\alpha=2\) 代替，在这种情况下，必须重新调整参数（并观察到 \(c_R\) 出现在分子中而不是分母中）。事实证明， \(c_R=1\) 与 \(\alpha=2\) 一起工作。</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="LocallyconservativeStokesdiscretization"></a><h3>Locally conservative Stokes discretization </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>Stokes的标准Taylor-Hood离散化，使用 \(Q_{k+1}^d \times Q_k\) 元素，是全局保守的，即 \(\int_{\partial\Omega} \mathbf n \cdot \mathbf u_h = 0\)  。这很容易看出：发散方程的弱形式为 \((q_h, \textrm{div}\; \mathbf u_h)=0, \forall q_h\in Q_h\)  。因为压力空间确实包含函数 \(q_h=1\)  ，所以我们得到</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{align*} 0 = (1, \textrm{div}\; \mathbf u_h)_\Omega = \int_\Omega \textrm{div}\; \mathbf u_h = \int_{\partial\Omega} \mathbf n \cdot \mathbf u_h \end{align*}
</p>
</pre><p></code></p>
<p><code></p><pre>由发散定理决定。这个性质很重要：如果我们想用速度场 \(u_h\) 沿途输送其他量（如电流方程中的温度，但也可以是化学物质的浓度或完全是人为的示踪量），那么守恒性质保证所输送的量保持恒定。</pre><p></code></p>
<p><code></p><pre>也就是说，在有些应用中，这个<em>global</em>属性是不够的。相反，我们希望它在每个单元上都持有<em>locally</em>。这可以通过使用空间 \(Q_{k+1}^d \times DGP_k\) 进行离散化来实现，我们用相同程度的完整多项式的<em>discontinuous</em>空间代替压力的张量积多项式 \(k\) 空间。(注意，2d中的张量积多项式包含函数 \(1, x, y, xy\) ，而完全多项式只包含函数 \(1,x,y\) ) 。这个空间对斯托克斯方程来说是稳定的。</pre><p></code></p>
<p><code></p><pre>因为空间是不连续的，我们现在可以特别选择测试函数 \(q_h(\mathbf x)=\chi_K(\mathbf x)\)  ，即单元格 \(K\)  的特征函数。然后我们以类似于上面的方式得到</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{align*} 0 = (q_h, \textrm{div}\; \mathbf u_h)_\Omega = (1, \textrm{div}\; \mathbf u_h)_K = \int_K \textrm{div}\; \mathbf u_h = \int_{\partial K} \mathbf n \cdot \mathbf u_h, \end{align*}
</p>
</pre><p></code></p>
<p><code></p><pre>显示了单元格 \(K\) 的保存属性。这显然对每个细胞都是成立的。</pre><p></code></p>
<p><code></p><pre>使用这种离散化是有充分理由的。如上所述，这个元素保证了每个单元上平流量的守恒。第二个优点是，我们用作预处理的压力质量矩阵代替了Schur补码，成为块状对角线，因此非常容易反转。然而，也有缺点。首先，现在有更多的压力变量，增加了问题的总体规模，尽管这在实践中似乎没有造成太大的影响。但更重要的是，现在每个单元上的发散是零，而以前不是，这并不能保证发散是点状的小。事实上，我们可以很容易地验证，与标准Taylor-Hood离散化相比，这个离散化的 \(L_2\) 准则是<em>larger</em>。然而，两者都以相同的速度收敛到零，因为很容易看到 \(\|\textrm{div}\; u_h\|= \|\textrm{div}\; (u-u_h)\|= \|\textrm{trace}\; \nabla (u-u_h)\|\le \|\nabla (u-u_h)\|={\cal O}(h^{k+2})\)  。因此，并不是先验的，仅仅因为我们现在有更多的自由度，误差就真的小了。</pre><p></code></p>
<p><code></p><pre>鉴于这些考虑，目前还不清楚应该选择哪种离散化方式。因此，我们把这个问题留给用户，并在输入文件中规定使用哪个参数。</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Higherordermappingsforcurvedboundaries"></a><h3>Higher order mappings for curved boundaries </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>在程序中，我们将使用一个球壳作为域。这意味着域的内部和外部边界不再是 "直的"（我们通常指它们是可以用FlatManifold类表示的双线性表面）。相反，它们是弯曲的，如果我们已经使用高阶有限元来计算速度，那么在程序中使用一个弯曲的近似值似乎是谨慎的。因此，我们将引入一个MappingQ类型的成员变量，表示这样的映射（步骤10和步骤11首次引入这样的映射），我们将在与边界相邻的单元的所有计算中使用。由于这只影响到相对较小的一部分单元格，额外的努力并不是很大，我们将对这些单元格使用四分法映射。ls.</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Parallelizationonclusters"></a><h3>Parallelization on clusters </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>在三维空间中运行具有显著雷利数的对流代码需要大量的计算；在整个地球模拟的情况下，需要一或几亿个未知数的数量。这显然不能用一台机器来完成（至少在2010年我们开始编写这段代码时不能）。因此，我们需要将其并行化。科学代码在计算机集群的多台机器上的并行化几乎总是使用消息传递接口（MPI）来完成。这个程序也不例外，它遵循了第17步和第18步程序的一般精神，尽管在实践中它更多地借用了第40步，在该步中我们首先介绍了当我们想<em>completely</em>分布所有计算时使用的类和策略，而第55步则展示了如何为 <a class="el" href="group__vector__valued.html">向量值问题</a>：包括，例如，将网格分割成若干部分，使每个处理器只存储自己的份额和一些幽灵单元，以及使用任何处理器都不可能有足够的内存在本地保存组合解向量的条目的策略。我们的目标是以合理的可扩展性在数百甚至数千台处理器上运行这段代码。</pre><p></code></p>
<p><code></p><pre> <dl class="section note"><dt>Note</dt><dd>即使它有一个较大的数字，步骤40在逻辑上是在当前程序之前。第55步的情况也是如此。在你试图理解我们在这里所做的事情之前，你可能会想看看这些程序。</dd></dl>
MPI是一个相当笨拙的编程接口。它是一套半面向对象的函数，虽然人们用它在网络上发送数据，但需要明确地描述数据类型，因为MPI函数坚持以 <code>void*</code> 对象的形式获得数据的地址，而不是通过重载或模板自动推断数据类型。我们已经在第17步和第18步中看到，如何通过将所有必要的通信放到deal.II库中，或者在这些程序中放到PETSc中，来避免几乎所有的MPI。我们将在这里做一些类似的事情：就像第40步和第55步一样，deal.II和底层的p4est库负责分配网格所需的所有通信，而我们将让Trilinos库（以及命名空间TrilinosWrappers中的包装器）处理线性代数组件的并行化问题。我们已经在<a class="el" href="step_31.html">step-31</a>中使用了Trilinos，在这里也会这样做，不同的是我们将使用它的并行能力。</pre><p></code></p>
<p><code></p><pre>Trilinos由大量的包组成，实现了基本的并行线性代数操作（Epetra包），不同的求解器和预处理包，以及对deal.II不太重要的东西（例如。deal.II的Trilinos接口封装了Trilinos提供的许多与PDE求解器相关的东西，并提供了封装类（在命名空间TrilinosWrappers中），使Trilinos的矩阵、向量、求解器和预处理器类看起来与deal.II自己对这些功能的实现非常相同。然而，与deal.II的类相比，如果我们给它们提供必要的信息，它们可以在并行中使用。因此，有两个Trilinos类我们必须直接处理（而不是通过包装器），这两个类都是Trilinos的Epetra基本线性代数和工具类库的一部分。   <ul>
<li>
<p class="startli">Epetra_Comm类是MPI "通信器 "的抽象，也就是说，它描述了多少台机器和哪些机器可以相互通信。   每个分布式对象，如稀疏矩阵或矢量，我们可能想在不同的机器上存储部分，需要有一个通信器对象来知道有多少部分，在哪里可以找到它们，以及如何访问它们。</p>
<p>在这个程序中，我们只真正使用了一个通信器对象&ndash;基于MPI变量 <code>MPI_COMM_WORLD</code> &ndash;它包含了<em>all</em>个一起工作的进程。在 \(N\) 机器上启动一个进程，但只在其中的一个子集上存储向量，产生一个只包括这个子集的机器的通信器对象是完全合法的；不过，在这里确实没有令人信服的理由这样做。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">IndexSet类用于描述一个向量的哪些元素或一个矩阵的哪些行应该驻留在作为通信器一部分的当前机器上。要创建这样一个对象，你需要知道（i）元素或行的总数，（ii）你想在本地存储的元素的索引。我们将在下面的 <code>partitioners</code> 函数中设置这些 <code>BoussinesqFlowProblem::setup_dofs</code> ，然后把它交给我们创建的每个parallel对象。</p>
<p class="endli">与PETSc不同，Trilinos没有假设矢量的元素需要被分割成连续的小块。至少在原则上，我们可以在一个处理器上存储所有偶数索引的元素，在另一个处理器上存储所有奇数索引的元素。当然，这不是很有效率，但这是可能的。此外，这些分区的元素不一定是相互排斥的。这一点很重要，因为在对解决方案进行后处理时，我们需要访问所有本地相关的或至少是本地活跃的自由度（定义见 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 上的模块，以及步骤40中的讨论）。那么Trilinos矢量认为哪些元素是本地拥有的，对我们来说并不重要。我们所关心的是，它在本地存储了我们所需要的那些元素。   </p>
</li>
</ul>
</pre><p></code></p>
<p><code></p><pre>还有一些与将网格分布到若干处理器上有关的概念；在尝试理解这个程序之前，你可能想看一下 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 模块和步骤40或步骤55。  程序的其余部分几乎完全不知道我们没有完全在本地存储所有对象的事实。有几个地方我们必须将所有单元的循环限制在本地拥有的单元上，或者我们需要区分只存储本地拥有的元素的向量和存储本地相关的所有元素的向量（见 <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">这个词汇表条目</a>），但总的来说，使程序在parallel中运行所需的大量繁重工作都很好地隐藏在这个程序赖以建立的库中。在任何情况下，当我们在程序代码中看到这些位置时，我们会对它们进行评论。</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Parallelizationwithinindividualnodesofacluster"></a><h3>Parallelization within individual nodes of a cluster </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>使程序并行化的第二个策略是利用这样一个事实，即今天大多数计算机都有一个以上的处理器，它们都可以访问相同的内存。换句话说，在这个模型中，我们不需要明确地说哪块数据在哪里，我们需要的所有数据都可以直接访问，我们要做的就是在可用的处理器之间分割<em>processing</em>这些数据。然后，我们将把它与上述的MPI并行化结合起来，也就是说，我们将让一台机器上的所有处理器一起工作，例如，为这台机器实际 "拥有 "的单元汇集对全局矩阵的局部贡献，而不是为那些被其他机器拥有的单元。我们将把这种策略用于本程序中经常进行的四种操作：组装斯托克斯和温度矩阵，组装形成斯托克斯预处理的矩阵，以及组装温度系统的右手边。</pre><p></code></p>
<p><code></p><pre>所有这些操作基本上都是这样的：我们需要在 <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> 等于我们机器在用于所有通信的通信器对象中的索引（即 <code>MPI_COMM_WORLD</code>  ，如上所述）的所有单元中循环。我们实际要使用的测试，简明扼要地描述了我们为什么要测试这个条件，是  <code>cell-&gt;is_locally_owned()</code>  。在每一个这样的单元上，我们需要集合对全局矩阵或向量的局部贡献，然后我们必须将每个单元的贡献复制到全局矩阵或向量中。请注意，第一部分（循环）定义了一个必须发生的迭代器的范围。第二部分，本地贡献的组装是在这个步骤序列中花费大部分CPU时间的事情，也是一个可以在并行中完成的典型例子：每个单元的贡献完全独立于所有其他单元的贡献。第三部分，复制到全局矩阵中，不能在parallel中进行，因为我们正在修改一个对象，所以几个线程不能同时读取一个现有的矩阵元素，增加他们的贡献，并将总和写回内存而不产生<a href="http://en.wikipedia.org/wiki/Race_condition">race condition</a>危险。</pre><p></code></p>
<p><code></p><pre>deal.II有一个类，正是为这个工作流程而生的。WorkStream，首先在步骤9和步骤13中讨论。它的使用在 <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> 模块中也有大量的记录（在 <a class="el" href="group__threads.html#MTWorkStream">WorkStream类 </a>一节），我们不会在这里重复那里阐述的原理和详细说明，尽管你会想通读这个模块以了解从头开始的空间和每单元数据之间的区别。我只想说，我们需要以下条件。</pre><p></code></p>
<p><code></p><pre><ul>
<li>迭代器的范围是我们要处理的那些单元格。这是由FilteredIterator类提供的，它的作用就像deal.II中的其他单元格迭代器一样，只是它跳过了所有不满足特定谓词（即，一个评估为真或假的标准）的单元。在我们的例子中，该谓词是一个单元格是否为本地所有。</li>
<li>一个为上面确定的每项任务在每个单元上做工作的函数，即集合对斯托克斯矩阵和预调节器、温度矩阵和温度右侧的局部贡献的函数。这些是下面代码中的 <code>BoussinesqFlowProblem::local_assemble_stokes_system</code> 、 <code>BoussinesqFlowProblem::local_assemble_stokes_preconditioner</code> 、 <code>BoussinesqFlowProblem::local_assemble_temperature_matrix</code> 和 <code>BoussinesqFlowProblem::local_assemble_temperature_rhs</code> 函数。这四个函数都可以有几个实例同时并行运行。</li>
<li>将前一个函数的结果复制到全局对象中的函数，并按顺序运行以避免竞赛条件。这些是 <code>BoussinesqFlowProblem::copy_local_to_global_stokes_system</code> 、 <code>BoussinesqFlowProblem::copy_local_to_global_stokes_preconditioner</code> 、 <code>BoussinesqFlowProblem::copy_local_to_global_temperature_matrix</code> 、和 <code>BoussinesqFlowProblem::copy_local_to_global_temperature_rhs</code> 函数。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre>我们将在实际代码中再评论一些要点，但总的来说，它们的结构应该从  <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a>  的讨论中清楚。</pre><p></code></p>
<p><code></p><pre>WorkStream的底层技术识别需要处理的 "任务"（例如，在一个单元上组装本地贡献），并将这些任务自动安排到可用的处理器上。WorkStream通过将迭代器范围分割成合适的小块，自动创建这些任务。</pre><p></code></p>
<p><code></p><pre> <dl class="section note"><dt>Note</dt><dd>在每个MPI进程中使用多个线程，只有当你在集群的每个节点上运行的MPI进程少于这台机器上的处理器核心时才有意义。否则，MPI已经让你的处理器很忙了，你不会从使用线程中获得任何额外的速度。例如，如果你的集群节点有8个内核，就像在写这篇文章的时候经常有的那样，如果你的批处理调度程序在每个节点上放8个MPI进程，那么使用线程并不能使程序更快。因此，你可能想在运行之前，要么配置你的deal.II不使用线程，要么将 <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> 中的线程数设置为1（第三个参数），或者 "export DEAL_II_NUM_THREADS=1"。也就是说，在写这篇文章的时候，我们只用WorkStream类来组装（部分）线性系统，而程序的75或更多的运行时间是在没有并行化的线性求解器中度过的&mdash;换句话说，我们最好的希望是将剩下的25并行化。</dd></dl>
<a class="anchor" id="Thetestcase"></a><h3>The testcase </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>这个程序的设置稍微让人想起我们当初想解决的问题（见步骤31的介绍）：地幔的对流。因此，我们选择了以下数据，所有这些数据在程序中都是以米和秒为单位（国际单位制）出现的，即使我们在这里以其他单位列出它们。然而，我们注意到，这些选择基本上仍然只是示范性的，而不是要形成对地幔对流的完全现实的描述：为此，必须实现更多、更困难的物理学，而且目前这个程序中也缺少其他几个方面。我们将在结果部分再次讨论这个问题，但现在要说明的是，在写这篇文章时，提供真实的描述是正在开发的<em>ASPECT</em>代码的一个目标。</pre><p></code></p>
<p><code></p><pre>作为提醒，让我们再次说明我们要解决的方程是这些。</pre><p></code></p>
<p><code></p><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla \left( \frac{\eta}{L} \hat p\right) &amp;=&amp; \rho(T) \mathbf{g}, \\ \frac{\eta}{L} \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
</pre><p></code></p>
<p><code></p><pre>用边界条件和初始条件增强。然后我们必须选择以下数量的数据。   <ul>
<li>
<p class="startli">域是一个环形（2D）或一个球壳（3D），其内外半径与地球的半径一致：地球的总半径为6371km，地幔从大约35km的深度开始（就在由<a href="http://en.wikipedia.org/wiki/Continental_crust" target="_top">continental</a>和<a href="http://en.wikipedia.org/wiki/Oceanic_crust" target="_top">oceanic
  plates</a>组成的固体地球<a href="http://en.wikipedia.org/wiki/Crust_(geology)" target="_top">crust</a>之下）到2890km深度（<a href="http://en.wikipedia.org/wiki/Outer_core" target="_top">outer earth
  core</a>开始）。因此半径为 \(R_0=(6371-2890)\text{km}, R_1=(6371-35)\text{km}\)  。这个领域是使用 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> 函数方便地生成的。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">在地壳和地幔的界面，温度在500到900摄氏度之间，而在其底部则是4000摄氏度左右（例如，见<a href="http://en.wikipedia.org/wiki/Mantle_(geology)" target="_top">this Wikipedia
  entry</a>）。因此，在开尔文中，我们选择 \(T_0=(4000+273)\text{K}\)  ， \(T_1=(500+273)\text{K}\) 作为内外边缘的边界条件。</p>
<p>除此以外，我们还必须为温度场指定一些初始条件。由于已经持续了40多亿年的对流，地球的真实温度场是相当复杂的&ndash;事实上，我们正是想通过这样的程序来探索这种温度分布的特性。因此，我们在这里并没有什么有用的东西可以提供，但是我们可以希望，如果我们从一些东西开始，让事情运行一段时间，确切的初始条件就不再那么重要了&mdash; 事实上，通过查看<a href="#Results">results section
  below</a>中显示的图片就可以看出。我们在这里使用的初始温度场是由 </p><p class="formulaDsp">
\begin{align*} s &amp;= \frac{\|\mathbf x\|-R_0}{R_1-R_0}, \\ \varphi &amp;= \arctan \frac{y}{x}, \\ \tau &amp;= s + \frac 15 s(1-s) \sin(6\varphi) q(z), \\ T(\mathbf x) &amp;= T_0(1-\tau) + T_1\tau, \end{align*}
</p>
<p>给出半径的。</p>
<p>其中 </p><p class="formulaDsp">
\begin{align*} q(z) = \left\{ \begin{array}{ll} 1 &amp; \text{in 2d} \\ \max\{0, \cos(\pi |z/R_1|)\} &amp; \text{in 3d} \end{array} \right. . \end{align*}
</p>
<p>这个复杂的函数本质上是内部和外部温度之间的线性轮廓的扰动。在2D中，函数 \(\tau=\tau(\mathbf x)\) 看起来是这样的（我从<a href="http://www.wolframalpha.com/input/?i=plot+%28sqrt%28x^2%2By^2%29%2B0.2*%28sqrt%28x^2%2By^2%29*%281-sqrt%28x^2%2By^2%29%29*sin%286*atan2%28x%2Cy%29%29%29%2C+x%3D-1+to+1%2C+y%3D-1+to+1">this
  page</a>得到的图片）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.2d-initial.png"/>
</div>
<p>这个剖面的重点是，如果我们在 \(T(\mathbf x)\) 的定义中使用 \(s\) 而不是 \(\tau\) ，那么它将只是一个线性内插。 \(\tau\) 在内部和外部边界具有与 \(s\) 相同的函数值（分别为0和1），但它根据角度和3D中的 \(z\) 值将温度曲线拉长一些，产生线性内插场的角度依赖性扰动。我们将在结果部分看到，这是一个完全不实际的温度场（尽管它将会产生有趣的图像），因为温度的平衡状态将是一个几乎恒定的温度，在内部和外部边界有边界层。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">温度方程的右边包含了内部加热的速率 \(\gamma\)  。地球确实通过几种机制自然升温：放射性衰变、化学分离（较重的元素沉到底部，较轻的元素升到顶部；逆流耗散的能量相当于这一分离过程中的势能损失）；随着地球内部固体核心的增长，液态金属结晶释放热量；以及流体运动时粘性摩擦产生的热量耗散。</p>
<p>化学分离很难建模，因为它需要将地幔物质建模为多个相；它也是一个相对较小的效应。结晶热就更难了，因为它只限于温度和压力允许相变的区域，也就是一个不连续的过程。鉴于对这两种现象进行建模的困难，我们将忽略它们。</p>
<p>另外两个很容易处理，考虑到我们对温度方程进行缩放的方式，可得出方程 </p><p class="formulaDsp">
\[ \gamma(\mathbf x) = \frac{\rho q+2\eta \varepsilon(\mathbf u):\varepsilon(\mathbf u)} {\rho c_p}, \]
</p>
<p>其中 \(q\) 是 \(\frac{W}{kg}\) 中的辐射性加热，列举器中的第二项是粘性摩擦加热。 \(\rho\)  是密度， \(c_p\)  是比热。文献中提供了以下近似值。 \(c_p=1250 \frac{J}{kg\; K}, q=7.4\cdot 10^{-12}\frac{W}{kg}\)  .   其他参数将在本节的其他地方讨论。</p>
<p>我们在这里忽略了一个内部热源，即绝热加热，这将导致一个令人惊讶的温度场。这一点将在下面的结果部分进行详细评论。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">对于速度，我们在内半径处选择 \(\mathbf{v}=0\) 作为边界条件（即流体粘在地心上），在外半径处选择 \(\mathbf{n}\cdot\mathbf{v}=0\) （即流体沿地壳底部切向流动）。这两种情况在物理上都不过分正确：当然，在这两个边界上，流体可以切向流动，但它们会通过与界面另一侧的介质（分别是金属核心和地壳）摩擦而产生剪切应力。这样的情况可以用切向速度的罗宾式边界条件来模拟；在这两种情况下，法向（垂直）速度将为零，尽管即使这样也不完全正确，因为大陆板块也有垂直运动（例如，见<a href="http://en.wikipedia.org/wiki/Postglacial_rebound">post-glacial
  rebound</a>的现象）。但是，对切向速度来说，另一侧的介质也在运动，这已经使事情变得更糟了，因此，在最简单的情况下，剪应力将与<em>velocity
  difference</em>成正比，导致边界条件的形式为 </p><p class="formulaDsp">
\begin{align*} \mathbf{n}\cdot [2\eta \varepsilon(\mathbf v)] &amp;= s \mathbf{n} \times [\mathbf v - \mathbf v_0], \\ \mathbf{n} \cdot \mathbf v &amp;= 0, \end{align*}
</p>
<p>有一个比例常数 \(s\)  。然而，我们没有走这条路，而是选择了零（棒）和切向流的边界条件。</p>
<p>顺便提一下，我们也可以在内外边界都选择切向流动条件。然而，这有一个明显的缺点：它使速度不是唯一定义的。原因是所有对应于绕域中心旋转的固体体的速度场 \(\hat{\mathbf v}\) 都满足 \(\mathrm{div}\; \varepsilon(\hat{\mathbf v})=0, \mathrm{div} \;\hat{\mathbf v} = 0\) ，和 \(\mathbf{n} \cdot \hat{\mathbf v} = 0\) 。因此，如果 \(\mathbf v\) 满足方程和边界条件，那么 \(\mathbf v + \hat{\mathbf v}\)  也满足。这当然不是一个我们想避免的好情况。解决这个问题的传统方法是在边界上选一个任意的点，通过选择速度在那里的所有分量为零，将其称为你的固定点。(在三维空间中，必须选择两个点。)由于这个程序开始时并不打算太现实，我们通过简单地固定整个内部边界的速度来避免这种复杂情况。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">根据第一顺序，重力矢量总是指向下方。对于像地球这样大的物体来说，问题只是："向上 "是什么地方。天真的答案当然是 "径向向内，向地球中心"。所以在地球表面，我们有 </p><p class="formulaDsp">
\[ \mathbf g = -9.81 \frac{\text{m}}{\text{s}^2} \frac{\mathbf x}{\|\mathbf x\|}, \]
</p>
<p>其中 \(9.81 \frac{\text{m}}{\text{s}^2}\) 刚好是地球表面的平均重力加速度。但是在地球内部，问题变得有点复杂：例如，在地球的（轨道）中心，你有物质在各个方向上同样用力拉扯，所以 \(\mathbf g=0\)  。在这两者之间，净力的描述如下：让我们用<a href="http://en.wikipedia.org/wiki/Potential_energy#Gravitational_potential_energy" target="_top">gravity
  potential</a>来定义 </p><p class="formulaDsp">
\[ \varphi(\mathbf x) = \int_{\text{earth}} -G \frac{\rho(\mathbf y)}{\|\mathbf x-\mathbf y\|} \ \text{d}y, \]
</p>
<p> 。</p>
<p>那么 \(\mathbf g(\mathbf x) = -\nabla \varphi(\mathbf x)\)  。如果我们假设密度 \(\rho\) 在整个地球上是恒定的，我们可以产生一个重力矢量的分析表达式（不要试图以某种方式整合上述方程&ndash;它导致了椭圆积分；一个更简单的方法是注意到 \(-\Delta\varphi(\mathbf x) = -4\pi G \rho \chi_{\text{earth}}(\mathbf x)\) 并利用径向对称性在所有 \({\mathbb R}^3\) 中解决这个偏微分方程）。 </p><p class="formulaDsp">
\[ \mathbf g(\mathbf x) = \left\{ \begin{array}{ll} -\frac{4}{3}\pi G \rho \|\mathbf x\| \frac{\mathbf x}{\|\mathbf x\|} &amp; \text{for} \ \|\mathbf x\|&lt;R_1, \\ -\frac{4}{3}\pi G \rho R^3 \frac{1}{\|\mathbf x\|^2} \frac{\mathbf x}{\|\mathbf x\|} &amp; \text{for} \ \|\mathbf x\|\ge R_1. \end{array} \right. \]
</p>
<p>因子 \(-\frac{\mathbf x}{\|\mathbf x\|}\) 是指向径向内的单位矢量。当然，在这个问题中，我们只对与地球内部有关的分支感兴趣，即 \(\|\mathbf x\|&lt;R_1\) 。因此，我们将只考虑表达式 </p><p class="formulaDsp">
\[ \mathbf g(\mathbf x) = -\frac{4}{3}\pi G \rho \|\mathbf x\| \frac{\mathbf x}{\|\mathbf x\|} = -\frac{4}{3}\pi G \rho \mathbf x = - 9.81 \frac{\mathbf x}{R_1} \frac{\text{m}}{\text{s}^2}, \]
</p>
<p> 。</p>
<p>其中我们可以推断出最后一个表达式，因为我们知道地球在表面的重力（其中 \(\|x\|=R_1\)  ）。</p>
<p>我们可以通过整合 \(\varphi(r)\) 的微分方程，在密度分布是径向对称的情况下，即 \(\rho(\mathbf x)=\rho(\|\mathbf x\|)=\rho(r)\) ，推导出一个更一般的表达。在这种情况下，我们将得到 </p><p class="formulaDsp">
\[ \varphi(r) = 4\pi G \int_0^r \frac 1{s^2} \int_0^s t^2 \rho(t) \; dt \; ds. \]
</p>
<p> 。</p>
<p>然而，这有两个问题。(i) 地球不是均匀的，即密度 \(\rho\) 取决于 \(\mathbf x\) ；事实上它甚至不是一个只取决于半径 \(r=\|\mathbf x\|\) 的函数。因此，在现实中，重力并不总是随着我们的深入而减少：因为地心比地幔的密度大得多，重力实际上在地心地幔边界的 \(10.7 \frac{\text{m}}{\text{s}^2}\) 左右达到峰值（见<a href="http://en.wikipedia.org/wiki/Earth&apos;s_gravity" target="_top">this
  article</a>）。(ii) 密度，以及由此产生的重力矢量，在时间上甚至不是恒定的：毕竟，我们要解决的问题是与时间有关的热的、密度较小的物质的上涌和冷的密度大的物质的下涌。这就导致了重力矢量随空间和时间的变化而变化，并不总是直接指向下方。</p>
<p>为了不使情况变得更加复杂，我们可以使用这样的近似值：在地幔的内部边界，重力是 \(10.7 \frac{\text{m}}{\text{s}^2}\) ，在外部边界，重力是 \(9.81 \frac{\text{m}}{\text{s}^2}\) ，在每种情况下都是径向向内的，在两者之间，重力随着离地球中心的径向距离而线性变化。也就是说，实际上稍微现实一点，假设（就像我们下面做的那样）地幔具有恒定的密度也不是那么难。在这种情况下，上面的方程可以被整合，我们得到一个 \(\|\mathbf{g}\|\) 的表达式，我们可以拟合常数以匹配地幔顶部和底部的重力，得到 </p><p class="formulaDsp">
\[ \|\mathbf{g}\| = 1.245\cdot 10^{-6} \frac{1}{\textrm{s}^2} r + 7.714\cdot 10^{13} \frac{\textrm{m}^3}{\textrm{s}^2}\frac{1}{r^2}. \]
</p>
<pre class="fragment">&lt;li&gt; 地幔的密度在空间上有变化，但变化幅度不大。 \form#3889 是参考温度 \form#3890 开尔文时的密度的一个相对较好的平均值。

&lt;li&gt;  热膨胀系数 \form#633 也随深度变化（通过其对温度和压力的依赖）。在接近地表的地方，它似乎是 \form#3891 ，而在地心地幔边界，它可能更接近 \form#3892@_fakenl 。作为一个合理的值，让我们选择 \form#3893 。那么密度与温度的关系是 \form#3894  。

&lt;li&gt;  我们需要指定的第二个至最后一个参数是粘度 \form#1914  。这是一个棘手的问题，因为在地幔典型的温度和压力下，岩石的流动非常缓慢，以至于在实验室里无法准确地确定粘度。那么我们如何知道地幔的粘度呢？最常用的方法是考虑在冰期和冰期之后，冰盾形成和消失的时间尺度比地幔流动的时间尺度短。因此，大陆在冰盾的附加重量下慢慢沉入地幔，而在冰盾再次消失后，它们又慢慢升起（这被称为&lt;a target="_top"
</pre><p>
  href="http://en.wikipedia.org/wiki/Postglacial_rebound"&gt;<em>postglacial
  rebound</em><em>postglacial
  rebound</em>）。通过测量这种反弹的速度，我们可以推断出流向反弹的大陆板块下腾出的区域的物质的粘度。</p>
<p>使用这种技术，发现 \(\eta=10^{21} \text{Pa}\;\text{s} = 10^{21} \frac{\text{N}\;\text{s}}{\text{m}^2} = 10^{21} \frac{\text{kg}}{\text{m}\;\text{s}}\) 附近的数值是最有可能的，尽管这上面的误差至少是一个数量级的。</p>
<p>虽然我们将使用这个值，但我们不得不再次提醒，有许多物理原因可以假设这不是正确的值。首先，它确实应该取决于温度：较热的材料很可能比较冷的材料的粘性要小。然而，在现实中，情况甚至更为复杂。地幔中的大多数岩石随着温度和压力的变化而发生相变：根据温度和压力的不同，不同的晶体构型在热力学上比其他的更受青睐，即使地幔的化学成分是均匀的。例如，常见的地幔物质MgSiO<sub>3</sub>在整个地幔的大部分地区以其<a href="http://en.wikipedia.org/wiki/Perovskite_(structure)" target="_top">perovskite
  structure</a>的形式存在，但在地幔下部，同样的物质只以<a href="http://en.wikipedia.org/wiki/Postperovskite" targe="_top">post-perovskite</a>的形式稳定。显然，为了计算现实的粘度，我们不仅需要知道地幔的确切化学成分和所有物质的粘度，而且还必须计算所有物质在每个正交点的热力学上最稳定的配置。在编写这个程序时，这不是一个可行的建议。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">我们的最后一个材料参数是热扩散率 \(\kappa\)  ，其定义为 \(\kappa=\frac{k}{\rho c_p}\)  ，其中 \(k\)  是热导率， \(\rho\)  是密度， \(c_p\)  是比热。对于这一点，文献表明，它从上地幔的 \(0.7\) 左右增加到下地幔的 \(1.7 \frac{\text{mm}^2}{\text{s}}\) 左右，尽管确切的数值其实并不那么重要：通过对流的热传输比通过热传导的热传输要重要几个数量级。可能有兴趣知道的是，地幔中最丰富的材料&ndash;过氧化物，在超过大约120GPa的压力下似乎变得透明（例如，见J. Badro等人，《科学》305，383-386（2004年））；因此，在下地幔中，通过辐射传输的热传输可能比通过热传导更有效。</p>
<p class="endli">鉴于这些考虑，让我们选择 \(\kappa=1 \frac{\text{mm}^2}{\text{s}} =10^{-6} \frac{\text{m}^2}{\text{s}}\) 作为本方案的目的。   </p>
</li>
</ul>
</pre><p></code></p>
<p><code></p><pre>所有这些方程数据都在程序中定义在 <code>EquationData</code> 命名空间。当运行时，该程序产生的长期最大速度大约为每年10-40厘米（见下面的结果部分），大约是物理上正确的数量级。我们将设定结束时间为10亿年。</pre><p></code></p>
<p><code></p><pre> <dl class="section note"><dt>Note</dt><dd>上述常数和材料参数的选择在很大程度上遵循了G.Schubert和D.L.Turcotte和P.Olson（剑桥，2001）的综合书籍《地球和行星的地幔对流，第一部分》。它包含了关于如何使程序更加真实的广泛讨论。</dd></dl>
<a class="anchor" id="Implementationdetails"></a><h3>Implementation details </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>与<a class="el" href="step_31.html">step-31</a>相比，这个程序有一些值得注意的区别。</pre><p></code></p>
<p><code></p><pre><ul>
<li><code>EquationData</code> 命名空间要大得多，这反映了我们现在有更多的物理学需要处理的事实。也就是说，这些额外的物理细节大部分是在这个命名空间的函数中自成一体的，并没有扩散到程序的其他部分。</li>
<li>更明显的可见性是，我们把大量的参数放入由ParameterHandler类处理的输入文件中（例如，见步骤29，关于用这个类设置运行时参数文件的方法）。当人们想避免仅仅因为想玩弄一个参数而重新编译程序时，这往往是有意义的（例如，想想确定上面讨论的稳定常数的最佳值的参数研究），特别是考虑到重新编译当前规模的程序需要花费非同小可的时间。为了仅仅概述我们从固定值移入输入文件的参数种类，这里列出了一个典型的 <code>step-32.prm</code> 文件。<div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line"><span class="preprocessor"># The end time of the simulation in years.</span></div><div class="line"><span class="keyword">set</span> End time                            = 1e8</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor"># Whether graphical output is to be generated or not. You may not want to get</span></div><div class="line"><span class="preprocessor"># graphical output if the number of processors is large.</span></div><div class="line"><span class="keyword">set</span> Generate graphical output           = <span class="keyword">false</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor"># The number of adaptive refinement steps performed after initial global</span></div><div class="line"><span class="preprocessor"># refinement.</span></div><div class="line"><span class="keyword">set</span> Initial adaptive refinement         = 1</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor"># The number of global refinement steps performed on the initial coarse mesh,</span></div><div class="line"><span class="preprocessor"># before the problem is first solved there.</span></div><div class="line"><span class="keyword">set</span> Initial global refinement           = 1</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor"># The number of time steps between each generation of graphical output files.</span></div><div class="line"><span class="keyword">set</span> Time steps between graphical output = 50</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor"># The number of time steps after which the mesh is to be adapted based on</span></div><div class="line"><span class="preprocessor"># computed error indicators.</span></div><div class="line"><span class="keyword">set</span> Time steps between mesh refinement  = 10</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Discretization</div><div class="line"><span class="preprocessor">  # The polynomial degree to use for the velocity variables in the Stokes</span></div><div class="line"><span class="preprocessor">  # system.</span></div><div class="line">  <span class="keyword">set</span> Stokes velocity polynomial degree       = 2</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # The polynomial degree to use for the temperature variable.</span></div><div class="line">  <span class="keyword">set</span> Temperature polynomial degree           = 2</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # Whether to use a Stokes discretization that is locally conservative at the</span></div><div class="line"><span class="preprocessor">  # expense of a larger number of degrees of freedom, or to go with a cheaper</span></div><div class="line"><span class="preprocessor">  # discretization that does not locally conserve mass (although it is</span></div><div class="line"><span class="preprocessor">  # globally conservative.</span></div><div class="line">  <span class="keyword">set</span> Use locally conservative discretization = <span class="keyword">true</span></div><div class="line">end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Stabilization parameters</div><div class="line"><span class="preprocessor">  # The exponent in the entropy viscosity stabilization.</span></div><div class="line">  <span class="keyword">set</span> alpha = 2</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">  # The beta factor in the artificial viscosity stabilization. An appropriate</span></div><div class="line"><span class="preprocessor">  # value for 2d is 0.052 and 0.078 for 3d.</span></div><div class="line">  <span class="keyword">set</span> beta  = 0.078</div><div class="line"></div><div class="line"></div><div class="line">  # The c_R factor in the entropy viscosity stabilization.</div><div class="line">  <span class="keyword">set</span> c_R   = 0.5</div><div class="line">end</div></div><!-- fragment --></li>
<li>很明显，有很多变化是与我们想在可能非常多的机器上运行我们的程序这一事实有关的。尽管人们可能会怀疑这需要我们完全重新构建我们的代码，但事实上并非如此（尽管在deal.II中实现大部分功能的类从实现的角度来看肯定非常不同，但这并没有反映在它们的公共接口中）。相反，这些变化大多是微妙的，主类的整体结构几乎没有变化。也就是说，魔鬼在细节中：正确地进行并行计算，没有死锁，确保正确的数据在正确的地方可用（例如，见关于全分布式向量与有鬼魂元素的向量的讨论），以及避免瓶颈是很困难的，关于这个话题的讨论将出现在本程序中的很多地方。</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Outlook"></a><h3>Outlook </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>这是一个教程性的程序。这意味着至少它的大部分重点需要放在演示如何使用deal.II和相关的库上，而不是通过过度关注物理细节来稀释这个教学课程。尽管上面有关于物理参数选择的长篇大论，但程序中专门讨论这个问题的部分实际上是很短的，而且是自成一体的。</pre><p></code></p>
<p><code></p><pre>也就是说，第31步和目前的第32步都不是偶然出现的，而肯定是作为通向更全面的计划的路标，该计划将模拟地幔的对流。我们把这个代码称为<em>ASPECT</em>（简称<em>Advanced Solver for Problems in Earth's
ConvecTion</em>）；它的开发是由<a href="http://www.geodynamics.org">Computational Infrastructure in
Geodynamics</a>计划资助的，得到了美国国家科学基金会的支持。关于<em>ASPECT</em>的更多信息可在其<a href="https://aspect.geodynamics.org/">homepage</a>中找到。</pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="CommProg"></a>
   <h1>The commented program</h1>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="Includefiles"></a> 
   <h3>Include files</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The first task as usual is to include the functionality of these well-known
   deal.II library files and some C++ header files.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="filtered__iterator_8h.html">deal.II/grid/filtered_iterator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgp_8h.html">deal.II/fe/fe_dgp.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;locale&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   This is the only include file that is new: It introduces the
   <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> equivalent of the
   <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class to take a solution from on mesh to the next
   one upon mesh refinement, but in the case of parallel distributed
   triangulations:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The following classes are used in parallel distributed computations and
   have all already been introduced in <a class="el" href="step_40.html">step-40</a>:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The next step is like in all previous tutorial programs: We put everything
   into a namespace of its own and then import the deal.II classes and
   functions into it:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">namespace </span>Step32</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="Equationdata"></a> 
   <h3>Equation data</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   In the following namespace, we define the various pieces of equation data
   that describe the problem. This corresponds to the various aspects of
   making the problem at least slightly realistic and that were exhaustively
   discussed in the description of the testcase in the introduction.</pre><p></code></p>
<p><code></p><pre>   We start with a few coefficients that have constant values (the comment
   after the value indicates its physical units):</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">double</span> eta                   = 1e21;    <span class="comment">/* Pa s       */</span></div><div class="line">  constexpr <span class="keywordtype">double</span> kappa                 = 1e-6;    <span class="comment">/* m^2 / s    */</span></div><div class="line">  constexpr <span class="keywordtype">double</span> reference_density     = 3300;    <span class="comment">/* kg / m^3   */</span></div><div class="line">  constexpr <span class="keywordtype">double</span> reference_temperature = 293;     <span class="comment">/* K          */</span></div><div class="line">  constexpr <span class="keywordtype">double</span> expansion_coefficient = 2e-5;    <span class="comment">/* 1/K        */</span></div><div class="line">  constexpr <span class="keywordtype">double</span> specific_heat         = 1250;    <span class="comment">/* J / K / kg */</span></div><div class="line">  constexpr <span class="keywordtype">double</span> radiogenic_heating    = 7.4e-12; <span class="comment">/* W / kg     */</span></div><div class="line"></div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> R0 = 6371000. - 2890000.; <span class="comment">/* m          */</span></div><div class="line">  constexpr <span class="keywordtype">double</span> R1 = 6371000. - 35000.;   <span class="comment">/* m          */</span></div><div class="line"></div><div class="line">  constexpr <span class="keywordtype">double</span> T0 = 4000 + 273; <span class="comment">/* K          */</span></div><div class="line">  constexpr <span class="keywordtype">double</span> T1 = 700 + 273;  <span class="comment">/* K          */</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The next set of definitions are for functions that encode the density
   as a function of temperature, the gravity vector, and the initial
   values for the temperature. Again, all of these (along with the values
   they compute) are discussed in the introduction:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keywordtype">double</span> density(<span class="keyword">const</span> <span class="keywordtype">double</span> temperature)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> (</div><div class="line">    reference_density *</div><div class="line">    (1 - expansion_coefficient * (temperature - reference_temperature)));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> gravity_vector(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">  <span class="keywordflow">return</span> -(1.245e-6 * r + 7.714e13 / r / r) * p / r;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TemperatureInitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TemperatureInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> r = p.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h = R1 - R0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> s = (r - R0) / h;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> q =</div><div class="line">    (dim == 3) ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(0.0, <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * <a class="code" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">abs</a>(p(2) / R1))) : 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> phi = <a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">std::atan2</a>(p(0), p(1));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> tau = s + 0.2 * s * (1 - s) * std::sin(6 * phi) * q;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> T0 * (1.0 - tau) + T1 * tau;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">TemperatureInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;<a class="code" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   As mentioned in the introduction we need to rescale the pressure to
   avoid the relative ill-conditioning of the momentum and mass
   conservation equations. The scaling factor is \(\frac{\eta}{L}\) where
 \(L\) was a typical length scale. By experimenting it turns out that a
   good length scale is the diameter of plumes, which is around 10 km:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">constexpr <span class="keywordtype">double</span> pressure_scaling = eta / 10000;</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The final number in this namespace is a constant that denotes the
   number of seconds per (average, tropical) year. We use this only when
   generating screen output: internally, all computations of this program
   happen in SI units (kilogram, meter, seconds) but writing geological
   times in seconds yields numbers that one can't relate to reality, and
   so we convert to years using the factor defined here:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> year_in_seconds = 60 * 60 * 24 * 365.2425;</div><div class="line"></div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="PreconditioningtheStokessystem"></a> 
   <h3>Preconditioning the Stokes system</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   This namespace implements the preconditioner. As discussed in the
   introduction, this preconditioner differs in a number of key portions
   from the one used in <a class="el" href="step_31.html">step-31</a>. Specifically, it is a right preconditioner,
   implementing the matrix
 <p class="formulaDsp">
\begin{align*} \left(\begin{array}{cc}A^{-1} &amp; B^T \\0 &amp; S^{-1} \end{array}\right) \end{align*}
</p>

   where the two inverse matrix operations
   are approximated by linear solvers or, if the right flag is given to the
   constructor of this class, by a single AMG V-cycle for the velocity
   block. The three code blocks of the <code>vmult</code> function implement
   the multiplications with the three blocks of this preconditioner matrix
   and should be self explanatory if you have read through <a class="el" href="step_31.html">step-31</a> or the
   discussion of composing solvers in <a class="el" href="step_20.html">step-20</a>.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">                             <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;Spre,</div><div class="line">                             <span class="keyword">const</span> PreconditionerTypeMp &amp;Mppreconditioner,</div><div class="line">                             <span class="keyword">const</span> PreconditionerTypeA &amp; Apreconditioner,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">bool</span>                  do_solve_A)</div><div class="line">      : stokes_matrix(&amp;S)</div><div class="line">      , stokes_preconditioner_matrix(&amp;Spre)</div><div class="line">      , mp_preconditioner(Mppreconditioner)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , do_solve_A(do_solve_A)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> utmp(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, 1e-6 * src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1).l2_norm());</div><div class="line"></div><div class="line">        <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line"></div><div class="line">        solver.solve(stokes_preconditioner_matrix-&gt;block(1, 1),</div><div class="line">                     dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                     src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1),</div><div class="line">                     mp_preconditioner);</div><div class="line"></div><div class="line">        dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1) *= -1.0;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        stokes_matrix-&gt;block(0, 1).vmult(utmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">        utmp *= -1.0;</div><div class="line">        utmp.add(src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (do_solve_A == <span class="keyword">true</span>)</div><div class="line">        {</div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(5000, utmp.l2_norm() * 1e-2);</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1SolverCG.html">TrilinosWrappers::SolverCG</a> solver(solver_control);</div><div class="line">          solver.solve(stokes_matrix-&gt;block(0, 0),</div><div class="line">                       dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0),</div><div class="line">                       utmp,</div><div class="line">                       a_preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), utmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">      stokes_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">                                stokes_preconditioner_matrix;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeMp &amp;mp_preconditioner;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp; a_preconditioner;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>                  do_solve_A;</div><div class="line">  };</div><div class="line">} <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="Definitionofassemblydatastructures"></a> 
   <h3>Definition of assembly data structures</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   As described in the introduction, we will use the <a class="el" href="namespaceWorkStream.html">WorkStream</a> mechanism
   discussed in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> module to parallelize operations among the
   processors of a single machine. The <a class="el" href="namespaceWorkStream.html">WorkStream</a> class requires that data
   is passed around in two kinds of data structures, one for scratch data
   and one to pass data from the assembly function to the function that
   copies local contributions into global objects.</pre><p></code></p>
<p><code></p><pre>   The following namespace (and the two sub-namespaces) contains a
   collection of data structures that serve this purpose, one pair for each
   of the four operations discussed in the introduction that we will want to
   parallelize. Each assembly routine gets two sets of data: a Scratch array
   that collects all the classes and arrays that are used for the
   calculation of the cell contribution, and a CopyData array that keeps
   local matrices and vectors which will be written into the global
   matrix. Whereas CopyData is a container for the final data that is
   written into the global matrices and vector (and, thus, absolutely
   necessary), the Scratch arrays are merely there for performance reasons
   &mdash; it would be much more expensive to set up a <a class="el" href="classFEValues.html">FEValues</a> object on
   each cell, than creating it only once and updating some derivative data.</pre><p></code></p>
<p><code></p><pre>   <a class="el" href="step_31.html">step-31</a> had four assembly routines: One for the preconditioner matrix of
   the Stokes system, one for the Stokes matrix and right hand side, one for
   the temperature matrices and one for the right hand side of the
   temperature equation. We here organize the scratch arrays and CopyData
   objects for each of those four assembly components using a
   <code>struct</code> environment (since we consider these as temporary
   objects we pass around, rather than classes that implement functionality
   of their own, though this is a more subjective point of view to
   distinguish between <code>struct</code>s and <code>class</code>es).</pre><p></code></p>
<p><code></p><pre>   Regarding the Scratch objects, each struct is equipped with a constructor
   that creates an <a class="el" href="classFEValues.html">FEValues</a> object using the <a class="el" href="classFiniteElement.html">FiniteElement</a>,
   <a class="el" href="classQuadrature.html">Quadrature</a>, <a class="el" href="classMapping.html">Mapping</a> (which describes the interpolation of curved
   boundaries), and <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> instances. Moreover, we manually
   implement a copy constructor (since the <a class="el" href="classFEValues.html">FEValues</a> class is not copyable by
   itself), and provide some additional vector fields that are used to hold
   intermediate data during the computation of local contributions.</pre><p></code></p>
<p><code></p><pre>   Let us start with the scratch arrays and, specifically, the one used for
   assembly of the Stokes preconditioner:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">namespace </span>Assembly</div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span>Scratch</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">    {</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags);</div><div class="line"></div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> stokes_fe_values;</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u;</div><div class="line">      std::vector&lt;double&gt;         phi_p;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">      : stokes_fe_values(mapping, stokes_fe, stokes_quadrature, update_flags)</div><div class="line">      , grad_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">      , phi_p(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> StokesPreconditioner &amp;scratch)</div><div class="line">      : stokes_fe_values(scratch.stokes_fe_values.get_mapping(),</div><div class="line">                         scratch.stokes_fe_values.get_fe(),</div><div class="line">                         scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                         scratch.stokes_fe_values.get_update_flags())</div><div class="line">      , grad_phi_u(scratch.grad_phi_u)</div><div class="line">      , phi_p(scratch.phi_p)</div><div class="line">    {}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The next one is the scratch object used for the assembly of the full
   Stokes system. Observe that we derive the StokesSystem scratch class
   from the StokesPreconditioner class above. We do this because all the
   objects that are necessary for the assembly of the preconditioner are
   also needed for the actual matrix system and right hand side, plus
   some extra data. This makes the program more compact. Note also that
   the assembly of the Stokes system and the temperature right hand side
   further down requires data from temperature and velocity,
   respectively, so we actually need two <a class="el" href="classFEValues.html">FEValues</a> objects for those two
   cases.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">{</div><div class="line">  StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags);</div><div class="line"></div><div class="line">  StokesSystem(<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u;</div><div class="line">  std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u;</div><div class="line">  std::vector&lt;double&gt;                  div_phi_u;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_temperature_values;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesSystem&lt;dim&gt;::StokesSystem(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   stokes_quadrature,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         stokes_update_flags,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         temperature_update_flags)</div><div class="line">  : StokesPreconditioner&lt;dim&gt;(stokes_fe,</div><div class="line">                              stokes_quadrature,</div><div class="line">                              mapping,</div><div class="line">                              stokes_update_flags)</div><div class="line">  , temperature_fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          stokes_quadrature,</div><div class="line">                          temperature_update_flags)</div><div class="line">  , phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , grads_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , div_phi_u(stokes_fe.n_dofs_per_cell())</div><div class="line">  , old_temperature_values(stokes_quadrature.size())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">StokesSystem&lt;dim&gt;::StokesSystem(<span class="keyword">const</span> StokesSystem&lt;dim&gt; &amp;scratch)</div><div class="line">  : StokesPreconditioner&lt;dim&gt;(scratch)</div><div class="line">  , temperature_fe_values(</div><div class="line">      scratch.temperature_fe_values.get_mapping(),</div><div class="line">      scratch.temperature_fe_values.get_fe(),</div><div class="line">      scratch.temperature_fe_values.get_quadrature(),</div><div class="line">      scratch.temperature_fe_values.get_update_flags())</div><div class="line">  , phi_u(scratch.phi_u)</div><div class="line">  , grads_phi_u(scratch.grads_phi_u)</div><div class="line">  , div_phi_u(scratch.div_phi_u)</div><div class="line">  , old_temperature_values(scratch.old_temperature_values)</div><div class="line">{}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   After defining the objects used in the assembly of the Stokes system,
   we do the same for the assembly of the matrices necessary for the
   temperature system. The general structure is very similar:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>TemperatureMatrix</div><div class="line">{</div><div class="line">  TemperatureMatrix(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   temperature_quadrature);</div><div class="line"></div><div class="line">  TemperatureMatrix(<span class="keyword">const</span> TemperatureMatrix &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         phi_T;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   temperature_quadrature)</div><div class="line">  : temperature_fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          temperature_quadrature,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">  , phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">  , grad_phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">  <span class="keyword">const</span> TemperatureMatrix &amp;scratch)</div><div class="line">  : temperature_fe_values(</div><div class="line">      scratch.temperature_fe_values.get_mapping(),</div><div class="line">      scratch.temperature_fe_values.get_fe(),</div><div class="line">      scratch.temperature_fe_values.get_quadrature(),</div><div class="line">      scratch.temperature_fe_values.get_update_flags())</div><div class="line">  , phi_T(scratch.phi_T)</div><div class="line">  , grad_phi_T(scratch.grad_phi_T)</div><div class="line">{}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The final scratch object is used in the assembly of the right hand
   side of the temperature system. This object is significantly larger
   than the ones above because a lot more quantities enter the
   computation of the right hand side of the temperature equation. In
   particular, the temperature values and gradients of the previous two
   time steps need to be evaluated at the quadrature points, as well as
   the velocities and the strain rates (i.e. the symmetric gradients of
   the velocity) that enter the right hand side as friction heating
   terms. Despite the number of terms, the following should be rather
   self explanatory:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>TemperatureRHS</div><div class="line">  {</div><div class="line">    TemperatureRHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line"></div><div class="line">    TemperatureRHS(<span class="keyword">const</span> TemperatureRHS &amp;data);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> stokes_fe_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T;</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values;</div><div class="line"></div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_strain_rates;</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; old_old_strain_rates;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         old_temperature_values;</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_values;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads;</div><div class="line">    std::vector&lt;double&gt;         old_temperature_laplacians;</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_laplacians;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TemperatureRHS&lt;dim&gt;::TemperatureRHS(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">    : temperature_fe_values(mapping,</div><div class="line">                            temperature_fe,</div><div class="line">                            quadrature,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    , stokes_fe_values(mapping,</div><div class="line">                       stokes_fe,</div><div class="line">                       quadrature,</div><div class="line">                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>)</div><div class="line">    , phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">    , grad_phi_T(temperature_fe.n_dofs_per_cell())</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_velocity_values(quadrature.size())</div><div class="line">    , old_old_velocity_values(quadrature.size())</div><div class="line">    , old_strain_rates(quadrature.size())</div><div class="line">    , old_old_strain_rates(quadrature.size())</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_temperature_values(quadrature.size())</div><div class="line">    , old_old_temperature_values(quadrature.size())</div><div class="line">    , old_temperature_grads(quadrature.size())</div><div class="line">    , old_old_temperature_grads(quadrature.size())</div><div class="line">    , old_temperature_laplacians(quadrature.size())</div><div class="line">    , old_old_temperature_laplacians(quadrature.size())</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TemperatureRHS&lt;dim&gt;::TemperatureRHS(<span class="keyword">const</span> TemperatureRHS &amp;scratch)</div><div class="line">    : temperature_fe_values(</div><div class="line">        scratch.temperature_fe_values.get_mapping(),</div><div class="line">        scratch.temperature_fe_values.get_fe(),</div><div class="line">        scratch.temperature_fe_values.get_quadrature(),</div><div class="line">        scratch.temperature_fe_values.get_update_flags())</div><div class="line">    , stokes_fe_values(scratch.stokes_fe_values.get_mapping(),</div><div class="line">                       scratch.stokes_fe_values.get_fe(),</div><div class="line">                       scratch.stokes_fe_values.get_quadrature(),</div><div class="line">                       scratch.stokes_fe_values.get_update_flags())</div><div class="line">    , phi_T(scratch.phi_T)</div><div class="line">    , grad_phi_T(scratch.grad_phi_T)</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_velocity_values(scratch.old_velocity_values)</div><div class="line">    , old_old_velocity_values(scratch.old_old_velocity_values)</div><div class="line">    , old_strain_rates(scratch.old_strain_rates)</div><div class="line">    , old_old_strain_rates(scratch.old_old_strain_rates)</div><div class="line">    ,</div><div class="line"></div><div class="line">    old_temperature_values(scratch.old_temperature_values)</div><div class="line">    , old_old_temperature_values(scratch.old_old_temperature_values)</div><div class="line">    , old_temperature_grads(scratch.old_temperature_grads)</div><div class="line">    , old_old_temperature_grads(scratch.old_old_temperature_grads)</div><div class="line">    , old_temperature_laplacians(scratch.old_temperature_laplacians)</div><div class="line">    , old_old_temperature_laplacians(scratch.old_old_temperature_laplacians)</div><div class="line">  {}</div><div class="line">} <span class="comment">// namespace Scratch</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The CopyData objects are even simpler than the Scratch objects as all
   they have to do is to store the results of local computations until
   they can be copied into the global matrix or vector objects. These
   structures therefore only need to provide a constructor, a copy
   operation, and some arrays for local matrix, local vectors and the
   relation between local and global degrees of freedom (a.k.a.
   <code>local_dof_indices</code>). Again, we have one such structure for
   each of the four operations we will parallelize using the <a class="el" href="namespaceWorkStream.html">WorkStream</a>
   class:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  <span class="keyword">namespace </span>CopyData</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesPreconditioner</div><div class="line">    {</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line">      StokesPreconditioner(<span class="keyword">const</span> StokesPreconditioner &amp;data);</div><div class="line">      StokesPreconditioner &amp;operator=(<span class="keyword">const</span> StokesPreconditioner &amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_matrix;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">      : local_matrix(stokes_fe.n_dofs_per_cell(), stokes_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesPreconditioner&lt;dim&gt;::StokesPreconditioner(</div><div class="line">      <span class="keyword">const</span> StokesPreconditioner &amp;data)</div><div class="line">      : local_matrix(data.local_matrix)</div><div class="line">      , local_dof_indices(data.local_dof_indices)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>StokesSystem : <span class="keyword">public</span> StokesPreconditioner&lt;dim&gt;</div><div class="line">    {</div><div class="line">      StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    StokesSystem&lt;dim&gt;::StokesSystem(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;stokes_fe)</div><div class="line">      : StokesPreconditioner&lt;dim&gt;(stokes_fe)</div><div class="line">      , local_rhs(stokes_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>TemperatureMatrix</div><div class="line">    {</div><div class="line">      TemperatureMatrix(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_mass_matrix;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   local_stiffness_matrix;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureMatrix&lt;dim&gt;::TemperatureMatrix(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">      : local_mass_matrix(temperature_fe.n_dofs_per_cell(),</div><div class="line">                          temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_stiffness_matrix(temperature_fe.n_dofs_per_cell(),</div><div class="line">                               temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(temperature_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">struct </span>TemperatureRHS</div><div class="line">    {</div><div class="line">      TemperatureRHS(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe);</div><div class="line"></div><div class="line">      <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       local_rhs;</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   matrix_for_bc;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    TemperatureRHS&lt;dim&gt;::TemperatureRHS(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;temperature_fe)</div><div class="line">      : local_rhs(temperature_fe.n_dofs_per_cell())</div><div class="line">      , local_dof_indices(temperature_fe.n_dofs_per_cell())</div><div class="line">      , matrix_for_bc(temperature_fe.n_dofs_per_cell(),</div><div class="line">                      temperature_fe.n_dofs_per_cell())</div><div class="line">    {}</div><div class="line">  } <span class="comment">// namespace CopyData</span></div><div class="line">}   <span class="comment">// namespace Assembly</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="ThecodeBoussinesqFlowProblemcodeclasstemplate"></a> 
   <h3>The <code>BoussinesqFlowProblem</code> class template</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   This is the declaration of the main class. It is very similar to <a class="el" href="step_31.html">step-31</a>
   but there are a number differences we will comment on below.</pre><p></code></p>
<p><code></p><pre>   The top of the class is essentially the same as in <a class="el" href="step_31.html">step-31</a>, listing the
   public methods and a set of private functions that do the heavy
   lifting. Compared to <a class="el" href="step_31.html">step-31</a> there are only two additions to this
   section: the function <code>get_cfl_number()</code> that computes the
   maximum CFL number over all cells which we then compute the global time
   step from, and the function <code>get_entropy_variation()</code> that is
   used in the computation of the entropy stabilization. It is akin to the
   <code>get_extrapolated_temperature_range()</code> we have used in <a class="el" href="step_31.html">step-31</a>
   for this purpose, but works on the entropy instead of the temperature
   instead.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">struct </span>Parameters;</div><div class="line">  BoussinesqFlowProblem(Parameters &amp;parameters);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_cfl_number() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">double</span> get_entropy_variation(<span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature) <span class="keyword">const</span>;</div><div class="line">  std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      solve();</div><div class="line">  <span class="keywordtype">void</span>                      output_results();</div><div class="line">  <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_strain_rates,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_old_strain_rates,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                average_temperature,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_entropy_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The first significant new component is the definition of a struct for
   the parameters according to the discussion in the introduction. This
   structure is initialized by reading from a parameter file during
   construction of this object.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  <span class="keyword">struct </span>Parameters</div><div class="line">  {</div><div class="line">    Parameters(<span class="keyword">const</span> std::string &amp;parameter_filename);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line">    <span class="keywordtype">void</span>        parse_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_global_refinement;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_adaptive_refinement;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span>         generate_graphical_output;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> graphical_output_interval;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> adaptive_refinement_interval;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> stabilization_alpha;</div><div class="line">    <span class="keywordtype">double</span> stabilization_c_R;</div><div class="line">    <span class="keywordtype">double</span> stabilization_beta;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stokes_velocity_degree;</div><div class="line">    <span class="keywordtype">bool</span>         use_locally_conservative_discretization;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temperature_degree;</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  Parameters &amp;parameters;</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The <code>pcout</code> (for <em>parallel <code>std::cout</code></em>)
   object is used to simplify writing output: each MPI process can use
   this to generate output as usual, but since each of these processes
   will (hopefully) produce the same output it will just be replicated
   many times over; with the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> class, only the output
   generated by one MPI process will actually be printed to screen,
   whereas the output by all the other threads will simply be forgotten.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The following member variables will then again be similar to those in
   <a class="el" href="step_31.html">step-31</a> (and to other tutorial programs). As mentioned in the
   introduction, we fully distribute computations, so we will have to use
   the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see <a class="el" href="step_40.html">step-40</a>) but the
   remainder of these variables is rather standard with two exceptions:</pre><p></code></p>
<p><code></p><pre><ul>
<li>The <code>mapping</code> variable is used to denote a higher-order
   polynomial mapping. As mentioned in the introduction, we use this
   mapping when forming integrals through quadrature for all cells that
   are adjacent to either the inner or outer boundaries of our domain
   where the boundary is curved.</li>
<li>In a bit of naming confusion, you will notice below that some of the
   variables from namespace <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> are taken from namespace
   <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">TrilinosWrappers::MPI</a> (such as the right hand side vectors) whereas
   others are not (such as the various matrices). This is due to legacy
   reasons. We will frequently have to query velocities
   and temperatures at arbitrary quadrature points; consequently, rather
   than importing ghost information of a vector whenever we need access
   to degrees of freedom that are relevant locally but owned by another
   processor, we solve linear systems in parallel but then immediately
   initialize a vector including ghost entries of the solution for further
   processing. The various <code>*_solution</code> vectors are therefore
   filled immediately after solving their respective linear system in
   parallel and will always contain values for all
   <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant degrees of freedom</a>;
   the fully distributed vectors that we obtain from the solution process
   and that only ever contain the
   <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned degrees of freedom</a> are
   destroyed immediately after the solution process and after we have
   copied the relevant values into the member variable vectors.</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keywordtype">double</span>                                    global_Omega_diameter;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>       stokes_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time_step;</div><div class="line"><span class="keywordtype">double</span>       old_time_step;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt;    Amg_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; Mp_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionJacobi&gt; T_preconditioner;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line"><span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line"><span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line"><span class="keywordtype">bool</span> rebuild_temperature_preconditioner;</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The next member variable, <code>computing_timer</code> is used to
   conveniently account for compute time spent in certain "sections" of
   the code that are repeatedly entered. For example, we will enter (and
   leave) sections for Stokes matrix assembly and would like to accumulate
   the run time spent in this section over all time steps. Every so many
   time steps as well as at the end of the program (through the destructor
   of the <a class="el" href="classTimerOutput.html">TimerOutput</a> class) we will then produce a nice summary of the
   times spent in the different sections into which we categorize the
   run-time of this program.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   After these member variables we have a number of auxiliary functions
   that have been broken out of the ones listed above. Specifically, there
   are first three functions that we call from <code>setup_dofs</code> and
   then the ones that do the assembling of linear systems:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_stokes_matrix(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line"><span class="keywordtype">void</span> setup_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning);</div><div class="line"><span class="keywordtype">void</span> setup_temperature_matrices(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioning,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioning);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Following the <a class="el" href="group__threads.html#MTWorkStream">task-based parallelization</a> paradigm,
   we split all the assembly routines into two parts: a first part that
   can do all the calculations on a certain cell without taking care of
   other threads, and a second part (which is writing the local data into
   the global matrices and vectors) which can be entered by only one
   thread at a time. In order to implement that, we provide functions for
   each of those two steps for all the four assembly routines that we use
   in this program. The following eight functions do exactly this:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keywordtype">void</span> local_assemble_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">  Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_stokes_system(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">  Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_stokes_system(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">  Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> local_assemble_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_velocity,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">  Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data);</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> copy_local_to_global_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Finally, we forward declare a member class that we will define later on
   and that will be used to compute a number of quantities from our
   solution vectors that we'd like to put into the output files for
   visualization.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  <span class="keyword">class </span>Postprocessor;</div><div class="line">};</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemclassimplementation"></a> 
   <h3>BoussinesqFlowProblem class implementation</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemParameters"></a> 
   <h4>BoussinesqFlowProblem::Parameters</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   Here comes the definition of the parameters for the Stokes problem. We
   allow to set the end time for the simulation, the level of refinements
   (both global and adaptive, which in the sum specify what maximum level
   the cells are allowed to have), and the interval between refinements in
   the time stepping.</pre><p></code></p>
<p><code></p><pre>   Then, we let the user specify constants for the stabilization parameters
   (as discussed in the introduction), the polynomial degree for the Stokes
   velocity space, whether to use the locally conservative discretization
   based on <a class="el" href="classFE__DGP.html">FE_DGP</a> elements for the pressure or not (<a class="el" href="classFE__Q.html">FE_Q</a> elements for
   pressure), and the polynomial degree for the temperature interpolation.</pre><p></code></p>
<p><code></p><pre>   The constructor checks for a valid input file (if not, a file with
   default parameters for the quantities is written), and eventually parses
   the parameters.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Parameters::Parameters(</div><div class="line">  <span class="keyword">const</span> std::string &amp;parameter_filename)</div><div class="line">  : end_time(1e8)</div><div class="line">  , initial_global_refinement(2)</div><div class="line">  , initial_adaptive_refinement(2)</div><div class="line">  , adaptive_refinement_interval(10)</div><div class="line">  , stabilization_alpha(2)</div><div class="line">  , stabilization_c_R(0.11)</div><div class="line">  , stabilization_beta(0.078)</div><div class="line">  , stokes_velocity_degree(2)</div><div class="line">  , use_locally_conservative_discretization(true)</div><div class="line">  , temperature_degree(2)</div><div class="line">{</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters(prm);</div><div class="line"></div><div class="line">  std::ifstream parameter_file(parameter_filename);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!parameter_file)</div><div class="line">    {</div><div class="line">      parameter_file.close();</div><div class="line"></div><div class="line">      std::ofstream parameter_out(parameter_filename);</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(parameter_out, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">        <span class="keyword">false</span>,</div><div class="line">        <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">          <span class="stringliteral">&quot;Input parameter file &lt;&quot;</span> + parameter_filename +</div><div class="line">          <span class="stringliteral">&quot;&gt; not found. Creating a template file of the same name.&quot;</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(parameter_file);</div><div class="line">  parse_parameters(prm);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Next we have a function that declares the parameters that we expect in
   the input file, together with their data types, default values and a
   description:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Parameters::declare_parameters(</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;End time&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;1e8&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The end time of the simulation in years.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Initial global refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The number of global refinement steps performed on &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;the initial coarse mesh, before the problem is first &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;solved there.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;The number of adaptive refinement steps performed after &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;initial global refinement.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;10&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;The number of time steps after which the mesh is to be &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;adapted based on computed error indicators.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Generate graphical output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Whether graphical output is to be generated or not. &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;You may not want to get graphical output if the number &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;of processors is large.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;50&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;The number of time steps between each generation of &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;graphical output files.&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;alpha&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(1, 2),</div><div class="line">                      <span class="stringliteral">&quot;The exponent in the entropy viscosity stabilization.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;c_R&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.11&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The c_R factor in the entropy viscosity &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;stabilization.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;beta&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.078&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;The beta factor in the artificial viscosity &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;stabilization. An appropriate value for 2d is 0.052 &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;and 0.078 for 3d.&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">      <span class="stringliteral">&quot;The polynomial degree to use for the velocity variables &quot;</span></div><div class="line">      <span class="stringliteral">&quot;in the Stokes system.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">      <span class="stringliteral">&quot;The polynomial degree to use for the temperature variable.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">      <span class="stringliteral">&quot;Whether to use a Stokes discretization that is locally &quot;</span></div><div class="line">      <span class="stringliteral">&quot;conservative at the expense of a larger number of degrees &quot;</span></div><div class="line">      <span class="stringliteral">&quot;of freedom, or to go with a cheaper discretization &quot;</span></div><div class="line">      <span class="stringliteral">&quot;that does not locally conserve mass (although it is &quot;</span></div><div class="line">      <span class="stringliteral">&quot;globally conservative.&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   And then we need a function that reads the contents of the
   <a class="el" href="classParameterHandler.html">ParameterHandler</a> object we get by reading the input file and puts the
   results into variables that store the values of the parameters we have
   previously declared:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Parameters::parse_parameters(</div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  end_time                  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;End time&quot;</span>);</div><div class="line">  initial_global_refinement = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Initial global refinement&quot;</span>);</div><div class="line">  initial_adaptive_refinement =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Initial adaptive refinement&quot;</span>);</div><div class="line"></div><div class="line">  adaptive_refinement_interval =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Time steps between mesh refinement&quot;</span>);</div><div class="line"></div><div class="line">  generate_graphical_output = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Generate graphical output&quot;</span>);</div><div class="line">  graphical_output_interval =</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Time steps between graphical output&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Stabilization parameters&quot;</span>);</div><div class="line">  {</div><div class="line">    stabilization_alpha = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;alpha&quot;</span>);</div><div class="line">    stabilization_c_R   = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;c_R&quot;</span>);</div><div class="line">    stabilization_beta  = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;beta&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#af29c20cde6d44186806d559beb468696">enter_subsection</a>(<span class="stringliteral">&quot;Discretization&quot;</span>);</div><div class="line">  {</div><div class="line">    stokes_velocity_degree =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Stokes velocity polynomial degree&quot;</span>);</div><div class="line">    temperature_degree = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Temperature polynomial degree&quot;</span>);</div><div class="line">    use_locally_conservative_discretization =</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Use locally conservative discretization&quot;</span>);</div><div class="line">  }</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a599462cacd492e2f712bf7369507dcff">leave_subsection</a>();</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemBoussinesqFlowProblem"></a> 
   <h4>BoussinesqFlowProblem::BoussinesqFlowProblem</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The constructor of the problem is very similar to the constructor in
   <a class="el" href="step_31.html">step-31</a>. What is different is the parallel communication: Trilinos uses
   a message passing interface (MPI) for data distribution. When entering
   the BoussinesqFlowProblem class, we have to decide how the parallelization
   is to be done. We choose a rather simple strategy and let all processors
   that are running the program work together, specified by the communicator
   <code>MPI_COMM_WORLD</code>. Next, we create the output stream (as we
   already did in <a class="el" href="step_18.html">step-18</a>) that only generates output on the first MPI
   process and is completely forgetful on all others. The implementation of
   this idea is to check the process number when <code>pcout</code> gets a
   true argument, and it uses the <code>std::cout</code> stream for
   output. If we are one processor five, for instance, then we will give a
   <code>false</code> argument to <code>pcout</code>, which means that the
   output of that processor will not be printed. With the exception of the
   mapping object (for which we use polynomials of degree 4) all but the
   final member variable are exactly the same as in <a class="el" href="step_31.html">step-31</a>.</pre><p></code></p>
<p><code></p><pre>   This final object, the <a class="el" href="classTimerOutput.html">TimerOutput</a> object, is then told to restrict
   output to the <code>pcout</code> stream (processor 0), and then we
   specify that we want to get a summary table at the end of the program
   which shows us wallclock times (as opposed to CPU times). We will
   manually also request intermediate summaries every so many time steps in
   the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function below.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem(Parameters &amp;parameters_)</div><div class="line">  : parameters(parameters_)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0))</div><div class="line">  ,</div><div class="line"></div><div class="line">  triangulation(MPI_COMM_WORLD,</div><div class="line">                typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing(</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement |</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening))</div><div class="line">  ,</div><div class="line"></div><div class="line">  global_Omega_diameter(0.)</div><div class="line">  ,</div><div class="line"></div><div class="line">  mapping(4)</div><div class="line">  ,</div><div class="line"></div><div class="line">  stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree),</div><div class="line">            dim,</div><div class="line">            (parameters.use_locally_conservative_discretization ?</div><div class="line">               static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;(</div><div class="line">                 <a class="code" href="classFE__DGP.html">FE_DGP</a>&lt;dim&gt;(parameters.stokes_velocity_degree - 1)) :</div><div class="line">               static_cast&lt;const <a class="code" href="classFiniteElement.html">FiniteElement</a>&lt;dim&gt; &amp;&gt;(</div><div class="line">                 <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(parameters.stokes_velocity_degree - 1))),</div><div class="line">            1)</div><div class="line">  ,</div><div class="line"></div><div class="line">  stokes_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  temperature_fe(parameters.temperature_degree)</div><div class="line">  , temperature_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , rebuild_stokes_matrix(true)</div><div class="line">  , rebuild_stokes_preconditioner(true)</div><div class="line">  , rebuild_temperature_matrices(true)</div><div class="line">  , rebuild_temperature_preconditioner(true)</div><div class="line">  ,</div><div class="line"></div><div class="line">  computing_timer(MPI_COMM_WORLD,</div><div class="line">                  pcout,</div><div class="line">                  <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary,</div><div class="line">                  <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="TheBoussinesqFlowProblemhelperfunctions"></a> 
   <h4>The BoussinesqFlowProblem helper functions</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemget_maximal_velocity"></a> 
   <h5>BoussinesqFlowProblem::get_maximal_velocity</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   Except for two small details, the function to compute the global maximum
   of the velocity is the same as in <a class="el" href="step_31.html">step-31</a>. The first detail is actually
   common to all functions that implement loops over all cells in the
   triangulation: When operating in parallel, each processor can only work
   on a chunk of cells since each processor only has a certain part of the
   entire triangulation. This chunk of cells that we want to work on is
   identified via a so-called <code>subdomain_id</code>, as we also did in
   <a class="el" href="step_18.html">step-18</a>. All we need to change is hence to perform the cell-related
   operations only on cells that are owned by the current process (as
   opposed to ghost or artificial cells), i.e. for which the subdomain id
   equals the number of the process ID. Since this is a commonly used
   operation, there is a shortcut for this operation: we can ask whether the
   cell is owned by the current processor using
   <code>cell-&gt;is_locally_owned()</code>.</pre><p></code></p>
<p><code></p><pre>   The second difference is the way we calculate the maximum value. Before,
   we could simply have a <code>double</code> variable that we checked
   against on each quadrature point for each cell. Now, we have to be a bit
   more careful since each processor only operates on a subset of
   cells. What we do is to first let each processor calculate the maximum
   among its cells, and then do a global communication operation
   <code><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a></code> that computes the maximum value among
   all the maximum values of the individual processors. MPI provides such a
   call, but it's even simpler to use the respective function in namespace
   <a class="el" href="namespaceUtilities_1_1MPI.html">Utilities::MPI</a> using the MPI communicator object since that will do the
   right thing even if we work without MPI and on a single machine only. The
   call to <code><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a></code> needs two arguments, namely the
   local maximum (input) and the MPI communicator, which is MPI_COMM_WORLD
   in this example.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.stokes_velocity_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(mapping,</div><div class="line">                          stokes_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_local_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_local_velocity =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_local_velocity, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemget_cfl_number"></a> 
   <h5>BoussinesqFlowProblem::get_cfl_number</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The next function does something similar, but we now compute the CFL
   number, i.e., maximal velocity on a cell divided by the cell
   diameter. This number is necessary to determine the time step size, as we
   use a semi-explicit time stepping scheme for the temperature equation
   (see <a class="el" href="step_31.html">step-31</a> for a discussion). We compute it in the same way as above:
   Compute the local maximum over all locally owned cells, then exchange it
   via MPI to find the global maximum.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_cfl_number()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.stokes_velocity_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(mapping,</div><div class="line">                          stokes_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_local_cfl = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.active_cell_iterators())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> max_local_velocity = 1e-10;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_local_velocity =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">        max_local_cfl =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_cfl, max_local_velocity / cell-&gt;diameter());</div><div class="line">      }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(max_local_cfl, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemget_entropy_variation"></a> 
   <h5>BoussinesqFlowProblem::get_entropy_variation</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   Next comes the computation of the global entropy variation
 \(\|E(T)-\bar{E}(T)\|_\infty\) where the entropy \(E\) is defined as
   discussed in the introduction.  This is needed for the evaluation of the
   stabilization in the temperature equation as explained in the
   introduction. The entropy variation is actually only needed if we use
 \(\alpha=2\) as a power in the residual computation. The infinity norm is
   computed by the maxima over quadrature points, as usual in discrete
   computations.</pre><p></code></p>
<p><code></p><pre>   In order to compute this quantity, we first have to find the
   space-average \(\bar{E}(T)\) and then evaluate the maximum. However, that
   means that we would need to perform two loops. We can avoid the overhead
   by noting that \(\|E(T)-\bar{E}(T)\|_\infty = \max\big(E_{\textrm{max}}(T)-\bar{E}(T), \bar{E}(T)-E_{\textrm{min}}(T)\big)\), i.e., the maximum out of the
   deviation from the average entropy in positive and negative
   directions. The four quantities we need for the latter formula (maximum
   entropy, minimum entropy, average entropy, area) can all be evaluated in
   the same loop over all cells, so we choose this simpler variant.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_entropy_variation(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (parameters.stabilization_alpha != 2)</div><div class="line">    <span class="keywordflow">return</span> 1.;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(parameters.temperature_degree + 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>       fe_values(temperature_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   In the two functions above we computed the maximum of numbers that were
   all non-negative, so we knew that zero was certainly a lower bound. On
   the other hand, here we need to find the maximum deviation from the
   average value, i.e., we will need to know the maximal and minimal
   values of the entropy for which we don't a priori know the sign.</pre><p></code></p>
<p><code></p><pre>   To compute it, we can therefore start with the largest and smallest
   possible values we can store in a double precision number: The minimum
   is initialized with a bigger and the maximum with a smaller number than
   any one that is going to appear. We are then guaranteed that these
   numbers will be overwritten in the loop on the first cell or, if this
   processor does not own any cells, in the communication step at the
   latest. The following loop then computes the minimum and maximum local
   entropy as well as keeps track of the area/volume of the part of the
   domain we locally own and the integral over the entropy on it:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keywordtype">double</span> min_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">       max_entropy = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(), area = 0,</div><div class="line">       entropy_integrated = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                    old_temperature_values);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                    old_old_temperature_values);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> T =</div><div class="line">            (old_temperature_values[q] + old_old_temperature_values[q]) / 2;</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> entropy =</div><div class="line">            ((T - average_temperature) * (T - average_temperature));</div><div class="line"></div><div class="line">          min_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_entropy, entropy);</div><div class="line">          max_entropy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_entropy, entropy);</div><div class="line">          area += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">          entropy_integrated += fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q) * entropy;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Now we only need to exchange data between processors: we need to sum
   the two integrals (<code>area</code>, <code>entropy_integrated</code>),
   and get the extrema for maximum and minimum. We could do this through
   four different data exchanges, but we can it with two:
   <a class="el" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> also exists in a variant that takes an array of
   values that are all to be summed up. And we can also utilize the
   <a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a> function by realizing that forming the minimum over
   the minimal entropies equals forming the negative of the maximum over
   the negative of the minimal entropies; this maximum can then be
   combined with forming the maximum over the maximal entropies.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> local_sums[2]   = {entropy_integrated, area},</div><div class="line">             local_maxima[2] = {-min_entropy, max_entropy};</div><div class="line"><span class="keywordtype">double</span> global_sums[2], global_maxima[2];</div><div class="line"></div><div class="line"><a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(local_sums, MPI_COMM_WORLD, global_sums);</div><div class="line"><a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(local_maxima, MPI_COMM_WORLD, global_maxima);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Having computed everything this way, we can then compute the average
   entropy and find the \(L^\infty\) norm by taking the larger of the
   deviation of the maximum or minimum from the average:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_entropy = global_sums[0] / global_sums[1];</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> entropy_diff    = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(global_maxima[1] - average_entropy,</div><div class="line">                                       average_entropy - (-global_maxima[0]));</div><div class="line">  <span class="keywordflow">return</span> entropy_diff;</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemget_extrapolated_temperature_range"></a> 
   <h5>BoussinesqFlowProblem::get_extrapolated_temperature_range</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The next function computes the minimal and maximal value of the
   extrapolated temperature over the entire domain. Again, this is only a
   slightly modified version of the respective function in <a class="el" href="step_31.html">step-31</a>. As in
   the function above, we collect local minima and maxima and then compute
   the global extrema using the same trick as above.</pre><p></code></p>
<p><code></p><pre>   As already discussed in <a class="el" href="step_31.html">step-31</a>, the function needs to distinguish
   between the first and all following time steps because it uses a higher
   order temperature extrapolation scheme when at least two previous time
   steps are available.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          parameters.temperature_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>       fe_values(mapping,</div><div class="line">                          temperature_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> min_local_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">         max_local_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                          old_old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                  (1. + time_step / old_time_step) *</div><div class="line">                    old_temperature_values[q] -</div><div class="line">                  time_step / old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">                min_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_local_temperature, temperature);</div><div class="line">                max_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.active_cell_iterators())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                min_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_local_temperature, temperature);</div><div class="line">                max_local_temperature =</div><div class="line">                  <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> local_extrema[2] = {-min_local_temperature, max_local_temperature};</div><div class="line">  <span class="keywordtype">double</span> global_extrema[2];</div><div class="line">  <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(local_extrema, MPI_COMM_WORLD, global_extrema);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> std::make_pair(-global_extrema[0], global_extrema[1]);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemcompute_viscosity"></a> 
   <h5>BoussinesqFlowProblem::compute_viscosity</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The function that calculates the viscosity is purely local and so needs
   no communication at all. It is mostly the same as in <a class="el" href="step_31.html">step-31</a> but with an
   updated formulation of the viscosity if \(\alpha=2\) is chosen:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;                 old_old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;         old_old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_strain_rates,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a>&gt; &amp;old_old_strain_rates,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_u_infty,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_T_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                average_temperature,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">    <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">  <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">        (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_rate =</div><div class="line">        (old_strain_rates[q] + old_old_strain_rates[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> T = (old_temperature[q] + old_old_temperature[q]) / 2;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">        (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">        u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">        EquationData::kappa *</div><div class="line">        (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">        2;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma =</div><div class="line">        ((EquationData::radiogenic_heating * EquationData::density(T) +</div><div class="line">          2 * EquationData::eta * strain_rate * strain_rate) /</div><div class="line">         (EquationData::density(T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> residual = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(dT_dt + u_grad_T - kappa_Delta_T - gamma);</div><div class="line">      <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">        residual *= <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(T - average_temperature);</div><div class="line"></div><div class="line">      max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">      max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_viscosity =</div><div class="line">    (parameters.stabilization_beta * max_velocity * cell_diameter);</div><div class="line">  <span class="keywordflow">if</span> (timestep_number == 0)</div><div class="line">    <span class="keywordflow">return</span> max_viscosity;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(old_time_step &gt; 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> entropy_viscosity;</div><div class="line">      <span class="keywordflow">if</span> (parameters.stabilization_alpha == 2)</div><div class="line">        entropy_viscosity =</div><div class="line">          (parameters.stabilization_c_R * cell_diameter * cell_diameter *</div><div class="line">           max_residual / global_entropy_variation);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        entropy_viscosity =</div><div class="line">          (parameters.stabilization_c_R * cell_diameter *</div><div class="line">           global_Omega_diameter * max_velocity * max_residual /</div><div class="line">           (global_u_infty * global_T_variation));</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(max_viscosity, entropy_viscosity);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="TheBoussinesqFlowProblemsetupfunctions"></a> 
   <h4>The BoussinesqFlowProblem setup functions</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The following three functions set up the Stokes matrix, the matrix used
   for the Stokes preconditioner, and the temperature matrix. The code is
   mostly the same as in <a class="el" href="step_31.html">step-31</a>, but it has been broken out into three
   functions of their own for simplicity.</pre><p></code></p>
<p><code></p><pre>   The main functional difference between the code here and that in <a class="el" href="step_31.html">step-31</a>
   is that the matrices we want to set up are distributed across multiple
   processors. Since we still want to build up the sparsity pattern first
   for efficiency reasons, we could continue to build the <em>entire</em>
   sparsity pattern as a <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a>, as we did in
   <a class="el" href="step_31.html">step-31</a>. However, that would be inefficient: every processor would build
   the same sparsity pattern, but only initialize a small part of the matrix
   using it. It also violates the principle that every processor should only
   work on those cells it owns (and, if necessary the layer of ghost cells
   around it).</pre><p></code></p>
<p><code></p><pre>   Rather, we use an object of type <a class="el" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a>,
   which is (obviously) a wrapper around a sparsity pattern object provided
   by Trilinos. The advantage is that the Trilinos sparsity pattern class
   can communicate across multiple processors: if this processor fills in
   all the nonzero entries that result from the cells it owns, and every
   other processor does so as well, then at the end after some MPI
   communication initiated by the <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> call, we will have
   the globally assembled sparsity pattern available with which the global
   matrix can be initialized.</pre><p></code></p>
<p><code></p><pre>   There is one important aspect when initializing Trilinos sparsity
   patterns in parallel: In addition to specifying the locally owned rows
   and columns of the matrices via the <code>stokes_partitioning</code> index set, we
   also supply information about all the rows we are possibly going to write
   into when assembling on a certain processor. The set of locally relevant
   rows contains all such rows (possibly also a few unnecessary ones, but it
   is difficult to find the exact row indices before actually getting
   indices on all cells and resolving constraints). This additional
   information allows to exactly determine the structure for the
   off-processor data found during assembly. While Trilinos matrices are
   able to collect this information on the fly as well (when initializing
   them from some other reinit method), it is less efficient and leads to
   problems when assembling matrices with multiple threads. In this program,
   we pessimistically assume that only one processor at a time can write
   into the matrix while assembly (whereas the computation is parallel),
   which is fine for Trilinos matrices. In practice, one can do better by
   hinting <a class="el" href="namespaceWorkStream.html">WorkStream</a> at cells that do not share vertices, allowing for
   parallelism among those cells (see the graph coloring algorithms and
   <a class="el" href="namespaceWorkStream.html">WorkStream</a> with colored iterators argument). However, that only works
   when only one MPI processor is present because Trilinos' internal data
   structures for accumulating off-processor data on the fly are not thread
   safe. With the initialization presented here, there is no such problem
   and one could safely introduce graph coloring for this algorithm.</pre><p></code></p>
<p><code></p><pre>   The only other change we need to make is to tell the
   <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function that it is only supposed to
   work on a subset of cells, namely the ones whose
   <code>subdomain_id</code> equals the number of the current processor, and
   to ignore all other cells.</pre><p></code></p>
<p><code></p><pre>   This strategy is replicated across all three of the following functions.</pre><p></code></p>
<p><code></p><pre>   Note that Trilinos matrices store the information contained in the
   sparsity patterns, so we can safely release the <code>sp</code> variable
   once the matrix has been given the sparsity structure.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_stokes_matrix(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">{</div><div class="line">  stokes_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning,</div><div class="line">                                            stokes_partitioning,</div><div class="line">                                            stokes_relevant_partitioning,</div><div class="line">                                            MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(stokes_dof_handler,</div><div class="line">                                  coupling,</div><div class="line">                                  sp,</div><div class="line">                                  stokes_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  stokes_matrix.reinit(sp);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_partitioning,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;IndexSet&gt; &amp;stokes_relevant_partitioning)</div><div class="line">{</div><div class="line">  Amg_preconditioner.reset();</div><div class="line">  Mp_preconditioner.reset();</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparsityPattern.html">TrilinosWrappers::BlockSparsityPattern</a> sp(stokes_partitioning,</div><div class="line">                                            stokes_partitioning,</div><div class="line">                                            stokes_relevant_partitioning,</div><div class="line">                                            MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(stokes_dof_handler,</div><div class="line">                                  coupling,</div><div class="line">                                  sp,</div><div class="line">                                  stokes_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.reinit(sp);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_temperature_matrices(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_partitioner,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classIndexSet.html">IndexSet</a> &amp;temperature_relevant_partitioner)</div><div class="line">{</div><div class="line">  T_preconditioner.reset();</div><div class="line">  temperature_mass_matrix.clear();</div><div class="line">  temperature_stiffness_matrix.clear();</div><div class="line">  temperature_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(temperature_partitioner,</div><div class="line">                                       temperature_partitioner,</div><div class="line">                                       temperature_relevant_partitioner,</div><div class="line">                                       MPI_COMM_WORLD);</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                  sp,</div><div class="line">                                  temperature_constraints,</div><div class="line">                                  <span class="keyword">false</span>,</div><div class="line">                                  <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                    MPI_COMM_WORLD));</div><div class="line">  sp.compress();</div><div class="line"></div><div class="line">  temperature_matrix.reinit(sp);</div><div class="line">  temperature_mass_matrix.reinit(sp);</div><div class="line">  temperature_stiffness_matrix.reinit(sp);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The remainder of the setup function (after splitting out the three
   functions above) mostly has to deal with the things we need to do for
   parallelization across processors. Because setting all of this up is a
   significant compute time expense of the program, we put everything we do
   here into a timer group so that we can get summary information about the
   fraction of time spent in this part of the program at its end.</pre><p></code></p>
<p><code></p><pre>   At the top as usual we enumerate degrees of freedom and sort them by
   component/block, followed by writing their numbers to the screen from
   processor zero. The DoFHandler::distributed_dofs() function, when applied
   to a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, sorts degrees of
   freedom in such a way that all degrees of freedom associated with
   subdomain zero come before all those associated with subdomain one,
   etc. For the Stokes part, this entails, however, that velocities and
   pressures become intermixed, but this is trivially solved by sorting
   again by blocks; it is worth noting that this latter operation leaves the
   relative ordering of all velocities and pressures alone, i.e. within the
   velocity block we will still have all those associated with subdomain
   zero before all velocities associated with subdomain one, etc. This is
   important since we store each of the blocks of this matrix distributed
   across all processors and want this to be done in such a way that each
   processor stores that part of the matrix that is roughly equal to the
   degrees of freedom located on those cells that it will actually work on.</pre><p></code></p>
<p><code></p><pre>   When printing the numbers of degrees of freedom, note that these numbers
   are going to be large if we use many processors. Consequently, we let the
   stream put a comma separator in between every three digits. The state of
   the stream, using the locale, is saved from before to after this
   operation. While slightly opaque, the code works because the default
   locale (which we get using the constructor call
   <code>std::locale("")</code>) implies printing numbers with a comma
   separator for every third digit (i.e., thousands, millions, billions).</pre><p></code></p>
<p><code></p><pre>   In this function as well as many below, we measure how much time
   we spend here and collect that in a section called "Setup dof
   systems" across function invocations. This is done using an
   <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> object that gets a timer going in the section
   with above name of the <code>computing_timer</code> object upon construction
   of the local variable; the timer is stopped again when the
   destructor of the <code>timing_section</code> variable is called.  This, of
   course, happens either at the end of the function, or if we leave
   the function through a <code>return</code> statement or when an exception is
   thrown somewhere &ndash; in other words, whenever we leave this
   function in any way. The use of such "scope" objects therefore
   makes sure that we do not have to manually add code that tells
   the timer to stop at every location where this function may be
   left.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timing_section(computing_timer, <span class="stringliteral">&quot;Setup dof systems&quot;</span>);</div><div class="line"></div><div class="line">  stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">  stokes_sub_blocks[dim] = 1;</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                     n_p = stokes_dofs_per_block[1],</div><div class="line">                     n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::locale s = pcout.get_stream().getloc();</div><div class="line">  pcout.get_stream().imbue(std::locale(<span class="stringliteral">&quot;&quot;</span>));</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; n_u</div><div class="line">        &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">  pcout.get_stream().imbue(s);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   After this, we have to set up the various partitioners (of type
   <code><a class="el" href="classIndexSet.html">IndexSet</a></code>, see the introduction) that describe which parts
   of each matrix or vector will be stored where, then call the functions
   that actually set up the matrices, and at the end also resize the
   various vectors we keep around in this program.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">std::vector&lt;IndexSet&gt; stokes_partitioning, stokes_relevant_partitioning;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>              temperature_partitioning(n_T),</div><div class="line">  temperature_relevant_partitioning(n_T);</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> stokes_relevant_set;</div><div class="line">{</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> stokes_index_set = stokes_dof_handler.locally_owned_dofs();</div><div class="line">  stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u));</div><div class="line">  stokes_partitioning.push_back(stokes_index_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(stokes_dof_handler,</div><div class="line">                                          stokes_relevant_set);</div><div class="line">  stokes_relevant_partitioning.push_back(</div><div class="line">    stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(0, n_u));</div><div class="line">  stokes_relevant_partitioning.push_back(</div><div class="line">    stokes_relevant_set.<a class="code" href="classIndexSet.html#add590b083cdde3fa61e637a058b51835">get_view</a>(n_u, n_u + n_p));</div><div class="line"></div><div class="line">  temperature_partitioning = temperature_dof_handler.locally_owned_dofs();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(</div><div class="line">    temperature_dof_handler, temperature_relevant_partitioning);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Following this, we can compute constraints for the solution vectors,
   including hanging node constraints and homogeneous and inhomogeneous
   boundary values for the Stokes and temperature fields. Note that as for
   everything else, the constraint objects can not hold <em>all</em>
   constraints on every processor. Rather, each processor needs to store
   only those that are actually necessary for correctness given that it
   only assembles linear systems on cells it owns. As discussed in the
   <a class="el" href="DEALGlossary.html#distributed_paper">this paper</a>, the set of constraints we need to
   know about is exactly the set of constraints on all locally relevant
   degrees of freedom, so this is what we use to initialize the constraint
   objects.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">{</div><div class="line">  stokes_constraints.clear();</div><div class="line">  stokes_constraints.reinit(stokes_relevant_set);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                          stokes_constraints);</div><div class="line"></div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocity_components(0);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    stokes_dof_handler,</div><div class="line">    0,</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(dim + 1),</div><div class="line">    stokes_constraints,</div><div class="line">    stokes_fe.component_mask(velocity_components));</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">  no_normal_flux_boundaries.insert(1);</div><div class="line">  <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                  0,</div><div class="line">                                                  no_normal_flux_boundaries,</div><div class="line">                                                  stokes_constraints,</div><div class="line">                                                  mapping);</div><div class="line">  stokes_constraints.close();</div><div class="line">}</div><div class="line">{</div><div class="line">  temperature_constraints.clear();</div><div class="line">  temperature_constraints.reinit(temperature_relevant_partitioning);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                          temperature_constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    temperature_dof_handler,</div><div class="line">    0,</div><div class="line">    EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">    temperature_constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    temperature_dof_handler,</div><div class="line">    1,</div><div class="line">    EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">    temperature_constraints);</div><div class="line">  temperature_constraints.close();</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   All this done, we can then initialize the various matrix and vector
   objects to their proper sizes. At the end, we also record that all
   matrices and preconditioners have to be re-computed at the beginning of
   the next time step. Note how we initialize the vectors for the Stokes
   and temperature right hand sides: These are writable vectors (last
   boolean argument set to <code>true</code>) that have the correct one-to-one
   partitioning of locally owned elements but are still given the relevant
   partitioning for means of figuring out the vector entries that are
   going to be set right away. As for matrices, this allows for writing
   local contributions into the vector with multiple threads (always
   assuming that the same vector entry is not accessed by multiple threads
   at the same time). The other vectors only allow for read access of
   individual elements, including ghosts, but are not suitable for
   solvers.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  setup_stokes_matrix(stokes_partitioning, stokes_relevant_partitioning);</div><div class="line">  setup_stokes_preconditioner(stokes_partitioning,</div><div class="line">                              stokes_relevant_partitioning);</div><div class="line">  setup_temperature_matrices(temperature_partitioning,</div><div class="line">                             temperature_relevant_partitioning);</div><div class="line"></div><div class="line">  stokes_rhs.reinit(stokes_partitioning,</div><div class="line">                    stokes_relevant_partitioning,</div><div class="line">                    MPI_COMM_WORLD,</div><div class="line">                    <span class="keyword">true</span>);</div><div class="line">  stokes_solution.reinit(stokes_relevant_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_stokes_solution.reinit(stokes_solution);</div><div class="line"></div><div class="line">  temperature_rhs.reinit(temperature_partitioning,</div><div class="line">                         temperature_relevant_partitioning,</div><div class="line">                         MPI_COMM_WORLD,</div><div class="line">                         <span class="keyword">true</span>);</div><div class="line">  temperature_solution.reinit(temperature_relevant_partitioning,</div><div class="line">                              MPI_COMM_WORLD);</div><div class="line">  old_temperature_solution.reinit(temperature_solution);</div><div class="line">  old_old_temperature_solution.reinit(temperature_solution);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix              = <span class="keyword">true</span>;</div><div class="line">  rebuild_stokes_preconditioner      = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_matrices       = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="TheBoussinesqFlowProblemassemblyfunctions"></a> 
   <h4>The BoussinesqFlowProblem assembly functions</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   Following the discussion in the introduction and in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a>
   module, we split the assembly functions into different parts:</pre><p></code></p>
<p><code></p><pre>   <ul>
<li>
<p class="startli">The local calculations of matrices and right hand sides, given
   a certain cell as input (these functions are named
   <code>local_assemble_*</code> below). The resulting function is, in other
   words, essentially the body of the loop over all cells in <a class="el" href="step_31.html">step-31</a>. Note,
   however, that these functions store the result from the local
   calculations in variables of classes from the CopyData namespace.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">These objects are then given to the second step which writes the
   local data into the global data structures (these functions are named
   <code>copy_local_to_global_*</code> below). These functions are pretty
   trivial.</p>
<p class="endli"></p>
</li>
<li>
These two subfunctions are then used in the respective assembly
   routine (called <code>assemble_*</code> below), where a <a class="el" href="namespaceWorkStream.html">WorkStream</a> object
   is set up and runs over all the cells that belong to the processor's
   subdomain.  </li>
</ul>
</pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="Stokespreconditionerassembly"></a> 
   <h5>Stokes preconditioner assembly</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   Let us start with the functions that builds the Stokes
   preconditioner. The first two of these are pretty trivial, given the
   discussion above. Note in particular that the main point in using the
   scratch data object is that we want to avoid allocating any objects on
   the free space each time we visit a new cell. As a consequence, the
   assembly function below only has automatic local variables, and
   everything else is accessed through the scratch data object, which is
   allocated only once before we start the loop over all cells:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">  Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values.reinit(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  data.local_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.grad_phi_u[k] =</div><div class="line">            scratch.stokes_fe_values[velocities].gradient(k, q);</div><div class="line">          scratch.phi_p[k] = scratch.stokes_fe_values[pressure].value(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          data.local_matrix(i, j) +=</div><div class="line">            (EquationData::eta *</div><div class="line">               <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(scratch.grad_phi_u[i], scratch.grad_phi_u[j]) +</div><div class="line">             (1. / EquationData::eta) * EquationData::pressure_scaling *</div><div class="line">               EquationData::pressure_scaling *</div><div class="line">               (scratch.phi_p[i] * scratch.phi_p[j])) *</div><div class="line">            scratch.stokes_fe_values.JxW(q);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_stokes_preconditioner(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  stokes_constraints.distribute_local_to_global(data.local_matrix,</div><div class="line">                                                data.local_dof_indices,</div><div class="line">                                                stokes_preconditioner_matrix);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Now for the function that actually puts things together, using the
   <a class="el" href="namespaceWorkStream.html">WorkStream</a> functions.  <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> needs a start and end iterator to
   enumerate the cells it is supposed to work on. Typically, one would use
   <a class="el" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">DoFHandler::begin_active()</a> and <a class="el" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">DoFHandler::end()</a> for that but here we
   actually only want the subset of cells that in fact are owned by the
   current processor. This is where the <a class="el" href="classFilteredIterator.html">FilteredIterator</a> class comes into
   play: you give it a range of cells and it provides an iterator that only
   iterates over that subset of cells that satisfy a certain predicate (a
   predicate is a function of one argument that either returns true or
   false). The predicate we use here is <a class="el" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>,
   i.e., it returns true exactly if the cell is owned by the current
   processor. The resulting iterator range is then exactly what we need.</pre><p></code></p>
<p><code></p><pre>   With this obstacle out of the way, we call the <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>
   function with this set of cells, scratch and copy objects, and
   with pointers to two functions: the local assembly and
   copy-local-to-global function. These functions need to have very
   specific signatures: three arguments in the first and one
   argument in the latter case (see the documentation of the
   <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> function for the meaning of these arguments).
   Note how we use a lambda functions to
   create a function object that satisfies this requirement. It uses
   function arguments for the local assembly function that specify
   cell, scratch data, and copy data, as well as function argument
   for the copy function that expects the
   data to be written into the global matrix (also see the discussion in
   <a class="el" href="step_13.html">step-13</a>'s <code>assemble_linear_system()</code> function). On the other
   hand, the implicit zeroth argument of member functions (namely
   the <code>this</code> pointer of the object on which that member
   function is to operate on) is <em>bound</em> to the
   <code>this</code> pointer of the current function and is captured. The
   <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> function, as a consequence, does not need to know
   anything about the object these functions work on.</pre><p></code></p>
<p><code></p><pre>   When the <a class="el" href="namespaceWorkStream.html">WorkStream</a> is executed, it will create several local assembly
   routines of the first kind for several cells and let some available
   processors work on them. The function that needs to be synchronized,
   i.e., the write operation into the global matrix, however, is executed by
   only one thread at a time in the prescribed order. Of course, this only
   holds for the parallelization on a single MPI process. Different MPI
   processes will have their own <a class="el" href="namespaceWorkStream.html">WorkStream</a> objects and do that work
   completely independently (and in different memory spaces). In a
   distributed calculation, some data will accumulate at degrees of freedom
   that are not owned by the respective processor. It would be inefficient
   to send data around every time we encounter such a dof. What happens
   instead is that the Trilinos sparse matrix will keep that data and send
   it to the owner at the end of assembly, by calling the
   <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> command.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">{</div><div class="line">  stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::StokesPreconditioner&lt;dim&gt; &amp;        scratch,</div><div class="line">           Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;       data) {</div><div class="line">      this-&gt;local_assemble_stokes_preconditioner(cell, scratch, data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::StokesPreconditioner&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_stokes_preconditioner(data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             stokes_dof_handler.begin_active()),</div><div class="line">                  CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             stokes_dof_handler.end()),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  Assembly::Scratch::StokesPreconditioner&lt;dim&gt;(</div><div class="line">                    stokes_fe,</div><div class="line">                    quadrature_formula,</div><div class="line">                    mapping,</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>),</div><div class="line">                  Assembly::CopyData::StokesPreconditioner&lt;dim&gt;(stokes_fe));</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The final function in this block initiates assembly of the Stokes
   preconditioner matrix and then in fact builds the Stokes
   preconditioner. It is mostly the same as in the serial case. The only
   difference to <a class="el" href="step_31.html">step-31</a> is that we use a Jacobi preconditioner for the
   pressure mass matrix instead of IC, as discussed in the introduction.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Build Stokes preconditioner&quot;</span>);</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                   stokes_fe.component_mask(</div><div class="line">                                     velocity_components),</div><div class="line">                                   constant_modes);</div><div class="line"></div><div class="line">  Mp_preconditioner =</div><div class="line">    std::make_shared&lt;TrilinosWrappers::PreconditionJacobi&gt;();</div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> Amg_data;</div><div class="line">  Amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">  Amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">  Amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">  Amg_data.smoother_sweeps       = 2;</div><div class="line">  Amg_data.aggregation_threshold = 0.02;</div><div class="line"></div><div class="line">  Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line">  Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                 Amg_data);</div><div class="line"></div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="Stokessystemassembly"></a> 
   <h5>Stokes system assembly</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The next three functions implement the assembly of the Stokes system,
   again split up into a part performing local calculations, one for writing
   the local data into the global matrix and vector, and one for actually
   running the loop over all cells with the help of the <a class="el" href="namespaceWorkStream.html">WorkStream</a>
   class. Note that the assembly of the Stokes matrix needs only to be done
   in case we have changed the mesh. Otherwise, just the
   (temperature-dependent) right hand side needs to be calculated
   here. Since we are working with distributed matrices and vectors, we have
   to call the respective <code><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></code> functions in the end of
   the assembly in order to send non-local data to the owner process.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_stokes_system(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">  Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.stokes_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.stokes_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> temperature_cell(</div><div class="line">    &amp;triangulation, cell-&gt;level(), cell-&gt;index(), &amp;temperature_dof_handler);</div><div class="line">  scratch.temperature_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(temperature_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">    data.local_matrix = 0;</div><div class="line">  data.local_rhs = 0;</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_temperature_solution, scratch.old_temperature_values);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = scratch.old_temperature_values[q];</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.phi_u[k] = scratch.stokes_fe_values[velocities].value(k, q);</div><div class="line">          <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">            {</div><div class="line">              scratch.grads_phi_u[k] =</div><div class="line">                scratch.stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">              scratch.div_phi_u[k] =</div><div class="line">                scratch.stokes_fe_values[velocities].divergence(k, q);</div><div class="line">              scratch.phi_p[k] =</div><div class="line">                scratch.stokes_fe_values[pressure].value(k, q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            data.local_matrix(i, j) +=</div><div class="line">              (EquationData::eta * 2 *</div><div class="line">                 (scratch.grads_phi_u[i] * scratch.grads_phi_u[j]) -</div><div class="line">               (EquationData::pressure_scaling * scratch.div_phi_u[i] *</div><div class="line">                scratch.phi_p[j]) -</div><div class="line">               (EquationData::pressure_scaling * scratch.phi_p[i] *</div><div class="line">                scratch.div_phi_u[j])) *</div><div class="line">              scratch.stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> gravity = EquationData::gravity_vector(</div><div class="line">        scratch.stokes_fe_values.quadrature_point(q));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        data.local_rhs(i) += (EquationData::density(old_temperature) *</div><div class="line">                              gravity * scratch.phi_u[i]) *</div><div class="line">                             scratch.stokes_fe_values.JxW(q);</div><div class="line">    }</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_stokes_system(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_constraints.distribute_local_to_global(data.local_matrix,</div><div class="line">                                                  data.local_rhs,</div><div class="line">                                                  data.local_dof_indices,</div><div class="line">                                                  stokes_matrix,</div><div class="line">                                                  stokes_rhs);</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    stokes_constraints.distribute_local_to_global(data.local_rhs,</div><div class="line">                                                  data.local_dof_indices,</div><div class="line">                                                  stokes_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Assemble Stokes system&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix = 0;</div><div class="line"></div><div class="line">  stokes_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.stokes_velocity_degree + 1);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               stokes_dof_handler.begin_active()),</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(), stokes_dof_handler.end()),</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::StokesSystem&lt;dim&gt; &amp;                scratch,</div><div class="line">           Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;               data) {</div><div class="line">      this-&gt;local_assemble_stokes_system(cell, scratch, data);</div><div class="line">    },</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::StokesSystem&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_stokes_system(data);</div><div class="line">    },</div><div class="line">    Assembly::Scratch::StokesSystem&lt;dim&gt;(</div><div class="line">      stokes_fe,</div><div class="line">      mapping,</div><div class="line">      quadrature_formula,</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">       (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0))),</div><div class="line">      temperature_fe,</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>),</div><div class="line">    Assembly::CopyData::StokesSystem&lt;dim&gt;(stokes_fe));</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  stokes_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  pcout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="Temperaturematrixassembly"></a> 
   <h5>Temperature matrix assembly</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The task to be performed by the next three functions is to calculate a
   mass matrix and a Laplace matrix on the temperature system. These will be
   combined in order to yield the semi-implicit time stepping matrix that
   consists of the mass matrix plus a time step-dependent weight factor
   times the Laplace matrix. This function is again essentially the body of
   the loop over all cells from <a class="el" href="step_31.html">step-31</a>.</pre><p></code></p>
<p><code></p><pre>   The two following functions perform similar services as the ones above.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">  Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.temperature_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.reinit(cell);</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  data.local_mass_matrix      = 0;</div><div class="line">  data.local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.grad_phi_T[k] =</div><div class="line">            scratch.temperature_fe_values.shape_grad(k, q);</div><div class="line">          scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          {</div><div class="line">            data.local_mass_matrix(i, j) +=</div><div class="line">              (scratch.phi_T[i] * scratch.phi_T[j] *</div><div class="line">               scratch.temperature_fe_values.JxW(q));</div><div class="line">            data.local_stiffness_matrix(i, j) +=</div><div class="line">              (EquationData::kappa * scratch.grad_phi_T[i] *</div><div class="line">               scratch.grad_phi_T[j] * scratch.temperature_fe_values.JxW(q));</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_temperature_matrix(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  temperature_constraints.distribute_local_to_global(data.local_mass_matrix,</div><div class="line">                                                     data.local_dof_indices,</div><div class="line">                                                     temperature_mass_matrix);</div><div class="line">  temperature_constraints.distribute_local_to_global(</div><div class="line">    data.local_stiffness_matrix,</div><div class="line">    data.local_dof_indices,</div><div class="line">    temperature_stiffness_matrix);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;   Assemble temperature matrices&quot;</span>);</div><div class="line">  temperature_mass_matrix      = 0;</div><div class="line">  temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree + 2);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               temperature_dof_handler.begin_active()),</div><div class="line">    CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">               temperature_dof_handler.end()),</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           Assembly::Scratch::TemperatureMatrix&lt;dim&gt; &amp;           scratch,</div><div class="line">           Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;          data) {</div><div class="line">      this-&gt;local_assemble_temperature_matrix(cell, scratch, data);</div><div class="line">    },</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::TemperatureMatrix&lt;dim&gt; &amp;data) {</div><div class="line">      this-&gt;copy_local_to_global_temperature_matrix(data);</div><div class="line">    },</div><div class="line">    Assembly::Scratch::TemperatureMatrix&lt;dim&gt;(temperature_fe,</div><div class="line">                                              mapping,</div><div class="line">                                              quadrature_formula),</div><div class="line">    Assembly::CopyData::TemperatureMatrix&lt;dim&gt;(temperature_fe));</div><div class="line"></div><div class="line">  temperature_mass_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  temperature_stiffness_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  rebuild_temperature_matrices       = <span class="keyword">false</span>;</div><div class="line">  rebuild_temperature_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="Temperaturerighthandsideassembly"></a> 
   <h5>Temperature right hand side assembly</h5>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   This is the last assembly function. It calculates the right hand side of
   the temperature system, which includes the convection and the
   stabilization terms. It includes a lot of evaluations of old solutions at
   the quadrature points (which are necessary for calculating the artificial
   viscosity of stabilization), but is otherwise similar to the other
   assembly functions. Notice, once again, how we resolve the dilemma of
   having inhomogeneous boundary conditions, by just making a right hand
   side at this point (compare the comments for the <code><a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project()</a></code>
   function above): We create some matrix columns with exactly the values
   that would be entered for the temperature stiffness matrix, in case we
   have inhomogeneously constrained dofs. That will account for the correct
   balance of the right hand side vector with the matrix system of
   temperature.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::local_assemble_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_velocity,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_entropy_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">  Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch.temperature_fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch.temperature_fe_values.n_quadrature_points;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  data.local_rhs     = 0;</div><div class="line">  data.matrix_for_bc = 0;</div><div class="line">  cell-&gt;get_dof_indices(data.local_dof_indices);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell);</div><div class="line"></div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> stokes_cell(</div><div class="line">    &amp;triangulation, cell-&gt;level(), cell-&gt;index(), &amp;stokes_dof_handler);</div><div class="line">  scratch.stokes_fe_values.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(stokes_cell);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_temperature_solution, scratch.old_temperature_values);</div><div class="line">  scratch.temperature_fe_values.get_function_values(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_values);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_gradients(</div><div class="line">    old_temperature_solution, scratch.old_temperature_grads);</div><div class="line">  scratch.temperature_fe_values.get_function_gradients(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_grads);</div><div class="line"></div><div class="line">  scratch.temperature_fe_values.get_function_laplacians(</div><div class="line">    old_temperature_solution, scratch.old_temperature_laplacians);</div><div class="line">  scratch.temperature_fe_values.get_function_laplacians(</div><div class="line">    old_old_temperature_solution, scratch.old_old_temperature_laplacians);</div><div class="line"></div><div class="line">  scratch.stokes_fe_values[velocities].get_function_values(</div><div class="line">    stokes_solution, scratch.old_velocity_values);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_values(</div><div class="line">    old_stokes_solution, scratch.old_old_velocity_values);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_symmetric_gradients(</div><div class="line">    stokes_solution, scratch.old_strain_rates);</div><div class="line">  scratch.stokes_fe_values[velocities].get_function_symmetric_gradients(</div><div class="line">    old_stokes_solution, scratch.old_old_strain_rates);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">    compute_viscosity(scratch.old_temperature_values,</div><div class="line">                      scratch.old_old_temperature_values,</div><div class="line">                      scratch.old_temperature_grads,</div><div class="line">                      scratch.old_old_temperature_grads,</div><div class="line">                      scratch.old_temperature_laplacians,</div><div class="line">                      scratch.old_old_temperature_laplacians,</div><div class="line">                      scratch.old_velocity_values,</div><div class="line">                      scratch.old_old_velocity_values,</div><div class="line">                      scratch.old_strain_rates,</div><div class="line">                      scratch.old_old_strain_rates,</div><div class="line">                      global_max_velocity,</div><div class="line">                      global_T_range.second - global_T_range.first,</div><div class="line">                      0.5 * (global_T_range.second + global_T_range.first),</div><div class="line">                      global_entropy_variation,</div><div class="line">                      cell-&gt;diameter());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">        {</div><div class="line">          scratch.phi_T[k] = scratch.temperature_fe_values.shape_value(k, q);</div><div class="line">          scratch.grad_phi_T[k] =</div><div class="line">            scratch.temperature_fe_values.shape_grad(k, q);</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_temperature_values[q] *</div><div class="line">              (1 + time_step / old_time_step) -</div><div class="line">            scratch.old_old_temperature_values[q] * (time_step * time_step) /</div><div class="line">              (old_time_step * (time_step + old_time_step))) :</div><div class="line">           scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> ext_T =</div><div class="line">        (use_bdf2_scheme ? (scratch.old_temperature_values[q] *</div><div class="line">                              (1 + time_step / old_time_step) -</div><div class="line">                            scratch.old_old_temperature_values[q] *</div><div class="line">                              time_step / old_time_step) :</div><div class="line">                           scratch.old_temperature_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">        (use_bdf2_scheme ? (scratch.old_temperature_grads[q] *</div><div class="line">                              (1 + time_step / old_time_step) -</div><div class="line">                            scratch.old_old_temperature_grads[q] * time_step /</div><div class="line">                              old_time_step) :</div><div class="line">                           scratch.old_temperature_grads[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_velocity_values[q] * (1 + time_step / old_time_step) -</div><div class="line">            scratch.old_old_velocity_values[q] * time_step / old_time_step) :</div><div class="line">           scratch.old_velocity_values[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> extrapolated_strain_rate =</div><div class="line">        (use_bdf2_scheme ?</div><div class="line">           (scratch.old_strain_rates[q] * (1 + time_step / old_time_step) -</div><div class="line">            scratch.old_old_strain_rates[q] * time_step / old_time_step) :</div><div class="line">           scratch.old_strain_rates[q]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> gamma =</div><div class="line">        ((EquationData::radiogenic_heating * EquationData::density(ext_T) +</div><div class="line">          2 * EquationData::eta * extrapolated_strain_rate *</div><div class="line">            extrapolated_strain_rate) /</div><div class="line">         (EquationData::density(ext_T) * EquationData::specific_heat));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          data.local_rhs(i) +=</div><div class="line">            (T_term_for_rhs * scratch.phi_T[i] -</div><div class="line">             time_step * extrapolated_u * ext_grad_T * scratch.phi_T[i] -</div><div class="line">             time_step * nu * ext_grad_T * scratch.grad_phi_T[i] +</div><div class="line">             time_step * gamma * scratch.phi_T[i]) *</div><div class="line">            scratch.temperature_fe_values.JxW(q);</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (temperature_constraints.is_inhomogeneously_constrained(</div><div class="line">                data.local_dof_indices[i]))</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                data.matrix_for_bc(j, i) +=</div><div class="line">                  (scratch.phi_T[i] * scratch.phi_T[j] *</div><div class="line">                     (use_bdf2_scheme ? ((2 * time_step + old_time_step) /</div><div class="line">                                         (time_step + old_time_step)) :</div><div class="line">                                        1.) +</div><div class="line">                   scratch.grad_phi_T[i] * scratch.grad_phi_T[j] *</div><div class="line">                     EquationData::kappa * time_step) *</div><div class="line">                  scratch.temperature_fe_values.JxW(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::copy_local_to_global_temperature_rhs(</div><div class="line">  <span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data)</div><div class="line">{</div><div class="line">  temperature_constraints.distribute_local_to_global(data.local_rhs,</div><div class="line">                                                     data.local_dof_indices,</div><div class="line">                                                     temperature_rhs,</div><div class="line">                                                     data.matrix_for_bc);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   In the function that runs the <a class="el" href="namespaceWorkStream.html">WorkStream</a> for actually calculating the
   right hand side, we also generate the final matrix. As mentioned above,
   it is a sum of the mass matrix and the Laplace matrix, times some time
   step-dependent weight. This weight is specified by the BDF-2 time
   integration scheme, see the introduction in <a class="el" href="step_31.html">step-31</a>. What is new in this
   tutorial program (in addition to the use of MPI parallelization and the
   <a class="el" href="namespaceWorkStream.html">WorkStream</a> class), is that we now precompute the temperature
   preconditioner as well. The reason is that the setup of the Jacobi
   preconditioner takes a noticeable time compared to the solver because we
   usually only need between 10 and 20 iterations for solving the
   temperature system (this might sound strange, as Jacobi really only
   consists of a diagonal, but in Trilinos it is derived from more general
   framework for point relaxation preconditioners which is a bit
   inefficient). Hence, it is more efficient to precompute the
   preconditioner, even though the matrix entries may slightly change
   because the time step might change. This is not too big a problem because
   we remesh every few time steps (and regenerate the preconditioner then).</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix *=</div><div class="line">        (2 * time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_preconditioner == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      T_preconditioner =</div><div class="line">        std::make_shared&lt;TrilinosWrappers::PreconditionJacobi&gt;();</div><div class="line">      T_preconditioner-&gt;initialize(temperature_matrix);</div><div class="line">      rebuild_temperature_preconditioner = <span class="keyword">false</span>;</div><div class="line">    }</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The next part is computing the right hand side vectors.  To do so, we
   first compute the average temperature \(T_m\) that we use for evaluating
   the artificial viscosity stabilization through the residual \(E(T) = (T-T_m)^2\). We do this by defining the midpoint between maximum and
   minimum temperature as average temperature in the definition of the
   entropy viscosity. An alternative would be to use the integral average,
   but the results are not very sensitive to this choice. The rest then
   only requires calling <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> again, binding the arguments to
   the <code>local_assemble_temperature_rhs</code> function that are the
   same in every call to the correct values:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  temperature_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(parameters.temperature_degree + 2);</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">    get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> average_temperature =</div><div class="line">    0.5 * (global_T_range.first + global_T_range.second);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_entropy_variation =</div><div class="line">    get_entropy_variation(average_temperature);</div><div class="line"></div><div class="line">  <span class="keyword">using</span> CellFilter =</div><div class="line">    <a class="code" href="classFilteredIterator.html">FilteredIterator&lt;typename DoFHandler&lt;2&gt;::active_cell_iterator</a>&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>, global_T_range, maximal_velocity, global_entropy_variation](</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      Assembly::Scratch::TemperatureRHS&lt;dim&gt; &amp;              scratch,</div><div class="line">      Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;             data) {</div><div class="line">      this-&gt;local_assemble_temperature_rhs(global_T_range,</div><div class="line">                                           maximal_velocity,</div><div class="line">                                           global_entropy_variation,</div><div class="line">                                           cell,</div><div class="line">                                           scratch,</div><div class="line">                                           data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [<span class="keyword">this</span>](<span class="keyword">const</span> Assembly::CopyData::TemperatureRHS&lt;dim&gt; &amp;data) {</div><div class="line">    this-&gt;copy_local_to_global_temperature_rhs(data);</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             temperature_dof_handler.begin_active()),</div><div class="line">                  CellFilter(<a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>(),</div><div class="line">                             temperature_dof_handler.end()),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  Assembly::Scratch::TemperatureRHS&lt;dim&gt;(</div><div class="line">                    temperature_fe, stokes_fe, mapping, quadrature_formula),</div><div class="line">                  Assembly::CopyData::TemperatureRHS&lt;dim&gt;(temperature_fe));</div><div class="line"></div><div class="line">  temperature_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemsolve"></a> 
   <h4>BoussinesqFlowProblem::solve</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   This function solves the linear systems in each time step of the
   Boussinesq problem. First, we work on the Stokes system and then on the
   temperature system. In essence, it does the same things as the respective
   function in <a class="el" href="step_31.html">step-31</a>. However, there are a few changes here.</pre><p></code></p>
<p><code></p><pre>   The first change is related to the way we store our solution: we keep the
   vectors with locally owned degrees of freedom plus ghost nodes on each
   MPI node. When we enter a solver which is supposed to perform
   matrix-vector products with a distributed matrix, this is not the
   appropriate form, though. There, we will want to have the solution vector
   to be distributed in the same way as the matrix, i.e. without any
   ghosts. So what we do first is to generate a distributed vector called
   <code>distributed_stokes_solution</code> and put only the locally owned
   dofs into that, which is neatly done by the <code>operator=</code> of the
   Trilinos vector.</pre><p></code></p>
<p><code></p><pre>   Next, we scale the pressure solution (or rather, the initial guess) for
   the solver so that it matches with the length scales in the matrices, as
   discussed in the introduction. We also immediately scale the pressure
   solution back to the correct units after the solution is completed.  We
   also need to set the pressure values at hanging nodes to zero. This we
   also did in <a class="el" href="step_31.html">step-31</a> in order not to disturb the Schur complement by some
   vector entries that actually are irrelevant during the solve stage. As a
   difference to <a class="el" href="step_31.html">step-31</a>, here we do it only for the locally owned pressure
   dofs. After solving for the Stokes solution, each processor copies the
   distributed solution back into the solution vector that also includes
   ghost elements.</pre><p></code></p>
<p><code></p><pre>   The third and most obvious change is that we have two variants for the
   Stokes solver: A fast solver that sometimes breaks down, and a robust
   solver that is slower. This is what we already discussed in the
   introduction. Here is how we realize it: First, we perform 30 iterations
   with the fast solver based on the simple preconditioner based on the AMG
   V-cycle instead of an approximate solve (this is indicated by the
   <code>false</code> argument to the
   <code>LinearSolvers::BlockSchurPreconditioner</code> object). If we
   converge, everything is fine. If we do not converge, the solver control
   object will throw an exception <a class="el" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a>. Usually,
   this would abort the program because we don't catch them in our usual
   <code>solve()</code> functions. This is certainly not what we want to
   happen here. Rather, we want to switch to the strong solver and continue
   the solution process with whatever vector we got so far. Hence, we catch
   the exception with the C++ try/catch mechanism. We then simply go through
   the same solver sequence again in the <code>catch</code> clause, this
   time passing the <code>true</code> flag to the preconditioner for the strong
   solver, signaling an approximate CG solve.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Solve Stokes system&quot;</span>);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solving Stokes system... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes_solution(</div><div class="line">      stokes_rhs);</div><div class="line">    distributed_stokes_solution = stokes_solution;</div><div class="line"></div><div class="line">    distributed_stokes_solution.block(1) /= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">      start = (distributed_stokes_solution.block(0).size() +</div><div class="line">               distributed_stokes_solution.block(1).local_range().first),</div><div class="line">      end   = (distributed_stokes_solution.block(0).size() +</div><div class="line">             distributed_stokes_solution.block(1).local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = start; i &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++i)</div><div class="line">      <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">        distributed_stokes_solution(i) = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classPrimitiveVectorMemory.html">PrimitiveVectorMemory&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> mem;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  n_iterations     = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>  solver_tolerance = 1e-8 * stokes_rhs.l2_norm();</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(30, solver_tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">          preconditioner(stokes_matrix,</div><div class="line">                         stokes_preconditioner_matrix,</div><div class="line">                         *Mp_preconditioner,</div><div class="line">                         *Amg_preconditioner,</div><div class="line">                         <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> solver(</div><div class="line">          solver_control,</div><div class="line">          mem,</div><div class="line">          <a class="code" href="structSolverFGMRES_1_1AdditionalData.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            30));</div><div class="line">        solver.solve(stokes_matrix,</div><div class="line">                     distributed_stokes_solution,</div><div class="line">                     stokes_rhs,</div><div class="line">                     preconditioner);</div><div class="line"></div><div class="line">        n_iterations = solver_control.last_step();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">catch</span> (<a class="code" href="classSolverControl_1_1NoConvergence.html">SolverControl::NoConvergence</a> &amp;)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1PreconditionJacobi.html">TrilinosWrappers::PreconditionJacobi</a>&gt;</div><div class="line">          preconditioner(stokes_matrix,</div><div class="line">                         stokes_preconditioner_matrix,</div><div class="line">                         *Mp_preconditioner,</div><div class="line">                         *Amg_preconditioner,</div><div class="line">                         <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control_refined(stokes_matrix.m(),</div><div class="line">                                             solver_tolerance);</div><div class="line">        <a class="code" href="classSolverFGMRES.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> solver(</div><div class="line">          solver_control_refined,</div><div class="line">          mem,</div><div class="line">          <a class="code" href="structSolverFGMRES_1_1AdditionalData.html">SolverFGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            50));</div><div class="line">        solver.solve(stokes_matrix,</div><div class="line">                     distributed_stokes_solution,</div><div class="line">                     stokes_rhs,</div><div class="line">                     preconditioner);</div><div class="line"></div><div class="line">        n_iterations =</div><div class="line">          (solver_control.last_step() + solver_control_refined.last_step());</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    stokes_constraints.distribute(distributed_stokes_solution);</div><div class="line"></div><div class="line">    distributed_stokes_solution.block(1) *= EquationData::pressure_scaling;</div><div class="line"></div><div class="line">    stokes_solution = distributed_stokes_solution;</div><div class="line">    pcout &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Now let's turn to the temperature part: First, we compute the time step
   size. We found that we need smaller time steps for 3D than for 2D for
   the shell geometry. This is because the cells are more distorted in
   that case (it is the smallest edge length that determines the CFL
   number). Instead of computing the time step from maximum velocity and
   minimal mesh size as in <a class="el" href="step_31.html">step-31</a>, we compute local CFL numbers, i.e., on
   each cell we compute the maximum velocity times the mesh size, and
   compute the maximum of them. Hence, we need to choose the factor in
   front of the time step slightly smaller.</pre><p></code></p>
<p><code></p><pre>   After temperature right hand side assembly, we solve the linear system
   for temperature (with fully distributed vectors without any ghosts),
   apply constraints and copy the vector back to one with ghosts.</pre><p></code></p>
<p><code></p><pre>   In the end, we extract the temperature range similarly to <a class="el" href="step_31.html">step-31</a> to
   produce some output (for example in order to help us choose the
   stabilization constants, as discussed in the introduction). The only
   difference is that we need to exchange maxima over all processors.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Assemble temperature rhs&quot;</span>);</div><div class="line"></div><div class="line">    old_time_step = time_step;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> scaling = (dim == 3 ? 0.25 : 1.0);</div><div class="line">    time_step            = (scaling / (2.1 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) /</div><div class="line">                 (parameters.temperature_degree * get_cfl_number()));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Maximal velocity: &quot;</span></div><div class="line">          &lt;&lt; maximal_velocity * EquationData::year_in_seconds * 100</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; cm/year&quot;</span> &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step / EquationData::year_in_seconds</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; years&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    temperature_solution = old_temperature_solution;</div><div class="line">    assemble_temperature_system(maximal_velocity);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;   Solve temperature system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                                 1e-12 * temperature_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temperature_solution(</div><div class="line">      temperature_rhs);</div><div class="line">    distributed_temperature_solution = temperature_solution;</div><div class="line"></div><div class="line">    cg.solve(temperature_matrix,</div><div class="line">             distributed_temperature_solution,</div><div class="line">             temperature_rhs,</div><div class="line">             *T_preconditioner);</div><div class="line"></div><div class="line">    temperature_constraints.distribute(distributed_temperature_solution);</div><div class="line">    temperature_solution = distributed_temperature_solution;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> temperature[2] = {<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">                             -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>()};</div><div class="line">    <span class="keywordtype">double</span> global_temperature[2];</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =</div><div class="line">           distributed_temperature_solution.local_range().first;</div><div class="line">         i &lt; distributed_temperature_solution.local_range().second;</div><div class="line">         ++i)</div><div class="line">      {</div><div class="line">        temperature[0] =</div><div class="line">          std::min&lt;double&gt;(temperature[0],</div><div class="line">                           distributed_temperature_solution(i));</div><div class="line">        temperature[1] =</div><div class="line">          std::max&lt;double&gt;(temperature[1],</div><div class="line">                           distributed_temperature_solution(i));</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature[0] *= -1.0;</div><div class="line">    <a class="code" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">Utilities::MPI::max</a>(temperature, MPI_COMM_WORLD, global_temperature);</div><div class="line">    global_temperature[0] *= -1.0;</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; global_temperature[0] &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">          &lt;&lt; global_temperature[1] &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemoutput_results"></a> 
   <h4>BoussinesqFlowProblem::output_results</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   Next comes the function that generates the output. The quantities to
   output could be introduced manually like we did in <a class="el" href="step_31.html">step-31</a>. An
   alternative is to hand this task over to a class PostProcessor that
   inherits from the class <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>, which can be attached to
   <a class="el" href="classDataOut.html">DataOut</a>. This allows us to output derived quantities from the solution,
   like the friction heating included in this example. It overloads the
   virtual function <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a>,
   which is then internally called from <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. We have to
   give it values of the numerical solution, its derivatives, normals to the
   cell, the actual evaluation points and any additional quantities. This
   follows the same procedure as discussed in <a class="el" href="step_29.html">step-29</a> and other programs.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem&lt;dim&gt;::Postprocessor</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="classDataPostprocessor.html">DataPostprocessor</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Postprocessor(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>, <span class="keyword">const</span> <span class="keywordtype">double</span> minimal_pressure);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::vector&lt;std::string&gt; <a class="code" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::vector&lt;</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">  <a class="code" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">get_data_component_interpretation</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="code" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags</a>() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::Postprocessor(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       minimal_pressure)</div><div class="line">  : partition(partition)</div><div class="line">  , minimal_pressure(minimal_pressure)</div><div class="line">{}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Here we define the names for the variables we want to output. These are
   the actual solution values for velocity, pressure, and temperature, as
   well as the friction heating and to each cell the number of the processor
   that owns it. This allows us to visualize the partitioning of the domain
   among the processors. Except for the velocity, which is vector-valued,
   all other quantities are scalar.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;std::string&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_names()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;friction_heating&quot;</span>);</div><div class="line">  solution_names.emplace_back(<span class="stringliteral">&quot;partition&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> solution_names;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_data_component_interpretation()<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    interpretation(dim,</div><div class="line">                   <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line"></div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  interpretation.push_back(<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> interpretation;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::get_needed_update_flags()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>;</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Now we implement the function that computes the derived quantities. As we
   also did for the output, we rescale the velocity from its SI units to
   something more readable, namely cm/year. Next, the pressure is scaled to
   be between 0 and the maximum pressure. This makes it more easily
   comparable &ndash; in essence making all pressure variables positive or
   zero. Temperature is taken as is, and the friction heating is computed as
 \(2 \eta \varepsilon(\mathbf{u}) \cdot \varepsilon(\mathbf{u})\).</pre><p></code></p>
<p><code></p><pre>   The quantities we output here are more for illustration, rather than for
   actual scientific value. We come back to this briefly in the results
   section of this program and explain what one may in fact be interested in.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::Postprocessor::evaluate_vector_field(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">  std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_quadrature_points = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size();</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>.size() == n_quadrature_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == n_quadrature_points,</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[0].size() == dim + 2, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_quadrature_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        computed_quantities[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) = (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>) *</div><div class="line">                                     EquationData::year_in_seconds * 100);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> pressure =</div><div class="line">        (inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim) - minimal_pressure);</div><div class="line">      computed_quantities[q](dim) = pressure;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> temperature        = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](dim + 1);</div><div class="line">      computed_quantities[q](dim + 1) = temperature;</div><div class="line"></div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> grad_u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        grad_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#ac96fb295c3c807f96021bae734e8c3c3">solution_gradients</a>[q][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>];</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> strain_rate = <a class="code" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a>(grad_u);</div><div class="line">      computed_quantities[q](dim + 2) =</div><div class="line">        2 * EquationData::eta * strain_rate * strain_rate;</div><div class="line"></div><div class="line">      computed_quantities[q](dim + 3) = <a class="code" href="namespaceSparsityTools.html#a452753b6ffdf31b33f2bcd792b05df93">partition</a>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   The <code>output_results()</code> function has a similar task to the one
   in <a class="el" href="step_31.html">step-31</a>. However, here we are going to demonstrate a different
   technique on how to merge output from different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The
   way we're going to achieve this recombination is to create a joint
   <a class="el" href="classDoFHandler.html">DoFHandler</a> that collects both components, the Stokes solution and the
   temperature solution. This can be nicely done by combining the finite
   elements from the two systems to form one <a class="el" href="classFESystem.html">FESystem</a>, and let this
   collective system define a new <a class="el" href="classDoFHandler.html">DoFHandler</a> object. To be sure that
   everything was done correctly, we perform a sanity check that ensures
   that we got all the dofs from both Stokes and temperature even in the
   combined system. We then combine the data vectors. Unfortunately, there
   is no straight-forward relation that tells us how to sort Stokes and
   temperature vector into the joint vector. The way we can get around this
   trouble is to rely on the information collected in the <a class="el" href="classFESystem.html">FESystem</a>. For each
   dof on a cell, the joint finite element knows to which equation component
   (velocity component, pressure, or temperature) it belongs – that's the
   information we need! So we step through all cells (with iterators into
   all three DoFHandlers moving in sync), and for each joint cell dof, we
   read out that component using the <a class="el" href="classFiniteElement.html#a95ac75dfc5b9f4e01c34d5865b4ca5a2">FiniteElement::system_to_base_index</a>
   function (see there for a description of what the various parts of its
   return value contain). We also need to keep track whether we're on a
   Stokes dof or a temperature dof, which is contained in
   joint_fe.system_to_base_index(i).first.first. Eventually, the dof_indices
   data structures on either of the three systems tell us how the relation
   between global vector and local dofs looks like on the present cell,
   which concludes this tedious work. We make sure that each processor only
   works on the subdomain it owns locally (and not on ghost or artificial
   cells) when building the joint solution vector. The same will then have
   to be done in <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>, but that function does so
   automatically.</pre><p></code></p>
<p><code></p><pre>   What we end up with is a set of patches that we can write using the
   functions in <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> in a variety of output formats. Here, we then
   have to pay attention that what each processor writes is really only its
   own part of the domain, i.e. we will want to write each processor's
   contribution into a separate file. This we do by adding an additional
   number to the filename when we write the solution. This is not really
   new, we did it similarly in <a class="el" href="step_40.html">step-40</a>. Note that we write in the compressed
   format <code></code>.vtu instead of plain vtk files, which saves quite some
   storage.</pre><p></code></p>
<p><code></p><pre>   All the rest of the work is done in the PostProcessor class.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer, <span class="stringliteral">&quot;Postprocessing&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(stokes_fe, 1, temperature_fe, 1);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> joint_dof_handler(triangulation);</div><div class="line">  joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">           stokes_dof_handler.n_dofs() + temperature_dof_handler.n_dofs(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> joint_solution;</div><div class="line">  joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(joint_dof_handler.locally_owned_dofs(),</div><div class="line">                        MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">      joint_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_stokes_dof_indices(</div><div class="line">      stokes_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_temperature_dof_indices(</div><div class="line">      temperature_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      joint_cell       = joint_dof_handler.begin_active(),</div><div class="line">      joint_endc       = joint_dof_handler.end(),</div><div class="line">      stokes_cell      = stokes_dof_handler.begin_active(),</div><div class="line">      temperature_cell = temperature_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">         ++joint_cell, ++stokes_cell, ++temperature_cell)</div><div class="line">      <span class="keywordflow">if</span> (joint_cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">          stokes_cell-&gt;get_dof_indices(local_stokes_dof_indices);</div><div class="line">          temperature_cell-&gt;get_dof_indices(local_temperature_dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_stokes_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">                joint_solution(local_joint_dof_indices[i]) = stokes_solution(</div><div class="line">                  local_stokes_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                             .second]);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_temperature_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                  temperature_solution(</div><div class="line">                    local_temperature_dof_indices</div><div class="line">                      [joint_fe.system_to_base_index(i).second]);</div><div class="line">              }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line">  joint_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_joint_dofs(joint_dof_handler.n_dofs());</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(joint_dof_handler,</div><div class="line">                                          locally_relevant_joint_dofs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_joint_solution;</div><div class="line">  locally_relevant_joint_solution.<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a>(locally_relevant_joint_dofs,</div><div class="line">                                         MPI_COMM_WORLD);</div><div class="line">  locally_relevant_joint_solution = joint_solution;</div><div class="line"></div><div class="line">  Postprocessor postprocessor(<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                MPI_COMM_WORLD),</div><div class="line">                              stokes_solution.block(1).min());</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">  data_out.add_data_vector(locally_relevant_joint_solution, postprocessor);</div><div class="line">  data_out.build_patches();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> out_index = 0;</div><div class="line">  data_out.write_vtu_with_pvtu_record(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, out_index, MPI_COMM_WORLD, 5);</div><div class="line"></div><div class="line">  out_index++;</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemrefine_mesh"></a> 
   <h4>BoussinesqFlowProblem::refine_mesh</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   This function isn't really new either. Since the <code>setup_dofs</code>
   function that we call in the middle has its own timer section, we split
   timing this function into two sections. It will also allow us to easily
   identify which of the two is more expensive.</pre><p></code></p>
<p><code></p><pre>   One thing of note, however, is that we only want to compute error
   indicators on the locally owned subdomain. In order to achieve this, we
   pass one additional argument to the <a class="el" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator::estimate</a>
   function. Note that the vector for error estimates is resized to the
   number of active cells present on the current process, which is less than
   the total number of active cells on all processors (but more than the
   number of locally owned active cells); each processor only has a few
   coarse cells around the locally owned ones, as also explained in <a class="el" href="step_40.html">step-40</a>.</pre><p></code></p>
<p><code></p><pre>   The local error estimates are then handed to a parallel version of
   <a class="el" href="namespaceGridRefinement.html">GridRefinement</a> (in namespace <a class="el" href="namespaceparallel_1_1distributed_1_1GridRefinement.html">parallel::distributed::GridRefinement</a>, see
   also <a class="el" href="step_40.html">step-40</a>) which looks at the errors and finds the cells that need
   refinement by comparing the error values across processors. As in
   <a class="el" href="step_31.html">step-31</a>, we want to limit the maximum grid level. So in case some cells
   have been marked that are already at the finest level, we simply clear
   the refine flags.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">    temperature_trans(temperature_dof_handler);</div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>&lt;dim,</div><div class="line">                                          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>&gt;</div><div class="line">    stokes_trans(stokes_dof_handler);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                     <span class="stringliteral">&quot;Refine mesh structure, part 1&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      temperature_dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(parameters.temperature_degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      temperature_solution,</div><div class="line">      estimated_error_per_cell,</div><div class="line">      <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">      <span class="keyword">nullptr</span>,</div><div class="line">      0,</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#ae5159e3207f6786f0749fc0b66ab8ca3">parallel::distributed::GridRefinement::refine_and_coarsen_fixed_fraction</a>(</div><div class="line">      triangulation, estimated_error_per_cell, 0.3, 0.1);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">             triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>(max_grid_level);</div><div class="line">           cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">           ++cell)</div><div class="line">        cell-&gt;clear_refine_flag();</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   With all flags marked as necessary, we can then tell the
   <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> objects to get ready to
   transfer data from one mesh to the next, which they will do when
   notified by
   <a class="el" href="classTriangulation.html">Triangulation</a> as part of the <code>execute_coarsening_and_refinement()</code> call.
   The syntax is similar to the non-parallel solution transfer (with the
   exception that here a pointer to the vector entries is enough). The
   remainder of the function further down below is then concerned with
   setting up the data structures again after mesh refinement and
   restoring the solution vectors on the new mesh.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  std::vector&lt;const TrilinosWrappers::MPI::Vector *&gt; x_temperature(2);</div><div class="line">  x_temperature[0] = &amp;temperature_solution;</div><div class="line">  x_temperature[1] = &amp;old_temperature_solution;</div><div class="line">  std::vector&lt;const TrilinosWrappers::MPI::BlockVector *&gt; x_stokes(2);</div><div class="line">  x_stokes[0] = &amp;stokes_solution;</div><div class="line">  x_stokes[1] = &amp;old_stokes_solution;</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">  stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div><div class="line"></div><div class="line">setup_dofs();</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(computing_timer,</div><div class="line">                                   <span class="stringliteral">&quot;Refine mesh structure, part 2&quot;</span>);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp1(temperature_rhs);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_temp2(temperature_rhs);</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector *&gt; tmp(2);</div><div class="line">    tmp[0] = &amp;(distributed_temp1);</div><div class="line">    tmp[1] = &amp;(distributed_temp2);</div><div class="line">    temperature_trans.interpolate(tmp);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   enforce constraints to make the interpolated solution conforming on
   the new mesh:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  temperature_constraints.distribute(distributed_temp1);</div><div class="line">  temperature_constraints.distribute(distributed_temp2);</div><div class="line"></div><div class="line">  temperature_solution     = distributed_temp1;</div><div class="line">  old_temperature_solution = distributed_temp2;</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distributed_stokes(stokes_rhs);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_distributed_stokes(stokes_rhs);</div><div class="line"></div><div class="line">  std::vector&lt;TrilinosWrappers::MPI::BlockVector *&gt; stokes_tmp(2);</div><div class="line">  stokes_tmp[0] = &amp;(distributed_stokes);</div><div class="line">  stokes_tmp[1] = &amp;(old_distributed_stokes);</div><div class="line"></div><div class="line">  stokes_trans.interpolate(stokes_tmp);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   enforce constraints to make the interpolated solution conforming on
   the new mesh:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">      stokes_constraints.distribute(distributed_stokes);</div><div class="line">      stokes_constraints.distribute(old_distributed_stokes);</div><div class="line"></div><div class="line">      stokes_solution     = distributed_stokes;</div><div class="line">      old_stokes_solution = old_distributed_stokes;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="BoussinesqFlowProblemrun"></a> 
   <h4>BoussinesqFlowProblem::run</h4>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   This is the final and controlling function in this class. It, in fact,
   runs the entire rest of the program and is, once more, very similar to
   <a class="el" href="step_31.html">step-31</a>. The only substantial difference is that we use a different mesh
   now (a <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> instead of a simple cube geometry).</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(triangulation,</div><div class="line">                             <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(),</div><div class="line">                             EquationData::R0,</div><div class="line">                             EquationData::R1,</div><div class="line">                             (dim == 3) ? 96 : 12,</div><div class="line">                             <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(parameters.initial_global_refinement);</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">start_time_iteration:</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution(</div><div class="line">      temperature_dof_handler.locally_owned_dofs());</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a> supports parallel vector classes with most
   standard finite elements via deal.II's own native <a class="el" href="classMatrixFree.html">MatrixFree</a> framework:
   since we use standard Lagrange elements of moderate order this function
   works well here.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                     temperature_constraints,</div><div class="line">                     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(parameters.temperature_degree + 2),</div><div class="line">                     EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                     solution);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Having so computed the current temperature field, let us set the member
   variable that holds the temperature nodes. Strictly speaking, we really
   only need to set <code>old_temperature_solution</code> since the first
   thing we will do is to compute the Stokes solution that only requires
   the previous time step's temperature field. That said, nothing good can
   come from not initializing the other vectors as well (especially since
   it's a relatively cheap operation and we only have to do it once at the
   beginning of the program) if we ever want to extend our numerical
   method or physical model, and so we initialize
   <code>old_temperature_solution</code> and
   <code>old_old_temperature_solution</code> as well. The assignment makes
   sure that the vectors on the left hand side (which where initialized to
   contain ghost elements as well) also get the correct ghost elements. In
   other words, the assignment here requires communication between
   processors:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">  temperature_solution         = solution;</div><div class="line">  old_temperature_solution     = solution;</div><div class="line">  old_old_temperature_solution = solution;</div><div class="line">}</div><div class="line"></div><div class="line">timestep_number = 0;</div><div class="line">time_step = old_time_step = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">do</span></div><div class="line">  {</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time / EquationData::year_in_seconds &lt;&lt; <span class="stringliteral">&quot; years&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_stokes_system();</div><div class="line">    build_stokes_preconditioner();</div><div class="line">    assemble_temperature_matrix();</div><div class="line"></div><div class="line">    solve();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">        (pre_refinement_step &lt; parameters.initial_adaptive_refinement))</div><div class="line">      {</div><div class="line">        refine_mesh(parameters.initial_global_refinement +</div><div class="line">                    parameters.initial_adaptive_refinement);</div><div class="line">        ++pre_refinement_step;</div><div class="line">        <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp;</div><div class="line">             (timestep_number % parameters.adaptive_refinement_interval ==</div><div class="line">              0))</div><div class="line">      refine_mesh(parameters.initial_global_refinement +</div><div class="line">                  parameters.initial_adaptive_refinement);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">        (timestep_number % parameters.graphical_output_interval == 0))</div><div class="line">      output_results();</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   In order to speed up linear solvers, we extrapolate the solutions
   from the old time levels to the new one. This gives a very good
   initial guess, cutting the number of iterations needed in solvers
   by more than one half. We do not need to extrapolate in the last
   iteration, so if we reached the final time, we stop here.</pre><p></code></p>
<p><code></p><pre>   As the last thing during a time step (before actually bumping up
   the number of the time step), we check whether the current time
   step number is divisible by 100, and if so we let the computing
   timer print a summary of CPU times spent so far.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keywordflow">if</span> (time &gt; parameters.end_time * EquationData::year_in_seconds)</div><div class="line">  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_old_stokes_solution;</div><div class="line">old_old_stokes_solution      = old_stokes_solution;</div><div class="line">old_stokes_solution          = stokes_solution;</div><div class="line">old_old_temperature_solution = old_temperature_solution;</div><div class="line">old_temperature_solution     = temperature_solution;</div><div class="line"><span class="keywordflow">if</span> (old_time_step &gt; 0)</div><div class="line">  {</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   Trilinos sadd does not like ghost vectors even as input. Copy
   into distributed vectors for now:</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">        {</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_solution(stokes_rhs);</div><div class="line">          distr_solution = stokes_solution;</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> distr_old_solution(stokes_rhs);</div><div class="line">          distr_old_solution = old_old_stokes_solution;</div><div class="line">          distr_solution.<a class="code" href="classBlockVectorBase.html#a71b0ab8295e98caf3dfe1ef14ae6b6c1">sadd</a>(1. + time_step / old_time_step,</div><div class="line">                              -time_step / old_time_step,</div><div class="line">                              distr_old_solution);</div><div class="line">          stokes_solution = distr_solution;</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_solution(temperature_rhs);</div><div class="line">          distr_solution = temperature_solution;</div><div class="line">          <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distr_old_solution(temperature_rhs);</div><div class="line">          distr_old_solution = old_old_temperature_solution;</div><div class="line">          distr_solution.sadd(1. + time_step / old_time_step,</div><div class="line">                              -time_step / old_time_step,</div><div class="line">                              distr_old_solution);</div><div class="line">          temperature_solution = distr_solution;</div><div class="line">        }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 100 == 0))</div><div class="line">      computing_timer.print_summary();</div><div class="line"></div><div class="line">    time += time_step;</div><div class="line">    ++timestep_number;</div><div class="line">  }</div><div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>);</div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   If we are generating graphical output, do so also for the last time
   step unless we had just done so before we left the do-while loop</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line">    <span class="keywordflow">if</span> ((parameters.generate_graphical_output == <span class="keyword">true</span>) &amp;&amp;</div><div class="line">        !((timestep_number - 1) % parameters.graphical_output_interval == 0))</div><div class="line">      output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step32</span></div></div><!-- fragment --></pre><p></code></p>
<p><code></p><pre>   <a class="anchor" id="Thecodemaincodefunction"></a> 
   <h3>The <code>main</code> function</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>   The main function is short as usual and very similar to the one in
   <a class="el" href="step_31.html">step-31</a>. Since we use a parameter file which is specified as an argument in
   the command line, we have to read it in here and pass it on to the
   Parameters class for parsing. If no filename is given in the command line,
   we simply use the <code>step-32.prm</code> file which is distributed
   together with the program.</pre><p></code></p>
<p><code></p><pre>   Because 3d computations are simply very slow unless you throw a lot of
   processors at them, the program defaults to 2d. You can get the 3d version
   by changing the constant dimension below to 3.</pre><p></code></p>
<p><code></p><pre><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step32;</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      std::string parameter_filename;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt;= 2)</div><div class="line">        parameter_filename = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_filename = <span class="stringliteral">&quot;step-32.prm&quot;</span>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span>                              dim = 2;</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt;::Parameters parameters(parameter_filename);</div><div class="line">      BoussinesqFlowProblem&lt;dim&gt;             flow_problem(parameters);</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment -->
examples/step-32/doc/results.dox</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Results"></a><h1>Results</h1>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>当运行时，该程序以与<a class="el" href="step_31.html">step-31</a>相同的方式模拟三维对流，尽管有一个完全不同的测试案例。</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Comparisonofresultswithstep31"></a><h3>Comparison of results with step-31</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>然而，在我们讨论这个测试案例之前，让我们展示一下这个程序稍早的版本的一些结果，该版本正是在解决我们在第31步中使用的测试案例，只是我们现在以并行方式解决它，而且分辨率要高很多。我们展示这些结果主要是为了比较。</pre><p></code></p>
<p><code></p><pre>下面是两张图片，如果我们选择 <code>main()</code> 中的3d计算，以及设置 <code>initial_refinement=3</code> 和 <code>n_pre_refinement_steps=4</code> ，则可以看到这种更高的分辨率。在所示的时间步骤中，网格有大约72,000和236,000个单元，分别为2,680,000和8,250,000个自由度，比我们在步骤31中的可用度多了一个数量级。</pre><p></code></p>
<p><code></p><pre> <table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d.cube.0.png"/>
</div>

    
  
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-32.3d.cube.1.png"/>
</div>

    
  
</td></tr>
</table>
</pre><p></code></p>
<p><code></p><pre>计算是在德克萨斯A&amp;M大学Brazos集群的50个处理器的子集上完成的。</pre><p></code></p>
<p><code></p><pre><a class="anchor" id="Resultsfora2dcircularshelltestcase"></a><h3>Results for a 2d circular shell testcase</h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>接下来，我们将用目录中的参数文件运行<a class="el" href="step_32.html">step-32</a>，但有一个变化：我们将最终时间增加到1e9。这里我们使用的是16个处理器。启动的命令是（注意，<a class="el" href="step_32.html">step-32</a>.prm是默认的）。</pre><p></code></p>
<p><code></p><pre><code> <pre> \( mpirun -np 16 ./step-32 &lt;/pre&gt; &lt;/code&gt; Note that running a job on a cluster typically requires going through a job scheduler, which we won&#39;t discuss here. The output will look roughly like this: &lt;code&gt; &lt;pre&gt; $ mpirun -np 16 ./step-32 活动单元的数量：12,288（在6层） 自由度的数量：186,624（99,840+36,864+49,920）。 时间步数0：t=0年 重建斯托克斯预处理程序... 解决斯托克斯系统...41次迭代。 最大速度：60.4935厘米/年 时间步长：18166.9年 温度的17次CG迭代 温度范围：973 4273.16 活动单元的数量：15,921（在7层） 自由度的数量：252,723（136,640+47,763+68,320）。 时间步数0：t=0年 重建斯托克斯预处理程序... 解决斯托克斯系统...50次迭代。 最大速度：60.3223厘米/年 时间步长：10557.6年 温度的19次CG迭代 温度范围：973 4273.16 活动单元的数量：19,926（在8层） 自由度的数量：321,246（174,312+59,778+87,156）。 时间步数0：t=0年 重建斯托克斯预处理程序... 解决斯托克斯系统...50次迭代。 最大速度：57.8396厘米/年 时间步长：5453.78年 温度的18次CG迭代 温度范围：973 4273.16 时间步数1：t=5453.78年 解决斯托克斯系统...49次迭代。 最大速度：59.0231厘米/年 时间步长：5345.86年 温度的18次CG迭代 温度范围：973 4273.16 时间步数2：t=10799.6年 解决斯托克斯系统...24次迭代。 最大速度：60.2139厘米/年 时间步长：5241.51年 温度的17次CG迭代 温度范围：973 4273.16 [...] 时间步数100：t=272151年 解决斯托克斯系统......21次迭代。 最大速度：161.546厘米/年 时间步长：1672.96年 温度的17次CG迭代 温度范围：973 4282.57 活动单元的数量：56,085（在8层） 自由度的数量：903,408（490,102+168,255+245,051）。 +---------------------------------------------+------------+------------+ | 从开始到现在，总的壁挂时间经过了115s构建斯托克斯预调节器 | 12 | 2.09s | 1.8% | 解算斯托克斯系统 | 103 | 90.4s | 79% | 解算温度系统 | 103 | 1.53s | 1.3% | 后处理 | 3 | 0.532s | 0.完善网格结构，第一部分 | 12 | 0.93s | 0.81% | 完善网格结构，第二部分 | 12 | 0.384s | 0.33% | 设置阻尼系统 | 13 | 2.96s | 2.6% | +---------------------------------+-----------+------------+------------+ [...] +---------------------------------------------+------------+------------+ | 从开始到现在总共经过了多少壁挂时间 | 9.14e+04s | | | | 部分 | 调用次数 | 壁挂时间 | 占总数的百分比 | +---------------------------------+-----------+------------+------------+ | 组装斯托克斯系统 | 47045 | 2.05e+03s | 2.2% | 组装温度矩阵 | 4707 | 310s | 0.34% | 组装温度rhs | 47045 | 8.7e+03s | 9.4707 | 1.48e+03s | 1.6% | 解决斯托克斯系统 | 47045 | 7.34e+04s | 80% | 解决温度系统 | 47045 | 1.46e+03s | 1.6% | 后处理 | 1883 | 222s | 0.24% | | 完善网格结构，第一部分 | 4706 | 641s | 0.7% | 完善网格结构，第二部分 | 4706 | 259s | 0.28% | 设置阻尼系统 | 4707 | 1.86e+03s | 2% | +---------------------------------+-----------+------------+------------+ &lt;/pre&gt; &lt;/code&gt; 当时间达到输入文件中选择的10亿年时，模拟就会终止。 你可以从中推断出不同的最终时间的模拟需要多长时间（时间步长最终确定在20,000年左右，所以计算20亿年需要100,000个时间步长，给或给20%）。 从这里可以看出，我们把大部分的计算时间花在了组装线性系统和&mdash;首先&mdash;解决斯托克斯系统。 为了演示输出，我们在这里展示了每1250个时间步骤的输出。 &lt;table&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-000.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-050.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-100.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-150.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-200.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-250.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-300.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-350.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-400.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-450.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-500.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-550.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-time-600.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-cells.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-partition.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 最后两张图片显示了网格以及16个子域和16个处理器的同一计算的网格划分情况。这个模拟的全部动态只有通过看动画才能看到，例如&lt;a href=&quot;https://www.dealii.org/images/steps/developer/step-32-2d-temperature.webm&quot;&gt;shown on this site&lt;/a&gt;。由于其艺术质量和对岩浆羽流演变的迷人描述，这个图像非常值得观看。 如果你看电影，你会看到对流模式经历了几个阶段。首先，它摆脱了不稳定的温度分层，热物质被致密的冷物质覆盖。在这个巨大的驱动力被消除后，我们有了一种稳定的情况，几个小球开始从内圈的热边界层中分离出来并上升，几个冷指也从外部边界层中掉下来。在这一阶段，解决方案仍然大部分是对称的，反映了原始网格的12倍对称性。在最后一个阶段，流体进入剧烈的混沌搅拌，其中所有的对称性都消失了。这是一个随后继续主导流动的模式。 如果我们看一下模拟中作为时间函数的最大速度，也可以确定这些不同阶段。 &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32.2d.t_vs_vmax.png&quot; alt=&quot;&quot;&gt; 在这里，当温度分层不稳定时，速度（以厘米/年表示）在开始时变得非常大，达到几米/年的数量级）。然后平静下来，变成相对较小的数值，然后在混乱的搅动系统中再次回升。在那里，它保持在每年10-40厘米的范围内，完全在物理上预期的区域内。 &lt;a name=&quot;Resultsfora3dsphericalshelltestcase&quot;&gt;&lt;/a&gt;&lt;h3&gt;Results for a 3d spherical shell testcase&lt;/h3&gt; 三维计算在计算上是非常昂贵的。此外，如上所述，有趣的行为只有在相当长的时间后才开始，需要更多的CPU时间，而不是在一个典型的集群上可用。因此，与其在这里展示一个完整的模拟，不如让我们简单地展示几张图片，我们使用这个程序的后续程序，称为&lt;i&gt;ASPECT&lt;/i&gt;（简称&lt;i&gt;Advanced %Solver for Problems in Earth&#39;s ConvecTion&lt;/i&gt;），该程序正在独立于deal.II开发，已经包括了下面讨论的一些扩展。下面两张图片显示了温度的等值线和领域（连同网格）在512个处理器上的划分。 &lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32.3d-sphere.solution.png&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;https://www.dealii.org/images/steps/developer/step-32.3d-sphere.partition.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt; 。 &lt;a name=&quot;extensions&quot;&gt;&lt;/a&gt; &lt;a name=&quot;Possibilitiesforextensions&quot;&gt;&lt;/a&gt;&lt;h3&gt;Possibilities for extensions&lt;/h3&gt; 这个程序有许多可以扩展的方向。正如在介绍的最后提到的，在本教程程序完成时，其中大部分正在&lt;i&gt;ASPECT&lt;/i&gt;（简称&lt;i&gt;Advanced %Solver for Problems in Earth&#39;s ConvecTion&lt;/i&gt;）代码中积极开发。具体来说，下面这些肯定是人们应该解决的话题，以使程序更加有用。 &lt;ul&gt; &lt;li&gt; &lt;b&gt;Adiabatic heating/cooling:&lt;/b&gt; 我们在模拟中得到的温度场在一段时间后大多是恒定的，在内部和外部边界有边界层，冷和热物质的流线混合一切。然而，这并不符合我们的预期，即靠近地心的东西应该比靠近地表的东西更热。原因是我们使用的能量方程不包括一个描述绝热冷却和加热的术语：岩石，像气体一样，在你压缩它的时候会加热。因此，上升的物质以绝热方式冷却，而下沉的冷物质则以绝热方式加热。因此，正确的温度方程看起来有点像这样。 @f{eqnarray*} \frac{D T}{Dt} - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma + \tau\frac{Dp}{Dt}, @f} 或者，扩大平流导数 \){D}{Dt} =
  {}{ t} +  u   \( : @f{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma + \tau\left\{\frac{\partial p}{\partial t} + \mathbf u \cdot \nabla p \right\}. @f} 。 换句话说，随着岩石体积中压力的增加（ \){Dp}{Dt}&gt;0 \( ），我们会得到一个额外的热源，反之亦然。 压力的时间导数实施起来有点困难。如果有必要，我们可以利用导言中概述的事实进行近似，即压力可以分解为由于温差和由此产生的流动而产生的动态部分，以及仅由上层岩石的静压力产生的静态部分。由于后者要大得多，我们可以对 \) p_{{static}}=-{{ref}}
  [1+ T_{{ref}}]  \( 进行近似处理，从而对 \){Dp}{Dt}  \{-  u   {{ref}}
  [1+ T_{{ref}}]\} = {{ref}}
  [1+ T_{{ref}}]  u   g \( 进行处理。 换句话说，如果流体沿着重力方向（向下）运动，它将被压缩，因为在这种情况下 \) u
    g &gt; 0 \( 我们得到一个正的热源。反之，如果流体逆着重力方向运动，它将被冷却。 &lt;li&gt; &lt;b&gt;Compressibility:&lt;/b&gt; 正如在上面的温度模型中已经暗示的那样，地幔岩石不是不可压缩的。相反，鉴于地幔中的巨大压力（在地核-地幔边界，压力约为140GPa，相当于大气压力的140万倍），岩石实际上确实被压缩到它在表面压力下的密度的1.5倍左右。对这一情况进行建模会遇到很多困难。首先，质量守恒方程不再是 \){div}\; u=0 \( ，而应该是 \){div}( u)=0 \( ，其中密度 \) \( 现在不再是空间常数，而是取决于温度和压力。一个后果是，该模型现在不再是线性的；线性化的斯托克斯方程也不再是对称的，需要我们重新考虑预处理程序，甚至可能是离散化。至于如何解决这个问题，我们在这里就不做详细介绍了。 &lt;li&gt; &lt;b&gt;Nonlinear material models:&lt;/b&gt; 正如在不同地方已经暗示的那样，材料参数，如密度、粘度和各种热参数，在整个地幔中并不恒定。相反，它们非线性地依赖于压力和温度，在粘度的情况下，还依赖于应变率 \)( u)
</pre><p></code></pre><p></code></p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
