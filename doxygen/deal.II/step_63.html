<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_63.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-63 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-63 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_16.html">step-16</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Equation">Equation</a>
      <ul>
        <li><a href="#Streamlinediffusion">Streamline diffusion</a>
      </ul>
        <li><a href="#Smoothers">Smoothers</a>
        <li><a href="#Testproblem">Test problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#MeshWorkerdata">MeshWorker data</a>
        <li><a href="#Problemparameters">Problem parameters</a>
        <li><a href="#Cellpermutations">Cell permutations</a>
        <li><a href="#Righthandsideandboundaryvalues">Right-hand side and boundary values</a>
        <li><a href="#Streamlinediffusionimplementation">Streamline diffusion implementation</a>
        <li><a href="#codeAdvectionProlemcodeclass"><code>AdvectionProlem</code> class</a>
      <ul>
        <li><a href="#codeAdvectionProblemsetup_systemcode"><code>AdvectionProblem::setup_system()</code></a>
        <li><a href="#codeAdvectionProblemassemble_cellcode"><code>AdvectionProblem::assemble_cell()</code></a>
        <li><a href="#codeAdvectionProblemassemble_system_and_multigridcode"><code>AdvectionProblem::assemble_system_and_multigrid()</code></a>
        <li><a href="#codeAdvectionProblemsetup_smoothercode"><code>AdvectionProblem::setup_smoother()</code></a>
        <li><a href="#codeAdvectionProblemsolvecode"><code>AdvectionProblem::solve()</code></a>
        <li><a href="#codeAdvectionProblemoutput_resultscode"><code>AdvectionProblem::output_results()</code></a>
        <li><a href="#codeAdvectionProblemruncode"><code>AdvectionProblem::run()</code></a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#GMRESIterationNumbers"> GMRES Iteration Numbers </a>
      <ul>
        <li><a href="#DoFCellRenumbering"> DoF/Cell Renumbering </a>
        <li><a href="#Pointvsblocksmoothers"> Point vs. block smoothers </a>
      </ul>
        <li><a href="#Cost"> Cost </a>
        <li><a href="#Additionalpoints"> Additional points </a>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
      <ul>
        <li><a href="#ConstantiterationsforQsub5sub"> Constant iterations for Q<sub>5</sub> </a>
        <li><a href="#Effectivenessofrenumberingforchangingepsilon"> Effectiveness of renumbering for changing epsilon </a>
        <li><a href="#Meshadaptivity"> Mesh adaptivity </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Thomas C. Clevenger and Timo Heister.</em></p>
<p><em>The creation of this tutorial was partially supported by NSF Award DMS-1522191, DMS-1901529, OAC-1835452, by the Computational Infrastructure in Geodynamics initiative (CIG), through the NSF under Award EAR-0949446 and EAR-1550901 and The University of California - Davis. </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3382899"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3382899.svg" alt="10.5281/zenodo.3382899"/></a> </dd></dl>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program solves an advection-diffusion problem using a geometric multigrid (GMG) preconditioner. The basics of this preconditioner are discussed in <a class="el" href="step_16.html">step-16</a>; here we discuss the necessary changes needed for a non-symmetric PDE. Additionally, we introduce the idea of block smoothing (as compared to point smoothing in <a class="el" href="step_16.html">step-16</a>), and examine the effects of DoF renumbering for additive and multiplicative smoothers.</p>
<p><a class="anchor" id="Equation"></a></p><h3>Equation</h3>
<p>The advection-diffusion equation is given by </p><p class="formulaDsp">
\begin{align*} -\varepsilon \Delta u + \boldsymbol{\beta}\cdot \nabla u &amp; = f &amp; \text{ in } \Omega\\ u &amp;= g &amp; \text{ on } \partial\Omega \end{align*}
</p>
<p> where \(\varepsilon&gt;0\), \(\boldsymbol{\beta}\) is the <em>advection direction</em>, and \(f\) is a source. A few notes:</p>
<ol type="1">
<li>If \(\boldsymbol{\beta}=\boldsymbol{0}\), this is the Laplace equation solved in <a class="el" href="step_16.html">step-16</a> (and many other places).</li>
<li>If \(\varepsilon=0\) then this is the stationary advection equation solved in <a class="el" href="step_9.html">step-9</a>.</li>
<li>One can define a dimensionless number for this problem, called the <em>Peclet number</em>: \(\mathcal{P} \dealcoloneq \frac{\|\boldsymbol{\beta}\| L}{\varepsilon}\), where \(L\) is the length scale of the domain. It characterizes the kind of equation we are considering: If \(\mathcal{P}&gt;1\), we say the problem is <em>advection-dominated</em>, else if \(\mathcal{P}&lt;1\) we will say the problem is <em>diffusion-dominated</em>.</li>
</ol>
<p>For the discussion in this tutorial we will be concerned with advection-dominated flow. This is the complicated case: We know that for diffusion-dominated problems, the standard Galerkin method works just fine, and we also know that simple multigrid methods such as those defined in <a class="el" href="step_16.html">step-16</a> are very efficient. On the other hand, for advection-dominated problems, the standard Galerkin approach leads to oscillatory and unstable discretizations, and simple solvers are often not very efficient. This tutorial program is therefore intended to address both of these issues.</p>
<p><a class="anchor" id="Streamlinediffusion"></a></p><h4>Streamline diffusion</h4>
<p>Using the standard Galerkin finite element method, for suitable test functions \(v_h\), a discrete weak form of the PDE would read </p><p class="formulaDsp">
\begin{align*} a(u_h,v_h) = F(v_h) \end{align*}
</p>
<p> where </p><p class="formulaDsp">
\begin{align*} a(u_h,v_h) &amp;= (\varepsilon \nabla v_h,\, \nabla u_h) + (v_h,\,\boldsymbol{\beta}\cdot \nabla u_h),\\ F(v_h) &amp;= (v_h,\,f). \end{align*}
</p>
<p>Unfortunately, one typically gets oscillatory solutions with this approach. Indeed, the following error estimate can be shown for this formulation: </p><p class="formulaDsp">
\begin{align*} \|\nabla (u-u_h)\| \leq (1+\mathcal{P}) \inf_{v_h} \|\nabla (u-v_h)\|. \end{align*}
</p>
<p> The infimum on the right can be estimated as follows if the exact solution is sufficiently smooth: </p><p class="formulaDsp">
\begin{align*} \inf_{v_h} \|\nabla (u-v_h)\|. \le \|\nabla (u-I_h u)\| \le h^k C \|\nabla^k u)\| \end{align*}
</p>
<p> where \(k\) is the polynomial degree of the finite elements used. As a consequence, we obtain the estimate </p><p class="formulaDsp">
\begin{align*} \|\nabla (u-u_h)\| \leq (1+\mathcal{P}) C h^k \|\nabla^k u)\|. \end{align*}
</p>
<p> In other words, the numerical solution will converge. On the other hand, given the definition of \(\mathcal{P}\) above, we have to expect poor numerical solutions with a large error when \(\varepsilon \ll \|\boldsymbol{\beta}\| L\), i.e., if the problem has only a small amount of diffusion.</p>
<p>To combat this, we will consider the new weak form </p><p class="formulaDsp">
\begin{align*} a(u_h,\,v_h) + \sum_K (-\varepsilon \Delta u_h + \boldsymbol{\beta}\cdot \nabla u_h-f,\,\delta_K \boldsymbol{\beta}\cdot \nabla v_h)_K = F(v_h) \end{align*}
</p>
<p> where the sum is done over all cells \(K\) with the inner product taken for each cell, and \(\delta_K\) is a cell-wise constant stabilization parameter defined in <b>[john2006discontinuity]</b>.</p>
<p>Essentially, adding in the discrete strong form residual enhances the coercivity of the bilinear form \(a(\cdot,\cdot)\) which increases the stability of the discrete solution. This method is commonly referred to as <em>streamline diffusion</em> or <em>SUPG</em> (streamline upwind/Petrov-Galerkin).</p>
<p><a class="anchor" id="Smoothers"></a></p><h3>Smoothers</h3>
<p>One of the goals of this tutorial is to expand from using a simple (point-wise) Gauss-Seidel (SOR) smoother that is used in <a class="el" href="step_16.html">step-16</a> (class <a class="el" href="classPreconditionSOR.html">PreconditionSOR</a>) on each level of the multigrid hierarchy. The term "point-wise" is traditionally used in solvers to indicate that one solves at one "grid point" at a time; for scalar problems, this means to use a solver that updates one unknown of the linear system at a time, keeping all of the others fixed; one would then iterate over all unknowns in the problem and, once done, start over again from the first unknown until these "sweeps" converge. Jacobi, Gauss-Seidel, and SOR iterations can all be interpreted in this way. In the context of multigrid, one does not think of these methods as "solvers", but as "smoothers". As such, one is not interested in actually solving the linear system. It is enough to remove the high-frequency part of the residual for the multigrid method to work, because that allows restricting the solution to a coarser mesh. Therefore, one only does a few, fixed number of "sweeps" over all unknowns. In the code in this tutorial this is controlled by the "Smoothing steps" parameter.</p>
<p>But these methods are known to converge rather slowly when used as solvers. While as multigrid smoothers, they are surprisingly good, they can also be improved upon. In particular, we consider "cell-based" smoothers here as well. These methods solve for all unknowns on a cell at once, keeping all other unknowns fixed; they then move on to the next cell, and so on and so forth. One can think of them as "block" versions of Jacobi, Gauss-Seidel, or SOR, but because degrees of freedom are shared among multiple cells, these blocks overlap and the methods are in fact best be explained within the framework of additive and multiplicative Schwarz methods.</p>
<p>In contrast to <a class="el" href="step_16.html">step-16</a>, our test problem contains an advective term. Especially with a small diffusion constant \(\varepsilon\), information is transported along streamlines in the given advection direction. This means that smoothers are likely to be more effective if they allow information to travel in downstream direction within a single smoother application. If we want to solve one unknown (or block of unknowns) at a time in the order in which these unknowns (or blocks) are enumerated, then this information propagation property requires reordering degrees of freedom or cells (for the cell-based smoothers) accordingly so that the ones further upstream are treated earlier (have lower indices) and those further downstream are treated later (have larger indices). The influence of the ordering will be visible in the results section.</p>
<p>Let us now briefly define the smoothers used in this tutorial. For a more detailed introduction, we refer to <b>[KanschatNotesIterative]</b> and the books <b>[smith2004domain]</b> and <b>[toselli2006domain]</b>. A Schwarz preconditioner requires a decomposition </p><p class="formulaDsp">
\begin{align*} V = \sum_{j=1}^J V_j \end{align*}
</p>
<p> of our finite element space \(V\). Each subproblem \(V_j\) also has a Ritz projection \(P_j: V \rightarrow V_j\) based on the bilinear form \(a(\cdot,\cdot)\). This projection induces a local operator \(A_j\) for each subproblem \(V_j\). If \(\Pi_j:V\rightarrow V_j\) is the orthogonal projector onto \(V_j\), one can show \(A_jP_j=\Pi_j^TA\).</p>
<p>With this we can define an <em>additive Schwarz preconditioner</em> for the operator \(A\) as </p><p class="formulaDsp">
\begin{align*} B^{-1} = \sum_{j=1}^J P_j A^{-1} = \sum_{j=1}^J A_j^{-1} \Pi_j^T. \end{align*}
</p>
<p> In other words, we project our solution into each subproblem, apply the inverse of the subproblem \(A_j\), and sum the contributions up over all \(j\).</p>
<p>Note that one can interpret the point-wise (one unknown at a time) Jacobi method as an additive Schwarz method by defining a subproblem \(V_j\) for each degree of freedom. Then, \(A_j^{-1}\) becomes a multiplication with the inverse of a diagonal entry of \(A\).</p>
<p>For the "Block Jacobi" method used in this tutorial, we define a subproblem \(V_j\) for each cell of the mesh on the current level. Note that we use a continuous finite element, so these blocks are overlapping, as degrees of freedom on an interface between two cells belong to both subproblems. The logic for the Schwarz operator operating on the subproblems (in deal.II they are called "blocks") is implemented in the class <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a>. The "Block
Jacobi" method is implemented in the class <a class="el" href="classRelaxationBlockJacobi.html">RelaxationBlockJacobi</a>. Many aspects of the class (for example how the blocks are defined and how to invert the local subproblems \(A_j\)) can be configured in the smoother data, see <a class="el" href="classRelaxationBlock_1_1AdditionalData.html">RelaxationBlock::AdditionalData</a> and <a class="el" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches()</a> for details.</p>
<p>So far, we discussed additive smoothers where the updates can be applied independently and there is no information flowing within a single smoother application. A <em>multiplicative Schwarz preconditioner</em> addresses this and is defined by </p><p class="formulaDsp">
\begin{align*} B^{-1} = \left( I- \prod_{j=1}^J \left(I-P_j\right) \right) A^{-1}. \end{align*}
</p>
<p> In contrast to above, the updates on the subproblems \(V_j\) are applied sequentially. This means that the update obtained when inverting the subproblem \(A_j\) is immediately used in \(A_{j+1}\). This becomes visible when writing out the project: </p><p class="formulaDsp">
\begin{align*} B^{-1} = \left( I - \left(I-P_1\right)\left(I-P_2\right)\cdots\left(I-P_J\right) \right) A^{-1} = A^{-1} - \left[ \left(I-P_1\right) \left[ \left(I-P_2\right)\cdots \left[\left(I-P_J\right) A^{-1}\right] \cdots \right] \right] \end{align*}
</p>
<p>When defining the sub-spaces \(V_j\) as whole blocks of degrees of freedom, this method is implemented in the class <a class="el" href="classRelaxationBlockSOR.html">RelaxationBlockSOR</a> and used when you select "Block SOR" in this tutorial. The class <a class="el" href="classRelaxationBlockSOR.html">RelaxationBlockSOR</a> is also derived from <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a>. As such, both additive and multiplicative Schwarz methods are implemented in a unified framework.</p>
<p>Finally, let us note that the standard Gauss-Seidel (or SOR) method can be seen as a multiplicative Schwarz method with a subproblem for each DoF.</p>
<p><a class="anchor" id="Testproblem"></a></p><h3>Test problem</h3>
<p>We will be considering the following test problem: \(\Omega = [-1,\,1]\times[-1,\,1]\backslash B_{0.3}(0)\), i.e., a square with a circle of radius 0.3 centered at the origin removed. In addition, we use \(\varepsilon=0.005\), \(\boldsymbol{\beta} = [-\sin(\pi/6),\,\cos(\pi/6)]\), \(f=0\), and Dirichlet boundary values </p><p class="formulaDsp">
\begin{align*} g = \left\{\begin{array}{ll} 1 &amp; \text{if } x=-1 \text{ or } y=-1,\,x\geq 0.5 \\ 0 &amp; \text{otherwise} \end{array}\right. \end{align*}
</p>
<p>The following figures depict the solutions with (left) and without (right) streamline diffusion. Without streamline diffusion we see large oscillations around the boundary layer, demonstrating the instability of the standard Galerkin finite element method for this problem.</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-solution.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-solution-no-sd.png"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Typical files needed for standard deal.II:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation__block_8h.html">deal.II/lac/relaxation_block.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div></div><!-- fragment --><p>Include all relevant multilevel files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div></div><!-- fragment --><p>We will be using <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a> functionality for assembling matrices:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p><a class="anchor" id="MeshWorkerdata"></a> </p><h3><a class="el" href="namespaceMeshWorker.html">MeshWorker</a> data</h3>
<p>As always, we will be putting everything related to this program into a namespace of its own.</p>
<p>Since we will be using the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework, the first step is to define the following structures needed by the assemble_cell() function used by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>: <code>ScratchData</code> contains an <a class="el" href="classFEValues.html">FEValues</a> object which is needed for assembling a cell's local contribution, while <code>CopyData</code> contains the output from a cell's local contribution and necessary information to copy that to the global system. (Their purpose is also explained in the documentation of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class.)</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step63</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree)</div><div class="line">      : fe_values(fe,</div><div class="line">                  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    CopyData() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  };</div></div><!-- fragment --><p><a class="anchor" id="Problemparameters"></a> </p><h3>Problem parameters</h3>
<p>The second step is to define the classes that deal with run-time parameters to be read from an input file.</p>
<p>We will use <a class="el" href="classParameterHandler.html">ParameterHandler</a> to pass in parameters at runtime. The structure <code>Settings</code> parses and stores the parameters to be queried throughout the program.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">{</div><div class="line">  <span class="keyword">enum</span> DoFRenumberingStrategy</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>,</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream</a>,</div><div class="line">    upstream,</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random</a></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>                 <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           fe_degree;</div><div class="line">  std::string            smoother_type;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           smoothing_steps;</div><div class="line">  DoFRenumberingStrategy dof_renumbering;</div><div class="line">  <span class="keywordtype">bool</span>                   with_streamline_diffusion;</div><div class="line">  <span class="keywordtype">bool</span>                   output;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Settings::get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename)</div><div class="line">{</div><div class="line">  <span class="comment">// First declare the parameters... </span></div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;0.005&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Diffusion parameter&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;Finite Element degree&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;block SOR&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;SOR|Jacobi|block SOR|block Jacobi&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Select smoother: SOR|Jacobi|block SOR|block Jacobi&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;Number of smoothing steps&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;DoF renumbering&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;downstream&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;none|downstream|upstream|random&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;Select DoF renumbering: none|downstream|upstream|random&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Enable streamline diffusion stabilization: true|false&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Generate graphical output: true|false&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// ...and then try to read their values from the input file :</span></div><div class="line">  <span class="keywordflow">if</span> (prm_filename.empty())</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">        <span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Please pass a .prm file as the first argument!&quot;</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(prm_filename);</div><div class="line"></div><div class="line">  <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>         = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>);</div><div class="line">  fe_degree       = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>);</div><div class="line">  smoother_type   = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>);</div><div class="line">  smoothing_steps = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string renumbering = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;DoF renumbering&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;none&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">DoFRenumberingStrategy::none</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;downstream&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumberingStrategy::downstream</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;upstream&quot;</span>)</div><div class="line">    dof_renumbering = DoFRenumberingStrategy::upstream;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;random&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumberingStrategy::random</a>;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;The &lt;DoF renumbering&gt; parameter has &quot;</span></div><div class="line">                           <span class="stringliteral">&quot;an invalid value.&quot;</span>));</div><div class="line"></div><div class="line">  with_streamline_diffusion = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>);</div><div class="line">  output                    = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Output&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Cellpermutations"></a> </p><h3>Cell permutations</h3>
<p>The ordering in which cells and degrees of freedom are traversed will play a role in the speed of convergence for multiplicative methods. Here we define functions which return a specific ordering of cells to be used by the block smoothers.</p>
<p>For each type of cell ordering, we define a function for the active mesh and one for a level mesh (i.e., for the cells at one level of a multigrid hierarchy). While the only reordering necessary for solving the system will be on the level meshes, we include the active reordering for visualization purposes in output_results().</p>
<p>For the two downstream ordering functions, we first create an array with all of the relevant cells that we then sort in downstream direction using a "comparator" object. The output of the functions is then simply an array of the indices of the cells in the just computed order.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">{</div><div class="line">  std::vector&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">    ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> DoFRenumbering::</div><div class="line">    CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator, dim&gt;</div><div class="line">      comparator(direction);</div><div class="line">  std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned&gt; ordered_indices;</div><div class="line">  ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">    ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_indices;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction)</div><div class="line">{</div><div class="line">  std::vector&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> DoFRenumbering::</div><div class="line">    CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator, dim&gt;</div><div class="line">      comparator(direction);</div><div class="line">  std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">  ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">    ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_indices;</div><div class="line">}</div></div><!-- fragment --><p>The functions that produce a random ordering are similar in spirit in that they first put information about all cells into an array. But then, instead of sorting them, they shuffle the elements randomly using the facilities C++ offers to generate random numbers. The way this is done is by iterating over all elements of the array, drawing a random number for another element before that, and then exchanging these elements. The result is a random shuffle of the elements of the array.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">    ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  std::mt19937 random_number_generator;</div><div class="line">  std::shuffle(ordered_cells.begin(),</div><div class="line">               ordered_cells.end(),</div><div class="line">               random_number_generator);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_cells;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  std::mt19937 random_number_generator;</div><div class="line">  std::shuffle(ordered_cells.begin(),</div><div class="line">               ordered_cells.end(),</div><div class="line">               random_number_generator);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_cells;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideandboundaryvalues"></a> </p><h3>Right-hand side and boundary values</h3>
<p>The problem solved in this tutorial is an adaptation of Ex. 3.1.3 found on pg. 118 of <a href="https://global.oup.com/academic/product/finite-elements-and-fast-iterative-solvers-9780199678808">Finite Elements and Fast Iterative Solvers: with Applications in Incompressible Fluid Dynamics by Elman, Silvester, and Wathen</a>. The main difference being that we add a hole in the center of our domain with zero Dirichlet boundary conditions.</p>
<p>For a complete description, we need classes that implement the zero right-hand side first (we could of course have just used <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  (void)component;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0.0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                    std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">    values[i] = RightHandSide&lt;dim&gt;::value(points[i], component);</div><div class="line">}</div></div><!-- fragment --><p>We also have Dirichlet boundary conditions. On a connected portion of the outer, square boundary we set the value to 1, and we set the value to 0 everywhere else (including the inner, circular boundary):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  (void)component;</div></div><!-- fragment --><p>Set boundary to 1 if \(x=1\), or if \(x&gt;0.5\) and \(y=-1\).</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[0] - 1) &lt; 1e-8 ||</div><div class="line">      (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[1] + 1) &lt; 1e-8 &amp;&amp; p[0] &gt;= 0.5))</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> 1.0;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> 0.0;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">    values[i] = BoundaryValues&lt;dim&gt;::value(points[i], component);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Streamlinediffusionimplementation"></a> </p><h3>Streamline diffusion implementation</h3>
<p>The streamline diffusion method has a stabilization constant that we need to be able to compute. The choice of how this parameter is computed is taken from <a href="https://link.springer.com/chapter/10.1007/978-3-540-34288-5_27">On Discontinuity-Capturing Methods for Convection-Diffusion Equations by Volker John and Petr Knobloch</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> compute_stabilization_delta(<span class="keyword">const</span> <span class="keywordtype">double</span>         hk,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>         <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acf35b7afd6a85044d32320355fbaabfe">eps</a>,</div><div class="line">                                   <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dir,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>         pk)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> Peclet = dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * hk / (2.0 * eps * pk);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a66e76f1c4fdb9a31f4fabef8abee5f28">coth</a> =</div><div class="line">    (1.0 + <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> hk / (2.0 * dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * pk) * (coth - 1.0 / Peclet);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeAdvectionProlemcodeclass"></a> </p><h3><code>AdvectionProlem</code> class</h3>
<p>This is the main class of the program, and should look very similar to <a class="el" href="step_16.html">step-16</a>. The major difference is that, since we are defining our multigrid smoother at runtime, we choose to define a function <code>create_smoother()</code> and a class object <code>mg_smoother</code> which is a <code>std::unique_ptr</code> to a smoother that is derived from <a class="el" href="classMGSmoother.html">MGSmoother</a>. Note that for smoothers derived from <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a>, we must include a <code>smoother_data</code> object for each level. This will contain information about the cell ordering and the method of inverting cell matrices.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AdvectionProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">  <span class="keywordtype">void</span> assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                     ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                     CopyData &amp;          copy_data);</div><div class="line">  <span class="keywordtype">void</span> assemble_system_and_multigrid();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_smoother();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>     fe;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line"></div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix;</div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_in;</div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_out;</div><div class="line"></div><div class="line">  std::unique_ptr&lt;MGSmoother&lt;Vector&lt;double&gt;&gt;&gt; mg_smoother;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> SmootherType =</div><div class="line">    <a class="code" href="classRelaxationBlock.html">RelaxationBlock&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classdouble.html">double</a>, Vector&lt;double&gt;&gt;;</div><div class="line">  <span class="keyword">using</span> SmootherAdditionalDataType = SmootherType::AdditionalData;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SmootherAdditionalDataType&gt;</a> smoother_data;</div><div class="line"></div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> advection_direction;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> settings;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">AdvectionProblem&lt;dim&gt;::AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe(settings.fe_degree)</div><div class="line">  , mapping(settings.fe_degree)</div><div class="line">  , settings(settings)</div><div class="line">{</div><div class="line">  advection_direction[0] = -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI / 6.0);</div><div class="line">  <span class="keywordflow">if</span> (dim &gt;= 2)</div><div class="line">    advection_direction[1] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI / 6.0);</div><div class="line">  <span class="keywordflow">if</span> (dim &gt;= 3)</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeAdvectionProblemsetup_systemcode"></a> </p><h4><code>AdvectionProblem::setup_system()</code></h4>
<p>Here we first set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, and <a class="el" href="classSparsityPattern.html">SparsityPattern</a> objects for both active and multigrid level meshes.</p>
<p>We could renumber the active DoFs with the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> class, but the smoothers only act on multigrid levels and as such, this would not matter for the computations. Instead, we will renumber the DoFs on each multigrid level below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.clear();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 1, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">  constraints.close();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                  dsp,</div><div class="line">                                  constraints,</div><div class="line">                                  <span class="comment">//keep_constrained_dofs ！改 =  false);</span></div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div></div><!-- fragment --><p>Having enumerated the global degrees of freedom as well as (in the last line above) the level degrees of freedom, let us renumber the level degrees of freedom to get a better smoother as explained in the introduction. The first block below renumbers DoFs on each level in downstream or upstream direction if needed. This is only necessary for point smoothers (SOR and Jacobi) as the block smoothers operate on cells (see <code>create_smoother()</code>). The blocks below then also implement random numbering.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span> || settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">          <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a> ||</div><div class="line">        settings.dof_renumbering ==</div><div class="line">          Settings::DoFRenumberingStrategy::upstream)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> direction =</div><div class="line">          (settings.dof_renumbering ==</div><div class="line">               Settings::DoFRenumberingStrategy::upstream ?</div><div class="line">             -1.0 :</div><div class="line">             1.0) *</div><div class="line">          advection_direction;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">          <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumbering::downstream</a>(dof_handler,</div><div class="line">                                     level,</div><div class="line">                                     direction,</div><div class="line">                                     <span class="comment">//dof_wise_renumbering = !改 true);</span></div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">             <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">          <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumbering::random</a>(dof_handler, level);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div></div><!-- fragment --><p>The rest of the function just sets up data structures. The last lines of the code below is unlike the other GMG tutorials, as it sets up both the interface in and out matrices. We need this since our problem is non-symmetric.</p>
<div class="fragment"><div class="line">  mg_constrained_dofs.clear();</div><div class="line">  mg_constrained_dofs.initialize(dof_handler);</div><div class="line"></div><div class="line">  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});</div><div class="line"></div><div class="line">  mg_matrices.resize(0, n_levels - 1);</div><div class="line">  mg_matrices.clear_elements();</div><div class="line">  mg_interface_in.resize(0, n_levels - 1);</div><div class="line">  mg_interface_in.clear_elements();</div><div class="line">  mg_interface_out.resize(0, n_levels - 1);</div><div class="line">  mg_interface_out.clear_elements();</div><div class="line">  mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">  mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                 mg_constrained_dofs,</div><div class="line">                                                 dsp,</div><div class="line">                                                 level);</div><div class="line">        mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">        mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">        mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeAdvectionProblemassemble_cellcode"></a> </p><h4><code>AdvectionProblem::assemble_cell()</code></h4>
<p>Here we define the assembly of the linear system on each cell to be used by the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function below. This one function assembles the cell matrix for either an active or a level cell (whatever it is passed as its first argument), and only assembles a right-hand side if called with an active cell.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                                          ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                          CopyData &amp;          copy_data)</div><div class="line">{</div><div class="line">  copy_data.level = cell-&gt;level();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  copy_data.dofs_per_cell = dofs_per_cell;</div><div class="line">  copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch_data.fe_values.get_quadrature().size();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">    copy_data.cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">  copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line">  cell-&gt;get_active_or_mg_dof_indices(copy_data.local_dof_indices);</div><div class="line"></div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">  std::vector&lt;double&gt; rhs_values(n_q_points);</div><div class="line"></div><div class="line">  right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),</div><div class="line">                             rhs_values);</div></div><!-- fragment --><p>If we are using streamline diffusion we must add its contribution to both the cell matrix and the cell right-hand side. If we are not using streamline diffusion, setting \(\delta=0\) negates this contribution below and we are left with the standard, Galerkin finite element assembly.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> delta = (settings.with_streamline_diffusion ?</div><div class="line">                        compute_stabilization_delta(cell-&gt;diameter(),</div><div class="line">                                                    settings.epsilon,</div><div class="line">                                                    advection_direction,</div><div class="line">                                                    settings.fe_degree) :</div><div class="line">                        0.0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div></div><!-- fragment --><p>The assembly of the local matrix has two parts. First the Galerkin contribution:</p>
<div class="fragment"><div class="line">copy_data.cell_matrix(i, j) +=</div><div class="line">  (settings.epsilon *</div><div class="line">   scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">   scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">   scratch_data.fe_values.JxW(q_point)) +</div><div class="line">  (scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">   (advection_direction *</div><div class="line">    scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">   scratch_data.fe_values.JxW(q_point))</div></div><!-- fragment --><p>and then the streamline diffusion contribution:</p>
<div class="fragment"><div class="line">      + delta *</div><div class="line">          (advection_direction *</div><div class="line">           scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">          (advection_direction *</div><div class="line">           scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">          scratch_data.fe_values.JxW(q_point) -</div><div class="line">      delta * settings.epsilon *</div><div class="line">        <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(scratch_data.fe_values.shape_hessian(j, q_point)) *</div><div class="line">        (advection_direction *</div><div class="line">         scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">        scratch_data.fe_values.JxW(q_point);</div><div class="line">  }</div><div class="line"><span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">  {</div></div><!-- fragment --><p>The same applies to the right hand side. First the Galerkin contribution:</p>
<div class="fragment"><div class="line">copy_data.cell_rhs(i) +=</div><div class="line">  scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">    rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)</div></div><!-- fragment --><p>and then the streamline diffusion contribution:</p>
<div class="fragment"><div class="line">              + delta * rhs_values[q_point] * advection_direction *</div><div class="line">                  scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">                  scratch_data.fe_values.JxW(q_point);</div><div class="line">          }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeAdvectionProblemassemble_system_and_multigridcode"></a> </p><h4><code>AdvectionProblem::assemble_system_and_multigrid()</code></h4>
<p>Here we employ <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to go over cells and assemble the system_matrix, system_rhs, and all mg_matrices for us.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system_and_multigrid()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_active =</div><div class="line">    [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()) &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                          scratch_data,</div><div class="line">        CopyData &amp;                                  copy_data) {</div><div class="line">      this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier_active = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    constraints.distribute_local_to_global(copy_data.cell_matrix,</div><div class="line">                                           copy_data.cell_rhs,</div><div class="line">                                           copy_data.local_dof_indices,</div><div class="line">                                           system_matrix,</div><div class="line">                                           system_rhs);</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker_active,</div><div class="line">                        copier_active,</div><div class="line">                        ScratchData&lt;dim&gt;(fe, fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div></div><!-- fragment --><p>Unlike the constraints for the active level, we choose to create constraint objects for each multigrid level local to this function since they are never needed elsewhere in the program.</p>
<div class="fragment"><div class="line">std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>());</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_level_dof_indices;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(</div><div class="line">      dof_handler, level, locally_owned_level_dof_indices);</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(locally_owned_level_dof_indices);</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">      mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">      mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_mg =</div><div class="line">  [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>()) &amp;cell,</div><div class="line">      ScratchData&lt;dim&gt; &amp;                      scratch_data,</div><div class="line">      CopyData &amp;                              copy_data) {</div><div class="line">    this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier_mg = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">  boundary_constraints[copy_data.level].distribute_local_to_global(</div><div class="line">    copy_data.cell_matrix,</div><div class="line">    copy_data.local_dof_indices,</div><div class="line">    mg_matrices[copy_data.level]);</div></div><!-- fragment --><p>If \((i,j)\) is an <code>interface_out</code> dof pair, then \((j,i)\) is an <code>interface_in</code> dof pair. Note: For <code>interface_in</code>, we load the transpose of the interface entries, i.e., the entry for dof pair \((j,i)\) is stored in <code>interface_in(i,j)</code>. This is an optimization for the symmetric case which allows only one matrix to be used when setting the edge_matrices in solve(). Here, however, since our problem is non-symmetric, we must store both <code>interface_in</code> and <code>interface_out</code> matrices.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.dofs_per_cell; ++j)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">              copy_data.level,</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j]))</div><div class="line">          {</div><div class="line">            mg_interface_out[copy_data.level].add(</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j],</div><div class="line">              copy_data.cell_matrix(i, j));</div><div class="line">            mg_interface_in[copy_data.level].add(</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j],</div><div class="line">              copy_data.cell_matrix(j, i));</div><div class="line">          }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                        cell_worker_mg,</div><div class="line">                        copier_mg,</div><div class="line">                        ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeAdvectionProblemsetup_smoothercode"></a> </p><h4><code>AdvectionProblem::setup_smoother()</code></h4>
<p>Next, we set up the smoother based on the settings in the <code>.prm</code> file. The two options that are of significance is the number of pre- and post-smoothing steps on each level of the multigrid v-cycle and the relaxation parameter.</p>
<p>Since multiplicative methods tend to be more powerful than additive method, fewer smoothing steps are required to see convergence independent of mesh size. The same holds for block smoothers over point smoothers. This is reflected in the choice for the number of smoothing steps for each type of smoother below.</p>
<p>The relaxation parameter for point smoothers is chosen based on trial and error, and reflects values necessary to keep the iteration counts in the GMRES solve constant (or as close as possible) as we refine the mesh. The two values given for both "Jacobi" and "SOR" in the <code>.prm</code> files are for degree 1 and degree 3 finite elements. If the user wants to change to another degree, they may need to adjust these numbers. For block smoothers, this parameter has a more straightforward interpretation, namely that for additive methods in 2D, a DoF can have a repeated contribution from up to 4 cells, therefore we must relax these methods by 0.25 to compensate. This is not an issue for multiplicative methods as each cell's inverse application carries new information to all its DoFs.</p>
<p>Finally, as mentioned above, the point smoothers only operate on DoFs, and the block smoothers on cells, so only the block smoothers need to be given information regarding cell orderings. DoF ordering for point smoothers has already been taken care of in <code>setup_system()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_smoother()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> smoother =</div><div class="line">        std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                Smoother,</div><div class="line">                                                Vector&lt;double&gt;&gt;&gt;();</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                           Smoother::AdditionalData(fe.degree == 1 ? 1.0 :</div><div class="line">                                                                     0.62));</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">      mg_smoother = std::move(smoother);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">      <span class="keyword">auto</span> smoother =</div><div class="line">        std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                Smoother,</div><div class="line">                                                Vector&lt;double&gt;&gt;&gt;();</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                           Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :</div><div class="line">                                                                     0.47));</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">      mg_smoother = std::move(smoother);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ||</div><div class="line">           settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">    {</div><div class="line">      smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() - 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches</a>(smoother_data[level].block_list,</div><div class="line">                                      dof_handler,</div><div class="line">                                      level);</div><div class="line"></div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].relaxation =</div><div class="line">            (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ? 1.0 : 0.25);</div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].inversion = <a class="code" href="classPreconditionBlockBase.html">PreconditionBlockBase&lt;double&gt;::svd</a>;</div><div class="line"></div><div class="line">          std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">          <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">                ordered_indices =</div><div class="line">                  create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                  advection_direction,</div><div class="line">                                                  level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">                ordered_indices =</div><div class="line">                  create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                  -1.0 * advection_direction,</div><div class="line">                                                  level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">                ordered_indices =</div><div class="line">                  create_random_cell_ordering(dof_handler, level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">default</span>:</div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].order =</div><div class="line">            std::vector&lt;std::vector&lt;unsigned int&gt;&gt;(1, ordered_indices);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> smoother = std::make_unique&lt;<a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a>&lt;</div><div class="line">            <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>,</div><div class="line">            <a class="code" href="classRelaxationBlockSOR.html">RelaxationBlockSOR&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classdouble.html">double</a>, Vector&lt;double&gt;&gt;,</div><div class="line">            Vector&lt;double&gt;&gt;&gt;();</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">          mg_smoother = std::move(smoother);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> smoother = std::make_unique&lt;</div><div class="line">            <a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;</a>,</div><div class="line">                                   <a class="code" href="classRelaxationBlockJacobi.html">RelaxationBlockJacobi&lt;SparseMatrix&lt;double&gt;</a>,</div><div class="line">                                                         double,</div><div class="line">                                                         Vector&lt;double&gt;&gt;,</div><div class="line">                                   Vector&lt;double&gt;&gt;&gt;();</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">          mg_smoother = std::move(smoother);</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeAdvectionProblemsolvecode"></a> </p><h4><code>AdvectionProblem::solve()</code></h4>
<p>Before we can solve the system, we must first set up the multigrid preconditioner. This requires the setup of the transfer between levels, the coarse matrix solver, and the smoother. This setup follows almost identically to <a class="el" href="step_16.html">step-16</a>, the main difference being the various smoothers defined above and the fact that we need different interface edge matrices for in and out since our problem is non-symmetric. (In reality, for this tutorial these interface matrices are empty since we are only using global refinement, and thus have no refinement edges. However, we have still included both here since if one made the simple switch to an adaptively refined method, the program would still run correctly.)</p>
<p>The last thing to note is that since our problem is non-symmetric, we must use an appropriate Krylov subspace method. We choose here to use GMRES since it offers the guarantee of residual reduction in each iteration. The major disavantage of GMRES is that, for each iteration, the number of stored temporary vectors increases by one, and one also needs to compute a scalar product with all previously stored vectors. This is rather expensive. This requirement is relaxed by using the restarted GMRES method which puts a cap on the number of vectors we are required to store at any one time (here we restart after 50 temporary vectors, or 48 iterations). This then has the disadvantage that we lose information we have gathered throughout the iteration and therefore we could see slower convergence. As a consequence, where to restart is a question of balancing memory consumption, CPU effort, and convergence speed. However, the goal of this tutorial is to have very low iteration counts by using a powerful GMG preconditioner, so we have picked the restart length such that all of the results shown below converge prior to restart happening, and thus we have a standard GMRES method. If the user is interested, another suitable method offered in deal.II would be BiCGStab.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iters       = 200;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       solve_tolerance = 1e-8 * system_rhs.l2_norm();</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>      solver_control(max_iters, solve_tolerance, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  solver_control.<a class="code" href="classSolverControl.html#a6d99741765243ccb65da4ff66558cf41">enable_history_data</a>();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> Transfer = MGTransferPrebuilt&lt;Vector&lt;double&gt;&gt;;</div><div class="line">  Transfer mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">  setup_smoother();</div><div class="line"></div><div class="line">  mg_matrix.initialize(mg_matrices);</div><div class="line">  mg_interface_matrix_in.initialize(mg_interface_in);</div><div class="line">  mg_interface_matrix_out.initialize(mg_interface_out);</div><div class="line"></div><div class="line">  <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">    mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);</div><div class="line">  <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, Transfer&gt; preconditioner(dof_handler,</div><div class="line">                                                               <a class="code" href="namespacemg.html">mg</a>,</div><div class="line">                                                               mg_transfer);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;     Solving with GMRES to tol &quot;</span> &lt;&lt; solve_tolerance &lt;&lt; <span class="stringliteral">&quot;...&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;Vector&lt;double&gt;</a>&gt; solver(</div><div class="line">    solver_control, <a class="code" href="classSolverGMRES.html">SolverGMRES</a>&lt;Vector&lt;double&gt;&gt;::AdditionalData(50, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  time.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;          converged in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#aba22973498b0e4c2b4d64bf799e95ba8">last_wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; seconds &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line"></div><div class="line">  mg_smoother.release();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeAdvectionProblemoutput_resultscode"></a> </p><h4><code>AdvectionProblem::output_results()</code></h4>
<p>The final function of interest generates graphical output. Here we output the solution and cell ordering in a .vtu format.</p>
<p>At the top of the function, we generate an index for each cell to visualize the ordering used by the smoothers. Note that we do this only for the active cells instead of the levels, where the smoothers are actually used. For the point smoothers we renumber DoFs instead of cells, so this is only an approximation of what happens in reality. Finally, the random ordering is not the random ordering we actually use (see <code>create_smoother()</code> for that).</p>
<p>The (integer) ordering of cells is then copied into a (floating point) vector for graphical output.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells = triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();</div><div class="line">  Vector&lt;double&gt;     cell_indices(n_active_cells);</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">    <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">          ordered_indices =</div><div class="line">            create_downstream_cell_ordering(dof_handler, advection_direction);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">          ordered_indices =</div><div class="line">            create_downstream_cell_ordering(dof_handler,</div><div class="line">                                            -1.0 * advection_direction);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">          ordered_indices = create_random_cell_ordering(dof_handler);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">          ordered_indices.resize(n_active_cells);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">            ordered_indices[i] = i;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">      cell_indices(ordered_indices[i]) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i);</div><div class="line">  }</div></div><!-- fragment --><p>The remainder of the function is then straightforward, given previous tutorial programs:</p>
<div class="fragment"><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(cell_indices, <span class="stringliteral">&quot;cell_index&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeAdvectionProblemruncode"></a> </p><h4><code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem::run()</a></code></h4>
<p>As in most tutorials, this function creates/refines the mesh and calls the various functions defined above to set up, assemble, solve, and output the results.</p>
<p>In cycle zero, we generate the mesh for the on the square <code>[-1,1]^dim</code> with a hole of radius 3/10 units centered at the origin. For objects with <code>manifold_id</code> equal to one (namely, the faces adjacent to the hole), we assign a spherical manifold.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; (settings.fe_degree == 1 ? 7 : 5);</div><div class="line">         ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation,</div><div class="line">                                                            0.3,</div><div class="line">                                                            1.0);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0));</div><div class="line">            triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, manifold_description);</div><div class="line">          }</div><div class="line"></div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>();</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of degrees of freedom: &quot;</span></div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system_and_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (settings.output)</div><div class="line">          output_results(cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step63</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>Finally, the main function is like most tutorials. The only interesting bit is that we require the user to pass a <code>.prm</code> file as a sole command line argument. If no parameter file is given, the program will output the contents of a sample parameter file with all default values to the screen that the user can then copy and paste into their own <code>.prm</code> file.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Step63::Settings</a> settings;</div><div class="line">      settings.get_parameters((argc &gt; 1) ? (argv[1]) : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">      Step63::AdvectionProblem&lt;2&gt; advection_problem_2d(settings);</div><div class="line">      advection_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="GMRESIterationNumbers"></a></p><h3>GMRES Iteration Numbers </h3>
<p>The major advantage for GMG is that it is an \(\mathcal{O}(n)\) method, that is, the complexity of the problem increases linearly with the problem size. To show then that the linear solver presented in this tutorial is in fact \(\mathcal{O}(n)\), all one needs to do is show that the iteration counts for the GMRES solve stay roughly constant as we refine the mesh.</p>
<p>Each of the following tables gives the GMRES iteration counts to reduce the initial residual by a factor of \(10^8\). We selected a sufficient number of smoothing steps (based on the method) to get iteration numbers independent of mesh size. As can be seen from the tables below, the method is indeed \(\mathcal{O}(n)\).</p>
<p><a class="anchor" id="DoFCellRenumbering"></a></p><h4>DoF/Cell Renumbering </h4>
<p>The point-wise smoothers ("Jacobi" and "SOR") get applied in the order the DoFs are numbered on each level. We can influence this using the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace. The block smoothers are applied based on the ordering we set in <code>setup_smoother()</code>. We can visualize this numbering. The following pictures show the cell numbering of the active cells in downstream, random, and upstream numbering (left to right):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-cell-order.png"/>
</div>
<p>Let us start with the additive smoothers. The following table shows the number of iterations necessary to obtain convergence from GMRES:</p>
<table align="center" class="doxtable">
<tr>
<th></th><th></th><th colspan="1">\(Q_1\) </th><th colspan="7">Smoother (smoothing steps)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Jacobi (6) </th><th></th><th colspan="3">Block Jacobi (3)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Renumbering Strategy </th><th></th><th colspan="3">Renumbering Strategy  </th></tr>
<tr>
<th>Cells </th><th></th><th>DoFs </th><th>Downstream </th><th>Random </th><th>Upstream </th><th></th><th>Downstream </th><th>Random </th><th>Upstream  </th></tr>
<tr>
<th>32 </th><th></th><th>48 </th><td>3 </td><td>3 </td><td>3 </td><th></th><td>3 </td><td>3 </td><td>3  </td></tr>
<tr>
<th>128 </th><th></th><th>160 </th><td>6 </td><td>6 </td><td>6 </td><th></th><td>6 </td><td>6 </td><td>6  </td></tr>
<tr>
<th>512 </th><th></th><th>576 </th><td>11 </td><td>11 </td><td>11 </td><th></th><td>9 </td><td>9 </td><td>9  </td></tr>
<tr>
<th>2048 </th><th></th><th>2176 </th><td>15 </td><td>15 </td><td>15 </td><th></th><td>13 </td><td>13 </td><td>13  </td></tr>
<tr>
<th>8192 </th><th></th><th>8448 </th><td>18 </td><td>18 </td><td>18 </td><th></th><td>15 </td><td>15 </td><td>15  </td></tr>
<tr>
<th>32768 </th><th></th><th>33280 </th><td>20 </td><td>20 </td><td>20 </td><th></th><td>16 </td><td>16 </td><td>16  </td></tr>
<tr>
<th>131072 </th><th></th><th>132096 </th><td>20 </td><td>20 </td><td>20 </td><th></th><td>16 </td><td>16 </td><td>16  </td></tr>
</table>
<p>We see that renumbering the DoFs/cells has no effect on convergence speed. This is because these smoothers compute operations on each DoF (point-smoother) or cell (block-smoother) independently and add up the results. Since we can define these smoothers as an application of a sum of matrices, and matrix addition is commutative, the order at which we sum the different components will not affect the end result.</p>
<p>On the other hand, the situation is different for multiplicative smoothers:</p>
<table align="center" class="doxtable">
<tr>
<th></th><th></th><th colspan="1">\(Q_1\) </th><th colspan="7">Smoother (smoothing steps)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">SOR (3) </th><th></th><th colspan="3">Block SOR (1)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Renumbering Strategy </th><th></th><th colspan="3">Renumbering Strategy  </th></tr>
<tr>
<th>Cells </th><th></th><th>DoFs </th><th>Downstream </th><th>Random </th><th>Upstream </th><th></th><th>Downstream </th><th>Random </th><th>Upstream  </th></tr>
<tr>
<th>32 </th><th></th><th>48 </th><td>2 </td><td>2 </td><td>3 </td><th></th><td>2 </td><td>2 </td><td>3  </td></tr>
<tr>
<th>128 </th><th></th><th>160 </th><td>5 </td><td>5 </td><td>7 </td><th></th><td>5 </td><td>5 </td><td>7  </td></tr>
<tr>
<th>512 </th><th></th><th>576 </th><td>7 </td><td>9 </td><td>11 </td><th></th><td>7 </td><td>7 </td><td>12  </td></tr>
<tr>
<th>2048 </th><th></th><th>2176 </th><td>10 </td><td>12 </td><td>15 </td><th></th><td>8 </td><td>10 </td><td>17  </td></tr>
<tr>
<th>8192 </th><th></th><th>8448 </th><td>11 </td><td>15 </td><td>19 </td><th></th><td>10 </td><td>11 </td><td>20  </td></tr>
<tr>
<th>32768 </th><th></th><th>33280 </th><td>12 </td><td>16 </td><td>20 </td><th></th><td>10 </td><td>12 </td><td>21  </td></tr>
<tr>
<th>131072 </th><th></th><th>132096 </th><td>12 </td><td>16 </td><td>19 </td><th></th><td>11 </td><td>12 </td><td>21  </td></tr>
</table>
<p>Here, we can speed up convergence by renumbering the DoFs/cells in the advection direction, and similarly, we can slow down convergence if we do the renumbering in the opposite direction. This is because advection-dominated problems have a directional flow of information (in the advection direction) which, given the right renumbering of DoFs/cells, multiplicative methods are able to capture.</p>
<p>This feature of multiplicative methods is, however, dependent on the value of \(\varepsilon\). As we increase \(\varepsilon\) and the problem becomes more diffusion-dominated, we have a more uniform propagation of information over the mesh and there is a diminished advantage for renumbering in the advection direction. On the opposite end, in the extreme case of \(\varepsilon=0\) (advection-only), we have a 1st-order PDE and multiplicative methods with the right renumbering become effective solvers: A correct downstream numbering may lead to methods that require only a single iteration because information can be propagated from the inflow boundary downstream, with no information transport in the opposite direction. (Note, however, that in the case of \(\varepsilon=0\), special care must be taken for the boundary conditions in this case).</p>
<p><a class="anchor" id="Pointvsblocksmoothers"></a></p><h4>Point vs. block smoothers </h4>
<p>We will limit the results to runs using the downstream renumbering. Here is a cross comparison of all four smoothers for both \(Q_1\) and \(Q_3\) elements:</p>
<table align="center" class="doxtable">
<tr>
<th></th><td></td><th colspan="1">\(Q_1\) </th><th colspan="4">Smoother (smoothing steps) </th><th></th><th colspan="1">\(Q_3\) </th><th colspan="4">Smoother (smoothing steps)  </th></tr>
<tr>
<th colspan="1">Cells </th><td></td><th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1) </th><th></th><th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1)  </th></tr>
<tr>
<th>32 </th><td></td><th>48 </th><td>3 </td><td>3 </td><td>2 </td><td>2 </td><td></td><th>336 </th><td>15 </td><td>14 </td><td>15 </td><td>6  </td></tr>
<tr>
<th>128 </th><td></td><th>160 </th><td>6 </td><td>6 </td><td>5 </td><td>5 </td><td></td><th>1248 </th><td>23 </td><td>18 </td><td>21 </td><td>9  </td></tr>
<tr>
<th>512 </th><td></td><th>576 </th><td>11 </td><td>9 </td><td>7 </td><td>7 </td><td></td><th>4800 </th><td>29 </td><td>21 </td><td>28 </td><td>9  </td></tr>
<tr>
<th>2048 </th><td></td><th>2176 </th><td>15 </td><td>13 </td><td>10 </td><td>8 </td><td></td><th>18816 </th><td>33 </td><td>22 </td><td>32 </td><td>9  </td></tr>
<tr>
<th>8192 </th><td></td><th>8448 </th><td>18 </td><td>15 </td><td>11 </td><td>10 </td><td></td><th>74496 </th><td>35 </td><td>22 </td><td>34 </td><td>10  </td></tr>
<tr>
<th>32768 </th><td></td><th>33280 </th><td>20 </td><td>16 </td><td>12 </td><td>10 </td><td></td></tr>
<tr>
<th>131072 </th><td></td><th>132096 </th><td>20 </td><td>16 </td><td>12 </td><td>11 </td><td></td></tr>
</table>
<p>We see that for \(Q_1\), both multiplicative smoothers require a smaller combination of smoothing steps and iteration counts than either additive smoother. However, when we increase the degree to a \(Q_3\) element, there is a clear advantage for the block smoothers in terms of the number of smoothing steps and iterations required to solve. Specifically, the block SOR smoother gives constant iteration counts over the degree, and the block Jacobi smoother only sees about a 38% increase in iterations compared to 75% and 183% for Jacobi and SOR respectively.</p>
<p><a class="anchor" id="Cost"></a></p><h3>Cost </h3>
<p>Iteration counts do not tell the full story in the optimality of a one smoother over another. Obviously we must examine the cost of an iteration. Block smoothers here are at a disadvantage as they are having to construct and invert a cell matrix for each cell. Here is a comparison of solve times for a \(Q_3\) element with 74,496 DoFs:</p>
<table align="center" class="doxtable">
<tr>
<th colspan="1">\(Q_3\) </th><th colspan="4">Smoother (smoothing steps)  </th></tr>
<tr>
<th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1)  </th></tr>
<tr>
<th>74496 </th><td>0.68s </td><td>5.82s </td><td>1.18s </td><td>1.02s  </td></tr>
</table>
<p>The smoother that requires the most iterations (Jacobi) actually takes the shortest time (roughly 2/3 the time of the next fastest method). This is because all that is required to apply a Jacobi smoothing step is multiplication by a diagonal matrix which is very cheap. On the other hand, while SOR requires over 3x more iterations (each with 3x more smoothing steps) than block SOR, the times are roughly equivalent, implying that a smoothing step of block SOR is roughly 9x slower than a smoothing step of SOR. Lastly, block Jacobi is almost 6x more expensive than block SOR, which intuitively makes sense from the fact that 1 step of each method has the same cost (inverting the cell matrices and either adding or multiply them together), and block Jacobi has 3 times the number of smoothing steps per iteration with 2 times the iterations.</p>
<p><a class="anchor" id="Additionalpoints"></a></p><h3>Additional points </h3>
<p>There are a few more important points to mention:</p>
<ol>
<li>
<p class="startli">For a mesh distributed in parallel, multiplicative methods cannot be executed over the entire domain. This is because they operate one cell at a time, and downstream cells can only be handled once upstream cells have already been done. This is fine on a single processor: The processor just goes through the list of cells one after the other. However, in parallel, it would imply that some processors are idle because upstream processors have not finished doing the work on cells upstream from the ones owned by the current processor. Once the upstream processors are done, the downstream ones can start, but by that time the upstream processors have no work left. In other words, most of the time during these smoother steps, most processors are in fact idle. This is not how one obtains good parallel scalability!</p>
<p>One can use a hybrid method where a multiplicative smoother is applied on each subdomain, but as you increase the number of subdomains, the method approaches the behavior of an additive method. This is a major disadvantage to these methods. </p>
<p class="endli"></p>
</li>
<li>
Current research into block smoothers suggest that soon we will be able to compute the inverse of the cell matrices much cheaper than what is currently being done inside deal.II. This research is based on the fast diagonalization method (dating back to the 1960s) and has been used in the spectral community for around 20 years (see, e.g., <a href="https://doi.org/10.1007/s10915-004-4787-3">Hybrid Multigrid/Schwarz Algorithms for the Spectral Element Method by Lottes and Fischer</a>). There are currently efforts to generalize these methods to DG and make them more robust. Also, it seems that one should be able to take advantage of matrix-free implementations and the fact that, in the interior of the domain, cell matrices tend to look very similar, allowing fewer matrix inverse computations.  </li>
</ol>
<p>Combining 1. and 2. gives a good reason for expecting that a method like block Jacobi could become very powerful in the future, even though currently for these examples it is quite slow.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="ConstantiterationsforQsub5sub"></a></p><h4>Constant iterations for Q<sub>5</sub> </h4>
<p>Change the number of smoothing steps and the smoother relaxation parameter (set in <code>Smoother::AdditionalData()</code> inside <code>create_smoother()</code>, only necessary for point smoothers) so that we maintain a constant number of iterations for a \(Q_5\) element.</p>
<p><a class="anchor" id="Effectivenessofrenumberingforchangingepsilon"></a></p><h4>Effectiveness of renumbering for changing epsilon </h4>
<p>Increase/decrease the parameter "Epsilon" in the <code>.prm</code> files of the multiplicative methods and observe for which values renumbering no longer influences convergence speed.</p>
<p><a class="anchor" id="Meshadaptivity"></a></p><h4>Mesh adaptivity </h4>
<p>The code is set up to work correctly with an adaptively refined mesh (the interface matrices are created and set). Devise a suitable refinement criterium or try the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Thomas C. Clevenger, Clemson University</span></div><div class="line"><span class="comment"> *          Timo Heister, Clemson University and University of Utah</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation__block_8h.html">deal.II/lac/relaxation_block.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step63</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree)</div><div class="line">      : fe_values(fe,</div><div class="line">                  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    CopyData() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span><a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  {</div><div class="line">    <span class="keyword">enum</span> DoFRenumberingStrategy</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>,</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream</a>,</div><div class="line">      upstream,</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random</a></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                 <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           fe_degree;</div><div class="line">    std::string            smoother_type;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           smoothing_steps;</div><div class="line">    DoFRenumberingStrategy dof_renumbering;</div><div class="line">    <span class="keywordtype">bool</span>                   with_streamline_diffusion;</div><div class="line">    <span class="keywordtype">bool</span>                   output;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Settings::get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename)</div><div class="line">  {</div><div class="line">    <span class="comment">/* First declare the parameters... */</span></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.005&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Diffusion parameter&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                      <span class="stringliteral">&quot;Finite Element degree&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;block SOR&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;SOR|Jacobi|block SOR|block Jacobi&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Select smoother: SOR|Jacobi|block SOR|block Jacobi&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                      <span class="stringliteral">&quot;Number of smoothing steps&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;DoF renumbering&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;downstream&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;none|downstream|upstream|random&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;Select DoF renumbering: none|downstream|upstream|random&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Enable streamline diffusion stabilization: true|false&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Generate graphical output: true|false&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* ...and then try to read their values from the input file: */</span></div><div class="line">    <span class="keywordflow">if</span> (prm_filename.empty())</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">          <span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Please pass a .prm file as the first argument!&quot;</span>));</div><div class="line">      }</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(prm_filename);</div><div class="line"></div><div class="line">    <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>         = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>);</div><div class="line">    fe_degree       = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>);</div><div class="line">    smoother_type   = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>);</div><div class="line">    smoothing_steps = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string renumbering = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;DoF renumbering&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;none&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">DoFRenumberingStrategy::none</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;downstream&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumberingStrategy::downstream</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;upstream&quot;</span>)</div><div class="line">      dof_renumbering = DoFRenumberingStrategy::upstream;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;random&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumberingStrategy::random</a>;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;The &lt;DoF renumbering&gt; parameter has &quot;</span></div><div class="line">                             <span class="stringliteral">&quot;an invalid value.&quot;</span>));</div><div class="line"></div><div class="line">    with_streamline_diffusion = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>);</div><div class="line">    output                    = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Output&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">  {</div><div class="line">    std::vector&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">      ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> DoFRenumbering::</div><div class="line">      CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator, dim&gt;</div><div class="line">        comparator(direction);</div><div class="line">    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned&gt; ordered_indices;</div><div class="line">    ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">      ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_indices;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction)</div><div class="line">  {</div><div class="line">    std::vector&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> DoFRenumbering::</div><div class="line">      CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator, dim&gt;</div><div class="line">        comparator(direction);</div><div class="line">    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">    ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">      ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_indices;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">      ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    std::mt19937 random_number_generator;</div><div class="line">    std::shuffle(ordered_cells.begin(),</div><div class="line">                 ordered_cells.end(),</div><div class="line">                 random_number_generator);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_cells;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    std::mt19937 random_number_generator;</div><div class="line">    std::shuffle(ordered_cells.begin(),</div><div class="line">                 ordered_cells.end(),</div><div class="line">                 random_number_generator);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_cells;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    (void)component;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                      std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">      values[i] = RightHandSide&lt;dim&gt;::value(points[i], component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    (void)component;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[0] - 1) &lt; 1e-8 ||</div><div class="line">        (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[1] + 1) &lt; 1e-8 &amp;&amp; p[0] &gt;= 0.5))</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> 1.0;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> 0.0;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">      values[i] = BoundaryValues&lt;dim&gt;::value(points[i], component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> compute_stabilization_delta(<span class="keyword">const</span> <span class="keywordtype">double</span>         hk,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span>         eps,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dir,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span>         pk)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> Peclet = dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * hk / (2.0 * eps * pk);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coth =</div><div class="line">      (1.0 + <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> hk / (2.0 * dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * pk) * (coth - 1.0 / Peclet);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>AdvectionProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">    <span class="keywordtype">void</span> assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                       ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                       CopyData &amp;          copy_data);</div><div class="line">    <span class="keywordtype">void</span> assemble_system_and_multigrid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_smoother();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>     fe;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix;</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_in;</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_out;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;MGSmoother&lt;Vector&lt;double&gt;&gt;&gt; mg_smoother;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classRelaxationBlock.html">RelaxationBlock&lt;SparseMatrix&lt;double&gt;</a>, double, Vector&lt;double&gt;&gt;;</div><div class="line">    <span class="keyword">using</span> SmootherAdditionalDataType = SmootherType::AdditionalData;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SmootherAdditionalDataType&gt;</a> smoother_data;</div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> advection_direction;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> settings;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  AdvectionProblem&lt;dim&gt;::AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe(settings.fe_degree)</div><div class="line">    , mapping(settings.fe_degree)</div><div class="line">    , settings(settings)</div><div class="line">  {</div><div class="line">    advection_direction[0] = -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI / 6.0);</div><div class="line">    <span class="keywordflow">if</span> (dim &gt;= 2)</div><div class="line">      advection_direction[1] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI / 6.0);</div><div class="line">    <span class="keywordflow">if</span> (dim &gt;= 3)</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 1, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                    dsp,</div><div class="line">                                    constraints,</div><div class="line">                                    <span class="comment">/*keep_constrained_dofs = */</span> <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span> || settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a> ||</div><div class="line">            settings.dof_renumbering ==</div><div class="line">              Settings::DoFRenumberingStrategy::upstream)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> direction =</div><div class="line">              (settings.dof_renumbering ==</div><div class="line">                   Settings::DoFRenumberingStrategy::upstream ?</div><div class="line">                 -1.0 :</div><div class="line">                 1.0) *</div><div class="line">              advection_direction;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumbering::downstream</a>(dof_handler,</div><div class="line">                                         level,</div><div class="line">                                         direction,</div><div class="line">                                         <span class="comment">/*dof_wise_renumbering = */</span> <span class="keyword">true</span>);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">                 <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumbering::random</a>(dof_handler, level);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line"></div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});</div><div class="line"></div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.clear_elements();</div><div class="line">    mg_interface_in.resize(0, n_levels - 1);</div><div class="line">    mg_interface_in.clear_elements();</div><div class="line">    mg_interface_out.resize(0, n_levels - 1);</div><div class="line">    mg_interface_out.clear_elements();</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">    mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line">          mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                   mg_constrained_dofs,</div><div class="line">                                                   dsp,</div><div class="line">                                                   level);</div><div class="line">          mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">          mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">          mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                                            ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                            CopyData &amp;          copy_data)</div><div class="line">  {</div><div class="line">    copy_data.level = cell-&gt;level();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">    copy_data.dofs_per_cell = dofs_per_cell;</div><div class="line">    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch_data.fe_values.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">      copy_data.cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">    copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_active_or_mg_dof_indices(copy_data.local_dof_indices);</div><div class="line"></div><div class="line">    scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">    std::vector&lt;double&gt; rhs_values(n_q_points);</div><div class="line"></div><div class="line">    right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),</div><div class="line">                               rhs_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> delta = (settings.with_streamline_diffusion ?</div><div class="line">                            compute_stabilization_delta(cell-&gt;diameter(),</div><div class="line">                                                        settings.epsilon,</div><div class="line">                                                        advection_direction,</div><div class="line">                                                        settings.fe_degree) :</div><div class="line">                            0.0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                (settings.epsilon *</div><div class="line">                 scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">                 scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">                 scratch_data.fe_values.JxW(q_point)) +</div><div class="line">                (scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">                 (advection_direction *</div><div class="line">                  scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">                 scratch_data.fe_values.JxW(q_point))</div><div class="line">                + delta *</div><div class="line">                    (advection_direction *</div><div class="line">                     scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">                    (advection_direction *</div><div class="line">                     scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">                    scratch_data.fe_values.JxW(q_point) -</div><div class="line">                delta * settings.epsilon *</div><div class="line">                  <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(scratch_data.fe_values.shape_hessian(j, q_point)) *</div><div class="line">                  (advection_direction *</div><div class="line">                   scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">                  scratch_data.fe_values.JxW(q_point);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">            {</div><div class="line">              copy_data.cell_rhs(i) +=</div><div class="line">                scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">                  rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)</div><div class="line">                + delta * rhs_values[q_point] * advection_direction *</div><div class="line">                    scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">                    scratch_data.fe_values.JxW(q_point);</div><div class="line">            }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system_and_multigrid()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_active =</div><div class="line">      [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()) &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                          scratch_data,</div><div class="line">          CopyData &amp;                                  copy_data) {</div><div class="line">        this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier_active = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      constraints.distribute_local_to_global(copy_data.cell_matrix,</div><div class="line">                                             copy_data.cell_rhs,</div><div class="line">                                             copy_data.local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker_active,</div><div class="line">                          copier_active,</div><div class="line">                          ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_level_dof_indices;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(</div><div class="line">          dof_handler, level, locally_owned_level_dof_indices);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(locally_owned_level_dof_indices);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_mg =</div><div class="line">      [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>()) &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                      scratch_data,</div><div class="line">          CopyData &amp;                              copy_data) {</div><div class="line">        this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier_mg = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      boundary_constraints[copy_data.level].distribute_local_to_global(</div><div class="line">        copy_data.cell_matrix,</div><div class="line">        copy_data.local_dof_indices,</div><div class="line">        mg_matrices[copy_data.level]);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">                copy_data.level,</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j]))</div><div class="line">            {</div><div class="line">              mg_interface_out[copy_data.level].add(</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j],</div><div class="line">                copy_data.cell_matrix(i, j));</div><div class="line">              mg_interface_in[copy_data.level].add(</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j],</div><div class="line">                copy_data.cell_matrix(j, i));</div><div class="line">            }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                          cell_worker_mg,</div><div class="line">                          copier_mg,</div><div class="line">                          ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_smoother()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> smoother =</div><div class="line">          std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                  Smoother,</div><div class="line">                                                  Vector&lt;double&gt;&gt;&gt;();</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                             Smoother::AdditionalData(fe.degree == 1 ? 1.0 :</div><div class="line">                                                                       0.62));</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">        mg_smoother = std::move(smoother);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">        <span class="keyword">auto</span> smoother =</div><div class="line">          std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                  Smoother,</div><div class="line">                                                  Vector&lt;double&gt;&gt;&gt;();</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                             Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :</div><div class="line">                                                                       0.47));</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">        mg_smoother = std::move(smoother);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ||</div><div class="line">             settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() - 1);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches</a>(smoother_data[level].block_list,</div><div class="line">                                        dof_handler,</div><div class="line">                                        level);</div><div class="line"></div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].relaxation =</div><div class="line">              (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ? 1.0 : 0.25);</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].inversion = <a class="code" href="classPreconditionBlockBase.html">PreconditionBlockBase&lt;double&gt;::svd</a>;</div><div class="line"></div><div class="line">            std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">            <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                    advection_direction,</div><div class="line">                                                    level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                    -1.0 * advection_direction,</div><div class="line">                                                    level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_random_cell_ordering(dof_handler, level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">default</span>:</div><div class="line">                  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].order =</div><div class="line">              std::vector&lt;std::vector&lt;unsigned int&gt;&gt;(1, ordered_indices);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span>)</div><div class="line">          {</div><div class="line">            <span class="keyword">auto</span> smoother = std::make_unique&lt;<a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a>&lt;</div><div class="line">              SparseMatrix&lt;double&gt;,</div><div class="line">              RelaxationBlockSOR&lt;SparseMatrix&lt;double&gt;, double, Vector&lt;double&gt;&gt;,</div><div class="line">              Vector&lt;double&gt;&gt;&gt;();</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">            mg_smoother = std::move(smoother);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">          {</div><div class="line">            <span class="keyword">auto</span> smoother = std::make_unique&lt;</div><div class="line">              MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                     RelaxationBlockJacobi&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                           double,</div><div class="line">                                                           Vector&lt;double&gt;&gt;,</div><div class="line">                                     Vector&lt;double&gt;&gt;&gt;();</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">            mg_smoother = std::move(smoother);</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iters       = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       solve_tolerance = 1e-8 * system_rhs.l2_norm();</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>      solver_control(max_iters, solve_tolerance, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">    solver_control.<a class="code" href="classSolverControl.html#a6d99741765243ccb65da4ff66558cf41">enable_history_data</a>();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Transfer = MGTransferPrebuilt&lt;Vector&lt;double&gt;&gt;;</div><div class="line">    Transfer mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    setup_smoother();</div><div class="line"></div><div class="line">    mg_matrix.initialize(mg_matrices);</div><div class="line">    mg_interface_matrix_in.initialize(mg_interface_in);</div><div class="line">    mg_interface_matrix_out.initialize(mg_interface_out);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, Transfer&gt; preconditioner(dof_handler,</div><div class="line">                                                                 <a class="code" href="namespacemg.html">mg</a>,</div><div class="line">                                                                 mg_transfer);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;     Solving with GMRES to tol &quot;</span> &lt;&lt; solve_tolerance &lt;&lt; <span class="stringliteral">&quot;...&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;Vector&lt;double&gt;</a>&gt; solver(</div><div class="line">      solver_control, <a class="code" href="classSolverGMRES.html">SolverGMRES</a>&lt;Vector&lt;double&gt;&gt;::AdditionalData(50, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    time.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;          converged in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#aba22973498b0e4c2b4d64bf799e95ba8">last_wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; seconds &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    mg_smoother.release();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells = triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();</div><div class="line">    Vector&lt;double&gt;     cell_indices(n_active_cells);</div><div class="line">    {</div><div class="line">      std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">      <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">            ordered_indices =</div><div class="line">              create_downstream_cell_ordering(dof_handler, advection_direction);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">            ordered_indices =</div><div class="line">              create_downstream_cell_ordering(dof_handler,</div><div class="line">                                              -1.0 * advection_direction);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">            ordered_indices = create_random_cell_ordering(dof_handler);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">            ordered_indices.resize(n_active_cells);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">              ordered_indices[i] = i;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">        cell_indices(ordered_indices[i]) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(cell_indices, <span class="stringliteral">&quot;cell_index&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename.c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; (settings.fe_degree == 1 ? 7 : 5);</div><div class="line">         ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation,</div><div class="line">                                                            0.3,</div><div class="line">                                                            1.0);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0));</div><div class="line">            triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, manifold_description);</div><div class="line">          }</div><div class="line"></div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>();</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of degrees of freedom: &quot;</span></div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system_and_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (settings.output)</div><div class="line">          output_results(cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step63</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Step63::Settings</a> settings;</div><div class="line">      settings.get_parameters((argc &gt; 1) ? (argv[1]) : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">      Step63::AdvectionProblem&lt;2&gt; advection_problem_2d(settings);</div><div class="line">      advection_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_16.html">step-16</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Equation">Equation</a><a href="#Equation">Equation</a>
 <ul>
 <li><a href="#Streamlinediffusion">Streamline diffusion</a><a
 href="#Streamlinediffusion">Streamline diffusion</a>
 </ul>
 <li><a href="#Smoothers">Smoothers</a><a href="#Smoothers">Smoothers</a>
 <li><a href="#Testproblem">Test problem</a><a href="#Testproblem">Test
 problem</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#MeshWorkerdata">MeshWorker data</a><a
 href="#MeshWorkerdata">MeshWorker data</a>
 <li><a href="#Problemparameters">Problem parameters</a><a
 href="#Problemparameters">Problem parameters</a>
 <li><a href="#Cellpermutations">Cell permutations</a><a
 href="#Cellpermutations">Cell permutations</a>
 <li><a href="#Righthandsideandboundaryvalues">Right-hand side and boundary
 values</a><a href="#Righthandsideandboundaryvalues">Right-hand side and
 boundary values</a>
 <li><a href="#Streamlinediffusionimplementation">Streamline diffusion
 implementation</a><a href="#Streamlinediffusionimplementation">Streamline
 diffusion implementation</a>
 <li><a href="#codeAdvectionProlemcodeclass"><code>AdvectionProlem</code>
 class</a><a
 href="#codeAdvectionProlemcodeclass"><code>AdvectionProlem</code> class</a>
 <ul>
 <li><a
 href="#codeAdvectionProblemsetup_systemcode"><code>AdvectionProblem::setup_system()</code></a><a
 href="#codeAdvectionProblemsetup_systemcode"><code>AdvectionProblem::setup_system()</code></a>
 <li><a
 href="#codeAdvectionProblemassemble_cellcode"><code>AdvectionProblem::assemble_cell()</code></a><a
 href="#codeAdvectionProblemassemble_cellcode"><code>AdvectionProblem::assemble_cell()</code></a>
 <li><a
 href="#codeAdvectionProblemassemble_system_and_multigridcode"><code>AdvectionProblem::assemble_system_and_multigrid()</code></a><a
 href="#codeAdvectionProblemassemble_system_and_multigridcode"><code>AdvectionProblem::assemble_system_and_multigrid()</code></a>
 <li><a
 href="#codeAdvectionProblemsetup_smoothercode"><code>AdvectionProblem::setup_smoother()</code></a><a
 href="#codeAdvectionProblemsetup_smoothercode"><code>AdvectionProblem::setup_smoother()</code></a>
 <li><a
 href="#codeAdvectionProblemsolvecode"><code>AdvectionProblem::solve()</code></a><a
 href="#codeAdvectionProblemsolvecode"><code>AdvectionProblem::solve()</code></a>
 <li><a
 href="#codeAdvectionProblemoutput_resultscode"><code>AdvectionProblem::output_results()</code></a><a
 href="#codeAdvectionProblemoutput_resultscode"><code>AdvectionProblem::output_results()</code></a>
 <li><a
 href="#codeAdvectionProblemruncode"><code>AdvectionProblem::run()</code></a><a
 href="#codeAdvectionProblemruncode"><code>AdvectionProblem::run()</code></a>
 </ul>
 <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a
 href="#Thecodemaincodefunction">The <code>main</code> function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#GMRESIterationNumbers"> GMRES Iteration Numbers </a><a
 href="#GMRESIterationNumbers"> GMRES Iteration Numbers </a>
 <ul>
 <li><a href="#DoFCellRenumbering"> DoF/Cell Renumbering </a><a
 href="#DoFCellRenumbering"> DoF/Cell Renumbering </a>
 <li><a href="#Pointvsblocksmoothers"> Point vs. block smoothers </a><a
 href="#Pointvsblocksmoothers"> Point vs. block smoothers </a>
 </ul>
 <li><a href="#Cost"> Cost </a><a href="#Cost"> Cost </a>
 <li><a href="#Additionalpoints"> Additional points </a><a
 href="#Additionalpoints"> Additional points </a>
 <li><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a>
 <ul>
 <li><a href="#ConstantiterationsforQsub5sub"> Constant iterations for
 Q<sub>5</sub> </a><a href="#ConstantiterationsforQsub5sub"> Constant
 iterations for Q<sub>5</sub> </a>
 <li><a href="#Effectivenessofrenumberingforchangingepsilon"> Effectiveness
 of renumbering for changing epsilon </a><a
 href="#Effectivenessofrenumberingforchangingepsilon"> Effectiveness of
 renumbering for changing epsilon </a>
 <li><a href="#Meshadaptivity"> Mesh adaptivity </a><a
 href="#Meshadaptivity"> Mesh adaptivity </a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Thomas C. Clevenger and Timo Heister.</em></p>
<p><em> The creation of this tutorial was partially supported by NSF Award DMS-1522191, DMS-1901529, OAC-1835452, by the Computational Infrastructure in Geodynamics initiative (CIG), through the NSF under Award EAR-0949446 and EAR-1550901 and The University of California</em></p>
<p><em></p><ul>
<li><p class="startli">Davis.  </p><dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3382899"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3382899.svg" alt="10.5281/zenodo.3382899"/></a>  <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a><h1>Introduction</h1>
</dd></dl>
<p class="startli">This program solves an advection-diffusion problem using a geometric multigrid(GMG) preconditioner. The basics of this preconditioner are discussed in <a class="el" href="step_16.html">step-16</a> ;here we discuss the necessary changes needed for a non-symmetricPDE. Additionally, we introduce the idea of block smoothing (as compared topoint smoothing in <a class="el" href="step_16.html">step-16</a> ), and examine the effects of DoF renumbering foradditive and multiplicative smoothers. <a class="anchor" id="Equation"></a></p><h3>Equation</h3>
<p class="startli">The advection-diffusion equation is given by </p><p class="formulaDsp">
\begin{align*} -\varepsilon \Delta u + \boldsymbol{\beta}\cdot \nabla u &amp; = f &amp; \text{ in } \Omega\\ u &amp;= g &amp; \text{ on } \partial\Omega \end{align*}
</p>
<p> where \(\varepsilon&gt;0\) , \(\boldsymbol{\beta}\) is the <em>advection direction</em>, and \(f\) is a source. A few notes: 1. If \(\boldsymbol{\beta}=\boldsymbol{0}\) , this is the Laplace equation solved in <a class="el" href="step_16.html">step-16</a> (and many other places). 2. If \(\varepsilon=0\) then this is the stationary advection equation solved in <a class="el" href="step_9.html">step-9</a> . 3. One can define a dimensionless number for this problem, called the<em>Peclet number</em>: \(\mathcal{P} \dealcoloneq \frac{\|\boldsymbol{\beta}\| L}{\varepsilon}\) , where \(L\) is the length scale of the domain. Itcharacterizes the kind of equation we areconsidering: If \(\mathcal{P}&gt;1\) , we say the problem is<em>advection-dominated</em>, else if \(\mathcal{P}&lt;1\) we will say the problem is<em>diffusion-dominated</em>. For the discussion in this tutorial we will be concerned withadvection-dominated flow. This is the complicated case: We know thatfor diffusion-dominated problems, the standard Galerkin method worksjust fine, and we also know that simple multigrid methods such asthose defined in <a class="el" href="step_16.html">step-16</a> are very efficient. On the other hand, foradvection-dominated problems, the standard Galerkin approach leads tooscillatory and unstable discretizations, and simple solvers are oftennot very efficient. This tutorial program is therefore intended toaddress both of these issues.</p>
<p class="startli"><a class="anchor" id="Streamlinediffusion"></a></p><h4>Streamline diffusion</h4>
<p class="startli">Using the standard Galerkin finite element method, for suitable testfunctions \(v_h\) , a discrete weak form of the PDE would read </p><p class="formulaDsp">
\begin{align*} a(u_h,v_h) = F(v_h) \end{align*}
</p>
<p> where </p><p class="formulaDsp">
\begin{align*} a(u_h,v_h) &amp;= (\varepsilon \nabla v_h,\, \nabla u_h) + (v_h,\,\boldsymbol{\beta}\cdot \nabla u_h),\\ F(v_h) &amp;= (v_h,\,f). \end{align*}
</p>
</li>
</ul>
<p></em></p>
<p><em> Unfortunately, one typically gets oscillatory solutions with thisapproach. Indeed, the following error estimate can be shown for thisformulation: </p><p class="formulaDsp">
\begin{align*} \|\nabla (u-u_h)\| \leq (1+\mathcal{P}) \inf_{v_h} \|\nabla (u-v_h)\|. \end{align*}
</p>
<p> The infimum on the right can be estimated as follows if the exactsolution is sufficiently smooth: </p><p class="formulaDsp">
\begin{align*} \inf_{v_h} \|\nabla (u-v_h)\|. \le \|\nabla (u-I_h u)\| \le h^k C \|\nabla^k u)\| \end{align*}
</p>
<p> where \(k\) is the polynomial degree of the finite elements used. As aconsequence, we obtain the estimate </p><p class="formulaDsp">
\begin{align*} \|\nabla (u-u_h)\| \leq (1+\mathcal{P}) C h^k \|\nabla^k u)\|. \end{align*}
</p>
<p> In other words, the numerical solution will converge. On the other hand,given the definition of \(\mathcal{P}\) above, we have to expect poornumerical solutions with a large error when \(\varepsilon \ll \|\boldsymbol{\beta}\| L\) , i.e., if the problem has only a smallamount of diffusion. To combat this, we will consider the new weak form </p><p class="formulaDsp">
\begin{align*} a(u_h,\,v_h) + \sum_K (-\varepsilon \Delta u_h + \boldsymbol{\beta}\cdot \nabla u_h-f,\,\delta_K \boldsymbol{\beta}\cdot \nabla v_h)_K = F(v_h) \end{align*}
</p>
<p> where the sum is done over all cells \(K\) with the inner product takenfor each cell, and \(\delta_K\) is a cell-wise constantstabilization parameter defined in <b>[john2006discontinuity]</b> . Essentially, adding in thediscrete strong form residual enhances the coercivity of the bilinearform \(a(\cdot,\cdot)\) which increases the stability of the discretesolution. This method is commonly referred to as <em>streamline diffusion</em> or <em>SUPG</em> (streamline upwind/Petrov-Galerkin).</em></p>
<p><em> <a class="anchor" id="Smoothers"></a></p><h3>Smoothers</h3>
<p></em></p>
<p><em></em></p>
<p><em> One of the goals of this tutorial is to expand from using a simple(point-wise) Gauss-Seidel (SOR) smoother that is used in <a class="el" href="step_16.html">step-16</a> (class <a class="el" href="classPreconditionSOR.html">PreconditionSOR</a>) on each level of the multigrid hierarchy.The term "point-wise" is traditionally used in solvers to indicate that onesolves at one "grid point" at a time; for scalar problems, this meansto use a solver that updates one unknown of the linearsystem at a time, keeping all of the others fixed; one would theniterate over all unknowns in the problem and, once done, start over againfrom the first unknown until these "sweeps" converge. Jacobi,Gauss-Seidel, and SOR iterations can all be interpreted in this way.In the context of multigrid, one does not think of these methods as"solvers", but as "smoothers". As such, one is not interested inactually solving the linear system. It is enough to remove the high-frequencypart of the residual for the multigrid method to work, because that allowsrestricting the solution to a coarser mesh. Therefore, one only does a few,fixed number of "sweeps" over all unknowns. In the code in thistutorial this is controlled by the "Smoothing steps" parameter. But these methods are known to converge rather slowly when used assolvers. While as multigrid smoothers, they are surprisingly good,they can also be improved upon. In particular, we consider"cell-based" smoothers here as well. These methods solve for allunknowns on a cell at once, keeping all other unknowns fixed; theythen move on to the next cell, and so on and so forth. One can thinkof them as "block" versions of Jacobi, Gauss-Seidel, or SOR, butbecause degrees of freedom are shared among multiple cells, theseblocks overlap and the methods are in factbest be explained within the framework of additive and multiplicativeSchwarz methods. In contrast to <a class="el" href="step_16.html">step-16</a> , our test problem contains an advectiveterm. Especially with a small diffusion constant \(\varepsilon\) , information istransported along streamlines in the given advection direction. This meansthat smoothers are likely to be more effective if they allow information totravel in downstream direction within a single smootherapplication. If we want to solve one unknown (or block of unknowns) ata time in the order in which these unknowns (or blocks) areenumerated, then this information propagation propertyrequires reordering degrees of freedom or cells (for the cell-based smoothers)accordingly so that the ones further upstream are treated earlier(have lower indices) and those further downstream are treated later(have larger indices). The influence of the ordering will be visiblein the results section. Let us now briefly define the smoothers used in this tutorial.For a more detailed introduction, we refer to <b>[KanschatNotesIterative]</b> and the books <b>[smith2004domain]</b> and <b>[toselli2006domain]</b> .A Schwarzpreconditioner requires a decomposition </p><p class="formulaDsp">
\begin{align*} V = \sum_{j=1}^J V_j \end{align*}
</p>
<p> of our finite element space \(V\) . Each subproblem \(V_j\) also has a Ritzprojection \(P_j: V \rightarrow V_j\) based on the bilinear form \(a(\cdot,\cdot)\) . This projection induces a local operator \(A_j\) for eachsubproblem \(V_j\) . If \(\Pi_j:V\rightarrow V_j\) is the orthogonal projector onto \(V_j\) , one can show \(A_jP_j=\Pi_j^TA\) . With this we can define an <em>additive Schwarz preconditioner</em> for theoperator \(A\) as </p><p class="formulaDsp">
\begin{align*} B^{-1} = \sum_{j=1}^J P_j A^{-1} = \sum_{j=1}^J A_j^{-1} \Pi_j^T. \end{align*}
</p>
<p> In other words, we project our solution into each subproblem, apply theinverse of the subproblem \(A_j\) , and sum the contributions up over all \(j\) . Note that one can interpret the point-wise (one unknown at a time)Jacobi method as an additiveSchwarz method by defining a subproblem \(V_j\) for each degree offreedom. Then, \(A_j^{-1}\) becomes a multiplication with the inverse of adiagonal entry of \(A\) . For the "Block Jacobi" method used in this tutorial, we define a subproblem \(V_j\) for each cell of the mesh on the current level. Note that we use acontinuous finite element, so these blocks are overlapping, as degrees offreedom on an interface between two cells belong to both subproblems. Thelogic for the Schwarz operator operating on the subproblems (in deal.II theyare called "blocks") is implemented in the class <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a>. The "BlockJacobi" method is implemented in the class <a class="el" href="classRelaxationBlockJacobi.html">RelaxationBlockJacobi</a>. Manyaspects of the class (for example how the blocks are defined and how to invertthe local subproblems \(A_j\) ) can be configured in the smoother data, see <a class="el" href="classRelaxationBlock_1_1AdditionalData.html">RelaxationBlock::AdditionalData</a> and <a class="el" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches()</a> for details. So far, we discussed additive smoothers where the updates can be appliedindependently and there is no information flowing within a single smootherapplication. A <em>multiplicative Schwarz preconditioner</em> addresses thisand is defined by </p><p class="formulaDsp">
\begin{align*} B^{-1} = \left( I- \prod_{j=1}^J \left(I-P_j\right) \right) A^{-1}. \end{align*}
</p>
<p> In contrast to above, the updates on the subproblems \(V_j\) are appliedsequentially. This means that the update obtained when inverting thesubproblem \(A_j\) is immediately used in \(A_{j+1}\) . This becomesvisible when writing out the project: </p><p class="formulaDsp">
\begin{align*} B^{-1} = \left( I - \left(I-P_1\right)\left(I-P_2\right)\cdots\left(I-P_J\right) \right) A^{-1} = A^{-1} - \left[ \left(I-P_1\right) \left[ \left(I-P_2\right)\cdots \left[\left(I-P_J\right) A^{-1}\right] \cdots \right] \right] \end{align*}
</p>
<p></em></p>
<p><em> When defining the sub-spaces \(V_j\) as whole blocks of degrees offreedom, this method is implemented in the class <a class="el" href="classRelaxationBlockSOR.html">RelaxationBlockSOR</a> and used when youselect "Block SOR" in this tutorial. The class <a class="el" href="classRelaxationBlockSOR.html">RelaxationBlockSOR</a> is alsoderived from <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a>. As such, both additive and multiplicativeSchwarz methods are implemented in a unified framework. Finally, let us note that the standard Gauss-Seidel (or SOR) method can beseen as a multiplicative Schwarz method with a subproblem for each DoF.</em></p>
<p><em> <a class="anchor" id="Testproblem"></a></p><h3>Test problem</h3>
<p></em></p>
<p><em></em></p>
<p><em> We will be considering the following test problem: \(\Omega = [-1,\,1]\times[-1,\,1]\backslash B_{0.3}(0)\) , i.e., a squarewith a circle of radius 0.3 centered at theorigin removed. In addition, we use \(\varepsilon=0.005\) , \(\boldsymbol{\beta} = [-\sin(\pi/6),\,\cos(\pi/6)]\) , \(f=0\) , and Dirichlet boundary values </p><p class="formulaDsp">
\begin{align*} g = \left\{\begin{array}{ll} 1 &amp; \text{if } x=-1 \text{ or } y=-1,\,x\geq 0.5 \\ 0 &amp; \text{otherwise} \end{array}\right. \end{align*}
</p>
<p></em></p>
<p><em> The following figures depict the solutions with (left) and without(right) streamline diffusion. Without streamline diffusion we see largeoscillations around the boundary layer, demonstrating the instabilityof the standard Galerkin finite element method for this problem. </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-solution.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-solution-no-sd.png"/>
</div>
   </td></tr>
</table>
<p></em></p>
<p><em> <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p></em></p>
<p><em> <a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p></em></p>
<p><em></em></p>
<p><em> Typical files needed for standard deal.II:</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation__block_8h.html">deal.II/lac/relaxation_block.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div></div><!-- fragment --><p></em></p>
<p><em> Include all relevant multilevel files:</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p></em></p>
<p><em> C++:</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div></div><!-- fragment --><p></em></p>
<p><em> We will be using <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a> functionality for assembling matrices:</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="MeshWorkerdata"></a> </p><h3><a class="el" href="namespaceMeshWorker.html">MeshWorker</a> data</h3>
<p></em></p>
<p><em></em></p>
<p><em> As always, we will be putting everything related to this program into a namespace of its own.</em></p>
<p><em> Since we will be using the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework, the first step is to define the following structures needed by the assemble_cell() function used by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>: <code>ScratchData</code> contains an <a class="el" href="classFEValues.html">FEValues</a> object which is needed for assembling a cell's local contribution, while <code>CopyData</code> contains the output from a cell's local contribution and necessary information to copy that to the global system. (Their purpose is also explained in the documentation of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class.)</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">namespace </span>Step63</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>ScratchData</div><div class="line">{</div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree)</div><div class="line">    : fe_values(fe,</div><div class="line">                <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree),</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">    : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                scratch_data.fe_values.get_quadrature(),</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData</div><div class="line">{</div><div class="line">  CopyData() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell;</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  Vector&lt;double&gt;                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">};</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Problemparameters"></a> </p><h3>Problem parameters</h3>
<p></em></p>
<p><em></em></p>
<p><em> The second step is to define the classes that deal with run-time parameters to be read from an input file. We will use <a class="el" href="classParameterHandler.html">ParameterHandler</a> to pass in parameters at runtime. The structure <code>Settings</code> parses and stores the parameters to be queried throughout the program.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">{</div><div class="line">  <span class="keyword">enum</span> DoFRenumberingStrategy</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>,</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream</a>,</div><div class="line">    upstream,</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random</a></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>                 <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           fe_degree;</div><div class="line">  std::string            smoother_type;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           smoothing_steps;</div><div class="line">  DoFRenumberingStrategy dof_renumbering;</div><div class="line">  <span class="keywordtype">bool</span>                   with_streamline_diffusion;</div><div class="line">  <span class="keywordtype">bool</span>                   output;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Settings::get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename)</div><div class="line">{</div><div class="line">  <span class="comment">// First declare the parameters...</span></div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;0.005&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Diffusion parameter&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;Finite Element degree&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;block SOR&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;SOR|Jacobi|block SOR|block Jacobi&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Select smoother: SOR|Jacobi|block SOR|block Jacobi&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;Number of smoothing steps&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;DoF renumbering&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;downstream&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;none|downstream|upstream|random&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;Select DoF renumbering: none|downstream|upstream|random&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Enable streamline diffusion stabilization: true|false&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Generate graphical output: true|false&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// ...and then try to read their values from the input file :</span></div><div class="line">  <span class="keywordflow">if</span> (prm_filename.empty())</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">        <span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Please pass a .prm file as the first argument!&quot;</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(prm_filename);</div><div class="line"></div><div class="line">  <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>         = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>);</div><div class="line">  fe_degree       = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>);</div><div class="line">  smoother_type   = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>);</div><div class="line">  smoothing_steps = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string renumbering = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;DoF renumbering&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;none&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">DoFRenumberingStrategy::none</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;downstream&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumberingStrategy::downstream</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;upstream&quot;</span>)</div><div class="line">    dof_renumbering = DoFRenumberingStrategy::upstream;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;random&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumberingStrategy::random</a>;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;The &lt;DoF renumbering&gt; parameter has &quot;</span></div><div class="line">                           <span class="stringliteral">&quot;an invalid value.&quot;</span>));</div><div class="line"></div><div class="line">  with_streamline_diffusion = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>);</div><div class="line">  output                    = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Output&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Cellpermutations"></a> </p><h3>Cell permutations</h3>
<p></em></p>
<p><em> The ordering in which cells and degrees of freedom are traversed will play a role in the speed of convergence for multiplicative methods. Here we define functions which return a specific ordering of cells to be used by the block smoothers. For each type of cell ordering, we define a function for the active mesh and one for a level mesh (i.e., for the cells at one level of a multigrid hierarchy). While the only reordering necessary for solving the system will be on the level meshes, we include the active reordering for visualization purposes in output_results(). For the two downstream ordering functions, we first create an array with all of the relevant cells that we then sort in downstream direction using a "comparator" object. The output of the functions is then simply an array of the indices of the cells in the just computed order.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">{</div><div class="line">  std::vector&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">    ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> DoFRenumbering::</div><div class="line">    CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator, dim&gt;</div><div class="line">      comparator(direction);</div><div class="line">  std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned&gt; ordered_indices;</div><div class="line">  ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">    ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_indices;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction)</div><div class="line">{</div><div class="line">  std::vector&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> DoFRenumbering::</div><div class="line">    CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator, dim&gt;</div><div class="line">      comparator(direction);</div><div class="line">  std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">  ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">    ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_indices;</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> The functions that produce a random ordering are similar in spirit in that they first put information about all cells into an array. But then, instead of sorting them, they shuffle the elements randomly using the facilities C++ offers to generate random numbers. The way this is done is by iterating over all elements of the array, drawing a random number for another element before that, and then exchanging these elements. The result is a random shuffle of the elements of the array.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">    ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  std::mt19937 random_number_generator;</div><div class="line">  std::shuffle(ordered_cells.begin(),</div><div class="line">               ordered_cells.end(),</div><div class="line">               random_number_generator);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_cells;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  std::mt19937 random_number_generator;</div><div class="line">  std::shuffle(ordered_cells.begin(),</div><div class="line">               ordered_cells.end(),</div><div class="line">               random_number_generator);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_cells;</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Righthandsideandboundaryvalues"></a> </p><h3>Right-hand side and boundary values</h3>
<p></em></p>
<p><em></em></p>
<p><em> The problem solved in this tutorial is an adaptation of Ex. 3.1.3 found on pg. 118 of <a href="https://global.oup.com/academic/product/finite-elements-and-fast-iterative-solvers-9780199678808">Finite Elements and Fast Iterative Solvers: with Applications in Incompressible Fluid Dynamics by Elman, Silvester, and Wathen</a>. The main difference being that we add a hole in the center of our domain with zero Dirichlet boundary conditions. For a complete description, we need classes that implement the zero right-hand side first (we could of course have just used <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a>):</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  (void)component;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0.0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                    std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">    values[i] = RightHandSide&lt;dim&gt;::value(points[i], component);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> We also have Dirichlet boundary conditions. On a connected portion of the outer, square boundary we set the value to 1, and we set the value to 0 everywhere else (including the inner, circular boundary):</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  (void)component;</div></div><!-- fragment --><p></em></p>
<p><em> Set boundary to 1 if \(x=1\) , or if \(x&gt;0.5\) and \(y=-1\) .</em></p>
<p><em></p><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[0]</div><div class="line"></div><div class="line">- 1) &lt; 1e-8 ||</div><div class="line">      (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[1] + 1) &lt; 1e-8 &amp;&amp; p[0] &gt;= 0.5))</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> 1.0;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> 0.0;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">    values[i] = BoundaryValues&lt;dim&gt;::value(points[i], component);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Streamlinediffusionimplementation"></a> </p><h3>Streamline diffusion implementation</h3>
<p></em></p>
<p><em></em></p>
<p><em> The streamline diffusion method has a stabilization constant that we need to be able to compute. The choice of how this parameter is computed is taken from <a href="https://link.springer.com/chapter/10.1007/978-3-540-34288-5_27">On Discontinuity-Capturing Methods for Convection-Diffusion Equations by Volker John and Petr Knobloch</a>.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> compute_stabilization_delta(<span class="keyword">const</span> <span class="keywordtype">double</span>         hk,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>         eps,</div><div class="line">                                   <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dir,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>         pk)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> Peclet = dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() hk / (2.0 eps pk);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coth =</div><div class="line">    (1.0 + <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-2.0 Peclet)) / (1.0</div><div class="line"></div><div class="line">- std::exp(-2.0 Peclet));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> hk / (2.0 dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() pk) (coth</div><div class="line"></div><div class="line">- 1.0 / Peclet);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProlemcodeclass"></a> </p><h3><code>AdvectionProlem</code> class</h3>
<p></em></p>
<p><em></em></p>
<p><em> This is the main class of the program, and should look very similar to <a class="el" href="step_16.html">step-16</a> . The major difference is that, since we are defining our multigrid smoother at runtime, we choose to define a function <code>create_smoother()</code> and a class object <code>mg_smoother</code> which is a <code>std::unique_ptr</code> to a smoother that is derived from <a class="el" href="classMGSmoother.html">MGSmoother</a>. Note that for smoothers derived from <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a>, we must include a <code>smoother_data</code> object for each level. This will contain information about the cell ordering and the method of inverting cell matrices.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AdvectionProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">  <span class="keywordtype">void</span> assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                     ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                     CopyData &amp;          copy_data);</div><div class="line">  <span class="keywordtype">void</span> assemble_system_and_multigrid();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_smoother();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>     fe;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line"></div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix;</div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_in;</div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_out;</div><div class="line"></div><div class="line">  std::unique_ptr&lt;MGSmoother&lt;Vector&lt;double&gt;&gt;&gt; mg_smoother;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> SmootherType =</div><div class="line">    <a class="code" href="classRelaxationBlock.html">RelaxationBlock&lt;SparseMatrix&lt;double&gt;</a>, double, Vector&lt;double&gt;&gt;;</div><div class="line">  <span class="keyword">using</span> SmootherAdditionalDataType = SmootherType::AdditionalData;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SmootherAdditionalDataType&gt;</a> smoother_data;</div><div class="line"></div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> advection_direction;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> settings;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">AdvectionProblem&lt;dim&gt;::AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe(settings.fe_degree)</div><div class="line">  , mapping(settings.fe_degree)</div><div class="line">  , settings(settings)</div><div class="line">{</div><div class="line">  advection_direction[0] =</div><div class="line"></div><div class="line">-<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI / 6.0);</div><div class="line">  <span class="keywordflow">if</span> (dim &gt;= 2)</div><div class="line">    advection_direction[1] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI / 6.0);</div><div class="line">  <span class="keywordflow">if</span> (dim &gt;= 3)</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemsetup_systemcode"></a> </p><h4><code>AdvectionProblem::setup_system()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Here we first set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, and <a class="el" href="classSparsityPattern.html">SparsityPattern</a> objects for both active and multigrid level meshes. We could renumber the active DoFs with the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> class, but the smoothers only act on multigrid levels and as such, this would not matter for the computations. Instead, we will renumber the DoFs on each multigrid level below.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.clear();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 1, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">  constraints.close();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                  dsp,</div><div class="line">                                  constraints,</div><div class="line">                                  <span class="comment">//keep_constrained_dofs ！改 =  false);</span></div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div></div><!-- fragment --><p></em></p>
<p><em> Having enumerated the global degrees of freedom as well as (in the last line above) the level degrees of freedom, let us renumber the level degrees of freedom to get a better smoother as explained in the introduction. The first block below renumbers DoFs on each level in downstream or upstream direction if needed. This is only necessary for point smoothers (SOR and Jacobi) as the block smoothers operate on cells (see <code>create_smoother()</code>). The blocks below then also implement random numbering.</em></p>
<p><em></p><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span> || settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">            <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a> ||</div><div class="line">          settings.dof_renumbering ==</div><div class="line">            Settings::DoFRenumberingStrategy::upstream)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> direction =</div><div class="line">            (settings.dof_renumbering ==</div><div class="line">                 Settings::DoFRenumberingStrategy::upstream ?</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1.0 :</div><div class="line">               1.0)</div><div class="line">            advection_direction;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">            <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumbering::downstream</a>(dof_handler,</div><div class="line">                                       level,</div><div class="line">                                       direction,</div><div class="line">                                       <span class="comment">//dof_wise_renumbering = !改 true);</span></div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">               <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">            <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumbering::random</a>(dof_handler, level);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    }</div></div><!-- fragment --><p></em></p>
<p><em> The rest of the function just sets up data structures. The last lines of the code below is unlike the other GMG tutorials, as it sets up both the interface in and out matrices. We need this since our problem is non-symmetric.</em></p>
<p><em></p><div class="fragment"><div class="line">  mg_constrained_dofs.clear();</div><div class="line">  mg_constrained_dofs.initialize(dof_handler);</div><div class="line"></div><div class="line">  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});</div><div class="line"></div><div class="line">  mg_matrices.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_matrices.clear_elements();</div><div class="line">  mg_interface_in.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_interface_in.clear_elements();</div><div class="line">  mg_interface_out.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_interface_out.clear_elements();</div><div class="line">  mg_sparsity_patterns.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_interface_sparsity_patterns.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                 mg_constrained_dofs,</div><div class="line">                                                 dsp,</div><div class="line">                                                 level);</div><div class="line">        mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">        mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">        mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemassemble_cellcode"></a> </p><h4><code>AdvectionProblem::assemble_cell()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Here we define the assembly of the linear system on each cell to be used by the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function below. This one function assembles the cell matrix for either an active or a level cell (whatever it is passed as its first argument), and only assembles a right-hand side if called with an active cell.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                                          ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                          CopyData &amp;          copy_data)</div><div class="line">{</div><div class="line">  copy_data.level = cell-&gt;level();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  copy_data.dofs_per_cell = dofs_per_cell;</div><div class="line">  copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch_data.fe_values.get_quadrature().size();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">    copy_data.cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">  copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line">  cell-&gt;get_active_or_mg_dof_indices(copy_data.local_dof_indices);</div><div class="line"></div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">  std::vector&lt;double&gt; rhs_values(n_q_points);</div><div class="line"></div><div class="line">  right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),</div><div class="line">                             rhs_values);</div></div><!-- fragment --><p></em></p>
<p><em> If we are using streamline diffusion we must add its contribution to both the cell matrix and the cell right-hand side. If we are not using streamline diffusion, setting \(\delta=0\) negates this contribution below and we are left with the standard, Galerkin finite element assembly.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> delta = (settings.with_streamline_diffusion ?</div><div class="line">                        compute_stabilization_delta(cell-&gt;diameter(),</div><div class="line">                                                    settings.epsilon,</div><div class="line">                                                    advection_direction,</div><div class="line">                                                    settings.fe_degree) :</div><div class="line">                        0.0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div></div><!-- fragment --><p></em></p>
<p><em> The assembly of the local matrix has two parts. First the Galerkin contribution:</em></p>
<p><em></p><div class="fragment"><div class="line">copy_data.cell_matrix(i, j) +=</div><div class="line">  (settings.epsilon</div><div class="line">   scratch_data.fe_values.shape_grad(i, q_point)</div><div class="line">   scratch_data.fe_values.shape_grad(j, q_point)</div><div class="line">   scratch_data.fe_values.JxW(q_point)) +</div><div class="line">  (scratch_data.fe_values.shape_value(i, q_point)</div><div class="line">   (advection_direction</div><div class="line">    scratch_data.fe_values.shape_grad(j, q_point))</div><div class="line">   scratch_data.fe_values.JxW(q_point))</div></div><!-- fragment --><p></em></p>
<p><em> and then the streamline diffusion contribution:</em></p>
<p><em></p><div class="fragment"><div class="line">              + delta</div><div class="line">                  (advection_direction</div><div class="line">                   scratch_data.fe_values.shape_grad(j, q_point))</div><div class="line">                  (advection_direction</div><div class="line">                   scratch_data.fe_values.shape_grad(i, q_point))</div><div class="line">                  scratch_data.fe_values.JxW(q_point)</div><div class="line"></div><div class="line">-</div><div class="line">              delta settings.epsilon</div><div class="line">                <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(scratch_data.fe_values.shape_hessian(j, q_point))</div><div class="line">                (advection_direction</div><div class="line">                 scratch_data.fe_values.shape_grad(i, q_point))</div><div class="line">                scratch_data.fe_values.JxW(q_point);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">          {</div></div><!-- fragment --><p></em></p>
<p><em> The same applies to the right hand side. First the Galerkin contribution:</em></p>
<p><em></p><div class="fragment"><div class="line">copy_data.cell_rhs(i) +=</div><div class="line">  scratch_data.fe_values.shape_value(i, q_point)</div><div class="line">    rhs_values[q_point] scratch_data.fe_values.JxW(q_point)</div></div><!-- fragment --><p></em></p>
<p><em> and then the streamline diffusion contribution:</em></p>
<p><em></p><div class="fragment"><div class="line">              + delta rhs_values[q_point] advection_direction</div><div class="line">                  scratch_data.fe_values.shape_grad(i, q_point)</div><div class="line">                  scratch_data.fe_values.JxW(q_point);</div><div class="line">          }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemassemble_system_and_multigridcode"></a> </p><h4><code>AdvectionProblem::assemble_system_and_multigrid()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Here we employ <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to go over cells and assemble the system_matrix, system_rhs, and all mg_matrices for us.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system_and_multigrid()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_active =</div><div class="line">    [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()) &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                          scratch_data,</div><div class="line">        CopyData &amp;                                  copy_data) {</div><div class="line">      this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier_active = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    constraints.distribute_local_to_global(copy_data.cell_matrix,</div><div class="line">                                           copy_data.cell_rhs,</div><div class="line">                                           copy_data.local_dof_indices,</div><div class="line">                                           system_matrix,</div><div class="line">                                           system_rhs);</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker_active,</div><div class="line">                        copier_active,</div><div class="line">                        ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div></div><!-- fragment --><p></em></p>
<p><em> Unlike the constraints for the active level, we choose to create constraint objects for each multigrid level local to this function since they are never needed elsewhere in the program.</em></p>
<p><em></p><div class="fragment"><div class="line">std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>());</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_level_dof_indices;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(</div><div class="line">      dof_handler, level, locally_owned_level_dof_indices);</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(locally_owned_level_dof_indices);</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">      mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">      mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_mg =</div><div class="line">  [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>()) &amp;cell,</div><div class="line">      ScratchData&lt;dim&gt; &amp;                      scratch_data,</div><div class="line">      CopyData &amp;                              copy_data) {</div><div class="line">    this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier_mg = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">  boundary_constraints[copy_data.level].distribute_local_to_global(</div><div class="line">    copy_data.cell_matrix,</div><div class="line">    copy_data.local_dof_indices,</div><div class="line">    mg_matrices[copy_data.level]);</div></div><!-- fragment --><p></em></p>
<p><em> If \((i,j)\) is an <code>interface_out</code> dof pair, then \((j,i)\) is an <code>interface_in</code> dof pair. Note: For <code>interface_in</code>, we load the transpose of the interface entries, i.e., the entry for dof pair \((j,i)\) is stored in <code>interface_in(i,j)</code>. This is an optimization for the symmetric case which allows only one matrix to be used when setting the edge_matrices in solve(). Here, however, since our problem is non-symmetric, we must store both <code>interface_in</code> and <code>interface_out</code> matrices.</em></p>
<p><em></p><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.dofs_per_cell; ++j)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">              copy_data.level,</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j]))</div><div class="line">          {</div><div class="line">            mg_interface_out[copy_data.level].add(</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j],</div><div class="line">              copy_data.cell_matrix(i, j));</div><div class="line">            mg_interface_in[copy_data.level].add(</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j],</div><div class="line">              copy_data.cell_matrix(j, i));</div><div class="line">          }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                        cell_worker_mg,</div><div class="line">                        copier_mg,</div><div class="line">                        ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemsetup_smoothercode"></a> </p><h4><code>AdvectionProblem::setup_smoother()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Next, we set up the smoother based on the settings in the <code>.prm</code> file. The two options that are of significance is the number of pre- and post-smoothing steps on each level of the multigrid v-cycle and the relaxation parameter.</em></p>
<p><em> Since multiplicative methods tend to be more powerful than additive method, fewer smoothing steps are required to see convergence independent of mesh size. The same holds for block smoothers over point smoothers. This is reflected in the choice for the number of smoothing steps for each type of smoother below.</em></p>
<p><em> The relaxation parameter for point smoothers is chosen based on trial and error, and reflects values necessary to keep the iteration counts in the GMRES solve constant (or as close as possible) as we refine the mesh. The two values given for both "Jacobi" and "SOR" in the <code>.prm</code> files are for degree 1 and degree 3 finite elements. If the user wants to change to another degree, they may need to adjust these numbers. For block smoothers, this parameter has a more straightforward interpretation, namely that for additive methods in 2D, a DoF can have a repeated contribution from up to 4 cells, therefore we must relax these methods by 0.25 to compensate. This is not an issue for multiplicative methods as each cell's inverse application carries new information to all its DoFs.</em></p>
<p><em> Finally, as mentioned above, the point smoothers only operate on DoFs, and the block smoothers on cells, so only the block smoothers need to be given information regarding cell orderings. DoF ordering for point smoothers has already been taken care of in <code>setup_system()</code>.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_smoother()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> smoother =</div><div class="line">        std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                Smoother,</div><div class="line">                                                Vector&lt;double&gt;&gt;&gt;();</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                           Smoother::AdditionalData(fe.degree == 1 ? 1.0 :</div><div class="line">                                                                     0.62));</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">      mg_smoother = std::move(smoother);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">      <span class="keyword">auto</span> smoother =</div><div class="line">        std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                Smoother,</div><div class="line">                                                Vector&lt;double&gt;&gt;&gt;();</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                           Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :</div><div class="line">                                                                     0.47));</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">      mg_smoother = std::move(smoother);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ||</div><div class="line">           settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">    {</div><div class="line">      smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>()</div><div class="line"></div><div class="line">- 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches</a>(smoother_data[level].block_list,</div><div class="line">                                      dof_handler,</div><div class="line">                                      level);</div><div class="line"></div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].relaxation =</div><div class="line">            (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ? 1.0 : 0.25);</div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].inversion = <a class="code" href="classPreconditionBlockBase.html">PreconditionBlockBase&lt;double&gt;::svd</a>;</div><div class="line"></div><div class="line">          std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">          <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">                ordered_indices =</div><div class="line">                  create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                  advection_direction,</div><div class="line">                                                  level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">                ordered_indices =</div><div class="line">                  create_downstream_cell_ordering(dof_handler,</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1.0 advection_direction,</div><div class="line">                                                  level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">                ordered_indices =</div><div class="line">                  create_random_cell_ordering(dof_handler, level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">default</span>:</div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].order =</div><div class="line">            std::vector&lt;std::vector&lt;unsigned int&gt;&gt;(1, ordered_indices);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> smoother = std::make_unique&lt;<a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a>&lt;</div><div class="line">            SparseMatrix&lt;double&gt;,</div><div class="line">            RelaxationBlockSOR&lt;SparseMatrix&lt;double&gt;, double, Vector&lt;double&gt;&gt;,</div><div class="line">            Vector&lt;double&gt;&gt;&gt;();</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">          mg_smoother = std::move(smoother);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> smoother = std::make_unique&lt;</div><div class="line">            MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                   RelaxationBlockJacobi&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                         double,</div><div class="line">                                                         Vector&lt;double&gt;&gt;,</div><div class="line">                                   Vector&lt;double&gt;&gt;&gt;();</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">          mg_smoother = std::move(smoother);</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemsolvecode"></a> </p><h4><code>AdvectionProblem::solve()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Before we can solve the system, we must first set up the multigrid preconditioner. This requires the setup of the transfer between levels, the coarse matrix solver, and the smoother. This setup follows almost identically to <a class="el" href="step_16.html">step-16</a> , the main difference being the various smoothers defined above and the fact that we need different interface edge matrices for in and out since our problem is non-symmetric. (In reality, for this tutorial these interface matrices are empty since we are only using global refinement, and thus have no refinement edges. However, we have still included both here since if one made the simple switch to an adaptively refined method, the program would still run correctly.)</em></p>
<p><em> The last thing to note is that since our problem is non-symmetric, we must use an appropriate Krylov subspace method. We choose here to use GMRES since it offers the guarantee of residual reduction in each iteration. The major disavantage of GMRES is that, for each iteration, the number of stored temporary vectors increases by one, and one also needs to compute a scalar product with all previously stored vectors. This is rather expensive. This requirement is relaxed by using the restarted GMRES method which puts a cap on the number of vectors we are required to store at any one time (here we restart after 50 temporary vectors, or 48 iterations). This then has the disadvantage that we lose information we have gathered throughout the iteration and therefore we could see slower convergence. As a consequence, where to restart is a question of balancing memory consumption, CPU effort, and convergence speed. However, the goal of this tutorial is to have very low iteration counts by using a powerful GMG preconditioner, so we have picked the restart length such that all of the results shown below converge prior to restart happening, and thus we have a standard GMRES method. If the user is interested, another suitable method offered in deal.II would be BiCGStab.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iters       = 200;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       solve_tolerance = 1e-8 system_rhs.l2_norm();</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>      solver_control(max_iters, solve_tolerance, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  solver_control.<a class="code" href="classSolverControl.html#a6d99741765243ccb65da4ff66558cf41">enable_history_data</a>();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> Transfer = MGTransferPrebuilt&lt;Vector&lt;double&gt;&gt;;</div><div class="line">  Transfer mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">  setup_smoother();</div><div class="line"></div><div class="line">  mg_matrix.initialize(mg_matrices);</div><div class="line">  mg_interface_matrix_in.initialize(mg_interface_in);</div><div class="line">  mg_interface_matrix_out.initialize(mg_interface_out);</div><div class="line"></div><div class="line">  <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">    mg_matrix, coarse_grid_solver, mg_transfer,mg_smoother,mg_smoother);</div><div class="line">  <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, Transfer&gt; preconditioner(dof_handler,</div><div class="line">                                                               <a class="code" href="namespacemg.html">mg</a>,</div><div class="line">                                                               mg_transfer);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;     Solving with GMRES to tol &quot;</span> &lt;&lt; solve_tolerance &lt;&lt; <span class="stringliteral">&quot;...&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;Vector&lt;double&gt;</a>&gt; solver(</div><div class="line">    solver_control, <a class="code" href="classSolverGMRES.html">SolverGMRES</a>&lt;Vector&lt;double&gt;&gt;::AdditionalData(50, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  time.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;          converged in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#aba22973498b0e4c2b4d64bf799e95ba8">last_wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; seconds &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line"></div><div class="line">  mg_smoother.release();</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemoutput_resultscode"></a> </p><h4><code>AdvectionProblem::output_results()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> The final function of interest generates graphical output. Here we output the solution and cell ordering in a .vtu format.</em></p>
<p><em> At the top of the function, we generate an index for each cell to visualize the ordering used by the smoothers. Note that we do this only for the active cells instead of the levels, where the smoothers are actually used. For the point smoothers we renumber DoFs instead of cells, so this is only an approximation of what happens in reality. Finally, the random ordering is not the random ordering we actually use (see <code>create_smoother()</code> for that). The (integer) ordering of cells is then copied into a (floating point) vector for graphical output.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells = triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();</div><div class="line">  Vector&lt;double&gt;     cell_indices(n_active_cells);</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">    <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">          ordered_indices =</div><div class="line">            create_downstream_cell_ordering(dof_handler, advection_direction);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">          ordered_indices =</div><div class="line">            create_downstream_cell_ordering(dof_handler,</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-1.0 advection_direction);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">          ordered_indices = create_random_cell_ordering(dof_handler);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">          ordered_indices.resize(n_active_cells);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">            ordered_indices[i] = i;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">      cell_indices(ordered_indices[i]) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i);</div><div class="line">  }</div></div><!-- fragment --><p></em></p>
<p><em> The remainder of the function is then straightforward, given previous tutorial programs:</em></p>
<p><em></p><div class="fragment"><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(cell_indices, <span class="stringliteral">&quot;cell_index&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemruncode"></a> </p><h4><code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem::run()</a></code></h4>
<p></em></p>
<p><em></em></p>
<p><em> As in most tutorials, this function creates/refines the mesh and calls the various functions defined above to set up, assemble, solve, and output the results.</em></p>
<p><em> In cycle zero, we generate the mesh for the on the square <code>[-1,1]^dim</code> with a hole of radius 3/10 units centered at the origin. For objects with <code>manifold_id</code> equal to one (namely, the faces adjacent to the hole), we assign a spherical manifold.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; (settings.fe_degree == 1 ? 7 : 5);</div><div class="line">       ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation,</div><div class="line">                                                          0.3,</div><div class="line">                                                          1.0);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0));</div><div class="line">          triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, manifold_description);</div><div class="line">        }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>();</div><div class="line"></div><div class="line">      setup_system();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl;</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of degrees of freedom: &quot;</span></div><div class="line">                &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_system_and_multigrid();</div><div class="line"></div><div class="line">      solve();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (settings.output)</div><div class="line">        output_results(cycle);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step63</span></div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p></em></p>
<p><em></em></p>
<p><em> Finally, the main function is like most tutorials. The only interesting bit is that we require the user to pass a <code>.prm</code> file as a sole command line argument. If no parameter file is given, the program will output the contents of a sample parameter file with all default values to the screen that the user can then copy and paste into their own <code>.prm</code> file.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Step63::Settings</a> settings;</div><div class="line">    settings.get_parameters((argc &gt; 1) ? (argv[1]) : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">    Step63::AdvectionProblem&lt;2&gt; advection_problem_2d(settings);</div><div class="line">    advection_problem_2d.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p></em></p>
<p><em></em></p>
<p><em> <a class="anchor" id="GMRESIterationNumbers"></a></p><h3>GMRES Iteration Numbers </h3>
<p></em></p>
<p><em></em></p>
<p><em> The major advantage for GMG is that it is an \(\mathcal{O}(n)\) method,that is, the complexity of the problem increases linearly with theproblem size. To show then that the linear solver presented in thistutorial is in fact \(\mathcal{O}(n)\) , all one needs to do is show thatthe iteration counts for the GMRES solve stay roughly constant as werefine the mesh. Each of the following tables gives the GMRES iteration counts to reduce theinitial residual by a factor of \(10^8\) . We selected a sufficient number of smoothing steps(based on the method) to get iteration numbers independent of mesh size. Ascan be seen from the tables below, the method is indeed \(\mathcal{O}(n)\) . <a class="anchor" id="DoFCellRenumbering"></a></p><h4>DoF/Cell Renumbering </h4>
<p></em></p>
<p><em></em></p>
<p><em> The point-wise smoothers ("Jacobi" and "SOR") get applied in the order theDoFs are numbered on each level. We can influence this using theDoFRenumbering namespace. The block smoothers are applied based on theordering we set in <code>setup_smoother()</code>. We can visualize this numbering. Thefollowing pictures show the cell numbering of the active cells in downstream,random, and upstream numbering (left to right): </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-cell-order.png"/>
</div>
<p> Let us start with the additive smoothers. The following table showsthe number of iterations necessary to obtain convergence from GMRES: </p><table align="center" class="doxtable">
<tr>
<th></th><th></th><th colspan="1">\(Q_1\) </th><th colspan="7">Smoother (smoothing steps)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Jacobi (6) </th><th></th><th colspan="3">Block Jacobi (3)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Renumbering Strategy </th><th></th><th colspan="3">Renumbering Strategy  </th></tr>
<tr>
<th>Cells </th><th></th><th>DoFs </th><th>Downstream </th><th>Random </th><th>Upstream </th><th></th><th>Downstream </th><th>Random </th><th>Upstream  </th></tr>
<tr>
<th>32 </th><th></th><th>48 </th><td>3 </td><td>3 </td><td>3 </td><th></th><td>3 </td><td>3 </td><td>3  </td></tr>
<tr>
<th>128 </th><th></th><th>160 </th><td>6 </td><td>6 </td><td>6 </td><th></th><td>6 </td><td>6 </td><td>6  </td></tr>
<tr>
<th>512 </th><th></th><th>576 </th><td>11 </td><td>11 </td><td>11 </td><th></th><td>9 </td><td>9 </td><td>9  </td></tr>
<tr>
<th>2048 </th><th></th><th>2176 </th><td>15 </td><td>15 </td><td>15 </td><th></th><td>13 </td><td>13 </td><td>13  </td></tr>
<tr>
<th>8192 </th><th></th><th>8448 </th><td>18 </td><td>18 </td><td>18 </td><th></th><td>15 </td><td>15 </td><td>15  </td></tr>
<tr>
<th>32768 </th><th></th><th>33280 </th><td>20 </td><td>20 </td><td>20 </td><th></th><td>16 </td><td>16 </td><td>16  </td></tr>
<tr>
<th>131072 </th><th></th><th>132096 </th><td>20 </td><td>20 </td><td>20 </td><th></th><td>16 </td><td>16 </td><td>16  </td></tr>
</table>
<p>We see that renumbering theDoFs/cells has no effect on convergence speed. This is because thesesmoothers compute operations on each DoF (point-smoother) or cell(block-smoother) independently and add up the results. Since we candefine these smoothers as an application of a sum of matrices, andmatrix addition is commutative, the order at which we sum thedifferent components will not affect the end result. On the other hand, the situation is different for multiplicative smoothers: </p><table align="center" class="doxtable">
<tr>
<th></th><th></th><th colspan="1">\(Q_1\) </th><th colspan="7">Smoother (smoothing steps)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">SOR (3) </th><th></th><th colspan="3">Block SOR (1)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Renumbering Strategy </th><th></th><th colspan="3">Renumbering Strategy  </th></tr>
<tr>
<th>Cells </th><th></th><th>DoFs </th><th>Downstream </th><th>Random </th><th>Upstream </th><th></th><th>Downstream </th><th>Random </th><th>Upstream  </th></tr>
<tr>
<th>32 </th><th></th><th>48 </th><td>2 </td><td>2 </td><td>3 </td><th></th><td>2 </td><td>2 </td><td>3  </td></tr>
<tr>
<th>128 </th><th></th><th>160 </th><td>5 </td><td>5 </td><td>7 </td><th></th><td>5 </td><td>5 </td><td>7  </td></tr>
<tr>
<th>512 </th><th></th><th>576 </th><td>7 </td><td>9 </td><td>11 </td><th></th><td>7 </td><td>7 </td><td>12  </td></tr>
<tr>
<th>2048 </th><th></th><th>2176 </th><td>10 </td><td>12 </td><td>15 </td><th></th><td>8 </td><td>10 </td><td>17  </td></tr>
<tr>
<th>8192 </th><th></th><th>8448 </th><td>11 </td><td>15 </td><td>19 </td><th></th><td>10 </td><td>11 </td><td>20  </td></tr>
<tr>
<th>32768 </th><th></th><th>33280 </th><td>12 </td><td>16 </td><td>20 </td><th></th><td>10 </td><td>12 </td><td>21  </td></tr>
<tr>
<th>131072 </th><th></th><th>132096 </th><td>12 </td><td>16 </td><td>19 </td><th></th><td>11 </td><td>12 </td><td>21  </td></tr>
</table>
<p>Here, we can speed upconvergence by renumbering the DoFs/cells in the advection direction,and similarly, we can slow down convergence if we do the renumberingin the opposite direction. This is because advection-dominatedproblems have a directional flow of information (in the advectiondirection) which, given the right renumbering of DoFs/cells,multiplicative methods are able to capture. This feature of multiplicative methods is, however, dependent on thevalue of \(\varepsilon\) . As we increase \(\varepsilon\) and the problembecomes more diffusion-dominated, we have a more uniform propagationof information over the mesh and there is a diminished advantage forrenumbering in the advection direction. On the opposite end, in theextreme case of \(\varepsilon=0\) (advection-only), we have a 1st-orderPDE and multiplicative methods with the right renumbering becomeeffective solvers: A correct downstream numbering may lead to methodsthat require only a single iteration because information can bepropagated from the inflow boundary downstream, with no informationtransport in the opposite direction. (Note, however, that in the caseof \(\varepsilon=0\) , special care must be taken for the boundaryconditions in this case).</em></p>
<p><em> <a class="anchor" id="Pointvsblocksmoothers"></a></p><h4>Point vs. block smoothers </h4>
<p></em></p>
<p><em></em></p>
<p><em> We will limit the results to runs using the downstreamrenumbering. Here is a cross comparison of all four smoothers for both \(Q_1\) and \(Q_3\) elements: </p><table align="center" class="doxtable">
<tr>
<th></th><td></td><th colspan="1">\(Q_1\) </th><th colspan="4">Smoother (smoothing steps) </th><th></th><th colspan="1">\(Q_3\) </th><th colspan="4">Smoother (smoothing steps)  </th></tr>
<tr>
<th colspan="1">Cells </th><td></td><th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1) </th><th></th><th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1)  </th></tr>
<tr>
<th>32 </th><td></td><th>48 </th><td>3 </td><td>3 </td><td>2 </td><td>2 </td><td></td><th>336 </th><td>15 </td><td>14 </td><td>15 </td><td>6  </td></tr>
<tr>
<th>128 </th><td></td><th>160 </th><td>6 </td><td>6 </td><td>5 </td><td>5 </td><td></td><th>1248 </th><td>23 </td><td>18 </td><td>21 </td><td>9  </td></tr>
<tr>
<th>512 </th><td></td><th>576 </th><td>11 </td><td>9 </td><td>7 </td><td>7 </td><td></td><th>4800 </th><td>29 </td><td>21 </td><td>28 </td><td>9  </td></tr>
<tr>
<th>2048 </th><td></td><th>2176 </th><td>15 </td><td>13 </td><td>10 </td><td>8 </td><td></td><th>18816 </th><td>33 </td><td>22 </td><td>32 </td><td>9  </td></tr>
<tr>
<th>8192 </th><td></td><th>8448 </th><td>18 </td><td>15 </td><td>11 </td><td>10 </td><td></td><th>74496 </th><td>35 </td><td>22 </td><td>34 </td><td>10  </td></tr>
<tr>
<th>32768 </th><td></td><th>33280 </th><td>20 </td><td>16 </td><td>12 </td><td>10 </td><td></td></tr>
<tr>
<th>131072 </th><td></td><th>132096 </th><td>20 </td><td>16 </td><td>12 </td><td>11 </td><td></td></tr>
</table>
<p>We see that for \(Q_1\) , both multiplicative smoothers require a smallercombination of smoothing steps and iteration counts than eitheradditive smoother. However, when we increase the degree to a \(Q_3\) element, there is a clear advantage for the block smoothers in termsof the number of smoothing steps and iterations required tosolve. Specifically, the block SOR smoother gives constant iterationcounts over the degree, and the block Jacobi smoother only sees abouta 38% increase in iterations compared to 75% and 183% for Jacobi andSOR respectively. <a class="anchor" id="Cost"></a></p><h3>Cost </h3>
<p></em></p>
<p><em></em></p>
<p><em> Iteration counts do not tell the full story in the optimality of a onesmoother over another. Obviously we must examine the cost of aniteration. Block smoothers here are at a disadvantage as they arehaving to construct and invert a cell matrix for each cell. Here is acomparison of solve times for a \(Q_3\) element with 74,496 DoFs: </p><table align="center" class="doxtable">
<tr>
<th colspan="1">\(Q_3\) </th><th colspan="4">Smoother (smoothing steps)  </th></tr>
<tr>
<th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1)  </th></tr>
<tr>
<th>74496 </th><td>0.68s </td><td>5.82s </td><td>1.18s </td><td>1.02s  </td></tr>
</table>
<p>The smoother that requires the most iterations (Jacobi) actually takesthe shortest time (roughly 2/3 the time of the next fastestmethod). This is because all that is required to apply a Jacobismoothing step is multiplication by a diagonal matrix which is verycheap. On the other hand, while SOR requires over 3x more iterations(each with 3x more smoothing steps) than block SOR, the times areroughly equivalent, implying that a smoothing step of block SOR isroughly 9x slower than a smoothing step of SOR. Lastly, block Jacobiis almost 6x more expensive than block SOR, which intuitively makessense from the fact that 1 step of each method has the same cost(inverting the cell matrices and either adding or multiply themtogether), and block Jacobi has 3 times the number of smoothing steps periteration with 2 times the iterations.</em></p>
<p><em> <a class="anchor" id="Additionalpoints"></a></p><h3>Additional points </h3>
<p></em></p>
<p><em></em></p>
<p><em> There are a few more important points to mention: </p><ol>
<li>
For a mesh distributed in parallel, multiplicative methods cannotbe executed over the entire domain. This is because they operate onecell at a time, and downstream cells can only be handled once upstreamcells have already been done. This is fine on a single processor: Theprocessor just goes through the list of cells one after theother. However, in parallel, it would imply that some processors areidle because upstream processors have not finished doing the work oncells upstream from the ones owned by the current processor. Once theupstream processors are done, the downstream ones can start, but bythat time the upstream processors have no work left. In other words,most of the time during these smoother steps, most processors are infact idle. This is not how one obtains good parallel scalability! One can use a hybrid method wherea multiplicative smoother is applied on each subdomain, but as youincrease the number of subdomains, the method approaches the behaviorof an additive method. This is a major disadvantage to these methods.  </li>
<li>
Current research into block smoothers suggest that soon we will beable to compute the inverse of the cell matrices much cheaper thanwhat is currently being done inside deal.II. This research is based onthe fast diagonalization method (dating back to the 1960s) and hasbeen used in the spectral community for around 20 years (see, e.g., <a href="https://doi.org/10.1007/s10915-004-4787-3">Hybrid Multigrid/Schwarz Algorithms for the Spectral Element Method by Lottes and Fischer</a>). There are currently efforts to generalize thesemethods to DG and make them more robust. Also, it seems that oneshould be able to take advantage of matrix-free implementations andthe fact that, in the interior of the domain, cell matrices tend tolook very similar, allowing fewer matrix inverse computations.  </li>
</ol>
<p>Combining 1. and 2. gives a good reason for expecting that a methodlike block Jacobi could become very powerful in the future, eventhough currently for these examples it is quite slow.</em></p>
<p><em> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p></em></p>
<p><em></em></p>
<p><em> <a class="anchor" id="ConstantiterationsforQsub5sub"></a></p><h4>Constant iterations for Q<sub>5</sub> </h4>
<p></em></p>
<p><em></em></p>
<p><em> Change the number of smoothing steps and the smoother relaxationparameter (set in <code>Smoother::AdditionalData()</code> inside <code>create_smoother()</code> , only necessary for point smoothers) sothat we maintain a constant number of iterations for a \(Q_5\) element. <a class="anchor" id="Effectivenessofrenumberingforchangingepsilon"></a></p><h4>Effectiveness of renumbering for changing epsilon </h4>
<p></em></p>
<p><em></em></p>
<p><em> Increase/decrease the parameter "Epsilon" in the <code>.prm</code> files of themultiplicative methods and observe for which values renumbering nolonger influences convergence speed. <a class="anchor" id="Meshadaptivity"></a></p><h4>Mesh adaptivity </h4>
<p></em></p>
<p><em></em></p>
<p><em> The code is set up to work correctly with an adaptively refined mesh (theinterface matrices are created and set). Devise a suitable refinementcriterium or try the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class.</em></p>
<p><em><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<p></em></p>
<p><em> </p><div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Thomas C. Clevenger, Clemson University</span></div><div class="line"><span class="comment"> *          Timo Heister, Clemson University and University of Utah</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation__block_8h.html">deal.II/lac/relaxation_block.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step63</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree)</div><div class="line">      : fe_values(fe,</div><div class="line">                  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    CopyData() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span><a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  {</div><div class="line">    <span class="keyword">enum</span> DoFRenumberingStrategy</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>,</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream</a>,</div><div class="line">      upstream,</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random</a></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                 <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           fe_degree;</div><div class="line">    std::string            smoother_type;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           smoothing_steps;</div><div class="line">    DoFRenumberingStrategy dof_renumbering;</div><div class="line">    <span class="keywordtype">bool</span>                   with_streamline_diffusion;</div><div class="line">    <span class="keywordtype">bool</span>                   output;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Settings::get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename)</div><div class="line">  {</div><div class="line">    <span class="comment">/* First declare the parameters... */</span></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.005&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Diffusion parameter&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                      <span class="stringliteral">&quot;Finite Element degree&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;block SOR&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;SOR|Jacobi|block SOR|block Jacobi&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Select smoother: SOR|Jacobi|block SOR|block Jacobi&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                      <span class="stringliteral">&quot;Number of smoothing steps&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;DoF renumbering&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;downstream&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;none|downstream|upstream|random&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;Select DoF renumbering: none|downstream|upstream|random&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Enable streamline diffusion stabilization: true|false&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Generate graphical output: true|false&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* ...and then try to read their values from the input file: */</span></div><div class="line">    <span class="keywordflow">if</span> (prm_filename.empty())</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">          <span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Please pass a .prm file as the first argument!&quot;</span>));</div><div class="line">      }</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(prm_filename);</div><div class="line"></div><div class="line">    <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>         = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>);</div><div class="line">    fe_degree       = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>);</div><div class="line">    smoother_type   = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>);</div><div class="line">    smoothing_steps = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string renumbering = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;DoF renumbering&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;none&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">DoFRenumberingStrategy::none</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;downstream&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumberingStrategy::downstream</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;upstream&quot;</span>)</div><div class="line">      dof_renumbering = DoFRenumberingStrategy::upstream;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;random&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumberingStrategy::random</a>;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;The &lt;DoF renumbering&gt; parameter has &quot;</span></div><div class="line">                             <span class="stringliteral">&quot;an invalid value.&quot;</span>));</div><div class="line"></div><div class="line">    with_streamline_diffusion = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>);</div><div class="line">    output                    = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Output&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">  {</div><div class="line">    std::vector&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">      ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> DoFRenumbering::</div><div class="line">      CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator, dim&gt;</div><div class="line">        comparator(direction);</div><div class="line">    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned&gt; ordered_indices;</div><div class="line">    ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">      ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_indices;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction)</div><div class="line">  {</div><div class="line">    std::vector&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> DoFRenumbering::</div><div class="line">      CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator, dim&gt;</div><div class="line">        comparator(direction);</div><div class="line">    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">    ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">      ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_indices;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">      ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    std::mt19937 random_number_generator;</div><div class="line">    std::shuffle(ordered_cells.begin(),</div><div class="line">                 ordered_cells.end(),</div><div class="line">                 random_number_generator);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_cells;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    std::mt19937 random_number_generator;</div><div class="line">    std::shuffle(ordered_cells.begin(),</div><div class="line">                 ordered_cells.end(),</div><div class="line">                 random_number_generator);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_cells;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    (void)component;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                      std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">      values[i] = RightHandSide&lt;dim&gt;::value(points[i], component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    (void)component;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[0] - 1) &lt; 1e-8 ||</div><div class="line">        (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[1] + 1) &lt; 1e-8 &amp;&amp; p[0] &gt;= 0.5))</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> 1.0;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> 0.0;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">      values[i] = BoundaryValues&lt;dim&gt;::value(points[i], component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> compute_stabilization_delta(<span class="keyword">const</span> <span class="keywordtype">double</span>         hk,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span>         eps,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dir,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span>         pk)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> Peclet = dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * hk / (2.0 * eps * pk);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coth =</div><div class="line">      (1.0 + <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> hk / (2.0 * dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * pk) * (coth - 1.0 / Peclet);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>AdvectionProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">    <span class="keywordtype">void</span> assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                       ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                       CopyData &amp;          copy_data);</div><div class="line">    <span class="keywordtype">void</span> assemble_system_and_multigrid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_smoother();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>     fe;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix;</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_in;</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_out;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;MGSmoother&lt;Vector&lt;double&gt;&gt;&gt; mg_smoother;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classRelaxationBlock.html">RelaxationBlock&lt;SparseMatrix&lt;double&gt;</a>, double, Vector&lt;double&gt;&gt;;</div><div class="line">    <span class="keyword">using</span> SmootherAdditionalDataType = SmootherType::AdditionalData;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SmootherAdditionalDataType&gt;</a> smoother_data;</div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> advection_direction;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> settings;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  AdvectionProblem&lt;dim&gt;::AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe(settings.fe_degree)</div><div class="line">    , mapping(settings.fe_degree)</div><div class="line">    , settings(settings)</div><div class="line">  {</div><div class="line">    advection_direction[0] = -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI / 6.0);</div><div class="line">    <span class="keywordflow">if</span> (dim &gt;= 2)</div><div class="line">      advection_direction[1] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI / 6.0);</div><div class="line">    <span class="keywordflow">if</span> (dim &gt;= 3)</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 1, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                    dsp,</div><div class="line">                                    constraints,</div><div class="line">                                    <span class="comment">/*keep_constrained_dofs = */</span> <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span> || settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a> ||</div><div class="line">            settings.dof_renumbering ==</div><div class="line">              Settings::DoFRenumberingStrategy::upstream)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> direction =</div><div class="line">              (settings.dof_renumbering ==</div><div class="line">                   Settings::DoFRenumberingStrategy::upstream ?</div><div class="line">                 -1.0 :</div><div class="line">                 1.0) *</div><div class="line">              advection_direction;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumbering::downstream</a>(dof_handler,</div><div class="line">                                         level,</div><div class="line">                                         direction,</div><div class="line">                                         <span class="comment">/*dof_wise_renumbering = */</span> <span class="keyword">true</span>);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">                 <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumbering::random</a>(dof_handler, level);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line"></div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});</div><div class="line"></div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.clear_elements();</div><div class="line">    mg_interface_in.resize(0, n_levels - 1);</div><div class="line">    mg_interface_in.clear_elements();</div><div class="line">    mg_interface_out.resize(0, n_levels - 1);</div><div class="line">    mg_interface_out.clear_elements();</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">    mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line">          mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                   mg_constrained_dofs,</div><div class="line">                                                   dsp,</div><div class="line">                                                   level);</div><div class="line">          mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">          mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">          mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                                            ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                            CopyData &amp;          copy_data)</div><div class="line">  {</div><div class="line">    copy_data.level = cell-&gt;level();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">    copy_data.dofs_per_cell = dofs_per_cell;</div><div class="line">    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch_data.fe_values.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">      copy_data.cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">    copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_active_or_mg_dof_indices(copy_data.local_dof_indices);</div><div class="line"></div><div class="line">    scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">    std::vector&lt;double&gt; rhs_values(n_q_points);</div><div class="line"></div><div class="line">    right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),</div><div class="line">                               rhs_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> delta = (settings.with_streamline_diffusion ?</div><div class="line">                            compute_stabilization_delta(cell-&gt;diameter(),</div><div class="line">                                                        settings.epsilon,</div><div class="line">                                                        advection_direction,</div><div class="line">                                                        settings.fe_degree) :</div><div class="line">                            0.0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                (settings.epsilon *</div><div class="line">                 scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">                 scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">                 scratch_data.fe_values.JxW(q_point)) +</div><div class="line">                (scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">                 (advection_direction *</div><div class="line">                  scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">                 scratch_data.fe_values.JxW(q_point))</div><div class="line">                + delta *</div><div class="line">                    (advection_direction *</div><div class="line">                     scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">                    (advection_direction *</div><div class="line">                     scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">                    scratch_data.fe_values.JxW(q_point) -</div><div class="line">                delta * settings.epsilon *</div><div class="line">                  <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(scratch_data.fe_values.shape_hessian(j, q_point)) *</div><div class="line">                  (advection_direction *</div><div class="line">                   scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">                  scratch_data.fe_values.JxW(q_point);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">            {</div><div class="line">              copy_data.cell_rhs(i) +=</div><div class="line">                scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">                  rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)</div><div class="line">                + delta * rhs_values[q_point] * advection_direction *</div><div class="line">                    scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">                    scratch_data.fe_values.JxW(q_point);</div><div class="line">            }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system_and_multigrid()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_active =</div><div class="line">      [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()) &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                          scratch_data,</div><div class="line">          CopyData &amp;                                  copy_data) {</div><div class="line">        this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier_active = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      constraints.distribute_local_to_global(copy_data.cell_matrix,</div><div class="line">                                             copy_data.cell_rhs,</div><div class="line">                                             copy_data.local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker_active,</div><div class="line">                          copier_active,</div><div class="line">                          ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_level_dof_indices;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(</div><div class="line">          dof_handler, level, locally_owned_level_dof_indices);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(locally_owned_level_dof_indices);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_mg =</div><div class="line">      [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>()) &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                      scratch_data,</div><div class="line">          CopyData &amp;                              copy_data) {</div><div class="line">        this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier_mg = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      boundary_constraints[copy_data.level].distribute_local_to_global(</div><div class="line">        copy_data.cell_matrix,</div><div class="line">        copy_data.local_dof_indices,</div><div class="line">        mg_matrices[copy_data.level]);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">                copy_data.level,</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j]))</div><div class="line">            {</div><div class="line">              mg_interface_out[copy_data.level].add(</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j],</div><div class="line">                copy_data.cell_matrix(i, j));</div><div class="line">              mg_interface_in[copy_data.level].add(</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j],</div><div class="line">                copy_data.cell_matrix(j, i));</div><div class="line">            }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                          cell_worker_mg,</div><div class="line">                          copier_mg,</div><div class="line">                          ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_smoother()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> smoother =</div><div class="line">          std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                  Smoother,</div><div class="line">                                                  Vector&lt;double&gt;&gt;&gt;();</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                             Smoother::AdditionalData(fe.degree == 1 ? 1.0 :</div><div class="line">                                                                       0.62));</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">        mg_smoother = std::move(smoother);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">        <span class="keyword">auto</span> smoother =</div><div class="line">          std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                  Smoother,</div><div class="line">                                                  Vector&lt;double&gt;&gt;&gt;();</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                             Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :</div><div class="line">                                                                       0.47));</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">        mg_smoother = std::move(smoother);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ||</div><div class="line">             settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() - 1);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches</a>(smoother_data[level].block_list,</div><div class="line">                                        dof_handler,</div><div class="line">                                        level);</div><div class="line"></div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].relaxation =</div><div class="line">              (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ? 1.0 : 0.25);</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].inversion = <a class="code" href="classPreconditionBlockBase.html">PreconditionBlockBase&lt;double&gt;::svd</a>;</div><div class="line"></div><div class="line">            std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">            <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                    advection_direction,</div><div class="line">                                                    level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                    -1.0 * advection_direction,</div><div class="line">                                                    level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_random_cell_ordering(dof_handler, level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">default</span>:</div><div class="line">                  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].order =</div><div class="line">              std::vector&lt;std::vector&lt;unsigned int&gt;&gt;(1, ordered_indices);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span>)</div><div class="line">          {</div><div class="line">            <span class="keyword">auto</span> smoother = std::make_unique&lt;<a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a>&lt;</div><div class="line">              SparseMatrix&lt;double&gt;,</div><div class="line">              RelaxationBlockSOR&lt;SparseMatrix&lt;double&gt;, double, Vector&lt;double&gt;&gt;,</div><div class="line">              Vector&lt;double&gt;&gt;&gt;();</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">            mg_smoother = std::move(smoother);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">          {</div><div class="line">            <span class="keyword">auto</span> smoother = std::make_unique&lt;</div><div class="line">              MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                     RelaxationBlockJacobi&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                           double,</div><div class="line">                                                           Vector&lt;double&gt;&gt;,</div><div class="line">                                     Vector&lt;double&gt;&gt;&gt;();</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">            mg_smoother = std::move(smoother);</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iters       = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       solve_tolerance = 1e-8 * system_rhs.l2_norm();</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>      solver_control(max_iters, solve_tolerance, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">    solver_control.<a class="code" href="classSolverControl.html#a6d99741765243ccb65da4ff66558cf41">enable_history_data</a>();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Transfer = MGTransferPrebuilt&lt;Vector&lt;double&gt;&gt;;</div><div class="line">    Transfer mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    setup_smoother();</div><div class="line"></div><div class="line">    mg_matrix.initialize(mg_matrices);</div><div class="line">    mg_interface_matrix_in.initialize(mg_interface_in);</div><div class="line">    mg_interface_matrix_out.initialize(mg_interface_out);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, Transfer&gt; preconditioner(dof_handler,</div><div class="line">                                                                 <a class="code" href="namespacemg.html">mg</a>,</div><div class="line">                                                                 mg_transfer);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;     Solving with GMRES to tol &quot;</span> &lt;&lt; solve_tolerance &lt;&lt; <span class="stringliteral">&quot;...&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;Vector&lt;double&gt;</a>&gt; solver(</div><div class="line">      solver_control, <a class="code" href="classSolverGMRES.html">SolverGMRES</a>&lt;Vector&lt;double&gt;&gt;::AdditionalData(50, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    time.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;          converged in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#aba22973498b0e4c2b4d64bf799e95ba8">last_wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; seconds &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    mg_smoother.release();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells = triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();</div><div class="line">    Vector&lt;double&gt;     cell_indices(n_active_cells);</div><div class="line">    {</div><div class="line">      std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">      <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">            ordered_indices =</div><div class="line">              create_downstream_cell_ordering(dof_handler, advection_direction);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">            ordered_indices =</div><div class="line">              create_downstream_cell_ordering(dof_handler,</div><div class="line">                                              -1.0 * advection_direction);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">            ordered_indices = create_random_cell_ordering(dof_handler);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">            ordered_indices.resize(n_active_cells);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">              ordered_indices[i] = i;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">        cell_indices(ordered_indices[i]) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(cell_indices, <span class="stringliteral">&quot;cell_index&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename.c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; (settings.fe_degree == 1 ? 7 : 5);</div><div class="line">         ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation,</div><div class="line">                                                            0.3,</div><div class="line">                                                            1.0);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0));</div><div class="line">            triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, manifold_description);</div><div class="line">          }</div><div class="line"></div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>();</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of degrees of freedom: &quot;</span></div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system_and_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (settings.output)</div><div class="line">          output_results(cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step63</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Step63::Settings</a> settings;</div><div class="line">      settings.get_parameters((argc &gt; 1) ? (argv[1]) : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">      Step63::AdvectionProblem&lt;2&gt; advection_problem_2d(settings);</div><div class="line">      advection_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em>This tutorial depends on <a class="el" href="step_16.html">step-16</a>.</em></p>
<p><em> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Equation">Equation</a>
      <ul>
        <li><a href="#Streamlinediffusion">Streamline diffusion</a>
      </ul>
        <li><a href="#Smoothers">Smoothers</a>
        <li><a href="#Testproblem">Test problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#MeshWorkerdata">MeshWorker data</a>
        <li><a href="#Problemparameters">Problem parameters</a>
        <li><a href="#Cellpermutations">Cell permutations</a>
        <li><a href="#Righthandsideandboundaryvalues">Right-hand side and boundary values</a>
        <li><a href="#Streamlinediffusionimplementation">Streamline diffusion implementation</a>
        <li><a href="#codeAdvectionProlemcodeclass"><code>AdvectionProlem</code> class</a>
      <ul>
        <li><a href="#codeAdvectionProblemsetup_systemcode"><code>AdvectionProblem::setup_system()</code></a>
        <li><a href="#codeAdvectionProblemassemble_cellcode"><code>AdvectionProblem::assemble_cell()</code></a>
        <li><a href="#codeAdvectionProblemassemble_system_and_multigridcode"><code>AdvectionProblem::assemble_system_and_multigrid()</code></a>
        <li><a href="#codeAdvectionProblemsetup_smoothercode"><code>AdvectionProblem::setup_smoother()</code></a>
        <li><a href="#codeAdvectionProblemsolvecode"><code>AdvectionProblem::solve()</code></a>
        <li><a href="#codeAdvectionProblemoutput_resultscode"><code>AdvectionProblem::output_results()</code></a>
        <li><a href="#codeAdvectionProblemruncode"><code>AdvectionProblem::run()</code></a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#GMRESIterationNumbers"> GMRES Iteration Numbers </a>
      <ul>
        <li><a href="#DoFCellRenumbering"> DoF/Cell Renumbering </a>
        <li><a href="#Pointvsblocksmoothers"> Point vs. block smoothers </a>
      </ul>
        <li><a href="#Cost"> Cost </a>
        <li><a href="#Additionalpoints"> Additional points </a>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
      <ul>
        <li><a href="#ConstantiterationsforQsub5sub"> Constant iterations for Q<sub>5</sub> </a>
        <li><a href="#Effectivenessofrenumberingforchangingepsilon"> Effectiveness of renumbering for changing epsilon </a>
        <li><a href="#Meshadaptivity"> Mesh adaptivity </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-63/doc/intro.dox</em></p>
<p><em> <br />
</em></p>
<p><em><em>This program was contributed by Thomas C. Clevenger and Timo Heister.</em></em></p>
<p><em><em>The creation of this tutorial was partially supported by NSF Award DMS-1522191, DMS-1901529, OAC-1835452, by the Computational Infrastructure in Geodynamics initiative (CIG), through the NSF under Award EAR-0949446 and EAR-1550901 and The University of California - Davis. </em></em></p>
<p><em> </p><dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.3382899"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.3382899.svg" alt="10.5281/zenodo.3382899"/></a> </dd></dl>
<p><a class="anchor" id="Intro"></a></em></p>
<p><em><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p></em></p>
<p><em></em></p>
<p><em>该程序使用几何多网格（GMG）预处理程序来解决一个平流-扩散问题。在步骤16中讨论了该预处理程序的基本原理；这里我们讨论了非对称PDE所需的必要变化。此外，我们还介绍了块平滑的概念（与步骤16中的点平滑相比），并检查了加法和乘法平滑器的DoF重新编号的效果。</em></p>
<p><em><a class="anchor" id="Equation"></a></p><h3>Equation</h3>
<p></em></p>
<p><em> 平流-扩散方程由以下公式给出</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} -\varepsilon \Delta u + \boldsymbol{\beta}\cdot \nabla u &amp; = f &amp; \text{ in } \Omega\\ u &amp;= g &amp; \text{ on } \partial\Omega \end{align*}
</p>
<p></em></p>
<p><em>其中 \(\varepsilon&gt;0\) ， \(\boldsymbol{\beta}\) 是<em>advection direction</em>，而 \(f\) 是一个来源。有几个注意事项。</em></p>
<p><em>1.如果 \(\boldsymbol{\beta}=\boldsymbol{0}\) ，这就是在步骤16（以及其他许多地方）解决的拉普拉斯方程。</em></p>
<p><em>2.如果 \(\varepsilon=0\) ，那么这就是步骤9中解决的静止平流方程。</em></p>
<p><em>3.人们可以为这个问题定义一个无尺寸的数字，称为<em>Peclet number</em>。 \(\mathcal{P} \dealcoloneq \frac{\|\boldsymbol{\beta}\| L}{\varepsilon}\) ，其中 \(L\) 是领域的长度尺度。它描述了我们所考虑的那种方程的特点。如果 \(\mathcal{P}&gt;1\) ，我们说问题是<em>advection-dominated</em>，否则如果 \(\mathcal{P}&lt;1\) 我们将说问题是<em>diffusion-dominated</em>。</em></p>
<p><em>在本教程的讨论中，我们将关注以对流为主的流动。这是很复杂的情况。我们知道，对于扩散主导的问题，标准的Galerkin方法可以很好地工作，我们也知道简单的多网格方法，如步骤16中定义的方法是非常有效的。另一方面，对于平流主导的问题，标准Galerkin方法会导致振荡和不稳定的离散，而简单的求解器往往不是很有效。因此，本教程程序旨在解决这两个问题。</em></p>
<p><em><a class="anchor" id="Streamlinediffusion"></a></p><h4>Streamline diffusion</h4>
<p></em></p>
<p><em></em></p>
<p><em>使用标准的Galerkin有限元方法，对于合适的测试函数 \(v_h\) ，PDE的离散弱形式将为</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} a(u_h,v_h) = F(v_h) \end{align*}
</p>
<p></em></p>
<p><em>其中</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} a(u_h,v_h) &amp;= (\varepsilon \nabla v_h,\, \nabla u_h) + (v_h,\,\boldsymbol{\beta}\cdot \nabla u_h),\\ F(v_h) &amp;= (v_h,\,f). \end{align*}
</p>
<p></em></p>
<p><em>不幸的是，用这种方法通常会得到震荡解。事实上，对于这种表述，可以显示出以下误差估计。</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} \|\nabla (u-u_h)\| \leq (1+\mathcal{P}) \inf_{v_h} \|\nabla (u-v_h)\|. \end{align*}
</p>
<p></em></p>
<p><em>如果精确解足够平滑，右边的下限可以按如下方式估计。</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} \inf_{v_h} \|\nabla (u-v_h)\|. \le \|\nabla (u-I_h u)\| \le h^k C \|\nabla^k u)\| \end{align*}
</p>
<p></em></p>
<p><em>其中 \(k\) 是所用有限元的多项式程度。因此，我们得到的估计是</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} \|\nabla (u-u_h)\| \leq (1+\mathcal{P}) C h^k \|\nabla^k u)\|. \end{align*}
</p>
<p></em></p>
<p><em>换句话说，数值解会收敛。另一方面，鉴于上述 \(\mathcal{P}\) 的定义，我们不得不期待当 \(\varepsilon \ll \|\boldsymbol{\beta}\| L\) 时，即如果问题只有少量的扩散时，数值解会很差，而且误差很大。</em></p>
<p><em>为了解决这个问题，我们将考虑新的弱形式</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} a(u_h,\,v_h) + \sum_K (-\varepsilon \Delta u_h + \boldsymbol{\beta}\cdot \nabla u_h-f,\,\delta_K \boldsymbol{\beta}\cdot \nabla v_h)_K = F(v_h) \end{align*}
</p>
<p></em></p>
<p><em>其中，对所有单元进行求和 \(K\) ，对每个单元进行内积， \(\delta_K\) 是定义在 <b>[john2006discontinuity]</b> 中的逐个单元的常数稳定参数。</em></p>
<p><em>从本质上讲，加入离散的强形式残差会增强双线性形式 \(a(\cdot,\cdot)\) 的矫捷性，从而增加离散解的稳定性。这种方法通常被称为<em>streamline diffusion</em>或<em>SUPG</em>（流线上风/Petrov-Galerkin）。</em></p>
<p><em><a class="anchor" id="Smoothers"></a></p><h3>Smoothers</h3>
<p></em></p>
<p><em></em></p>
<p><em>本教程的目标之一是从使用一个简单的（point-wise）高斯-赛德尔（SOR）平滑器开始扩展，该平滑器在步骤16（类PreconditionSOR）中用于多网格层次结构的每一层。术语 "point-wise "传统上用于求解器，表示每次在一个 "网格点 "求解；对于标量问题，这意味着使用一个求解器，每次更新线性系统的一个未知数，保持所有其他未知数固定不变；然后在问题中的所有未知数上进行迭代，一旦完成，从第一个未知数开始重新进行，直到这些 "扫频 "收敛。雅可比、高斯-赛德尔和SOR迭代都可以用这种方式解释。在多网格的背景下，人们不认为这些方法是 "求解器"，而是 "平滑器"。因此，人们对实际解决线性系统不感兴趣。为了使多网格方法发挥作用，只需去除残差的高频部分即可，因为这样可以将解限制在更粗的网格中。 因此，我们只需对所有未知数进行少量的、固定数量的 "扫频"。在本教程的代码中，这是由 "平滑步骤 "参数控制的。</em></p>
<p><em>但众所周知，这些方法在作为求解器时收敛得相当慢。虽然作为多网格平滑器，它们出乎意料地好，但它们也可以被改进。特别是，我们在这里也考虑 "基于单元的 "平滑器。这些方法一次解决一个单元上的所有未知数，保持所有其他未知数的固定；然后它们转到下一个单元，如此反复。我们可以把它们看作是雅可比（Jacobi）、高斯-赛德尔（Gauss-Seidel）或SOR的 "区块 "版本，但由于自由度是在多个单元中共享的，这些区块是重叠的，实际上这些方法最好在加法和乘法施瓦兹方法的框架内解释。</em></p>
<p><em>与<a class="el" href="step_16.html">step-16</a>相比，我们的测试问题包含一个平流项。特别是在小的扩散常数 \(\varepsilon\) 下，信息会沿着给定的平流方向的流线进行传输。这意味着，如果平滑器允许信息在单一平滑器应用中沿下游方向传播，那么平滑器可能会更有效。如果我们想按照这些未知数（或未知数块）的列举顺序一次解决一个未知数（或未知数块），那么这个信息传播特性需要相应地重新排列自由度或单元（对于基于单元的平滑器），以便更上游的自由度被提前处理（指数较低），更下游的自由度被推迟处理（指数较大）。排序的影响将在结果部分可见。</em></p>
<p><em>现在让我们简单地定义一下本教程中使用的平滑器。关于更详细的介绍，我们参考 <b>[KanschatNotesIterative]</b> 和书籍 <b>[smith2004domain]</b> 和 <b>[toselli2006domain]</b> 。施瓦兹预处理器需要一个分解</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} V = \sum_{j=1}^J V_j \end{align*}
</p>
<p></em></p>
<p><em>的有限元空间 \(V\) 。每个子问题 \(V_j\) 也有一个基于双线性形式 \(a(\cdot,\cdot)\) 的 Ritz 投影 \(P_j: V \rightarrow V_j\) 。这个投影对每个子问题 \(A_j\) 诱导出一个局部算子 \(V_j\) 。如果 \(\Pi_j:V\rightarrow V_j\) 是对 \(V_j\) 的正交投影，可以证明 \(A_jP_j=\Pi_j^TA\) 。</em></p>
<p><em>有了这个，我们可以为算子 \(A\) 定义一个<em>additive Schwarz preconditioner</em>为</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} B^{-1} = \sum_{j=1}^J P_j A^{-1} = \sum_{j=1}^J A_j^{-1} \Pi_j^T. \end{align*}
</p>
<p></em></p>
<p><em>换句话说，我们将我们的解决方案投射到每个子问题中，应用子问题的逆向 \(A_j\) ，并将所有 \(j\) 的贡献加起来。</em></p>
<p><em>请注意，我们可以通过为每个自由度定义一个子问题 \(V_j\) ，将逐点（一次一个未知数）的雅可比方法解释为加性施瓦兹方法。然后， \(A_j^{-1}\) 成为与 \(A\) 的对角线项的逆数相乘的方法。</em></p>
<p><em>对于本教程中使用的 "块状雅可比 "方法，我们为当前层次上的网格的每个单元定义一个子问题 \(V_j\) 。注意，我们使用的是连续有限元，所以这些块是重叠的，因为两个单元之间的界面上的自由度都属于两个子问题。对子问题（在deal.II中它们被称为 "块"）进行操作的施瓦茨算子的逻辑在RelaxationBlock类中实现。块状雅可比 "方法是在RelaxationBlockJacobi类中实现的。该类的许多方面（例如如何定义块以及如何反转局部子问题 \(A_j\) ）可以在平滑器数据中配置，详见 <a class="el" href="classRelaxationBlock_1_1AdditionalData.html">RelaxationBlock::AdditionalData</a> 和 <a class="el" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches()</a> 。</em></p>
<p><em>到目前为止，我们讨论了加法平滑器，其中更新可以独立应用，并且在单个平滑器应用中没有信息流动。A<em>multiplicative Schwarz preconditioner</em>解决了这个问题，其定义为</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} B^{-1} = \left( I- \prod_{j=1}^J \left(I-P_j\right) \right) A^{-1}. \end{align*}
</p>
<p></em></p>
<p><em>与上面不同的是，对子问题 \(V_j\) 的更新是按顺序应用的。这意味着在颠倒子问题 \(A_j\) 时得到的更新立即被用于 \(A_{j+1}\) 。这在写出项目的时候就可以看到。</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} B^{-1} = \left( I - \left(I-P_1\right)\left(I-P_2\right)\cdots\left(I-P_J\right) \right) A^{-1} = A^{-1} - \left[ \left(I-P_1\right) \left[ \left(I-P_2\right)\cdots \left[\left(I-P_J\right) A^{-1}\right] \cdots \right] \right] \end{align*}
</p>
<p></em></p>
<p><em>当把子空间 \(V_j\) 定义为整个自由度块时，这个方法在RelaxationBlockSOR类中实现，当你在本教程中选择 "块SOR "时使用。RelaxationBlockSOR类也是从RelaxationBlock派生的。因此，加法和乘法的施瓦兹方法都在一个统一的框架内实现。</em></p>
<p><em>最后，让我们注意到，标准的高斯-赛德尔（或SOR）方法可以被看作是一个乘法施瓦茨方法，每个DoF都有一个子问题。</em></p>
<p><em><a class="anchor" id="Testproblem"></a></p><h3>Test problem</h3>
<p></em></p>
<p><em></em></p>
<p><em>我们将考虑以下测试问题： \(\Omega = [-1,\,1]\times[-1,\,1]\backslash B_{0.3}(0)\) ，即一个以原点为圆心的半径为0.3的正方形被移除。此外，我们使用 \(\varepsilon=0.005\) , \(\boldsymbol{\beta} = [-\sin(\pi/6),\,\cos(\pi/6)]\) , \(f=0\) , 和迪里希特边界值</em></p>
<p><em> </p><p class="formulaDsp">
\begin{align*} g = \left\{\begin{array}{ll} 1 &amp; \text{if } x=-1 \text{ or } y=-1,\,x\geq 0.5 \\ 0 &amp; \text{otherwise} \end{array}\right. \end{align*}
</p>
<p></em></p>
<p><em>下面的数字描述了有（左）和无（右）流线扩散的解决方案。在没有流线扩散的情况下，我们看到边界层周围有很大的振荡，这表明标准的Galerkin有限元方法对这个问题的不稳定性。</em></p>
<p><em> </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-solution.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-solution-no-sd.png"/>
</div>
   </td></tr>
</table>
<p></em></p>
<p><em> <a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p></em></p>
<p><em></em></p>
<p><em> <a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p></em></p>
<p><em></em></p>
<p><em> Typical files needed for standard deal.II:</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation__block_8h.html">deal.II/lac/relaxation_block.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div></div><!-- fragment --><p></em></p>
<p><em> Include all relevant multilevel files:</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p></em></p>
<p><em> C++:</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div></div><!-- fragment --><p></em></p>
<p><em> We will be using <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a> functionality for assembling matrices:</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="MeshWorkerdata"></a> </p><h3><a class="el" href="namespaceMeshWorker.html">MeshWorker</a> data</h3>
<p></em></p>
<p><em></em></p>
<p><em> As always, we will be putting everything related to this program into a namespace of its own.</em></p>
<p><em> Since we will be using the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework, the first step is to define the following structures needed by the assemble_cell() function used by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>: <code>ScratchData</code> contains an <a class="el" href="classFEValues.html">FEValues</a> object which is needed for assembling a cell's local contribution, while <code>CopyData</code> contains the output from a cell's local contribution and necessary information to copy that to the global system. (Their purpose is also explained in the documentation of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> class.)</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">namespace </span>Step63</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree)</div><div class="line">      : fe_values(fe,</div><div class="line">                  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    CopyData() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  };</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Problemparameters"></a> </p><h3>Problem parameters</h3>
<p></em></p>
<p><em></em></p>
<p><em> The second step is to define the classes that deal with run-time parameters to be read from an input file.</em></p>
<p><em> We will use <a class="el" href="classParameterHandler.html">ParameterHandler</a> to pass in parameters at runtime. The structure <code>Settings</code> parses and stores the parameters to be queried throughout the program.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">{</div><div class="line">  <span class="keyword">enum</span> DoFRenumberingStrategy</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>,</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream</a>,</div><div class="line">    upstream,</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random</a></div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>                 <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           fe_degree;</div><div class="line">  std::string            smoother_type;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           smoothing_steps;</div><div class="line">  DoFRenumberingStrategy dof_renumbering;</div><div class="line">  <span class="keywordtype">bool</span>                   with_streamline_diffusion;</div><div class="line">  <span class="keywordtype">bool</span>                   output;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Settings::get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename)</div><div class="line">{</div><div class="line">  <span class="comment">/* First declare the parameters... */</span></div><div class="line">  <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;0.005&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                    <span class="stringliteral">&quot;Diffusion parameter&quot;</span>);</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;Finite Element degree&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;block SOR&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;SOR|Jacobi|block SOR|block Jacobi&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Select smoother: SOR|Jacobi|block SOR|block Jacobi&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                    <span class="stringliteral">&quot;Number of smoothing steps&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;DoF renumbering&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;downstream&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;none|downstream|upstream|random&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;Select DoF renumbering: none|downstream|upstream|random&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Enable streamline diffusion stabilization: true|false&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Generate graphical output: true|false&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* ...and then try to read their values from the input file: */</span></div><div class="line">  <span class="keywordflow">if</span> (prm_filename.empty())</div><div class="line">    {</div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">        <span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Please pass a .prm file as the first argument!&quot;</span>));</div><div class="line">    }</div><div class="line"></div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(prm_filename);</div><div class="line"></div><div class="line">  <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>         = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>);</div><div class="line">  fe_degree       = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>);</div><div class="line">  smoother_type   = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>);</div><div class="line">  smoothing_steps = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string renumbering = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;DoF renumbering&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;none&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">DoFRenumberingStrategy::none</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;downstream&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumberingStrategy::downstream</a>;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;upstream&quot;</span>)</div><div class="line">    dof_renumbering = DoFRenumberingStrategy::upstream;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;random&quot;</span>)</div><div class="line">    dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumberingStrategy::random</a>;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;The &lt;DoF renumbering&gt; parameter has &quot;</span></div><div class="line">                           <span class="stringliteral">&quot;an invalid value.&quot;</span>));</div><div class="line"></div><div class="line">  with_streamline_diffusion = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>);</div><div class="line">  output                    = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Output&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Cellpermutations"></a> </p><h3>Cell permutations</h3>
<p></em></p>
<p><em></em></p>
<p><em> The ordering in which cells and degrees of freedom are traversed will play a role in the speed of convergence for multiplicative methods. Here we define functions which return a specific ordering of cells to be used by the block smoothers.</em></p>
<p><em> For each type of cell ordering, we define a function for the active mesh and one for a level mesh (i.e., for the cells at one level of a multigrid hierarchy). While the only reordering necessary for solving the system will be on the level meshes, we include the active reordering for visualization purposes in output_results().</em></p>
<p><em> For the two downstream ordering functions, we first create an array with all of the relevant cells that we then sort in downstream direction using a "comparator" object. The output of the functions is then simply an array of the indices of the cells in the just computed order.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">{</div><div class="line">  std::vector&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">    ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> DoFRenumbering::</div><div class="line">    CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator, dim&gt;</div><div class="line">      comparator(direction);</div><div class="line">  std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned&gt; ordered_indices;</div><div class="line">  ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">    ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_indices;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction)</div><div class="line">{</div><div class="line">  std::vector&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> DoFRenumbering::</div><div class="line">    CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator, dim&gt;</div><div class="line">      comparator(direction);</div><div class="line">  std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">  std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">  ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">    ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_indices;</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> The functions that produce a random ordering are similar in spirit in that they first put information about all cells into an array. But then, instead of sorting them, they shuffle the elements randomly using the facilities C++ offers to generate random numbers. The way this is done is by iterating over all elements of the array, drawing a random number for another element before that, and then exchanging these elements. The result is a random shuffle of the elements of the array.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">    ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  std::mt19937 random_number_generator;</div><div class="line">  std::shuffle(ordered_cells.begin(),</div><div class="line">               ordered_cells.end(),</div><div class="line">               random_number_generator);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_cells;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::vector&lt;unsigned int&gt;</div><div class="line">create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">  ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">  std::mt19937 random_number_generator;</div><div class="line">  std::shuffle(ordered_cells.begin(),</div><div class="line">               ordered_cells.end(),</div><div class="line">               random_number_generator);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ordered_cells;</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Righthandsideandboundaryvalues"></a> </p><h3>Right-hand side and boundary values</h3>
<p></em></p>
<p><em></em></p>
<p><em> The problem solved in this tutorial is an adaptation of Ex. 3.1.3 found on pg. 118 of <a href="https://global.oup.com/academic/product/finite-elements-and-fast-iterative-solvers-9780199678808">Finite Elements and Fast Iterative Solvers: with Applications in Incompressible Fluid Dynamics by Elman, Silvester, and Wathen</a>. The main difference being that we add a hole in the center of our domain with zero Dirichlet boundary conditions.</em></p>
<p><em> For a complete description, we need classes that implement the zero right-hand side first (we could of course have just used <a class="el" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a>):</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  (void)component;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0.0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                    std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">    values[i] = RightHandSide&lt;dim&gt;::value(points[i], component);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> We also have Dirichlet boundary conditions. On a connected portion of the outer, square boundary we set the value to 1, and we set the value to 0 everywhere else (including the inner, circular boundary):</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">  (void)component;</div></div><!-- fragment --><p></em></p>
<p><em> Set boundary to 1 if \(x=1\), or if \(x&gt;0.5\) and \(y=-1\).</em></p>
<p><em></p><div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[0] - 1) &lt; 1e-8 ||</div><div class="line">      (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[1] + 1) &lt; 1e-8 &amp;&amp; p[0] &gt;= 0.5))</div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> 1.0;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordflow">return</span> 0.0;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">    values[i] = BoundaryValues&lt;dim&gt;::value(points[i], component);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Streamlinediffusionimplementation"></a> </p><h3>Streamline diffusion implementation</h3>
<p></em></p>
<p><em></em></p>
<p><em> The streamline diffusion method has a stabilization constant that we need to be able to compute. The choice of how this parameter is computed is taken from <a href="https://link.springer.com/chapter/10.1007/978-3-540-34288-5_27">On Discontinuity-Capturing Methods for Convection-Diffusion Equations by Volker John and Petr Knobloch</a>.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> compute_stabilization_delta(<span class="keyword">const</span> <span class="keywordtype">double</span>         hk,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>         eps,</div><div class="line">                                   <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dir,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>         pk)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> Peclet = dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * hk / (2.0 * eps * pk);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coth =</div><div class="line">    (1.0 + <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> hk / (2.0 * dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * pk) * (coth - 1.0 / Peclet);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProlemcodeclass"></a> </p><h3><code>AdvectionProlem</code> class</h3>
<p></em></p>
<p><em></em></p>
<p><em> This is the main class of the program, and should look very similar to <a class="el" href="step_16.html">step-16</a>. The major difference is that, since we are defining our multigrid smoother at runtime, we choose to define a function <code>create_smoother()</code> and a class object <code>mg_smoother</code> which is a <code>std::unique_ptr</code> to a smoother that is derived from <a class="el" href="classMGSmoother.html">MGSmoother</a>. Note that for smoothers derived from <a class="el" href="classRelaxationBlock.html">RelaxationBlock</a>, we must include a <code>smoother_data</code> object for each level. This will contain information about the cell ordering and the method of inverting cell matrices.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AdvectionProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">  <span class="keywordtype">void</span> assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                     ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                     CopyData &amp;          copy_data);</div><div class="line">  <span class="keywordtype">void</span> assemble_system_and_multigrid();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_smoother();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>     fe;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line"></div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix;</div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_in;</div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_out;</div><div class="line"></div><div class="line">  std::unique_ptr&lt;MGSmoother&lt;Vector&lt;double&gt;&gt;&gt; mg_smoother;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> SmootherType =</div><div class="line">    <a class="code" href="classRelaxationBlock.html">RelaxationBlock&lt;SparseMatrix&lt;double&gt;</a>, double, Vector&lt;double&gt;&gt;;</div><div class="line">  <span class="keyword">using</span> SmootherAdditionalDataType = SmootherType::AdditionalData;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SmootherAdditionalDataType&gt;</a> smoother_data;</div><div class="line"></div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> advection_direction;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> settings;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">AdvectionProblem&lt;dim&gt;::AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe(settings.fe_degree)</div><div class="line">  , mapping(settings.fe_degree)</div><div class="line">  , settings(settings)</div><div class="line">{</div><div class="line">  advection_direction[0] = -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI / 6.0);</div><div class="line">  <span class="keywordflow">if</span> (dim &gt;= 2)</div><div class="line">    advection_direction[1] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI / 6.0);</div><div class="line">  <span class="keywordflow">if</span> (dim &gt;= 3)</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemsetup_systemcode"></a> </p><h4><code>AdvectionProblem::setup_system()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Here we first set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, and <a class="el" href="classSparsityPattern.html">SparsityPattern</a> objects for both active and multigrid level meshes.</em></p>
<p><em> We could renumber the active DoFs with the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> class, but the smoothers only act on multigrid levels and as such, this would not matter for the computations. Instead, we will renumber the DoFs on each multigrid level below.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.clear();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 0, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">    mapping, dof_handler, 1, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">  constraints.close();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                  dsp,</div><div class="line">                                  constraints,</div><div class="line">                                  <span class="comment">/*keep_constrained_dofs = */</span> <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div></div><!-- fragment --><p></em></p>
<p><em> Having enumerated the global degrees of freedom as well as (in the last line above) the level degrees of freedom, let us renumber the level degrees of freedom to get a better smoother as explained in the introduction. The first block below renumbers DoFs on each level in downstream or upstream direction if needed. This is only necessary for point smoothers (SOR and Jacobi) as the block smoothers operate on cells (see <code>create_smoother()</code>). The blocks below then also implement random numbering.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span> || settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">          <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a> ||</div><div class="line">        settings.dof_renumbering ==</div><div class="line">          Settings::DoFRenumberingStrategy::upstream)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> direction =</div><div class="line">          (settings.dof_renumbering ==</div><div class="line">               Settings::DoFRenumberingStrategy::upstream ?</div><div class="line">             -1.0 :</div><div class="line">             1.0) *</div><div class="line">          advection_direction;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">          <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumbering::downstream</a>(dof_handler,</div><div class="line">                                     level,</div><div class="line">                                     direction,</div><div class="line">                                     <span class="comment">/*dof_wise_renumbering = */</span> <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">             <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">          <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumbering::random</a>(dof_handler, level);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div></div><!-- fragment --><p></em></p>
<p><em> The rest of the function just sets up data structures. The last lines of the code below is unlike the other GMG tutorials, as it sets up both the interface in and out matrices. We need this since our problem is non-symmetric.</em></p>
<p><em></p><div class="fragment"><div class="line">  mg_constrained_dofs.clear();</div><div class="line">  mg_constrained_dofs.initialize(dof_handler);</div><div class="line"></div><div class="line">  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});</div><div class="line"></div><div class="line">  mg_matrices.resize(0, n_levels - 1);</div><div class="line">  mg_matrices.clear_elements();</div><div class="line">  mg_interface_in.resize(0, n_levels - 1);</div><div class="line">  mg_interface_in.clear_elements();</div><div class="line">  mg_interface_out.resize(0, n_levels - 1);</div><div class="line">  mg_interface_out.clear_elements();</div><div class="line">  mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">  mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                 mg_constrained_dofs,</div><div class="line">                                                 dsp,</div><div class="line">                                                 level);</div><div class="line">        mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">        mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">        mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemassemble_cellcode"></a> </p><h4><code>AdvectionProblem::assemble_cell()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Here we define the assembly of the linear system on each cell to be used by the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function below. This one function assembles the cell matrix for either an active or a level cell (whatever it is passed as its first argument), and only assembles a right-hand side if called with an active cell.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                                          ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                          CopyData &amp;          copy_data)</div><div class="line">{</div><div class="line">  copy_data.level = cell-&gt;level();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  copy_data.dofs_per_cell = dofs_per_cell;</div><div class="line">  copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    scratch_data.fe_values.get_quadrature().size();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">    copy_data.cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">  copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line">  cell-&gt;get_active_or_mg_dof_indices(copy_data.local_dof_indices);</div><div class="line"></div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">  std::vector&lt;double&gt; rhs_values(n_q_points);</div><div class="line"></div><div class="line">  right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),</div><div class="line">                             rhs_values);</div></div><!-- fragment --><p></em></p>
<p><em> If we are using streamline diffusion we must add its contribution to both the cell matrix and the cell right-hand side. If we are not using streamline diffusion, setting \(\delta=0\) negates this contribution below and we are left with the standard, Galerkin finite element assembly.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> delta = (settings.with_streamline_diffusion ?</div><div class="line">                        compute_stabilization_delta(cell-&gt;diameter(),</div><div class="line">                                                    settings.epsilon,</div><div class="line">                                                    advection_direction,</div><div class="line">                                                    settings.fe_degree) :</div><div class="line">                        0.0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div></div><!-- fragment --><p></em></p>
<p><em> The assembly of the local matrix has two parts. First the Galerkin contribution:</em></p>
<p><em></p><div class="fragment"><div class="line">copy_data.cell_matrix(i, j) +=</div><div class="line">  (settings.epsilon *</div><div class="line">   scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">   scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">   scratch_data.fe_values.JxW(q_point)) +</div><div class="line">  (scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">   (advection_direction *</div><div class="line">    scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">   scratch_data.fe_values.JxW(q_point))</div></div><!-- fragment --><p></em></p>
<p><em> and then the streamline diffusion contribution:</em></p>
<p><em></p><div class="fragment"><div class="line">      + delta *</div><div class="line">          (advection_direction *</div><div class="line">           scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">          (advection_direction *</div><div class="line">           scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">          scratch_data.fe_values.JxW(q_point) -</div><div class="line">      delta * settings.epsilon *</div><div class="line">        <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(scratch_data.fe_values.shape_hessian(j, q_point)) *</div><div class="line">        (advection_direction *</div><div class="line">         scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">        scratch_data.fe_values.JxW(q_point);</div><div class="line">  }</div><div class="line"><span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">  {</div></div><!-- fragment --><p></em></p>
<p><em> The same applies to the right hand side. First the Galerkin contribution:</em></p>
<p><em></p><div class="fragment"><div class="line">copy_data.cell_rhs(i) +=</div><div class="line">  scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">    rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)</div></div><!-- fragment --><p></em></p>
<p><em> and then the streamline diffusion contribution:</em></p>
<p><em></p><div class="fragment"><div class="line">              + delta * rhs_values[q_point] * advection_direction *</div><div class="line">                  scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">                  scratch_data.fe_values.JxW(q_point);</div><div class="line">          }</div><div class="line">      }</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemassemble_system_and_multigridcode"></a> </p><h4><code>AdvectionProblem::assemble_system_and_multigrid()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Here we employ <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to go over cells and assemble the system_matrix, system_rhs, and all mg_matrices for us.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system_and_multigrid()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_active =</div><div class="line">    [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()) &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                          scratch_data,</div><div class="line">        CopyData &amp;                                  copy_data) {</div><div class="line">      this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier_active = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">    constraints.distribute_local_to_global(copy_data.cell_matrix,</div><div class="line">                                           copy_data.cell_rhs,</div><div class="line">                                           copy_data.local_dof_indices,</div><div class="line">                                           system_matrix,</div><div class="line">                                           system_rhs);</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker_active,</div><div class="line">                        copier_active,</div><div class="line">                        ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div></div><!-- fragment --><p></em></p>
<p><em> Unlike the constraints for the active level, we choose to create constraint objects for each multigrid level local to this function since they are never needed elsewhere in the program.</em></p>
<p><em></p><div class="fragment"><div class="line">std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>());</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_level_dof_indices;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(</div><div class="line">      dof_handler, level, locally_owned_level_dof_indices);</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(locally_owned_level_dof_indices);</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">      mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">      mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">    boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_mg =</div><div class="line">  [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>()) &amp;cell,</div><div class="line">      ScratchData&lt;dim&gt; &amp;                      scratch_data,</div><div class="line">      CopyData &amp;                              copy_data) {</div><div class="line">    this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier_mg = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">  boundary_constraints[copy_data.level].distribute_local_to_global(</div><div class="line">    copy_data.cell_matrix,</div><div class="line">    copy_data.local_dof_indices,</div><div class="line">    mg_matrices[copy_data.level]);</div></div><!-- fragment --><p></em></p>
<p><em> If \((i,j)\) is an <code>interface_out</code> dof pair, then \((j,i)\) is an <code>interface_in</code> dof pair. Note: For <code>interface_in</code>, we load the transpose of the interface entries, i.e., the entry for dof pair \((j,i)\) is stored in <code>interface_in(i,j)</code>. This is an optimization for the symmetric case which allows only one matrix to be used when setting the edge_matrices in solve(). Here, however, since our problem is non-symmetric, we must store both <code>interface_in</code> and <code>interface_out</code> matrices.</em></p>
<p><em></p><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.dofs_per_cell; ++j)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">              copy_data.level,</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j]))</div><div class="line">          {</div><div class="line">            mg_interface_out[copy_data.level].add(</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j],</div><div class="line">              copy_data.cell_matrix(i, j));</div><div class="line">            mg_interface_in[copy_data.level].add(</div><div class="line">              copy_data.local_dof_indices[i],</div><div class="line">              copy_data.local_dof_indices[j],</div><div class="line">              copy_data.cell_matrix(j, i));</div><div class="line">          }</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                        cell_worker_mg,</div><div class="line">                        copier_mg,</div><div class="line">                        ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemsetup_smoothercode"></a> </p><h4><code>AdvectionProblem::setup_smoother()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Next, we set up the smoother based on the settings in the <code>.prm</code> file. The two options that are of significance is the number of pre- and post-smoothing steps on each level of the multigrid v-cycle and the relaxation parameter.</em></p>
<p><em> Since multiplicative methods tend to be more powerful than additive method, fewer smoothing steps are required to see convergence independent of mesh size. The same holds for block smoothers over point smoothers. This is reflected in the choice for the number of smoothing steps for each type of smoother below.</em></p>
<p><em> The relaxation parameter for point smoothers is chosen based on trial and error, and reflects values necessary to keep the iteration counts in the GMRES solve constant (or as close as possible) as we refine the mesh. The two values given for both "Jacobi" and "SOR" in the <code>.prm</code> files are for degree 1 and degree 3 finite elements. If the user wants to change to another degree, they may need to adjust these numbers. For block smoothers, this parameter has a more straightforward interpretation, namely that for additive methods in 2D, a DoF can have a repeated contribution from up to 4 cells, therefore we must relax these methods by 0.25 to compensate. This is not an issue for multiplicative methods as each cell's inverse application carries new information to all its DoFs.</em></p>
<p><em> Finally, as mentioned above, the point smoothers only operate on DoFs, and the block smoothers on cells, so only the block smoothers need to be given information regarding cell orderings. DoF ordering for point smoothers has already been taken care of in <code>setup_system()</code>.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_smoother()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> smoother =</div><div class="line">        std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                Smoother,</div><div class="line">                                                Vector&lt;double&gt;&gt;&gt;();</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                           Smoother::AdditionalData(fe.degree == 1 ? 1.0 :</div><div class="line">                                                                     0.62));</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">      mg_smoother = std::move(smoother);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">      <span class="keyword">auto</span> smoother =</div><div class="line">        std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                Smoother,</div><div class="line">                                                Vector&lt;double&gt;&gt;&gt;();</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                           Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :</div><div class="line">                                                                     0.47));</div><div class="line">      smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">      mg_smoother = std::move(smoother);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ||</div><div class="line">           settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">    {</div><div class="line">      smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() - 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches</a>(smoother_data[level].block_list,</div><div class="line">                                      dof_handler,</div><div class="line">                                      level);</div><div class="line"></div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].relaxation =</div><div class="line">            (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ? 1.0 : 0.25);</div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].inversion = <a class="code" href="classPreconditionBlockBase.html">PreconditionBlockBase&lt;double&gt;::svd</a>;</div><div class="line"></div><div class="line">          std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">          <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">                ordered_indices =</div><div class="line">                  create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                  advection_direction,</div><div class="line">                                                  level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">                ordered_indices =</div><div class="line">                  create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                  -1.0 * advection_direction,</div><div class="line">                                                  level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">                ordered_indices =</div><div class="line">                  create_random_cell_ordering(dof_handler, level);</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">              <span class="keywordflow">default</span>:</div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].order =</div><div class="line">            std::vector&lt;std::vector&lt;unsigned int&gt;&gt;(1, ordered_indices);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> smoother = std::make_unique&lt;<a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a>&lt;</div><div class="line">            SparseMatrix&lt;double&gt;,</div><div class="line">            RelaxationBlockSOR&lt;SparseMatrix&lt;double&gt;, double, Vector&lt;double&gt;&gt;,</div><div class="line">            Vector&lt;double&gt;&gt;&gt;();</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">          mg_smoother = std::move(smoother);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> smoother = std::make_unique&lt;</div><div class="line">            MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                   RelaxationBlockJacobi&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                         double,</div><div class="line">                                                         Vector&lt;double&gt;&gt;,</div><div class="line">                                   Vector&lt;double&gt;&gt;&gt;();</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">          smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">          mg_smoother = std::move(smoother);</div><div class="line">        }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemsolvecode"></a> </p><h4><code>AdvectionProblem::solve()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> Before we can solve the system, we must first set up the multigrid preconditioner. This requires the setup of the transfer between levels, the coarse matrix solver, and the smoother. This setup follows almost identically to <a class="el" href="step_16.html">step-16</a>, the main difference being the various smoothers defined above and the fact that we need different interface edge matrices for in and out since our problem is non-symmetric. (In reality, for this tutorial these interface matrices are empty since we are only using global refinement, and thus have no refinement edges. However, we have still included both here since if one made the simple switch to an adaptively refined method, the program would still run correctly.)</em></p>
<p><em> The last thing to note is that since our problem is non-symmetric, we must use an appropriate Krylov subspace method. We choose here to use GMRES since it offers the guarantee of residual reduction in each iteration. The major disavantage of GMRES is that, for each iteration, the number of stored temporary vectors increases by one, and one also needs to compute a scalar product with all previously stored vectors. This is rather expensive. This requirement is relaxed by using the restarted GMRES method which puts a cap on the number of vectors we are required to store at any one time (here we restart after 50 temporary vectors, or 48 iterations). This then has the disadvantage that we lose information we have gathered throughout the iteration and therefore we could see slower convergence. As a consequence, where to restart is a question of balancing memory consumption, CPU effort, and convergence speed. However, the goal of this tutorial is to have very low iteration counts by using a powerful GMG preconditioner, so we have picked the restart length such that all of the results shown below converge prior to restart happening, and thus we have a standard GMRES method. If the user is interested, another suitable method offered in deal.II would be BiCGStab.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iters       = 200;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       solve_tolerance = 1e-8 * system_rhs.l2_norm();</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>      solver_control(max_iters, solve_tolerance, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  solver_control.<a class="code" href="classSolverControl.html#a6d99741765243ccb65da4ff66558cf41">enable_history_data</a>();</div><div class="line"></div><div class="line">  <span class="keyword">using</span> Transfer = MGTransferPrebuilt&lt;Vector&lt;double&gt;&gt;;</div><div class="line">  Transfer mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">  setup_smoother();</div><div class="line"></div><div class="line">  mg_matrix.initialize(mg_matrices);</div><div class="line">  mg_interface_matrix_in.initialize(mg_interface_in);</div><div class="line">  mg_interface_matrix_out.initialize(mg_interface_out);</div><div class="line"></div><div class="line">  <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">    mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);</div><div class="line">  <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, Transfer&gt; preconditioner(dof_handler,</div><div class="line">                                                               <a class="code" href="namespacemg.html">mg</a>,</div><div class="line">                                                               mg_transfer);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;     Solving with GMRES to tol &quot;</span> &lt;&lt; solve_tolerance &lt;&lt; <span class="stringliteral">&quot;...&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;Vector&lt;double&gt;</a>&gt; solver(</div><div class="line">    solver_control, <a class="code" href="classSolverGMRES.html">SolverGMRES</a>&lt;Vector&lt;double&gt;&gt;::AdditionalData(50, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">  time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  time.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;          converged in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#aba22973498b0e4c2b4d64bf799e95ba8">last_wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; seconds &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line"></div><div class="line">  mg_smoother.release();</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemoutput_resultscode"></a> </p><h4><code>AdvectionProblem::output_results()</code></h4>
<p></em></p>
<p><em></em></p>
<p><em> The final function of interest generates graphical output. Here we output the solution and cell ordering in a .vtu format.</em></p>
<p><em> At the top of the function, we generate an index for each cell to visualize the ordering used by the smoothers. Note that we do this only for the active cells instead of the levels, where the smoothers are actually used. For the point smoothers we renumber DoFs instead of cells, so this is only an approximation of what happens in reality. Finally, the random ordering is not the random ordering we actually use (see <code>create_smoother()</code> for that).</em></p>
<p><em> The (integer) ordering of cells is then copied into a (floating point) vector for graphical output.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells = triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();</div><div class="line">  Vector&lt;double&gt;     cell_indices(n_active_cells);</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">    <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">          ordered_indices =</div><div class="line">            create_downstream_cell_ordering(dof_handler, advection_direction);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">          ordered_indices =</div><div class="line">            create_downstream_cell_ordering(dof_handler,</div><div class="line">                                            -1.0 * advection_direction);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">          ordered_indices = create_random_cell_ordering(dof_handler);</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">          ordered_indices.resize(n_active_cells);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">            ordered_indices[i] = i;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">      cell_indices(ordered_indices[i]) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i);</div><div class="line">  }</div></div><!-- fragment --><p></em></p>
<p><em> The remainder of the function is then straightforward, given previous tutorial programs:</em></p>
<p><em></p><div class="fragment"><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(cell_indices, <span class="stringliteral">&quot;cell_index&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename.c_str());</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="codeAdvectionProblemruncode"></a> </p><h4><code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem::run()</a></code></h4>
<p></em></p>
<p><em></em></p>
<p><em> As in most tutorials, this function creates/refines the mesh and calls the various functions defined above to set up, assemble, solve, and output the results.</em></p>
<p><em> In cycle zero, we generate the mesh for the on the square <code>[-1,1]^dim</code> with a hole of radius 3/10 units centered at the origin. For objects with <code>manifold_id</code> equal to one (namely, the faces adjacent to the hole), we assign a spherical manifold.</em></p>
<p><em></p><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; (settings.fe_degree == 1 ? 7 : 5);</div><div class="line">         ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation,</div><div class="line">                                                            0.3,</div><div class="line">                                                            1.0);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0));</div><div class="line">            triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, manifold_description);</div><div class="line">          }</div><div class="line"></div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>();</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of degrees of freedom: &quot;</span></div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system_and_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (settings.output)</div><div class="line">          output_results(cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step63</span></div></div><!-- fragment --><p></em></p>
<p><em> <a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p></em></p>
<p><em></em></p>
<p><em> Finally, the main function is like most tutorials. The only interesting bit is that we require the user to pass a <code>.prm</code> file as a sole command line argument. If no parameter file is given, the program will output the contents of a sample parameter file with all default values to the screen that the user can then copy and paste into their own <code>.prm</code> file.</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Step63::Settings</a> settings;</div><div class="line">      settings.get_parameters((argc &gt; 1) ? (argv[1]) : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">      Step63::AdvectionProblem&lt;2&gt; advection_problem_2d(settings);</div><div class="line">      advection_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-63/doc/results.dox</em></p>
<p><em><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p></em></p>
<p><em></em></p>
<p><em><a class="anchor" id="GMRESIterationNumbers"></a></p><h3>GMRES Iteration Numbers </h3>
<p></em></p>
<p><em></em></p>
<p><em>GMG的主要优势在于它是一种 \(\mathcal{O}(n)\) 方法，也就是说，问题的复杂性随着问题的大小而线性增加。为了证明本教程中介绍的线性求解器实际上是 \(\mathcal{O}(n)\) ，我们只需要证明GMRES求解的迭代次数在我们细化网格时保持大致不变。</em></p>
<p><em>以下每个表格都给出了GMRES的迭代次数，以减少初始残差的系数 \(10^8\) 。我们选择了足够数量的平滑步骤（基于该方法），以获得与网格大小无关的迭代数。从下面的表格可以看出，该方法确实是 \(\mathcal{O}(n)\) 。</em></p>
<p><em><a class="anchor" id="DoFCellRenumbering"></a></p><h4>DoF/Cell Renumbering </h4>
<p></em></p>
<p><em></em></p>
<p><em>逐点平滑器（"Jacobi "和 "SOR"）是按照每层的DoFs的编号顺序来应用的。我们可以使用DoFRenumbering命名空间来影响这一点。块平滑器的应用是基于我们在<code>setup_smoother()</code>中设置的顺序。我们可以直观地看到这个编号。下面的图片显示了在下游、随机和上游编号中的活动单元的编号（从左到右）。</em></p>
<p><em> </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-63-cell-order.png"/>
</div>
<p></em></p>
<p><em>让我们从加性平滑器开始。下表显示了从GMRES获得收敛的必要迭代次数。</em></p>
<p><em> </p><table align="center" class="doxtable">
<tr>
<th></th><th></th><th colspan="1">\(Q_1\) </th><th colspan="7">Smoother (smoothing steps)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Jacobi (6) </th><th></th><th colspan="3">Block Jacobi (3)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Renumbering Strategy </th><th></th><th colspan="3">Renumbering Strategy  </th></tr>
<tr>
<th>Cells </th><th></th><th>DoFs </th><th>Downstream </th><th>Random </th><th>Upstream </th><th></th><th>Downstream </th><th>Random </th><th>Upstream  </th></tr>
<tr>
<th>32 </th><th></th><th>48 </th><td>3 </td><td>3 </td><td>3 </td><th></th><td>3 </td><td>3 </td><td>3  </td></tr>
<tr>
<th>128 </th><th></th><th>160 </th><td>6 </td><td>6 </td><td>6 </td><th></th><td>6 </td><td>6 </td><td>6  </td></tr>
<tr>
<th>512 </th><th></th><th>576 </th><td>11 </td><td>11 </td><td>11 </td><th></th><td>9 </td><td>9 </td><td>9  </td></tr>
<tr>
<th>2048 </th><th></th><th>2176 </th><td>15 </td><td>15 </td><td>15 </td><th></th><td>13 </td><td>13 </td><td>13  </td></tr>
<tr>
<th>8192 </th><th></th><th>8448 </th><td>18 </td><td>18 </td><td>18 </td><th></th><td>15 </td><td>15 </td><td>15  </td></tr>
<tr>
<th>32768 </th><th></th><th>33280 </th><td>20 </td><td>20 </td><td>20 </td><th></th><td>16 </td><td>16 </td><td>16  </td></tr>
<tr>
<th>131072 </th><th></th><th>132096 </th><td>20 </td><td>20 </td><td>20 </td><th></th><td>16 </td><td>16 </td><td>16  </td></tr>
</table>
<p></em></p>
<p><em>我们看到，重新编号的DoF/单元对收敛速度没有影响。这是因为这些平滑器独立计算每个DoF（点平滑器）或单元（块平滑器）的操作，并将结果相加。由于我们可以将这些平滑器定义为矩阵之和的应用，而矩阵加法是交换性的，所以我们对不同组件进行加法的顺序不会影响最终结果。</em></p>
<p><em>另一方面，乘法平滑器的情况则不同。</em></p>
<p><em> </p><table align="center" class="doxtable">
<tr>
<th></th><th></th><th colspan="1">\(Q_1\) </th><th colspan="7">Smoother (smoothing steps)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">SOR (3) </th><th></th><th colspan="3">Block SOR (1)  </th></tr>
<tr>
<th></th><th></th><th></th><th colspan="3">Renumbering Strategy </th><th></th><th colspan="3">Renumbering Strategy  </th></tr>
<tr>
<th>Cells </th><th></th><th>DoFs </th><th>Downstream </th><th>Random </th><th>Upstream </th><th></th><th>Downstream </th><th>Random </th><th>Upstream  </th></tr>
<tr>
<th>32 </th><th></th><th>48 </th><td>2 </td><td>2 </td><td>3 </td><th></th><td>2 </td><td>2 </td><td>3  </td></tr>
<tr>
<th>128 </th><th></th><th>160 </th><td>5 </td><td>5 </td><td>7 </td><th></th><td>5 </td><td>5 </td><td>7  </td></tr>
<tr>
<th>512 </th><th></th><th>576 </th><td>7 </td><td>9 </td><td>11 </td><th></th><td>7 </td><td>7 </td><td>12  </td></tr>
<tr>
<th>2048 </th><th></th><th>2176 </th><td>10 </td><td>12 </td><td>15 </td><th></th><td>8 </td><td>10 </td><td>17  </td></tr>
<tr>
<th>8192 </th><th></th><th>8448 </th><td>11 </td><td>15 </td><td>19 </td><th></th><td>10 </td><td>11 </td><td>20  </td></tr>
<tr>
<th>32768 </th><th></th><th>33280 </th><td>12 </td><td>16 </td><td>20 </td><th></th><td>10 </td><td>12 </td><td>21  </td></tr>
<tr>
<th>131072 </th><th></th><th>132096 </th><td>12 </td><td>16 </td><td>19 </td><th></th><td>11 </td><td>12 </td><td>21  </td></tr>
</table>
<p></em></p>
<p><em>在这里，我们可以通过在平流方向上对DoFs/单元进行重新编号来加快收敛速度，同样，如果我们在相反的方向上进行重新编号，我们可以减缓收敛速度。这是因为平流主导的问题有一个定向的信息流（在平流方向），如果对DoFs/单元进行正确的重新编号，乘法就能够捕捉到这些信息。</em></p>
<p><em>然而，乘法的这一特点取决于 \(\varepsilon\) 的值。当我们增加 \(\varepsilon\) ，问题变得更加以扩散为主时，我们的信息在网格上的传播更加均匀，在平流方向上重新编号的优势就会减弱。相反，在 \(\varepsilon=0\) 的极端情况下（仅有平流），我们有一个一阶PDE，具有正确重编号的乘法成为有效的求解器。正确的下游编号可能导致方法只需要一次迭代，因为信息可以从流入边界向下游传播，而没有相反方向的信息传输。然而，请注意，在 \(\varepsilon=0\) 的情况下，必须对这种情况下的边界条件给予特别关注）。</em></p>
<p><em><a class="anchor" id="Pointvsblocksmoothers"></a></p><h4>Point vs. block smoothers </h4>
<p></em></p>
<p><em></em></p>
<p><em>我们将把结果限制在使用下游重新编号的运行上。下面是对 \(Q_1\) 和 \(Q_3\) 元素的所有四个平滑器的交叉比较。</em></p>
<p><em> </p><table align="center" class="doxtable">
<tr>
<th></th><td></td><th colspan="1">\(Q_1\) </th><th colspan="4">Smoother (smoothing steps) </th><th></th><th colspan="1">\(Q_3\) </th><th colspan="4">Smoother (smoothing steps)  </th></tr>
<tr>
<th colspan="1">Cells </th><td></td><th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1) </th><th></th><th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1)  </th></tr>
<tr>
<th>32 </th><td></td><th>48 </th><td>3 </td><td>3 </td><td>2 </td><td>2 </td><td></td><th>336 </th><td>15 </td><td>14 </td><td>15 </td><td>6  </td></tr>
<tr>
<th>128 </th><td></td><th>160 </th><td>6 </td><td>6 </td><td>5 </td><td>5 </td><td></td><th>1248 </th><td>23 </td><td>18 </td><td>21 </td><td>9  </td></tr>
<tr>
<th>512 </th><td></td><th>576 </th><td>11 </td><td>9 </td><td>7 </td><td>7 </td><td></td><th>4800 </th><td>29 </td><td>21 </td><td>28 </td><td>9  </td></tr>
<tr>
<th>2048 </th><td></td><th>2176 </th><td>15 </td><td>13 </td><td>10 </td><td>8 </td><td></td><th>18816 </th><td>33 </td><td>22 </td><td>32 </td><td>9  </td></tr>
<tr>
<th>8192 </th><td></td><th>8448 </th><td>18 </td><td>15 </td><td>11 </td><td>10 </td><td></td><th>74496 </th><td>35 </td><td>22 </td><td>34 </td><td>10  </td></tr>
<tr>
<th>32768 </th><td></td><th>33280 </th><td>20 </td><td>16 </td><td>12 </td><td>10 </td><td></td></tr>
<tr>
<th>131072 </th><td></td><th>132096 </th><td>20 </td><td>16 </td><td>12 </td><td>11 </td><td></td></tr>
</table>
<p></em></p>
<p><em>我们看到，对于 \(Q_1\) ，两个乘法平滑器需要的平滑步骤和迭代次数的组合都比任何一个加法平滑器小。然而，当我们将度数增加到 \(Q_3\) 元素时，在平滑步骤和迭代次数方面，块平滑器有明显的优势。具体来说，块状SOR平滑器在度数上给出了恒定的迭代次数，而块状Jacobi平滑器的迭代次数只增加了约38，而Jacobi和SOR的迭代次数分别为75和183。</em></p>
<p><em><a class="anchor" id="Cost"></a></p><h3>Cost </h3>
<p></em></p>
<p><em></em></p>
<p><em>迭代次数并不能完全说明一个平滑器对另一个平滑器的最优性。很明显，我们必须检查迭代的成本。块状平滑器在这里处于不利地位，因为它们必须为每个单元构建和反转一个单元矩阵。下面是一个具有74,496个DoF的 \(Q_3\) 元素的求解时间的比较。</em></p>
<p><em> </p><table align="center" class="doxtable">
<tr>
<th colspan="1">\(Q_3\) </th><th colspan="4">Smoother (smoothing steps)  </th></tr>
<tr>
<th colspan="1">DoFs </th><th colspan="1">Jacobi (6) </th><th colspan="1">Block Jacobi (3) </th><th colspan="1">SOR (3) </th><th colspan="1">Block SOR (1)  </th></tr>
<tr>
<th>74496 </th><td>0.68s </td><td>5.82s </td><td>1.18s </td><td>1.02s  </td></tr>
</table>
<p></em></p>
<p><em>需要最多迭代的平滑器（Jacobi）实际上需要最短的时间（大约是下一个最快方法的2/3）。这是因为应用雅可比平滑步骤所需要的只是乘以一个对角线矩阵，这是非常便宜的。另一方面，虽然SOR比块SOR需要超过3倍的迭代（每个迭代有3倍的平滑步骤），但时间大致相当，这意味着块SOR的一个平滑步骤比SOR的一个平滑步骤大约慢9倍。最后，Jacobi块的成本比SOR块高6倍，这在直觉上是有道理的，因为每种方法的1个步骤都有相同的成本（反转单元格矩阵并将其相加或相乘），而Jacobi块每次迭代的平滑步骤是3倍，迭代次数是2倍。</em></p>
<p><em><a class="anchor" id="Additionalpoints"></a></p><h3>Additional points </h3>
<p></em></p>
<p><em></em></p>
<p><em>还有几个重要的点需要提及。</em></p>
<p><em></p><ol>
<li>
<p class="startli">对于平行分布的网格，乘法不能在整个领域内执行。这是因为它们一次操作一个单元，而下游的单元只有在上游的单元已经完成后才能被处理。这在单个处理器上是没有问题的。处理器只是一个接一个地浏览单元的列表。然而，在并行的情况下，这将意味着一些处理器是空闲的，因为上游处理器还没有完成对当前处理器所拥有的上游单元的工作。一旦上游处理器完成工作，下游处理器就可以开始工作，但那时上游处理器已经没有工作了。换句话说，在这些平稳的步骤中，大部分时间，大多数处理器实际上是空闲的。这不是获得良好的并行可扩展性的方法!</p>
<p>我们可以使用一种混合方法，即在每个子域上应用乘法平滑器，但是当你增加子域的数量时，该方法接近于加法的行为。这是这些方法的一个主要缺点。 </p>
<p class="endli"></p>
</li>
<li>
目前对块平滑器的研究表明，很快我们将能够计算单元矩阵的逆，比目前在deal.II里面做的要便宜得多。这项研究是基于快速对角线化方法（可以追溯到20世纪60年代），在光谱界已经使用了大约20年（例如，见<a href="https://doi.org/10.1007/s10915-004-4787-3">Hybrid Multigrid/Schwarz Algorithms for the Spectral Element Method by Lottes and Fischer</a>）。目前，人们正在努力将这些方法推广到DG，并使其更加强大。此外，人们似乎应该能够利用无矩阵的实现，以及在域的内部，单元矩阵往往看起来非常相似的事实，允许更少的矩阵逆计算。  </li>
</ol>
<p>。</em></p>
<p><em>结合1.和2.，我们有充分的理由期待像块状雅可比这样的方法在未来变得非常强大，尽管目前对这些例子来说它是相当缓慢的。</em></p>
<p><em><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p></em></p>
<p><em></em></p>
<p><em><a class="anchor" id="ConstantiterationsforQsub5sub"></a></p><h4>Constant iterations for Q<sub>5</sub> </h4>
<p></em></p>
<p><em></em></p>
<p><em>改变平滑步骤的数量和平滑器放松参数（在 <code>Smoother::AdditionalData()</code> 中设置在 <code>create_smoother()</code> 里面，只对点平滑器有必要），以便我们对一个 \(Q_5\) 元素保持一个恒定的迭代次数。</em></p>
<p><em><a class="anchor" id="Effectivenessofrenumberingforchangingepsilon"></a></p><h4>Effectiveness of renumbering for changing epsilon </h4>
<p></em></p>
<p><em></em></p>
<p><em>增加/减少乘法的<code>.prm</code>文件中的参数 "Epsilon"，观察哪些数值的重编号不再影响收敛速度。</em></p>
<p><em><a class="anchor" id="Meshadaptivity"></a></p><h4>Mesh adaptivity </h4>
<p></em></p>
<p><em></em></p>
<p><em>这段代码被设置为可以在自适应细化的网格中正常工作（接口矩阵被创建和设置）。设计一个合适的细化标准或尝试KellyErrorEstimator类。</em></p>
<p><em><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<p></em></p>
<p><em> </p><div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Thomas C. Clevenger, Clemson University</span></div><div class="line"><span class="comment"> *          Timo Heister, Clemson University and University of Utah</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="relaxation__block_8h.html">deal.II/lac/relaxation_block.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q_8h.html">deal.II/fe/mapping_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step63</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree)</div><div class="line">      : fe_values(fe,</div><div class="line">                  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    CopyData() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell;</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span><a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a></div><div class="line">  {</div><div class="line">    <span class="keyword">enum</span> DoFRenumberingStrategy</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">none</a>,</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream</a>,</div><div class="line">      upstream,</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random</a></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                 <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           fe_degree;</div><div class="line">    std::string            smoother_type;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>           smoothing_steps;</div><div class="line">    DoFRenumberingStrategy dof_renumbering;</div><div class="line">    <span class="keywordtype">bool</span>                   with_streamline_diffusion;</div><div class="line">    <span class="keywordtype">bool</span>                   output;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Settings::get_parameters(<span class="keyword">const</span> std::string &amp;prm_filename)</div><div class="line">  {</div><div class="line">    <span class="comment">/* First declare the parameters... */</span></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;0.005&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0),</div><div class="line">                      <span class="stringliteral">&quot;Diffusion parameter&quot;</span>);</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                      <span class="stringliteral">&quot;Finite Element degree&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;block SOR&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;SOR|Jacobi|block SOR|block Jacobi&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Select smoother: SOR|Jacobi|block SOR|block Jacobi&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(1),</div><div class="line">                      <span class="stringliteral">&quot;Number of smoothing steps&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;DoF renumbering&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;downstream&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;none|downstream|upstream|random&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;Select DoF renumbering: none|downstream|upstream|random&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Enable streamline diffusion stabilization: true|false&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;Output&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;true&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Generate graphical output: true|false&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">/* ...and then try to read their values from the input file: */</span></div><div class="line">    <span class="keywordflow">if</span> (prm_filename.empty())</div><div class="line">      {</div><div class="line">        prm.<a class="code" href="classParameterHandler.html#a4ac3a8b19ade16e96e8ea25906daf23a">print_parameters</a>(std::cout, <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827ae4d13a4598073bfcb69cd0cf4c1f8365">ParameterHandler::Text</a>);</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(</div><div class="line">          <span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Please pass a .prm file as the first argument!&quot;</span>));</div><div class="line">      }</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(prm_filename);</div><div class="line"></div><div class="line">    <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>         = prm.<a class="code" href="classParameterHandler.html#aeaf3c7846747695b1f327677e3716ec5">get_double</a>(<span class="stringliteral">&quot;Epsilon&quot;</span>);</div><div class="line">    fe_degree       = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Fe degree&quot;</span>);</div><div class="line">    smoother_type   = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;Smoother type&quot;</span>);</div><div class="line">    smoothing_steps = prm.<a class="code" href="classParameterHandler.html#a61fa98fdc0c52980a5b1de0ee1fc5bb2">get_integer</a>(<span class="stringliteral">&quot;Smoothing steps&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string renumbering = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;DoF renumbering&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;none&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">DoFRenumberingStrategy::none</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;downstream&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumberingStrategy::downstream</a>;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;upstream&quot;</span>)</div><div class="line">      dof_renumbering = DoFRenumberingStrategy::upstream;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (renumbering == <span class="stringliteral">&quot;random&quot;</span>)</div><div class="line">      dof_renumbering = <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumberingStrategy::random</a>;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;The &lt;DoF renumbering&gt; parameter has &quot;</span></div><div class="line">                             <span class="stringliteral">&quot;an invalid value.&quot;</span>));</div><div class="line"></div><div class="line">    with_streamline_diffusion = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;With streamline diffusion&quot;</span>);</div><div class="line">    output                    = prm.<a class="code" href="classParameterHandler.html#a6bb45dc67787e3fab7882461929b5fbe">get_bool</a>(<span class="stringliteral">&quot;Output&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">  {</div><div class="line">    std::vector&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">      ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> DoFRenumbering::</div><div class="line">      CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::level_cell_iterator, dim&gt;</div><div class="line">        comparator(direction);</div><div class="line">    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned&gt; ordered_indices;</div><div class="line">    ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">      ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_indices;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_downstream_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>   direction)</div><div class="line">  {</div><div class="line">    std::vector&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      ordered_cells.push_back(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> DoFRenumbering::</div><div class="line">      CompareDownstream&lt;typename DoFHandler&lt;dim&gt;::active_cell_iterator, dim&gt;</div><div class="line">        comparator(direction);</div><div class="line">    std::sort(ordered_cells.begin(), ordered_cells.end(), comparator);</div><div class="line"></div><div class="line">    std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">    ordered_indices.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : ordered_cells)</div><div class="line">      ordered_indices.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_indices;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     level)</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>(level));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacb307c39a2891e324a723063c6994427">cell_iterators_on_level</a>(level))</div><div class="line">      ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    std::mt19937 random_number_generator;</div><div class="line">    std::shuffle(ordered_cells.begin(),</div><div class="line">                 ordered_cells.end(),</div><div class="line">                 random_number_generator);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_cells;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">  create_random_cell_ordering(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; ordered_cells;</div><div class="line">    ordered_cells.reserve(dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>().<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      ordered_cells.push_back(cell-&gt;index());</div><div class="line"></div><div class="line">    std::mt19937 random_number_generator;</div><div class="line">    std::shuffle(ordered_cells.begin(),</div><div class="line">                 ordered_cells.end(),</div><div class="line">                 random_number_generator);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ordered_cells;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    (void)component;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                      std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">      values[i] = RightHandSide&lt;dim&gt;::value(points[i], component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line">    (void)component;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[0] - 1) &lt; 1e-8 ||</div><div class="line">        (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(p[1] + 1) &lt; 1e-8 &amp;&amp; p[0] &gt;= 0.5))</div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> 1.0;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordflow">return</span> 0.0;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; points.size(); ++i)</div><div class="line">      values[i] = BoundaryValues&lt;dim&gt;::value(points[i], component);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> compute_stabilization_delta(<span class="keyword">const</span> <span class="keywordtype">double</span>         hk,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span>         eps,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> dir,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">double</span>         pk)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> Peclet = dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * hk / (2.0 * eps * pk);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coth =</div><div class="line">      (1.0 + <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-2.0 * Peclet)) / (1.0 - std::exp(-2.0 * Peclet));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> hk / (2.0 * dir.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * pk) * (coth - 1.0 / Peclet);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>AdvectionProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">    <span class="keywordtype">void</span> assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                       ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                       CopyData &amp;          copy_data);</div><div class="line">    <span class="keywordtype">void</span> assemble_system_and_multigrid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_smoother();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>     fe;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ.html">MappingQ&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix;</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_in;</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_matrix_out;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;MGSmoother&lt;Vector&lt;double&gt;&gt;&gt; mg_smoother;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classRelaxationBlock.html">RelaxationBlock&lt;SparseMatrix&lt;double&gt;</a>, double, Vector&lt;double&gt;&gt;;</div><div class="line">    <span class="keyword">using</span> SmootherAdditionalDataType = SmootherType::AdditionalData;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SmootherAdditionalDataType&gt;</a> smoother_data;</div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> advection_direction;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> settings;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  AdvectionProblem&lt;dim&gt;::AdvectionProblem(<span class="keyword">const</span> <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Settings</a> &amp;settings)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe(settings.fe_degree)</div><div class="line">    , mapping(settings.fe_degree)</div><div class="line">    , settings(settings)</div><div class="line">  {</div><div class="line">    advection_direction[0] = -<a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI / 6.0);</div><div class="line">    <span class="keywordflow">if</span> (dim &gt;= 2)</div><div class="line">      advection_direction[1] = <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI / 6.0);</div><div class="line">    <span class="keywordflow">if</span> (dim &gt;= 3)</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 0, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      mapping, dof_handler, 1, BoundaryValues&lt;dim&gt;(), constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                    dsp,</div><div class="line">                                    constraints,</div><div class="line">                                    <span class="comment">/*keep_constrained_dofs = */</span> <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span> || settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a> ||</div><div class="line">            settings.dof_renumbering ==</div><div class="line">              Settings::DoFRenumberingStrategy::upstream)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> direction =</div><div class="line">              (settings.dof_renumbering ==</div><div class="line">                   Settings::DoFRenumberingStrategy::upstream ?</div><div class="line">                 -1.0 :</div><div class="line">                 1.0) *</div><div class="line">              advection_direction;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumbering::downstream</a>(dof_handler,</div><div class="line">                                         level,</div><div class="line">                                         direction,</div><div class="line">                                         <span class="comment">/*dof_wise_renumbering = */</span> <span class="keyword">true</span>);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.dof_renumbering ==</div><div class="line">                 <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">              <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumbering::random</a>(dof_handler, level);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line"></div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler, {0, 1});</div><div class="line"></div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.clear_elements();</div><div class="line">    mg_interface_in.resize(0, n_levels - 1);</div><div class="line">    mg_interface_in.clear_elements();</div><div class="line">    mg_interface_out.resize(0, n_levels - 1);</div><div class="line">    mg_interface_out.clear_elements();</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">    mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line">          mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                   mg_constrained_dofs,</div><div class="line">                                                   dsp,</div><div class="line">                                                   level);</div><div class="line">          mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">          mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">          mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_interface_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> IteratorType&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_cell(<span class="keyword">const</span> IteratorType &amp;cell,</div><div class="line">                                            ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                            CopyData &amp;          copy_data)</div><div class="line">  {</div><div class="line">    copy_data.level = cell-&gt;level();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">    copy_data.dofs_per_cell = dofs_per_cell;</div><div class="line">    copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">      scratch_data.fe_values.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">      copy_data.cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">    copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_active_or_mg_dof_indices(copy_data.local_dof_indices);</div><div class="line"></div><div class="line">    scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">    std::vector&lt;double&gt; rhs_values(n_q_points);</div><div class="line"></div><div class="line">    right_hand_side.value_list(scratch_data.fe_values.get_quadrature_points(),</div><div class="line">                               rhs_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> delta = (settings.with_streamline_diffusion ?</div><div class="line">                            compute_stabilization_delta(cell-&gt;diameter(),</div><div class="line">                                                        settings.epsilon,</div><div class="line">                                                        advection_direction,</div><div class="line">                                                        settings.fe_degree) :</div><div class="line">                            0.0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                (settings.epsilon *</div><div class="line">                 scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">                 scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">                 scratch_data.fe_values.JxW(q_point)) +</div><div class="line">                (scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">                 (advection_direction *</div><div class="line">                  scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">                 scratch_data.fe_values.JxW(q_point))</div><div class="line">                + delta *</div><div class="line">                    (advection_direction *</div><div class="line">                     scratch_data.fe_values.shape_grad(j, q_point)) *</div><div class="line">                    (advection_direction *</div><div class="line">                     scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">                    scratch_data.fe_values.JxW(q_point) -</div><div class="line">                delta * settings.epsilon *</div><div class="line">                  <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(scratch_data.fe_values.shape_hessian(j, q_point)) *</div><div class="line">                  (advection_direction *</div><div class="line">                   scratch_data.fe_values.shape_grad(i, q_point)) *</div><div class="line">                  scratch_data.fe_values.JxW(q_point);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_level_cell() == <span class="keyword">false</span>)</div><div class="line">            {</div><div class="line">              copy_data.cell_rhs(i) +=</div><div class="line">                scratch_data.fe_values.shape_value(i, q_point) *</div><div class="line">                  rhs_values[q_point] * scratch_data.fe_values.JxW(q_point)</div><div class="line">                + delta * rhs_values[q_point] * advection_direction *</div><div class="line">                    scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">                    scratch_data.fe_values.JxW(q_point);</div><div class="line">            }</div><div class="line">        }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system_and_multigrid()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_active =</div><div class="line">      [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()) &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                          scratch_data,</div><div class="line">          CopyData &amp;                                  copy_data) {</div><div class="line">        this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier_active = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      constraints.distribute_local_to_global(copy_data.cell_matrix,</div><div class="line">                                             copy_data.cell_rhs,</div><div class="line">                                             copy_data.local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker_active,</div><div class="line">                          copier_active,</div><div class="line">                          ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line"></div><div class="line">    std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_level_dof_indices;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(</div><div class="line">          dof_handler, level, locally_owned_level_dof_indices);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(locally_owned_level_dof_indices);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker_mg =</div><div class="line">      [&amp;](<span class="keyword">const</span> decltype(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>()) &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                      scratch_data,</div><div class="line">          CopyData &amp;                              copy_data) {</div><div class="line">        this-&gt;assemble_cell(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier_mg = [&amp;](<span class="keyword">const</span> CopyData &amp;copy_data) {</div><div class="line">      boundary_constraints[copy_data.level].distribute_local_to_global(</div><div class="line">        copy_data.cell_matrix,</div><div class="line">        copy_data.local_dof_indices,</div><div class="line">        mg_matrices[copy_data.level]);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">                copy_data.level,</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j]))</div><div class="line">            {</div><div class="line">              mg_interface_out[copy_data.level].add(</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j],</div><div class="line">                copy_data.cell_matrix(i, j));</div><div class="line">              mg_interface_in[copy_data.level].add(</div><div class="line">                copy_data.local_dof_indices[i],</div><div class="line">                copy_data.local_dof_indices[j],</div><div class="line">                copy_data.cell_matrix(j, i));</div><div class="line">            }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                          cell_worker_mg,</div><div class="line">                          copier_mg,</div><div class="line">                          ScratchData&lt;dim&gt;(fe, fe.degree + 1),</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_smoother()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;SOR&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> smoother =</div><div class="line">          std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                  Smoother,</div><div class="line">                                                  Vector&lt;double&gt;&gt;&gt;();</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                             Smoother::AdditionalData(fe.degree == 1 ? 1.0 :</div><div class="line">                                                                       0.62));</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">        mg_smoother = std::move(smoother);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionJacobi.html">PreconditionJacobi&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">        <span class="keyword">auto</span> smoother =</div><div class="line">          std::make_unique&lt;MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                  Smoother,</div><div class="line">                                                  Vector&lt;double&gt;&gt;&gt;();</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices,</div><div class="line">                             Smoother::AdditionalData(fe.degree == 1 ? 0.6667 :</div><div class="line">                                                                       0.47));</div><div class="line">        smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">        mg_smoother = std::move(smoother);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ||</div><div class="line">             settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">      {</div><div class="line">        smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() - 1);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceDoFTools.html#a43ee44769769065bc594d1730477a4b9">DoFTools::make_cell_patches</a>(smoother_data[level].block_list,</div><div class="line">                                        dof_handler,</div><div class="line">                                        level);</div><div class="line"></div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].relaxation =</div><div class="line">              (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span> ? 1.0 : 0.25);</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].inversion = <a class="code" href="classPreconditionBlockBase.html">PreconditionBlockBase&lt;double&gt;::svd</a>;</div><div class="line"></div><div class="line">            std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">            <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                    advection_direction,</div><div class="line">                                                    level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_downstream_cell_ordering(dof_handler,</div><div class="line">                                                    -1.0 * advection_direction,</div><div class="line">                                                    level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">                  ordered_indices =</div><div class="line">                    create_random_cell_ordering(dof_handler, level);</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">default</span>:</div><div class="line">                  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].order =</div><div class="line">              std::vector&lt;std::vector&lt;unsigned int&gt;&gt;(1, ordered_indices);</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block SOR&quot;</span>)</div><div class="line">          {</div><div class="line">            <span class="keyword">auto</span> smoother = std::make_unique&lt;<a class="code" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a>&lt;</div><div class="line">              SparseMatrix&lt;double&gt;,</div><div class="line">              RelaxationBlockSOR&lt;SparseMatrix&lt;double&gt;, double, Vector&lt;double&gt;&gt;,</div><div class="line">              Vector&lt;double&gt;&gt;&gt;();</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">            mg_smoother = std::move(smoother);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (settings.smoother_type == <span class="stringliteral">&quot;block Jacobi&quot;</span>)</div><div class="line">          {</div><div class="line">            <span class="keyword">auto</span> smoother = std::make_unique&lt;</div><div class="line">              MGSmootherPrecondition&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                     RelaxationBlockJacobi&lt;SparseMatrix&lt;double&gt;,</div><div class="line">                                                           double,</div><div class="line">                                                           Vector&lt;double&gt;&gt;,</div><div class="line">                                     Vector&lt;double&gt;&gt;&gt;();</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmootherPrecondition.html#a3cb789b815bf6719eee79e2137c9bd84">initialize</a>(mg_matrices, smoother_data);</div><div class="line">            smoother-&gt;<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(settings.smoothing_steps);</div><div class="line">            mg_smoother = std::move(smoother);</div><div class="line">          }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_iters       = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       solve_tolerance = 1e-8 * system_rhs.l2_norm();</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>      solver_control(max_iters, solve_tolerance, <span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">    solver_control.<a class="code" href="classSolverControl.html#a6d99741765243ccb65da4ff66558cf41">enable_history_data</a>();</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Transfer = MGTransferPrebuilt&lt;Vector&lt;double&gt;&gt;;</div><div class="line">    Transfer mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    setup_smoother();</div><div class="line"></div><div class="line">    mg_matrix.initialize(mg_matrices);</div><div class="line">    mg_interface_matrix_in.initialize(mg_interface_in);</div><div class="line">    mg_interface_matrix_out.initialize(mg_interface_out);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, *mg_smoother, *mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_matrix_out, mg_interface_matrix_in);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, Transfer&gt; preconditioner(dof_handler,</div><div class="line">                                                                 <a class="code" href="namespacemg.html">mg</a>,</div><div class="line">                                                                 mg_transfer);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;     Solving with GMRES to tol &quot;</span> &lt;&lt; solve_tolerance &lt;&lt; <span class="stringliteral">&quot;...&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;Vector&lt;double&gt;</a>&gt; solver(</div><div class="line">      solver_control, <a class="code" href="classSolverGMRES.html">SolverGMRES</a>&lt;Vector&lt;double&gt;&gt;::AdditionalData(50, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> time;</div><div class="line">    time.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    time.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;          converged in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations&quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; in &quot;</span> &lt;&lt; time.<a class="code" href="classTimer.html#aba22973498b0e4c2b4d64bf799e95ba8">last_wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; seconds &quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line"></div><div class="line">    mg_smoother.release();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_active_cells = triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>();</div><div class="line">    Vector&lt;double&gt;     cell_indices(n_active_cells);</div><div class="line">    {</div><div class="line">      std::vector&lt;unsigned int&gt; ordered_indices;</div><div class="line">      <span class="keywordflow">switch</span> (settings.dof_renumbering)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">Settings::DoFRenumberingStrategy::downstream</a>:</div><div class="line">            ordered_indices =</div><div class="line">              create_downstream_cell_ordering(dof_handler, advection_direction);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> Settings::DoFRenumberingStrategy::upstream:</div><div class="line">            ordered_indices =</div><div class="line">              create_downstream_cell_ordering(dof_handler,</div><div class="line">                                              -1.0 * advection_direction);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">Settings::DoFRenumberingStrategy::random</a>:</div><div class="line">            ordered_indices = create_random_cell_ordering(dof_handler);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aa6f1f99c613aeb81b8d8e598b5567ce1">Settings::DoFRenumberingStrategy::none</a>:</div><div class="line">            ordered_indices.resize(n_active_cells);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">              ordered_indices[i] = i;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">n_active_cells</a>; ++i)</div><div class="line">        cell_indices(ordered_indices[i]) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(cell_indices, <span class="stringliteral">&quot;cell_index&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename.c_str());</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; (settings.fe_degree == 1 ? 7 : 5);</div><div class="line">         ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation,</div><div class="line">                                                            0.3,</div><div class="line">                                                            1.0);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0));</div><div class="line">            triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, manifold_description);</div><div class="line">          }</div><div class="line"></div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>();</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;     Number of degrees of freedom: &quot;</span></div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system_and_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (settings.output)</div><div class="line">          output_results(cycle);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step63</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0">Step63::Settings</a> settings;</div><div class="line">      settings.get_parameters((argc &gt; 1) ? (argv[1]) : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">      Step63::AdvectionProblem&lt;2&gt; advection_problem_2d(settings);</div><div class="line">      advection_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> </em></p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
