<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_66.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-66 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-66 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a>, <a class="el" href="step_37.html">step-37</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemformulation">Problem formulation</a>
        <li><a href="#Discretizationwithfiniteelements">Discretization with finite elements</a>
        <li><a href="#Numericallinearalgebra">Numerical linear algebra</a>
        <li><a href="#Triangulation">Triangulation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#MatrixfreeJacobianOperator">Matrix-free JacobianOperator</a>
      <ul>
        <li><a href="#EvaluationoftheoldNewtonstep">Evaluation of the old Newton step</a>
        <li><a href="#Nonlinearmatrixfreeoperatorapplication">Nonlinear matrix-free operator application</a>
        <li><a href="#DiagonaloftheJacobianOperator">Diagonal of the JacobianOperator</a>
      </ul>
        <li><a href="#GelfandProblemclass">GelfandProblem class</a>
      <ul>
        <li><a href="#GelfandProblemmake_grid">GelfandProblem::make_grid</a>
        <li><a href="#GelfandProblemsetup_system">GelfandProblem::setup_system</a>
        <li><a href="#GelfandProblemevaluate_residual">GelfandProblem::evaluate_residual</a>
        <li><a href="#GelfandProblemlocal_evaluate_residual">GelfandProblem::local_evaluate_residual</a>
        <li><a href="#GelfandProblemassemble_rhs">GelfandProblem::assemble_rhs</a>
        <li><a href="#GelfandProblemcompute_residual">GelfandProblem::compute_residual</a>
        <li><a href="#GelfandProblemcompute_update">GelfandProblem::compute_update</a>
        <li><a href="#GelfandProblemsolve">GelfandProblem::solve</a>
        <li><a href="#GelfandProblemcompute_solution_norm">GelfandProblem::compute_solution_norm</a>
        <li><a href="#GelfandProblemoutput_results">GelfandProblem::output_results</a>
        <li><a href="#GelfandProblemrun">GelfandProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
        <li><a href="#Newtonsolver">Newton solver</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#MoresophisticatedNewtoniteration">More sophisticated Newton iteration</a>
        <li><a href="#Parallelscalabilityandthreadparallelism">Parallel scalability and thread parallelism</a>
        <li><a href="#Comparisontomatrixbasedmethods">Comparison to matrix-based methods</a>
        <li><a href="#Eigenvalueproblem">Eigenvalue problem</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Fabian Castelli.</em></p>
<p><em>A version of this code was presented and discussed in <b>[castelli2021numerical]</b> G.F. Castelli: Numerical Investigation of Cahn-Hilliard-Type Phase-Field Models for Battery Active <a class="el" href="namespaceParticles.html">Particles</a>, PhD thesis, Karlsruhe Institute of Technology (KIT), 2021. (To be published)</em></p>
<p><em>Fabian Castelli acknowledges financial support by the German Research Foundation (DFG) through the Research Training Group 2218 SiMET &ndash; Simulation of mechano-electro-thermal processes in lithium-ion batteries, project number 281041241.</em></p>
<p><em>Finally Fabian Castelli would like to thank Timo Heister for the encouragement and advice in writing this tutorial. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The aim of this tutorial program is to demonstrate how to solve a nonlinear problem using Newton's method within the matrix-free framework. This tutorial combines several techniques already introduced in <a class="el" href="step_15.html">step-15</a>, <a class="el" href="step_16.html">step-16</a>, <a class="el" href="step_37.html">step-37</a>, <a class="el" href="step_48.html">step-48</a> and others.</p>
<p><a class="anchor" id="Problemformulation"></a></p><h3>Problem formulation</h3>
<p>On the unit circle \(\Omega = \bigl\{ x \in \mathbb{R}^2 : \|x\| \leq 1 \bigr\}\) we consider the following nonlinear elliptic boundary value problem subject to a homogeneous Dirichlet boundary condition: Find a function \(u\colon\Omega\to\mathbb{R}\) such that it holds: </p><p class="formulaDsp">
\begin{align*} - \Delta u &amp;= \exp(u) &amp; \quad &amp; \text{in } \Omega,\\ u &amp;= 0 &amp; \quad &amp; \text{on } \partial\Omega. \end{align*}
</p>
<p> This problem is also called the <em>Gelfand problem</em> and is a typical example for problems from combustion theory, see for example <b>[bebernes1989mathematical]</b>.</p>
<p><a class="anchor" id="Discretizationwithfiniteelements"></a></p><h3>Discretization with finite elements</h3>
<p>As usual, we first derive the weak formulation for this problem by multiplying with a smooth test function \(v\colon\Omega\to\mathbb{R}\) respecting the boundary condition and integrating over the domain \(\Omega\). Integration by parts and putting the term from the right hand side to the left yields the weak formulation: Find a function \(u\colon\Omega\to\mathbb{R}\) such that for all test functions \(v\) it holds: </p><p class="formulaDsp">
\begin{align*} \int_\Omega \nabla v \cdot \nabla u \,\mathrm{d}x - \int_\Omega v \exp(u) \,\mathrm{d}x = 0. \end{align*}
</p>
<p>Choosing the Lagrangian finite element space \(V_h \dealcoloneq \bigl\{ v \in C(\overline{\Omega}) : v|_Q \in \mathbb{Q}_p \text{ for all } Q \in \mathcal{T}_h \bigr\} \cap H_0^1(\Omega)\), which directly incorporates the homogeneous Dirichlet boundary condition, we can define a basis \(\{\varphi_i\}_{i=1,\dots,N}\) and thus it suffices to test only with those basis functions. So the discrete problem reads as follows: Find \(u_h\in V_h\) such that for all \(i=1,\dots,N\) it holds: </p><p class="formulaDsp">
\begin{align*} F(u_h) \dealcoloneq \int_\Omega \nabla \varphi_i \cdot \nabla u_h \,\mathrm{d}x - \int_\Omega \varphi_i \exp(u_h) \,\mathrm{d}x \stackrel{!}{=} 0. \end{align*}
</p>
<p> As each finite element function is a linear combination of the basis functions \(\{\varphi_i\}_{i=1,\dots,N}\), we can identify the finite element solution by a vector from \(\mathbb{R}^N\) consisting of the unknown values in each degree of freedom (DOF). Thus, we define the nonlinear function \(F\colon\mathbb{R}^N\to\mathbb{R}^N\) representing the discrete nonlinear problem.</p>
<p>To solve this nonlinear problem we use Newton's method. So given an initial guess \(u_h^0\in V_h\), which already fulfills the Dirichlet boundary condition, we determine a sequence of Newton steps \(\bigl( u_h^n \bigr)_n\) by successively applying the following scheme: </p><p class="formulaDsp">
\begin{align*} &amp;\text{Solve for } s_h^n\in V_h: \quad &amp; F&#39;(u_h^n)[s_h^n] &amp;= -F(u_h^n),\\ &amp;\text{Update: } &amp; u_h^{n+1} &amp;= u_h^n + s_h^n. \end{align*}
</p>
<p> So in each Newton step we have to solve a linear problem \(A\,x = b\), where the system matrix \(A\) is represented by the Jacobian \(F&#39;(u_h^n)[\,\cdot\,]\colon\mathbb{R}^N\to\mathbb{R}^N\) and the right hand side \(b\) by the negative residual \(-F(u_h^n)\). The solution vector \(x\) is in that case the Newton update of the \(n\)-th Newton step. Note, that we assume an initial guess \(u_h^0\), which already fulfills the Dirichlet boundary conditions of the problem formulation (in fact this could also be an inhomogeneous Dirichlet boundary condition) and thus the Newton updates \(s_h\) satisfy a homogeneous Dirichlet condition.</p>
<p>Until now we only tested with the basis functions, however, we can also represent any function of \(V_h\) as linear combination of basis functions. More mathematically this means, that every element of \(V_h\) can be identified with a vector \(U\in\mathbb{R}^N\) via the representation formula: \(u_h = \sum_{i=1}^N U_i \varphi_i\). So using this we can give an expression for the discrete Jacobian and the residual: </p><p class="formulaDsp">
\begin{align*} A_{i,j} = \bigl( F&#39;(u_h^n) \bigr)_{i,j} &amp;= \int_\Omega \nabla\varphi_i \cdot \nabla \varphi_j \,\mathrm{d} x - \int_\Omega \varphi_i \, \exp( u_h ) \varphi_j \,\mathrm{d} x,\\ b_{i} = \bigl( F(u_h^n) \bigr)_{i} &amp;= \int_\Omega \nabla\varphi_i \cdot \nabla u_h^n \,\mathrm{d} x - \int_\Omega \varphi_i \, \exp( u_h^n ) \,\mathrm{d} x. \end{align*}
</p>
<p> Compared to <a class="el" href="step_15.html">step-15</a> we could also have formed the Frech{\'e}t derivative of the nonlinear function corresponding to the strong formulation of the problem and discretized it afterwards. However, in the end we would get the same set of discrete equations.</p>
<p><a class="anchor" id="Numericallinearalgebra"></a></p><h3>Numerical linear algebra</h3>
<p>Note, how the system matrix, actually the Jacobian, depends on the previous Newton step \(A = F&#39;(u^n)\). Hence we need to tell the function that computes the system matrix about the solution at the last Newton step. In an implementation with a classical <code>assemble_system()</code> function we would gather this information from the last Newton step during assembly by the use of the member functions <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> and <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValuesBase::get_function_gradients()</a>. The <code>assemble_system()</code> function would then looks like: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;                       cell_rhs(dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; newton_step_gradients(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         newton_step_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0.0;</div><div class="line">      cell_rhs    = 0.0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, newton_step_values);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(solution, newton_step_gradients);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> nonlinearity = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(newton_step_values[q]);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1af54db6e70b60a249b36f803d0657b39e">dx</a>           = fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i      = fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i = fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_j      = fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q);</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_j = fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q);</div><div class="line"></div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (grad_phi_i * grad_phi_j - phi_i * nonlinearity * phi_j) *</div><div class="line">                    dx;</div><div class="line">                }</div><div class="line"></div><div class="line">              cell_rhs(i) += (-grad_phi_i * newton_step_gradients[q] +</div><div class="line">                              phi_i * newton_step_values[q]) *</div><div class="line">                             dx;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Since we want to solve this problem without storing a matrix, we need to tell the matrix-free operator this information before we use it. Therefore in the derived class <code>JacobianOperator</code> we will implement a function called <code>evaluate_newton_step</code>, which will process the information of the last Newton step prior to the usage of the matrix-vector implementation. Furthermore we want to use a geometric multigrid (GMG) preconditioner for the linear solver, so in order to apply the multilevel operators we need to pass the last Newton step also to these operators. This is kind of a tricky task, since the vector containing the last Newton step has to be interpolated to all levels of the triangulation. In the code this task will be done by the function <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>. Note, a fundamental difference to the previous cases, where we set up and used a geometric multigrid preconditioner, is the fact, that we can reuse the <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> object for the computation of all Newton steps. So we can save some work here by defining a class variable and using an already set up <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> object <code>mg_transfer</code> that was initialized in the <code>setup_system()</code> function. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div><div class="line"></div><div class="line">  solution.update_ghost_values();</div><div class="line"></div><div class="line">  system_matrix.evaluate_newton_step(solution);</div><div class="line"></div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Set up options for the multilevel preconditioner</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// Define the actual preconditioner</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line">  <span class="comment">// Solve the linear system</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>The function evaluating the nonlinearity works basically in the same way as the function <code>evaluate_coefficient</code> from <a class="el" href="step_37.html">step-37</a> evaluating a coefficient function. The idea is to use an <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object to evaluate the Newton step and store the expression in a table for all cells and all quadrature points: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;n_cell_batches();</div><div class="line"></div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line">  nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values_plain(newton_step);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Triangulation"></a></p><h3><a class="el" href="classTriangulation.html">Triangulation</a></h3>
<p>As said in <a class="el" href="step_37.html">step-37</a> the matrix-free method gets more efficient if we choose a higher order finite element space. Since we want to solve the problem on the \(d\)-dimensional unit ball, it would be good to have an appropriate boundary approximation to overcome convergence issues. For this reason we use an isoparametric approach with the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> class to recover the smooth boundary as well as the mapping for inner cells. In addition, to get a good triangulation in total we make use of the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First we include the typical headers of the deal.II library needed for this tutorial:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vectorization_8h.html">deal.II/base/vectorization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__accessor_8h.html">deal.II/grid/tria_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__iterator_8h.html">deal.II/grid/tria_iterator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>In particular, we need to include the headers for the matrix-free framework:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tools_8h.html">deal.II/matrix_free/tools.h</a>&gt;</span></div></div><!-- fragment --><p>And since we want to use a geometric multigrid preconditioner, we need also the multilevel headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div></div><!-- fragment --><p>Finally some common C++ headers for in and output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step66</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="MatrixfreeJacobianOperator"></a> </p><h3>Matrix-free JacobianOperator</h3>
<p>In the beginning we define the matrix-free operator for the Jacobian. As a guideline we follow the tutorials <a class="el" href="step_37.html">step-37</a> and <a class="el" href="step_48.html">step-48</a>, where the precise interface of the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class was extensively documented.</p>
<p>Since we want to use the Jacobian as system matrix and pass it to the linear solver as well as to the multilevel preconditioner classes, we derive the <code>JacobianOperator</code> class from the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class, such that we have already the right interface. The two functions we need to override from the base class are the <a class="el" href="classMatrixFreeOperators_1_1Base.html#abc81493aad390198580330cc99203b3c">MatrixFreeOperators::Base::apply_add()</a> and the <a class="el" href="classMatrixFreeOperators_1_1Base.html#a16d883c49c69eef468b39b2e991d8b0d">MatrixFreeOperators::Base::compute_diagonal()</a> function. To allow preconditioning with float precision we define the number type as template argument.</p>
<p>As mentioned already in the introduction, we need to evaluate the Jacobian \(F&#39;\) at the last Newton step \(u_h^n\) for the computation of the Newton update \(s_h^n\). To get the information of the last Newton step \(u_h^n\) we do pretty much the same as in <a class="el" href="step_37.html">step-37</a>, where we stored the values of a coefficient function in a table <code>nonlinear_values</code> once before we use the matrix-free operator. Instead of a function <code>evaluate_coefficient()</code>, we here implement a function <code>evaluate_newton_step()</code>.</p>
<p>As additional private member functions of the <code>JacobianOperator</code> we implement the <code>local_apply()</code> and the <code>local_compute_diagonal()</code> function. The first one is the actual worker function for the matrix-vector application, which we pass to the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> in the <code>apply_add()</code> function. The later one is the worker function to compute the diagonal, which we pass to the <a class="el" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal()</a> function.</p>
<p>For better readability of the source code we further define an alias for the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keyword">class </span>JacobianOperator</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">      Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> FECellIntegrator =</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a>;</div><div class="line"></div><div class="line">  JacobianOperator();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_newton_step(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">              <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">              <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_compute_diagonal(FECellIntegrator &amp;integrator) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; nonlinear_values;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the <code>JacobianOperator</code> just calls the constructor of the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, which is itself derived from the <a class="el" href="classSubscriptor.html">Subscriptor</a> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">JacobianOperator&lt;dim, fe_degree, number&gt;::JacobianOperator()</div><div class="line">  : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                              <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="classVector.html">Vector</a>&lt;number&gt;&gt;()</div><div class="line">{}</div></div><!-- fragment --><p>The <code>clear()</code> function resets the table holding the values for the nonlinearity and call the <code>clear()</code> function of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">{</div><div class="line">  nonlinear_values.reinit(0, 0);</div><div class="line">  <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">    clear();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EvaluationoftheoldNewtonstep"></a> </p><h4>Evaluation of the old Newton step</h4>
<p>The following <code>evaluate_newton_step()</code> function is based on the <code>evaluate_coefficient()</code> function from <a class="el" href="step_37.html">step-37</a>. However, it does not evaluate a function object, but evaluates a vector representing a finite element function, namely the last Newton step needed for the Jacobian. Therefore we set up a <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object and evaluate the finite element function in the quadrature points with the <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> and <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a> functions. We store the evaluated values of the finite element function directly in the <code>nonlinear_values</code> table.</p>
<p>This will work well and in the <code>local_apply()</code> function we can use the values stored in the table to apply the matrix-vector product. However, we can also optimize the implementation of the Jacobian at this stage. We can directly evaluate the nonlinear function <code>std::exp(newton_step[q])</code> and store these values in the table. This skips all evaluations of the nonlinearity in each call of the <code>vmult()</code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;n_cell_batches();</div><div class="line">  FECellIntegrator   phi(*this-&gt;data);</div><div class="line"></div><div class="line">  nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values_plain(newton_step);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Nonlinearmatrixfreeoperatorapplication"></a> </p><h4>Nonlinear matrix-free operator application</h4>
<p>Now in the <code>local_apply()</code> function, which actually implements the cell wise action of the system matrix, we can use the information of the last Newton step stored in the table <code>nonlinear_values</code>. The rest of this function is basically the same as in <a class="el" href="step_37.html">step-37</a>. We set up the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object, gather and evaluate the values and gradients of the input vector <code>src</code>, submit the values and gradients according to the form of the Jacobian and finally call <a class="el" href="classFEEvaluation.html#a491779be7bd032d277e41f1dda8dc584">FEEvaluation::integrate_scatter()</a> to perform the cell integration and distribute the local contributions into the global vector <code> dst</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  FECellIntegrator phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                      phi.get_matrix_free().n_cell_batches());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line"></div><div class="line">      phi.gather_evaluate(src,</div><div class="line">                          <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                            <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">          phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">        }</div><div class="line"></div><div class="line">      phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                            dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next we use <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> to perform the actual loop over all cells computing the cell contribution to the matrix-vector product.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;JacobianOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DiagonaloftheJacobianOperator"></a> </p><h4>Diagonal of the JacobianOperator</h4>
<p>The internal worker function <code>local_compute_diagonal()</code> for the computation of the diagonal is similar to the above worker function <code>local_apply()</code>. However, as major difference we do not read values from a input vector or distribute any local results to an output vector. Instead the only input argument is the used <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">  FECellIntegrator &amp;phi)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                  phi.get_matrix_free().n_cell_batches());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = phi.get_current_cell_index();</div><div class="line"></div><div class="line">  phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">    {</div><div class="line">      phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">      phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">    }</div><div class="line"></div><div class="line">  phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">}</div></div><!-- fragment --><p>Finally we override the <a class="el" href="classMatrixFreeOperators_1_1Base.html#a16d883c49c69eef468b39b2e991d8b0d">MatrixFreeOperators::Base::compute_diagonal()</a> function of the base class of the <code>JacobianOperator</code>. Although the name of the function suggests just the computation of the diagonal, this function does a bit more. Because we only really need the inverse of the matrix diagonal elements for the Chebyshev smoother of the multigrid preconditioner, we compute the diagonal and store the inverse elements. Therefore we first initialize the <code>inverse_diagonal_entries</code>. Then we compute the diagonal by passing the worker function <code>local_compute_diagonal()</code> to the <a class="el" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal()</a> function. In the end we loop over the diagonal and invert the elements by hand. Note, that during this loop we catch the constrained DOFs and set them manually to one.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">JacobianOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">{</div><div class="line">  this-&gt;inverse_diagonal_entries.reset(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">    this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal</a>(*this-&gt;data,</div><div class="line">                                    inverse_diagonal,</div><div class="line">                                    &amp;JacobianOperator::local_compute_diagonal,</div><div class="line">                                    <span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;diagonal_element : inverse_diagonal)</div><div class="line">    {</div><div class="line">      diagonal_element = (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(diagonal_element) &gt; 1.0e-10) ?</div><div class="line">                           (1.0 / diagonal_element) :</div><div class="line">                           1.0;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemclass"></a> </p><h3>GelfandProblem class</h3>
<p>After implementing the matrix-free operators we can now define the solver class for the <em>Gelfand problem</em>. This class is based on the common structure of all previous tutorial programs, in particular it is based on <a class="el" href="step_15.html">step-15</a>, solving also a nonlinear problem. Since we are using the matrix-free framework, we no longer need an assemble_system function any more, instead the information of the matrix is rebuilt in every call of the <code>vmult()</code> function. However, for the application of the Newton scheme we need to assemble the right hand side of the linearized problems and compute the residuals. Therefore, we implement an additional function <code>evaluate_residual()</code>, which we later call in the <code>assemble_rhs()</code> and the <code>compute_residual()</code> function. Finally, the typical <code>solve()</code> function here implements the Newton method, whereas the solution of the linearized system is computed in the function <code>compute_update()</code>. As the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework handles the polynomial degree of the Lagrangian finite element method as a template parameter, we declare it also as a template parameter for the problem solver class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>GelfandProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  GelfandProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_residual(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_evaluate_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> compute_update();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_solution_norm() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div></div><!-- fragment --><p>For the parallel computation we define a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. As the computational domain is a circle in 2D and a ball in 3D, we assign in addition to the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> for boundary cells a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> object for the mapping of the inner cells, which takes care of the inner cells. In this example we use an isoparametric finite element approach and thus use the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> class. Note, that we could also create an instance of the <a class="el" href="classMappingQ.html">MappingQ</a> class and set the <code>use_mapping_q_on_all_cells</code> flags in the contructor call to <code>true</code>. For further details on the connection of <a class="el" href="classMappingQ.html">MappingQ</a> and <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> you may read the detailed description of these classes.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>                mapping;</div></div><!-- fragment --><p>As usual we then define the Lagrangian finite elements <a class="el" href="classFE__Q.html">FE_Q</a> and a <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div></div><!-- fragment --><p>For the linearized discrete system we define an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects and the <code>system_matrix</code>, which is in this example represented as a matrix-free operator.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"><span class="keyword">using</span> SystemMatrixType = JacobianOperator&lt;dim, fe_degree, double&gt;;</div><div class="line">SystemMatrixType system_matrix;</div></div><!-- fragment --><p>The multilevel object is also based on the matrix-free operator for the Jacobian. Since we need to evaluate the Jacobian with the last Newton step, we also need to evaluate the level operator with the last Newton step for the preconditioner. Thus in addition to <code>mg_matrices</code>, we also need a <a class="el" href="classMGLevelObject.html">MGLevelObject</a> to store the interpolated solution vector on each level. As in <a class="el" href="step_37.html">step-37</a> we use float precision for the preconditioner. Moreover, we define the <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> object as a class variable, since we need to set it up only once when the triangulation has changed and can then use it again in each Newton step.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"><span class="keyword">using</span> LevelMatrixType = JacobianOperator&lt;dim, fe_degree, float&gt;;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a>                           mg_matrices;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_solution;</div><div class="line"><a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>                         mg_transfer;</div></div><!-- fragment --><p>Of course we also need vectors holding the <code>solution</code>, the <code>newton_update</code> and the <code>system_rhs</code>. In that way we can always store the last Newton step in the solution vector and just add the update to get the next Newton step.</p>
<div class="fragment"><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> newton_update;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div></div><!-- fragment --><p>Finally we have a variable for the number of iterations of the linear solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linear_iterations;</div></div><!-- fragment --><p>For the output in programs running in parallel with MPI, we use the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> class to avoid multiple output of the same data by different MPI ranks.</p>
<div class="fragment"><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div></div><!-- fragment --><p>Finally for the time measurement we use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object, which prints the elapsed CPU and wall times for each function in a nicely formatted table after the program has finished.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the <code>GelfandProblem</code> initializes the class variables. In particular, we set up the multilevel support for the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, set the mapping degree equal to the finite element degree, initialize the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and tell the <a class="el" href="classTimerOutput.html">TimerOutput</a> that we want to see the wall times only on demand.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">GelfandProblem&lt;dim, fe_degree&gt;::GelfandProblem()</div><div class="line">  : triangulation(MPI_COMM_WORLD,</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">                  <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;</div><div class="line">                    dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">  , mapping(fe_degree)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">  , computing_timer(MPI_COMM_WORLD,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemmake_grid"></a> </p><h4>GelfandProblem::make_grid</h4>
<p>As the computational domain we use the <code>dim</code>-dimensional unit ball. We follow the instructions for the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class and also assign a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> for the boundary. Finally, we refine the initial mesh 3 - <code>dim</code> times globally.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;make grid&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>                boundary_manifold;</div><div class="line">  <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> inner_manifold;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(1);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, boundary_manifold);</div><div class="line"></div><div class="line">  inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, inner_manifold);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemsetup_system"></a> </p><h4>GelfandProblem::setup_system</h4>
<p>The <code>setup_system()</code> function is quasi identical to the one in <a class="el" href="step_37.html">step-37</a>. The only differences are obviously the time measurement with only one <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> instead of measuring each part individually, and more importantly the initialization of the <a class="el" href="classMGLevelObject.html">MGLevelObject</a> for the interpolated solution vector of the previous Newton step. Another important change is the setup of the <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> object, which we can reuse in each Newton step as the <code>triangulation</code> will not be not changed.</p>
<p>Note how we can use the same <a class="el" href="classMatrixFree.html">MatrixFree</a> object twice, for the <code>JacobianOperator</code> and the multigrid preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup system&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  mg_matrices.clear_elements();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">      <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::partition_color</a>;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <span class="keyword">auto</span> system_mf_storage = std::make_shared&lt;MatrixFree&lt;dim, double&gt;&gt;();</div><div class="line">    system_mf_storage-&gt;reinit(mapping,</div><div class="line">                              dof_handler,</div><div class="line">                              constraints,</div><div class="line">                              <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                              additional_data);</div><div class="line"></div><div class="line">    system_matrix.initialize(system_mf_storage);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(solution);</div><div class="line">  system_matrix.initialize_dof_vector(newton_update);</div><div class="line">  system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">  mg_matrices.resize(0, nlevels - 1);</div><div class="line">  mg_solution.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">  dirichlet_boundary.insert(0);</div><div class="line">  mg_constrained_dofs.initialize(dof_handler);</div><div class="line">  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                     dirichlet_boundary);</div><div class="line"></div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a69e2b416ab209936f94db08e865cd92b">initialize_constraints</a>(mg_constrained_dofs);</div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                    level,</div><div class="line">                                                    relevant_dofs);</div><div class="line"></div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">        mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::partition_color</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">      <span class="keyword">auto</span> mg_mf_storage_level = std::make_shared&lt;MatrixFree&lt;dim, float&gt;&gt;();</div><div class="line">      mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                  dof_handler,</div><div class="line">                                  level_constraints,</div><div class="line">                                  <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                  additional_data);</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                    mg_constrained_dofs,</div><div class="line">                                    level);</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize_dof_vector(mg_solution[level]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemevaluate_residual"></a> </p><h4>GelfandProblem::evaluate_residual</h4>
<p>Next we implement a function which evaluates the nonlinear discrete residual for a given input vector ( \(\texttt{dst} = F(\texttt{src})\)). This function is then used for the assembly of the right hand side of the linearized system and later for the computation of the residual of the next Newton step to check if we already reached the error tolerance. As this function should not affect any class variable we define it as a constant function. Internally we exploit the fast finite element evaluation through the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class and the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>, similar to <code>apply_add()</code> function of the <code>JacobianOperator</code>.</p>
<p>First we create a pointer to the <a class="el" href="classMatrixFree.html">MatrixFree</a> object, which is stored in the <code>system_matrix</code>. Then we pass the worker function <code>local_evaluate_residual()</code> for the cell wise evaluation of the residual together with the input and output vector to the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>. In addition, we enable the zero out of the output vector in the loop, which is more efficient than calling <code>dst = 0.0</code> separately before.</p>
<p>Note that with this approach we do not have to take care about the MPI related data exchange, since all the bookkeeping is done by the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::evaluate_residual(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">auto</span> matrix_free = system_matrix.get_matrix_free();</div><div class="line"></div><div class="line">  matrix_free-&gt;cell_loop(</div><div class="line">    &amp;GelfandProblem::local_evaluate_residual, <span class="keyword">this</span>, dst, src, <span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemlocal_evaluate_residual"></a> </p><h4>GelfandProblem::local_evaluate_residual</h4>
<p>This is the internal worker function for the evaluation of the residual. Essentially it has the same structure as the <code>local_apply()</code> function of the <code>JacobianOperator</code> and evaluates the residual for the input vector <code>src</code> on the given set of cells <code>cell_range</code>. The difference to the above mentioned <code>local_apply()</code> function is, that we split the <a class="el" href="classFEEvaluation.html#ab53d5c08f460cfe6c9830ac14a427115">FEEvaluation::gather_evaluate()</a> function into <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> and <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a>, since the input vector might have constrained DOFs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::local_evaluate_residual(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line"></div><div class="line">      phi.read_dof_values_plain(src);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_value(-std::exp(phi.get_value(q)), q);</div><div class="line">          phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">        }</div><div class="line"></div><div class="line">      phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                            dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemassemble_rhs"></a> </p><h4>GelfandProblem::assemble_rhs</h4>
<p>Using the above function <code>evaluate_residual()</code> to evaluate the nonlinear residual, the assembly of the right hand side of the linearized system becomes now a very easy task. We just call the <code>evaluate_residual()</code> function and multiply the result with minus one.</p>
<p>Experiences show that using the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class is much faster than a classical implementation with <a class="el" href="classFEValues.html">FEValues</a> and co.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assemble right hand side&quot;</span>);</div><div class="line"></div><div class="line">  evaluate_residual(system_rhs, solution);</div><div class="line"></div><div class="line">  system_rhs *= -1.0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_residual"></a> </p><h4>GelfandProblem::compute_residual</h4>
<p>According to <a class="el" href="step_15.html">step-15</a> the following function computes the norm of the nonlinear residual for the solution \(u_h^n + \alpha s_h^n\) with the help of the <code>evaluate_residual()</code> function. The Newton step length \(\alpha\) becomes important if we would use an adaptive version of the Newton method. Then for example we would compute the residual for different step lengths and compare the residuals. However, for our problem the full Newton step with \(\alpha=1\) is the best we can do. An adaptive version of Newton's method becomes interesting if we have no good initial value. Note that in theory Newton's method converges with quadratic order, but only if we have an appropriate initial value. For unsuitable initial values the Newton method diverges even with quadratic order. A common way is then to use a damped version \(\alpha&lt;1\) until the Newton step is good enough and the full Newton step can be performed. This was also discussed in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute residual&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> residual;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> evaluation_point;</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(residual);</div><div class="line">  system_matrix.initialize_dof_vector(evaluation_point);</div><div class="line"></div><div class="line">  evaluation_point = solution;</div><div class="line">  <span class="keywordflow">if</span> (alpha &gt; 1e-12)</div><div class="line">    {</div><div class="line">      evaluation_point.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a>(alpha, newton_update);</div><div class="line">    }</div><div class="line"></div><div class="line">  evaluate_residual(residual, evaluation_point);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_update"></a> </p><h4>GelfandProblem::compute_update</h4>
<p>In order to compute the Newton updates in each Newton step we solve the linear system with the CG algorithm together with a geometric multigrid preconditioner. For this we first set up the <a class="el" href="classPreconditionMG.html">PreconditionMG</a> object with a Chebyshev smoother like we did in <a class="el" href="step_37.html">step-37</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div></div><!-- fragment --><p>We remember that the Jacobian depends on the last Newton step stored in the solution vector. So we update the ghost values of the Newton step and pass it to the <code>JacobianOperator</code> to store the information.</p>
<div class="fragment"><div class="line">solution.update_ghost_values();</div><div class="line"></div><div class="line">system_matrix.evaluate_newton_step(solution);</div></div><!-- fragment --><p>Next we also have to pass the last Newton step to the multilevel operators. Therefore, we need to interpolate the Newton step to all levels of the triangulation. This is done with the <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>.</p>
<div class="fragment"><div class="line">mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div></div><!-- fragment --><p>Now we can set up the preconditioner. We define the smoother and pass the interpolated vectors of the Newton step to the multilevel operators.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> SmootherType =</div><div class="line">  <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                        LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                       LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                     mg_smoother;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">      {</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 4;</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        smoother_data[0].smoothing_range = 1e-3;</div><div class="line">        smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">        smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">      }</div><div class="line"></div><div class="line">    mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line">    mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line"></div><div class="line">    smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">  }</div><div class="line">mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line"><a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">  mg_coarse;</div><div class="line">mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">  mg_matrices);</div><div class="line"></div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">  mg_interface_matrices;</div><div class="line">mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_matrices[level]);</div><div class="line">  }</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">  mg_interface_matrices);</div><div class="line"></div><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">               LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">               <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>Finally we set up the <a class="el" href="classSolverControl.html">SolverControl</a> and the <a class="el" href="classSolverCG.html">SolverCG</a> to solve the linearized problem for the current Newton update. An important fact of the implementation of <a class="el" href="classSolverCG.html">SolverCG</a> or also <a class="el" href="classSolverGMRES.html">SolverGMRES</a> is, that the vector holding the solution of the linear system (here <code>newton_update</code>) can be used to pass a starting value. In order to start the iterative solver always with a zero vector we reset the <code>newton_update</code> explicitly before calling <a class="el" href="classSolverCG.html#aa52469650d9b9ef2f4cb4884caeb0723">SolverCG::solve()</a>. Afterwards we distribute the Dirichlet boundary conditions stored in <code>constraints</code> and store the number of iteration steps for the later output.</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1.e-12);</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">newton_update = 0.0;</div><div class="line"></div><div class="line">cg.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(newton_update);</div><div class="line"></div><div class="line">linear_iterations = solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>();</div></div><!-- fragment --><p>Then for bookkeeping we zero out the ghost values.</p>
<div class="fragment"><div class="line">  solution.zero_out_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemsolve"></a> </p><h4>GelfandProblem::solve</h4>
<p>Now we implement the actual Newton solver for the nonlinear problem.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>);</div></div><!-- fragment --><p>We define a maximal number of Newton steps and tolerances for the convergence criterion. Usually, with good starting values, the Newton method converges in three to six steps, so maximal ten steps should be totally sufficient. As tolerances we use \(\|F(u^n_h)\|&lt;\text{TOL}_f = 10^{-12}\) for the norm of the residual and \(\|s_h^n\| &lt; \text{TOL}_x = 10^{-10}\) for the norm of the Newton update. This seems a bit over the top, but we will see that, for our example, we will achieve these tolerances after a few steps.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> itmax = 10;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       TOLf  = 1e-12;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       TOLx  = 1e-10;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTimer.html">Timer</a> solver_timer;</div><div class="line">solver_timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div></div><!-- fragment --><p>Now we start the actual Newton iteration.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= itmax; ++newton_step)</div><div class="line">  {</div></div><!-- fragment --><p>We assemble the right hand side of the linearized problem and compute the Newton update.</p>
<div class="fragment"><div class="line">assemble_rhs();</div><div class="line">compute_update();</div></div><!-- fragment --><p>Then we compute the errors, namely the norm of the Newton update and the residual. Note that at this point one could incorporate a step size control for the Newton method by varying the input parameter \(\alpha\) for the compute_residual function. However, here we just use \(\alpha\) equal to one for a plain Newton iteration.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> ERRx = newton_update.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> ERRf = compute_residual(1.0);</div></div><!-- fragment --><p>Next we advance the Newton step by adding the Newton update to the current Newton step.</p>
<div class="fragment"><div class="line">solution.add(1.0, newton_update);</div></div><!-- fragment --><p>A short output will inform us on the current Newton step.</p>
<div class="fragment"><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Nstep &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot;, errf = &quot;</span> &lt;&lt; ERRf</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;, errx = &quot;</span> &lt;&lt; ERRx &lt;&lt; <span class="stringliteral">&quot;, it = &quot;</span> &lt;&lt; linear_iterations</div><div class="line">      &lt;&lt; std::endl;</div></div><!-- fragment --><p>After each Newton step we check the convergence criteria. If at least one of those is fulfilled we are done and end the loop. If we haven't found a satisfying solution after the maximal amount of Newton iterations, we inform the user about this shortcoming.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (ERRf &lt; TOLf || ERRx &lt; TOLx)</div><div class="line">        {</div><div class="line">          solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;Convergence step &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; value &quot;</span> &lt;&lt; ERRf</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; (used wall time: &quot;</span> &lt;&lt; solver_timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s)&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == itmax)</div><div class="line">        {</div><div class="line">          solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;WARNING: No convergence of Newton&#39;s method after &quot;</span></div><div class="line">                &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; steps.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_solution_norm"></a> </p><h4>GelfandProblem::compute_solution_norm</h4>
<p>The computation of the H1-seminorm of the solution can be done in the same way as in <a class="el" href="step_59.html">step-59</a>. We update the ghost values and use the function <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. In the end we gather all computations from all MPI ranks and return the norm.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_solution_norm()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  solution.update_ghost_values();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> norm_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                    norm_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">  solution.zero_out_ghost_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                           norm_per_cell,</div><div class="line">                                           <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemoutput_results"></a> </p><h4>GelfandProblem::output_results</h4>
<p>We generate the graphical output files in vtu format together with a pvtu master file at once by calling the <a class="el" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">DataOut::write_vtu_with_pvtu_record()</a> function in the same way as in <a class="el" href="step_37.html">step-37</a>. In addition, as in <a class="el" href="step_40.html">step-40</a>, we query the <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> of each cell and write the distribution of the triangulation among the MPI ranks into the output file. Finally, we generate the patches of the solution by calling <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. However, since we have a computational domain with a curved boundary, we additionally pass the <code>mapping</code> and the finite element degree as number of subdivision. But this is still not enough for the correct representation of the solution, for example in ParaView, because we attached a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to the inner cells, which results in curved cells in the interior. Therefore we pass as third argument the <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ad8379a354d5bd6484471f6bf755cd111">DataOut::curved_inner_cells</a> option, such that also the inner cells use the corresponding manifold description to build the patches.</p>
<p>Note that we could handle the higher order elements with the flag <a class="el" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">DataOutBase::VtkFlags::write_higher_order_cells</a>. However, due to the limited compatibility to previous version of ParaView and the missing support by VisIt, we left this option for a future version.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">GelfandProblem&lt;dim, fe_degree&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1e6)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  solution.update_ghost_values();</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">    {</div><div class="line">      subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">    }</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                         fe.degree,</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <span class="stringliteral">&quot;d&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">  solution.zero_out_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemrun"></a> </p><h4>GelfandProblem::run</h4>
<p>The last missing function of the solver class for the <em>Gelfand problem</em> is the run function. In the beginning we print information about the system specifications and the finite element space we use. The problem is solved several times on a successively refined mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">GelfandProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_ranks =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(double) * n_vect_doubles;</div><div class="line"></div><div class="line">    std::string DAT_header = <span class="stringliteral">&quot;START DATE: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#aff548b3b9b7a035ea112729700ef7c64">Utilities::System::get_date</a>() +</div><div class="line">                             <span class="stringliteral">&quot;, TIME: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">Utilities::System::get_time</a>();</div><div class="line">    std::string MPI_header = <span class="stringliteral">&quot;Running with &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_ranks) +</div><div class="line">                             <span class="stringliteral">&quot; MPI process&quot;</span> + (n_ranks &gt; 1 ? <span class="stringliteral">&quot;es&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    std::string VEC_header =</div><div class="line">      <span class="stringliteral">&quot;Vectorization over &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_doubles) +</div><div class="line">      <span class="stringliteral">&quot; doubles = &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_bits) + <span class="stringliteral">&quot; bits (&quot;</span> +</div><div class="line">      <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() +</div><div class="line">      <span class="stringliteral">&quot;), VECTORIZATION_LEVEL=&quot;</span> +</div><div class="line">      <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="config_8h.html#a32dc208a29f23d1f031fb40b0d21e60e">DEAL_II_COMPILER_VECTORIZATION_LEVEL</a>);</div><div class="line">    std::string SOL_header = <span class="stringliteral">&quot;Finite element space: &quot;</span> + fe.get_name();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; DAT_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; MPI_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; VEC_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; SOL_header &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">    {</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>The first task in actually solving the problem is to generate or refine the triangulation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cycle == 0)</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">  }</div></div><!-- fragment --><p>Now we set up the system and solve the problem. These steps are accompanied by time measurement and textual output.</p>
<div class="fragment"><div class="line"><a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Set up system...&quot;</span> &lt;&lt; std::endl;</div><div class="line">setup_system();</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Triangulation: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot; cells&quot;</span> &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   DoFHandler:    &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; DoFs&quot;</span></div><div class="line">      &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Solve using Newton&#39;s method...&quot;</span> &lt;&lt; std::endl;</div><div class="line">solve();</div><div class="line">pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Time for setup+solve (CPU/Wall) &quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span></div><div class="line">      &lt;&lt; timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s&quot;</span> &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div></div><!-- fragment --><p>After the problem was solved we compute the norm of the solution and generate the graphical output files.</p>
<div class="fragment"><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Output results...&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> norm = compute_solution_norm();</div><div class="line">output_results(cycle);</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;  H1 seminorm: &quot;</span> &lt;&lt; norm &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div></div><!-- fragment --><p>Finally after each cycle we print the timing information.</p>
<div class="fragment"><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step66</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>As typical for programs running in parallel with MPI we set up the MPI framework and disable shared-memory parallelization by limiting the number of threads to one. Finally to run the solver for the <em>Gelfand problem</em> we create an object of the <code>GelfandProblem</code> class and call the run function. Exemplarily we solve the problem once in 2D and once in 3D each with fourth-order Lagrangian finite elements.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step66;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;2, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;3, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The aim of this tutorial step was to demonstrate the solution of a nonlinear PDE with the matrix-free framework.</p>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>Running the program on two processes in release mode via </p><div class="fragment"><div class="line">cmake . &amp;&amp; make release &amp;&amp; make &amp;&amp; mpirun -n 2 ./step-66</div></div><!-- fragment --><p> gives the following output on the console </p><div class="fragment"><div class="line">================================================================================</div><div class="line">START DATE: 2021/5/18, TIME: 16:25:48</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Running with 2 MPI processes</div><div class="line">Vectorization over 4 doubles = 256 bits (AVX), VECTORIZATION_LEVEL=2</div><div class="line">Finite element space: <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>(4)</div><div class="line">================================================================================</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Cycle 0</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Set up system...</div><div class="line">   <a class="code" href="classTriangulation.html">Triangulation</a>: 20 cells</div><div class="line">   <a class="code" href="classDoFHandler.html">DoFHandler</a>:    337 DoFs</div><div class="line"></div><div class="line">Solve <span class="keyword">using</span> Newton<span class="stringliteral">&#39;s method...</span></div><div class="line"><span class="stringliteral">   Nstep 1, errf = 0.00380835, errx = 3.61904, it = 7</span></div><div class="line"><span class="stringliteral">   Nstep 2, errf = 3.80167e-06, errx = 0.104353, it = 6</span></div><div class="line"><span class="stringliteral">   Nstep 3, errf = 3.97939e-12, errx = 0.00010511, it = 4</span></div><div class="line"><span class="stringliteral">   Nstep 4, errf = 2.28859e-13, errx = 1.07726e-10, it = 1</span></div><div class="line"><span class="stringliteral">Convergence step 4 value 2.28859e-13 (used wall time: 0.0096409 s)</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Time for setup+solve (CPU/Wall) 0.015617/0.0156447 s</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Output results...</span></div><div class="line"><span class="stringliteral">  H1 seminorm: 0.773426</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">+---------------------------------------------+------------+------------+</span></div><div class="line"><span class="stringliteral">| Total wallclock time elapsed since start    |    0.0286s |            |</span></div><div class="line"><span class="stringliteral">|                                             |            |            |</span></div><div class="line"><span class="stringliteral">| Section                         | no. calls |  wall time | % of total |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral">| assemble right hand side        |         4 |  9.71e-05s |      0.34% |</span></div><div class="line"><span class="stringliteral">| compute residual                |         4 |  0.000137s |      0.48% |</span></div><div class="line"><span class="stringliteral">| compute update                  |         4 |   0.00901s |        32% |</span></div><div class="line"><span class="stringliteral">| make grid                       |         1 |   0.00954s |        33% |</span></div><div class="line"><span class="stringliteral">| setup system                    |         1 |   0.00585s |        20% |</span></div><div class="line"><span class="stringliteral">| solve                           |         1 |   0.00966s |        34% |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">--------------------------------------------------------------------------------</span></div><div class="line"><span class="stringliteral">Cycle 6</span></div><div class="line"><span class="stringliteral">--------------------------------------------------------------------------------</span></div><div class="line"><span class="stringliteral">Set up system...</span></div><div class="line"><span class="stringliteral">   Triangulation: 81920 cells</span></div><div class="line"><span class="stringliteral">   DoFHandler:    1311745 DoFs</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Solve using Newton&#39;</span>s method...</div><div class="line">   Nstep 1, errf = 5.90478e-05, errx = 231.427, it = 9</div><div class="line">   Nstep 2, errf = 5.89991e-08, errx = 6.67102, it = 6</div><div class="line">   Nstep 3, errf = 4.28813e-13, errx = 0.0067188, it = 4</div><div class="line">Convergence step 3 value 4.28813e-13 (used wall time: 4.82953 s)</div><div class="line"></div><div class="line">Time <span class="keywordflow">for</span> setup+solve (CPU/Wall) 6.25094/6.37174 s</div><div class="line"></div><div class="line">Output results...</div><div class="line">  H1 seminorm: 0.773426</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      9.04s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| <a class="code" href="namespaceinternal.html#a2b3d48efdf7c94da455dc6a3553bab79">assemble</a> right hand side        |         3 |    0.0827s |      0.91% |</div><div class="line">| compute residual                |         3 |    0.0909s |         1% |</div><div class="line">| compute update                  |         3 |      4.65s |        51% |</div><div class="line">| setup system                    |         1 |      1.54s |        17% |</div><div class="line">| solve                           |         1 |      4.83s |        53% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line">================================================================================</div><div class="line">START DATE: 2021/5/18, TIME: 16:26:00</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Running with 2 MPI processes</div><div class="line">Vectorization over 4 doubles = 256 bits (AVX), VECTORIZATION_LEVEL=2</div><div class="line">Finite element space: <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(4)</div><div class="line">================================================================================</div><div class="line"></div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Cycle 5</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Set up system...</div><div class="line">   <a class="code" href="classTriangulation.html">Triangulation</a>: 229376 cells</div><div class="line">   <a class="code" href="classDoFHandler.html">DoFHandler</a>:    14729857 DoFs</div><div class="line"></div><div class="line">Solve <span class="keyword">using</span> Newton<span class="stringliteral">&#39;s method...</span></div><div class="line"><span class="stringliteral">   Nstep 1, errf = 6.30096e-06, errx = 481.74, it = 8</span></div><div class="line"><span class="stringliteral">   Nstep 2, errf = 4.25607e-10, errx = 4.14315, it = 6</span></div><div class="line"><span class="stringliteral">   Nstep 3, errf = 7.29563e-13, errx = 0.000321775, it = 2</span></div><div class="line"><span class="stringliteral">Convergence step 3 value 7.29563e-13 (used wall time: 133.793 s)</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Time for setup+solve (CPU/Wall) 226.809/232.615 s</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Output results...</span></div><div class="line"><span class="stringliteral">  H1 seminorm: 0.588667</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">+---------------------------------------------+------------+------------+</span></div><div class="line"><span class="stringliteral">| Total wallclock time elapsed since start    |       390s |            |</span></div><div class="line"><span class="stringliteral">|                                             |            |            |</span></div><div class="line"><span class="stringliteral">| Section                         | no. calls |  wall time | % of total |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral">| assemble right hand side        |         3 |      2.06s |      0.53% |</span></div><div class="line"><span class="stringliteral">| compute residual                |         3 |      2.46s |      0.63% |</span></div><div class="line"><span class="stringliteral">| compute update                  |         3 |       129s |        33% |</span></div><div class="line"><span class="stringliteral">| setup system                    |         1 |      98.8s |        25% |</span></div><div class="line"><span class="stringliteral">| solve                           |         1 |       134s |        34% |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div></div><!-- fragment --><p>We show the solution for the two- and three-dimensional problem in the following figure.</p>
<div class="twocolumn" style="width: 80%; text-align: center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-66.solution-2d.png" alt="Solution of the two-dimensional Gelfand problem." width="100%"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-66.solution-3d.png" alt="Solution of the three-dimensional Gelfand problem." width="100%"/>
</div>
 </div> </div><p><a class="anchor" id="Newtonsolver"></a></p><h3>Newton solver</h3>
<p>In the program output above we find some interesting information about the Newton iterations. The terminal output in each refinement cycle presents detailed diagnostics of the Newton method, which show first of all the number of Newton steps and for each step the norm of the residual \(\|F(u_h^{n+1})\|\), the norm of the Newton update \(\|s_h^n\|\), and the number of CG iterations <code>it</code>.</p>
<p>We observe that for all cases the Newton method converges in approximately three to four steps, which shows the quadratic convergence of the Newton method with a full step length \(\alpha = 1\). However, be aware that for a badly chosen initial guess \(u_h^0\), the Newton method will also diverge quadratically. Usually if you do not have an appropriate initial guess, you try a few damped Newton steps with a reduced step length \(\alpha &lt; 1\) until the Newton step is again in the quadratic convergence domain. This damping and relaxation of the Newton step length truly requires a more sophisticated implementation of the Newton method, which we designate to you as a possible extension of the tutorial.</p>
<p>Furthermore, we see that the number of CG iterations is approximately constant with successive mesh refinements and an increasing number of DoFs. This is of course due to the geometric multigrid preconditioner and similar to the observations made in other tutorials that use this method, e.g., <a class="el" href="step_16.html">step-16</a> and <a class="el" href="step_37.html">step-37</a>. Just to give an example, in the three-dimensional case after five refinements, we have approximately 14.7 million distributed DoFs with fourth-order Lagrangian finite elements, but the number of CG iterations is still less than ten.</p>
<p>In addition, there is one more very useful optimization that we applied and that should be mentioned here. In the <code>compute_update()</code> function we explicitly reset the vector holding the Newton update before passing it as the output vector to the solver. In that case we use a starting value of zero for the CG method, which is more suitable than the previous Newton update, the actual content of the <code>newton_update</code> before resetting, and thus reduces the number of CG iterations by a few steps.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>A couple of possible extensions are available concerning minor updates fo the present code as well as a deeper numerical investigation of the Gelfand problem.</p>
<p><a class="anchor" id="MoresophisticatedNewtoniteration"></a></p><h4>More sophisticated Newton iteration</h4>
<p>Beside a step size controlled version of the Newton iteration as mentioned already in <a class="el" href="step_15.html">step-15</a>, one could also implement a more flexible stopping criterion for the Newton iteration. For example one could replace the fixed tolerances for the residual <code>TOLf</code> and for the Newton updated <code>TOLx</code> and implement a mixed error control with a given absolute and relative tolerance, such that the Newton iteration exists with success as, e.g., </p><p class="formulaDsp">
\begin{align*} \|F(u_h^{n+1})\| \leq \texttt{RelTol} \|u_h^{n+1}\| + \texttt{AbsTol}. \end{align*}
</p>
<p> For more advanced applications with many nonlinear systems to solve, for example at each time step for a time-dependent problem, it turns out that it is not necessary to set up and assemble the Jacobian anew at every single Newton step or even for each time step. Instead, the existing Jacobian from a previous step can be used for the Newton iteration. The Jacobian is then only rebuilt if, for example, the Newton iteration converges too slowly. Such an idea yields a <a href="https://en.wikipedia.org/wiki/Quasi-Newton_method">quasi-Newton method</a>. Admittedly, when using the matrix-free framework, the assembly of the Jacobian is omitted anyway, but with in this way one can try to optimize the reassembly of the geometric multigrid preconditioner. Remember that each time the solution from the old Newton step must be distributed to all levels and the mutligrid preconditioner must be reinitialized.</p>
<p><a class="anchor" id="Parallelscalabilityandthreadparallelism"></a></p><h4>Parallel scalability and thread parallelism</h4>
<p>In the results section of <a class="el" href="step_37.html">step-37</a> and others, the parallel scalability of the matrix-free framework on a large number of processors has already been demonstrated very impressively. In the nonlinear case we consider here, we note that one of the bottlenecks could become the transfer and evaluation of the matrix-free Jacobi operator and its multistage operators in the previous Newton step, since we need to transfer the old solution at all stages in each step. A first parallel scalability analysis in <b>[castelli2021numerical]</b> shows quite good strong scalability when the problem size is large enough. However, a more detailed analysis needs to be performed for reliable results. Moreover, the problem has been solved only with MPI so far, without using the possibilities of shared memory parallelization with threads. Therefore, for this example, you could try hybrid parallelization with MPI and threads, such as described in <a class="el" href="step_48.html">step-48</a>.</p>
<p><a class="anchor" id="Comparisontomatrixbasedmethods"></a></p><h4>Comparison to matrix-based methods</h4>
<p>Analogously to <a class="el" href="step_50.html">step-50</a> and the mentioned possible extension of <a class="el" href="step_75.html">step-75</a>, you can convince yourself which method is faster.</p>
<p><a class="anchor" id="Eigenvalueproblem"></a></p><h4>Eigenvalue problem</h4>
<p>One can consider the corresponding eigenvalue problem, which is called Bratu problem. For example, if we define a fixed eigenvalue \(\lambda\in[0,6]\), we can compute the corresponding discrete eigenfunction. You will notice that the number of Newton steps will increase with increasing \(\lambda\). To reduce the number of Newton steps you can use the following trick: start from a certain \(\lambda\), compute the eigenfunction, increase \(\lambda=\lambda + \delta_\lambda\), and then use the previous solution as an initial guess for the Newton iteration. In the end you can plot the \(H^1(\Omega)\)-norm over the eigenvalue \(\lambda \mapsto \|u_h\|_{H^1(\Omega)}\). What do you observe for further increasing \(\lambda&gt;7\)?</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Fabian Castelli, Karlsruhe Institute of Technology (KIT)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vectorization_8h.html">deal.II/base/vectorization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__accessor_8h.html">deal.II/grid/tria_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__iterator_8h.html">deal.II/grid/tria_iterator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tools_8h.html">deal.II/matrix_free/tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step66</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keyword">class </span>JacobianOperator</div><div class="line">    : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">        Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> FECellIntegrator =</div><div class="line">      <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a>;</div><div class="line"></div><div class="line">    JacobianOperator();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_newton_step(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">                <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">                <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_compute_diagonal(FECellIntegrator &amp;integrator) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; nonlinear_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  JacobianOperator&lt;dim, fe_degree, number&gt;::JacobianOperator()</div><div class="line">    : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                                <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">Vector</a>&lt;number&gt;&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">  {</div><div class="line">    nonlinear_values.reinit(0, 0);</div><div class="line">    <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">      clear();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">    FECellIntegrator   phi(*this-&gt;data);</div><div class="line"></div><div class="line">    nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        phi.read_dof_values_plain(newton_step);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    FECellIntegrator phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                        phi.get_matrix_free().n_cell_batches());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line"></div><div class="line">        phi.gather_evaluate(src,</div><div class="line">                            <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">            phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">          }</div><div class="line"></div><div class="line">        phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                                <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                              dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;JacobianOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">    FECellIntegrator &amp;phi)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                    phi.get_matrix_free().n_cell_batches());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = phi.get_current_cell_index();</div><div class="line"></div><div class="line">    phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">      {</div><div class="line">        phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">        phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">      }</div><div class="line"></div><div class="line">    phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">JacobianOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">  {</div><div class="line">    this-&gt;inverse_diagonal_entries.reset(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">      this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal</a>(*this-&gt;data,</div><div class="line">                                      inverse_diagonal,</div><div class="line">                                      &amp;JacobianOperator::local_compute_diagonal,</div><div class="line">                                      <span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;diagonal_element : inverse_diagonal)</div><div class="line">      {</div><div class="line">        diagonal_element = (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(diagonal_element) &gt; 1.0e-10) ?</div><div class="line">                             (1.0 / diagonal_element) :</div><div class="line">                             1.0;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keyword">class </span>GelfandProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    GelfandProblem();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_residual(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_evaluate_residual(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">      <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> compute_update();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_solution_norm() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>                mapping;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType = JacobianOperator&lt;dim, fe_degree, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = JacobianOperator&lt;dim, fe_degree, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a>                           mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_solution;</div><div class="line">    <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>                         mg_transfer;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> newton_update;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linear_iterations;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  GelfandProblem&lt;dim, fe_degree&gt;::GelfandProblem()</div><div class="line">    : triangulation(MPI_COMM_WORLD,</div><div class="line">                    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">                    <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;</div><div class="line">                      dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    , mapping(fe_degree)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    , computing_timer(MPI_COMM_WORLD,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;make grid&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>                boundary_manifold;</div><div class="line">    <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> inner_manifold;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(1);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, boundary_manifold);</div><div class="line"></div><div class="line">    inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, inner_manifold);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup system&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    mg_matrices.clear_elements();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::partition_color</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      <span class="keyword">auto</span> system_mf_storage = std::make_shared&lt;MatrixFree&lt;dim, double&gt;&gt;();</div><div class="line">      system_mf_storage-&gt;reinit(mapping,</div><div class="line">                                dof_handler,</div><div class="line">                                constraints,</div><div class="line">                                <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                additional_data);</div><div class="line"></div><div class="line">      system_matrix.initialize(system_mf_storage);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(solution);</div><div class="line">    system_matrix.initialize_dof_vector(newton_update);</div><div class="line">    system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">    mg_matrices.resize(0, nlevels - 1);</div><div class="line">    mg_solution.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">    dirichlet_boundary.insert(0);</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary);</div><div class="line"></div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a69e2b416ab209936f94db08e865cd92b">initialize_constraints</a>(mg_constrained_dofs);</div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      relevant_dofs);</div><div class="line"></div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">        <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">          <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::partition_color</a>;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">          (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">        <span class="keyword">auto</span> mg_mf_storage_level = std::make_shared&lt;MatrixFree&lt;dim, float&gt;&gt;();</div><div class="line">        mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    level_constraints,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                    additional_data);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                      mg_constrained_dofs,</div><div class="line">                                      level);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize_dof_vector(mg_solution[level]);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::evaluate_residual(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">auto</span> matrix_free = system_matrix.get_matrix_free();</div><div class="line"></div><div class="line">    matrix_free-&gt;cell_loop(</div><div class="line">      &amp;GelfandProblem::local_evaluate_residual, <span class="keyword">this</span>, dst, src, <span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::local_evaluate_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line"></div><div class="line">        phi.read_dof_values_plain(src);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            phi.submit_value(-std::exp(phi.get_value(q)), q);</div><div class="line">            phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">          }</div><div class="line"></div><div class="line">        phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                                <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                              dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assemble right hand side&quot;</span>);</div><div class="line"></div><div class="line">    evaluate_residual(system_rhs, solution);</div><div class="line"></div><div class="line">    system_rhs *= -1.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute residual&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> residual;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> evaluation_point;</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(residual);</div><div class="line">    system_matrix.initialize_dof_vector(evaluation_point);</div><div class="line"></div><div class="line">    evaluation_point = solution;</div><div class="line">    <span class="keywordflow">if</span> (alpha &gt; 1e-12)</div><div class="line">      {</div><div class="line">        evaluation_point.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a>(alpha, newton_update);</div><div class="line">      }</div><div class="line"></div><div class="line">    evaluate_residual(residual, evaluation_point);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line"></div><div class="line">    system_matrix.evaluate_newton_step(solution);</div><div class="line"></div><div class="line"></div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                            LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                           LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                         mg_smoother;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">    smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">          {</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 4;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            smoother_data[0].smoothing_range = 1e-3;</div><div class="line">            smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">          }</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line"></div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">      }</div><div class="line">    mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line">    <a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">      mg_coarse;</div><div class="line">    mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">      mg_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">      mg_interface_matrices;</div><div class="line">    mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_matrices[level]);</div><div class="line">      }</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">      mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">                   LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">                   <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1.e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    newton_update = 0.0;</div><div class="line"></div><div class="line">    cg.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(newton_update);</div><div class="line"></div><div class="line">    linear_iterations = solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>();</div><div class="line"></div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> itmax = 10;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       TOLf  = 1e-12;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       TOLx  = 1e-10;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> solver_timer;</div><div class="line">    solver_timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= itmax; ++newton_step)</div><div class="line">      {</div><div class="line">        assemble_rhs();</div><div class="line">        compute_update();</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ERRx = newton_update.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ERRf = compute_residual(1.0);</div><div class="line"></div><div class="line"></div><div class="line">        solution.add(1.0, newton_update);</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Nstep &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot;, errf = &quot;</span> &lt;&lt; ERRf</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, errx = &quot;</span> &lt;&lt; ERRx &lt;&lt; <span class="stringliteral">&quot;, it = &quot;</span> &lt;&lt; linear_iterations</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (ERRf &lt; TOLf || ERRx &lt; TOLx)</div><div class="line">          {</div><div class="line">            solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;Convergence step &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; value &quot;</span> &lt;&lt; ERRf</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; (used wall time: &quot;</span> &lt;&lt; solver_timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s)&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == itmax)</div><div class="line">          {</div><div class="line">            solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;WARNING: No convergence of Newton&#39;s method after &quot;</span></div><div class="line">                  &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; steps.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_solution_norm()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    solution.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values</a>();</div><div class="line"></div><div class="line">    Vector&lt;float&gt; norm_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                      norm_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                             norm_per_cell,</div><div class="line">                                             <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  GelfandProblem&lt;dim, fe_degree&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1e6)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      {</div><div class="line">        subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">      }</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                           fe.degree,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">    flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <span class="stringliteral">&quot;d&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">GelfandProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_ranks =</div><div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(double) * n_vect_doubles;</div><div class="line"></div><div class="line">      std::string DAT_header = <span class="stringliteral">&quot;START DATE: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#aff548b3b9b7a035ea112729700ef7c64">Utilities::System::get_date</a>() +</div><div class="line">                               <span class="stringliteral">&quot;, TIME: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">Utilities::System::get_time</a>();</div><div class="line">      std::string MPI_header = <span class="stringliteral">&quot;Running with &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_ranks) +</div><div class="line">                               <span class="stringliteral">&quot; MPI process&quot;</span> + (n_ranks &gt; 1 ? <span class="stringliteral">&quot;es&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">      std::string VEC_header =</div><div class="line">        <span class="stringliteral">&quot;Vectorization over &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_doubles) +</div><div class="line">        <span class="stringliteral">&quot; doubles = &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_bits) + <span class="stringliteral">&quot; bits (&quot;</span> +</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() +</div><div class="line">        <span class="stringliteral">&quot;), VECTORIZATION_LEVEL=&quot;</span> +</div><div class="line">        <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="config_8h.html#a32dc208a29f23d1f031fb40b0d21e60e">DEAL_II_COMPILER_VECTORIZATION_LEVEL</a>);</div><div class="line">      std::string SOL_header = <span class="stringliteral">&quot;Finite element space: &quot;</span> + fe.get_name();</div><div class="line"></div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; DAT_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      pcout &lt;&lt; MPI_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; VEC_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; SOL_header &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            make_grid();</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Set up system...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Triangulation: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; cells&quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   DoFHandler:    &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; DoFs&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Solve using Newton&#39;s method...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Time for setup+solve (CPU/Wall) &quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span></div><div class="line">              &lt;&lt; timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s&quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Output results...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> norm = compute_solution_norm();</div><div class="line">        output_results(cycle);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;  H1 seminorm: &quot;</span> &lt;&lt; norm &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step66</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step66;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;2, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;3, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a> , <a class="el" href="step_37.html">step-37</a> . <table
 class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Problemformulation">Problem formulation</a><a
 href="#Problemformulation">Problem formulation</a>
 <li><a href="#Discretizationwithfiniteelements">Discretization with finite
 elements</a><a href="#Discretizationwithfiniteelements">Discretization with
 finite elements</a>
 <li><a href="#Numericallinearalgebra">Numerical linear algebra</a><a
 href="#Numericallinearalgebra">Numerical linear algebra</a>
 <li><a href="#Triangulation">Triangulation</a><a
 href="#Triangulation">Triangulation</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#MatrixfreeJacobianOperator">Matrix-free
 JacobianOperator</a><a href="#MatrixfreeJacobianOperator">Matrix-free
 JacobianOperator</a>
 <ul>
 <li><a href="#EvaluationoftheoldNewtonstep">Evaluation of the old Newton
 step</a><a href="#EvaluationoftheoldNewtonstep">Evaluation of the old
 Newton step</a>
 <li><a href="#Nonlinearmatrixfreeoperatorapplication">Nonlinear matrix-free
 operator application</a><a
 href="#Nonlinearmatrixfreeoperatorapplication">Nonlinear matrix-free
 operator application</a>
 <li><a href="#DiagonaloftheJacobianOperator">Diagonal of the
 JacobianOperator</a><a href="#DiagonaloftheJacobianOperator">Diagonal of
 the JacobianOperator</a>
 </ul>
 <li><a href="#GelfandProblemclass">GelfandProblem class</a><a
 href="#GelfandProblemclass">GelfandProblem class</a>
 <ul>
 <li><a href="#GelfandProblemmake_grid">GelfandProblem::make_grid</a><a
 href="#GelfandProblemmake_grid">GelfandProblem::make_grid</a>
 <li><a
 href="#GelfandProblemsetup_system">GelfandProblem::setup_system</a><a
 href="#GelfandProblemsetup_system">GelfandProblem::setup_system</a>
 <li><a
 href="#GelfandProblemevaluate_residual">GelfandProblem::evaluate_residual</a><a
 href="#GelfandProblemevaluate_residual">GelfandProblem::evaluate_residual</a>
 <li><a
 href="#GelfandProblemlocal_evaluate_residual">GelfandProblem::local_evaluate_residual</a><a
 href="#GelfandProblemlocal_evaluate_residual">GelfandProblem::local_evaluate_residual</a>
 <li><a
 href="#GelfandProblemassemble_rhs">GelfandProblem::assemble_rhs</a><a
 href="#GelfandProblemassemble_rhs">GelfandProblem::assemble_rhs</a>
 <li><a
 href="#GelfandProblemcompute_residual">GelfandProblem::compute_residual</a><a
 href="#GelfandProblemcompute_residual">GelfandProblem::compute_residual</a>
 <li><a
 href="#GelfandProblemcompute_update">GelfandProblem::compute_update</a><a
 href="#GelfandProblemcompute_update">GelfandProblem::compute_update</a>
 <li><a href="#GelfandProblemsolve">GelfandProblem::solve</a><a
 href="#GelfandProblemsolve">GelfandProblem::solve</a>
 <li><a
 href="#GelfandProblemcompute_solution_norm">GelfandProblem::compute_solution_norm</a><a
 href="#GelfandProblemcompute_solution_norm">GelfandProblem::compute_solution_norm</a>
 <li><a
 href="#GelfandProblemoutput_results">GelfandProblem::output_results</a><a
 href="#GelfandProblemoutput_results">GelfandProblem::output_results</a>
 <li><a href="#GelfandProblemrun">GelfandProblem::run</a><a
 href="#GelfandProblemrun">GelfandProblem::run</a>
 </ul>
 <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a
 href="#Thecodemaincodefunction">The <code>main</code> function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Programoutput">Program output</a><a
 href="#Programoutput">Program output</a>
 <li><a href="#Newtonsolver">Newton solver</a><a href="#Newtonsolver">Newton
 solver</a>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 <ul>
 <li><a href="#MoresophisticatedNewtoniteration">More sophisticated Newton
 iteration</a><a href="#MoresophisticatedNewtoniteration">More sophisticated
 Newton iteration</a>
 <li><a href="#Parallelscalabilityandthreadparallelism">Parallel scalability
 and thread parallelism</a><a
 href="#Parallelscalabilityandthreadparallelism">Parallel scalability and
 thread parallelism</a>
 <li><a href="#Comparisontomatrixbasedmethods">Comparison to matrix-based
 methods</a><a href="#Comparisontomatrixbasedmethods">Comparison to
 matrix-based methods</a>
 <li><a href="#Eigenvalueproblem">Eigenvalue problem</a><a
 href="#Eigenvalueproblem">Eigenvalue problem</a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em> This program was contributed by Fabian Castelli.</em></p>
<p><em> A version of this code was presented and discussed in <b>[castelli2021numerical]</b> G.F. Castelli: Numerical Investigation of Cahn-Hilliard-Type Phase-Field Models for Battery Active <a class="el" href="namespaceParticles.html">Particles</a>, PhD thesis, Karlsruhe Institute of Technology (KIT), 2021. (To be published)</em></p>
<p><em> Fabian Castelli acknowledges financial support by the German Research Foundation (DFG) through the Research Training Group 2218 SiMET</em></p>
<p><em> &ndash; Simulation of mechano-electro-thermal processes in lithium-ion batteries, project number 281041241.</em></p>
<p><em> Finally Fabian Castelli would like to thank Timo Heister for the encouragement and advice in writing this tutorial. </em></p>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The aim of this tutorial program is to demonstrate how to solve a nonlinearproblem using Newton's method within the matrix-free framework. This tutorialcombines several techniques already introduced in <a class="el" href="step_15.html">step-15</a> , <a class="el" href="step_16.html">step-16</a> , <a class="el" href="step_37.html">step-37</a> , <a class="el" href="step_48.html">step-48</a> and others.</p>
<p><a class="anchor" id="Problemformulation"></a></p><h3>Problem formulation</h3>
<p>On the unit circle \(\Omega = \bigl\{ x \in \mathbb{R}^2 : \|x\| \leq 1 \bigr\}\) we consider the following nonlinear elliptic boundary value problem subject to ahomogeneous Dirichlet boundary condition: Find a function \(u\colon\Omega\to\mathbb{R}\) such that it holds: </p><p class="formulaDsp">
\begin{align*} - \Delta u &amp;= \exp(u) &amp; \quad &amp; \text{in } \Omega,\\ u &amp;= 0 &amp; \quad &amp; \text{on } \partial\Omega. \end{align*}
</p>
<p> This problem is also called the <em>Gelfand problem</em> and is a typical examplefor problems from combustion theory, see for example <b>[bebernes1989mathematical]</b> .</p>
<p><a class="anchor" id="Discretizationwithfiniteelements"></a></p><h3>Discretization with finite elements</h3>
<p>As usual, we first derive the weak formulation for this problem by multiplyingwith a smooth test function \(v\colon\Omega\to\mathbb{R}\) respecting theboundary condition and integrating over the domain \(\Omega\) . Integration byparts and putting the term from the right hand side to the left yields the weakformulation: Find a function \(u\colon\Omega\to\mathbb{R}\) such that for alltest functions \(v\) it holds: </p><p class="formulaDsp">
\begin{align*} \int_\Omega \nabla v \cdot \nabla u \,\mathrm{d}x - \int_\Omega v \exp(u) \,\mathrm{d}x = 0. \end{align*}
</p>
<p>Choosing the Lagrangian finite element space \(V_h \dealcoloneq \bigl\{ v \in C(\overline{\Omega}) : v|_Q \in \mathbb{Q}_p \text{ for all } Q \in \mathcal{T}_h \bigr\} \cap H_0^1(\Omega)\) , which directly incorporatesthe homogeneous Dirichlet boundary condition, we can define a basis \(\{\varphi_i\}_{i=1,\dots,N}\) and thus it suffices to test only with thosebasis functions. So the discrete problem reads as follows: Find \(u_h\in V_h\) such that for all \(i=1,\dots,N\) it holds: </p><p class="formulaDsp">
\begin{align*} F(u_h) \dealcoloneq \int_\Omega \nabla \varphi_i \cdot \nabla u_h \,\mathrm{d}x - \int_\Omega \varphi_i \exp(u_h) \,\mathrm{d}x \stackrel{!}{=} 0. \end{align*}
</p>
<p> As each finite element function is a linear combination of the basis functions \(\{\varphi_i\}_{i=1,\dots,N}\) , we can identify the finite element solution bya vector from \(\mathbb{R}^N\) consisting of the unknown values in each degree offreedom (DOF). Thus, we define the nonlinear function \(F\colon\mathbb{R}^N\to\mathbb{R}^N\) representing the discrete nonlinearproblem. To solve this nonlinear problem we use Newton's method. So given aninitial guess \(u_h^0\in V_h\) , which already fulfills the Dirichlet boundarycondition, we determine a sequence of Newton steps \(\bigl( u_h^n \bigr)_n\) bysuccessively applying the following scheme: </p><p class="formulaDsp">
\begin{align*} &amp;\text{Solve for } s_h^n\in V_h: \quad &amp; F&#39;(u_h^n)[s_h^n] &amp;= -F(u_h^n),\\ &amp;\text{Update: } &amp; u_h^{n+1} &amp;= u_h^n + s_h^n. \end{align*}
</p>
<p> So in each Newton step we have to solve a linear problem \(A\,x = b\) , where thesystem matrix \(A\) is represented by the Jacobian \(F&#39;(u_h^n)[\,\cdot\,]\colon\mathbb{R}^N\to\mathbb{R}^N\) and the right hand side \(b\) by the negative residual \(-F(u_h^n)\) . The solution vector \(x\) is in thatcase the Newton update of the \(n\) -th Newton step. Note, that we assume aninitial guess \(u_h^0\) , which already fulfills the Dirichlet boundary conditionsof the problem formulation (in fact this could also be an inhomogeneousDirichlet boundary condition) and thus the Newton updates \(s_h\) satisfy ahomogeneous Dirichlet condition. Until now we only tested with the basis functions, however, we can alsorepresent any function of \(V_h\) as linear combination of basis functions. Moremathematically this means, that every element of \(V_h\) can beidentified with a vector \(U\in\mathbb{R}^N\) via the representation formula: \(u_h = \sum_{i=1}^N U_i \varphi_i\) . So using this we can give an expression forthe discrete Jacobian and the residual: </p><p class="formulaDsp">
\begin{align*} A_{i,j} = \bigl( F&#39;(u_h^n) \bigr)_{i,j} &amp;= \int_\Omega \nabla\varphi_i \cdot \nabla \varphi_j \,\mathrm{d} x - \int_\Omega \varphi_i \, \exp( u_h ) \varphi_j \,\mathrm{d} x,\\ b_{i} = \bigl( F(u_h^n) \bigr)_{i} &amp;= \int_\Omega \nabla\varphi_i \cdot \nabla u_h^n \,\mathrm{d} x - \int_\Omega \varphi_i \, \exp( u_h^n ) \,\mathrm{d} x. \end{align*}
</p>
<p> Compared to <a class="el" href="step_15.html">step-15</a> we could also have formed the Frech{\'e}t derivative of thenonlinear function corresponding to the strong formulation of the problem anddiscretized it afterwards. However, in the end we would get the same set ofdiscrete equations.</p>
<p><a class="anchor" id="Numericallinearalgebra"></a></p><h3>Numerical linear algebra</h3>
<p>Note, how the system matrix, actually the Jacobian, depends on the previousNewton step \(A = F&#39;(u^n)\) . Hence we need to tell the function that computesthe system matrix about the solution at the last Newton step. In animplementation with a classical <code>assemble_system()</code> function wewould gather this information from the last Newton step during assembly by theuse of the member functions <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> and <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValuesBase::get_function_gradients()</a>. The <code>assemble_system()</code> function would then looks like: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">system_matrix = 0;</div><div class="line">system_rhs    = 0;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                       quadrature_formula,</div><div class="line">                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell);</div><div class="line">Vector&lt;double&gt;                       cell_rhs(dofs_per_cell);</div><div class="line">std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; newton_step_gradients(n_q_points);</div><div class="line">std::vector&lt;double&gt;         newton_step_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line"> {</div><div class="line">   cell_matrix = 0.0;</div><div class="line">   cell_rhs    = 0.0;</div><div class="line"></div><div class="line">   fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">   fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, newton_step_values);</div><div class="line">   fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(solution, newton_step_gradients);</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">     {</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">double</span> nonlinearity = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(newton_step_values[q]);</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">double</span> dx           = fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">         {</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i      = fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i = fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line"></div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">             {</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_j      = fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q);</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_j = fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q);</div><div class="line"></div><div class="line">               <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                 (grad_phi_i grad_phi_j</div><div class="line"></div><div class="line">- phi_i nonlinearity phi_j)</div><div class="line">                 dx;</div><div class="line">             }</div><div class="line"></div><div class="line">           cell_rhs(i) += (-grad_phi_i newton_step_gradients[q] +</div><div class="line">                           phi_i newton_step_values[q])</div><div class="line">                          dx;</div><div class="line">         }</div><div class="line">     }</div><div class="line"></div><div class="line">   cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">   constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">     cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line"> }</div><div class="line">}</div></div><!-- fragment --><p>Since we want to solve this problem without storing a matrix, we need to tellthe matrix-free operator this information before we use it. Therefore in thederived class <code>JacobianOperator</code> we will implement a functioncalled <code>evaluate_newton_step</code> , which will process the information ofthe last Newton step prior to the usage of the matrix-vector implementation.Furthermore we want to use a geometric multigrid (GMG) preconditioner for thelinear solver, so in order to apply the multilevel operators we need to pass thelast Newton step also to these operators. This is kind of a tricky task, sincethe vector containing the last Newton step has to be interpolated to all levelsof the triangulation. In the code this task will be done by the function <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>. Note, a fundamental difference tothe previous cases, where we set up and used a geometric multigridpreconditioner, is the fact, that we can reuse the <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> objectfor the computation of all Newton steps. So we can save some work here bydefining a class variable and using an already set up MGTransferMatrixFreeobject <code>mg_transfer</code> that was initialized in the <code>setup_system()</code> function. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">{</div><div class="line"><a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div><div class="line"></div><div class="line">solution.update_ghost_values();</div><div class="line"></div><div class="line">system_matrix.evaluate_newton_step(solution);</div><div class="line"></div><div class="line">mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Set up options for the multilevel preconditioner</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line"> {</div><div class="line">   mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line"> }</div><div class="line"></div><div class="line"><span class="comment">// Define the actual preconditioner</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// Solve the linear system</span></div><div class="line"><span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>The function evaluating the nonlinearity works basically in the same way as thefunction <code>evaluate_coefficient</code> from <a class="el" href="step_37.html">step-37</a> evaluating a coefficientfunction. The idea is to use an <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object to evaluate the Newton stepand store the expression in a table for all cells and all quadrature points: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line"><span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">{</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line"></div><div class="line"><a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line">nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line"> {</div><div class="line">   phi.reinit(cell);</div><div class="line">   phi.read_dof_values_plain(newton_step);</div><div class="line">   phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">     {</div><div class="line">       nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">     }</div><div class="line"> }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Triangulation"></a></p><h3><a class="el" href="classTriangulation.html">Triangulation</a></h3>
<p>As said in step-37 the matrix-free method gets more efficient if we choose ahigher order finite element space. Since we want to solve the problem on the \(d\) -dimensional unit ball, it would be good to have an appropriate boundaryapproximation to overcome convergence issues. For this reason we use anisoparametric approach with the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> class to recover the smoothboundary as well as the mapping for inner cells. In addition, to get a goodtriangulation in total we make use of the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First we include the typical headers of the deal.II library needed for this tutorial:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vectorization_8h.html">deal.II/base/vectorization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__accessor_8h.html">deal.II/grid/tria_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__iterator_8h.html">deal.II/grid/tria_iterator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>In particular, we need to include the headers for the matrix-free framework:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tools_8h.html">deal.II/matrix_free/tools.h</a>&gt;</span></div></div><!-- fragment --><p>And since we want to use a geometric multigrid preconditioner, we need also the multilevel headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div></div><!-- fragment --><p>Finally some common C++ headers for in and output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step66</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="MatrixfreeJacobianOperator"></a> </p><h3>Matrix-free JacobianOperator</h3>
<p>In the beginning we define the matrix-free operator for the Jacobian. As a guideline we follow the tutorials <a class="el" href="step_37.html">step-37</a> and <a class="el" href="step_48.html">step-48</a> , where the precise interface of the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class was extensively documented. Since we want to use the Jacobian as system matrix and pass it to the linear solver as well as to the multilevel preconditioner classes, we derive the <code>JacobianOperator</code> class from the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class, such that we have already the right interface. The two functions we need to override from the base class are the <a class="el" href="classMatrixFreeOperators_1_1Base.html#abc81493aad390198580330cc99203b3c">MatrixFreeOperators::Base::apply_add()</a> and the <a class="el" href="classMatrixFreeOperators_1_1Base.html#a16d883c49c69eef468b39b2e991d8b0d">MatrixFreeOperators::Base::compute_diagonal()</a> function. To allow preconditioning with float precision we define the number type as template argument. As mentioned already in the introduction, we need to evaluate the Jacobian \(F&#39;\) at the last Newton step \(u_h^n\) for the computation of the Newton update \(s_h^n\) . To get the information of the last Newton step \(u_h^n\) we do pretty much the same as in <a class="el" href="step_37.html">step-37</a> , where we stored the values of a coefficient function in a table <code>nonlinear_values</code> once before we use the matrix-free operator. Instead of a function <code>evaluate_coefficient()</code> , we here implement a function <code>evaluate_newton_step()</code> . As additional private member functions of the <code>JacobianOperator</code> we implement the <code>local_apply()</code> and the <code>local_compute_diagonal()</code> function. The first one is the actual worker function for the matrix-vector application, which we pass to the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> in the <code>apply_add()</code> function. The later one is the worker function to compute the diagonal, which we pass to the <a class="el" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal()</a> function. For better readability of the source code we further define an alias for the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keyword">class </span>JacobianOperator</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">      Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> FECellIntegrator =</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a>;</div><div class="line"></div><div class="line">  JacobianOperator();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_newton_step(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">              <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">              <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_compute_diagonal(FECellIntegrator &amp;integrator) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; nonlinear_values;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the <code>JacobianOperator</code> just calls the constructor of the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, which is itself derived from the <a class="el" href="classSubscriptor.html">Subscriptor</a> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">JacobianOperator&lt;dim, fe_degree, number&gt;::JacobianOperator()</div><div class="line">  : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                              <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="classVector.html">Vector</a>&lt;number&gt;&gt;()</div><div class="line">{}</div></div><!-- fragment --><p>The <code>clear()</code> function resets the table holding the values for the nonlinearity and call the <code>clear()</code> function of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">{</div><div class="line">  nonlinear_values.reinit(0, 0);</div><div class="line">  <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">    clear();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EvaluationoftheoldNewtonstep"></a> </p><h4>Evaluation of the old Newton step</h4>
<p>The following <code>evaluate_newton_step()</code> function is based on the <code>evaluate_coefficient()</code> function from <a class="el" href="step_37.html">step-37</a> . However, it does not evaluate a function object, but evaluates a vector representing a finite element function, namely the last Newton step needed for the Jacobian. Therefore we set up a <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object and evaluate the finite element function in the quadrature points with the <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> and <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a> functions. We store the evaluated values of the finite element function directly in the <code>nonlinear_values</code> table. This will work well and in the <code>local_apply()</code> function we can use the values stored in the table to apply the matrix-vector product. However, we can also optimize the implementation of the Jacobian at this stage. We can directly evaluate the nonlinear function <code>std::exp(newton_step[q])</code> and store these values in the table. This skips all evaluations of the nonlinearity in each call of the <code>vmult()</code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">  FECellIntegrator   phi(*this-&gt;data);</div><div class="line"></div><div class="line">  nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values_plain(newton_step);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Nonlinearmatrixfreeoperatorapplication"></a> </p><h4>Nonlinear matrix-free operator application</h4>
<p>Now in the <code>local_apply()</code> function, which actually implements the cell wise action of the system matrix, we can use the information of the last Newton step stored in the table <code>nonlinear_values</code> . The rest of this function is basically the same as in <a class="el" href="step_37.html">step-37</a> . We set up the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object, gather and evaluate the values and gradients of the input vector <code>src</code> , submit the values and gradients according to the form of the Jacobian and finally call <a class="el" href="classFEEvaluation.html#a491779be7bd032d277e41f1dda8dc584">FEEvaluation::integrate_scatter()</a> to perform the cell integration and distribute the local contributions into the global vector <code> dst</code> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  FECellIntegrator phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                      phi.get_matrix_free().n_cell_batches());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line"></div><div class="line">      phi.gather_evaluate(src,</div><div class="line">                          <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                            <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_value(-nonlinear_values(cell, q) phi.get_value(q), q);</div><div class="line">          phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">        }</div><div class="line"></div><div class="line">      phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                            dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next we use <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> to perform the actual loop over all cells computing the cell contribution to the matrix-vector product.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;JacobianOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DiagonaloftheJacobianOperator"></a> </p><h4>Diagonal of the JacobianOperator</h4>
<p>The internal worker function <code>local_compute_diagonal()</code> for the computation of the diagonal is similar to the above worker function <code>local_apply()</code> . However, as major difference we do not read values from a input vector or distribute any local results to an output vector. Instead the only input argument is the used <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">  FECellIntegrator &amp;phi)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                  phi.get_matrix_free().n_cell_batches());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = phi.get_current_cell_index();</div><div class="line"></div><div class="line">  phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">    {</div><div class="line">      phi.submit_value(-nonlinear_values(cell, q) phi.get_value(q), q);</div><div class="line">      phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">    }</div><div class="line"></div><div class="line">  phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">}</div></div><!-- fragment --><p>Finally we override the <a class="el" href="classMatrixFreeOperators_1_1Base.html#a16d883c49c69eef468b39b2e991d8b0d">MatrixFreeOperators::Base::compute_diagonal()</a> function of the base class of the <code>JacobianOperator</code> . Although the name of the function suggests just the computation of the diagonal, this function does a bit more. Because we only really need the inverse of the matrix diagonal elements for the Chebyshev smoother of the multigrid preconditioner, we compute the diagonal and store the inverse elements. Therefore we first initialize the <code>inverse_diagonal_entries</code> . Then we compute the diagonal by passing the worker function <code>local_compute_diagonal()</code> to the <a class="el" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal()</a> function. In the end we loop over the diagonal and invert the elements by hand. Note, that during this loop we catch the constrained DOFs and set them manually to one.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">JacobianOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">{</div><div class="line">  this-&gt;inverse_diagonal_entries.reset(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">    this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal</a>(*this-&gt;data,</div><div class="line">                                    inverse_diagonal,</div><div class="line">                                    &amp;JacobianOperator::local_compute_diagonal,</div><div class="line">                                    <span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;diagonal_element : inverse_diagonal)</div><div class="line">    {</div><div class="line">      diagonal_element = (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(diagonal_element) &gt; 1.0e-10) ?</div><div class="line">                           (1.0 / diagonal_element) :</div><div class="line">                           1.0;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemclass"></a> </p><h3>GelfandProblem class</h3>
<p>After implementing the matrix-free operators we can now define the solver class for the <em>Gelfand problem</em>. This class is based on the common structure of all previous tutorial programs, in particular it is based on <a class="el" href="step_15.html">step-15</a> , solving also a nonlinear problem. Since we are using the matrix-free framework, we no longer need an assemble_system function any more, instead the information of the matrix is rebuilt in every call of the <code>vmult()</code> function. However, for the application of the Newton scheme we need to assemble the right hand side of the linearized problems and compute the residuals. Therefore, we implement an additional function <code>evaluate_residual()</code> , which we later call in the <code>assemble_rhs()</code> and the <code>compute_residual()</code> function. Finally, the typical <code>solve()</code> function here implements the Newton method, whereas the solution of the linearized system is computed in the function <code>compute_update()</code> . As the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework handles the polynomial degree of the Lagrangian finite element method as a template parameter, we declare it also as a template parameter for the problem solver class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>GelfandProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  GelfandProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_residual(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_evaluate_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> compute_update();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_solution_norm() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div></div><!-- fragment --><p>For the parallel computation we define a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. As the computational domain is a circle in 2D and a ball in 3D, we assign in addition to the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> for boundary cells a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> object for the mapping of the inner cells, which takes care of the inner cells. In this example we use an isoparametric finite element approach and thus use the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> class. Note, that we could also create an instance of the <a class="el" href="classMappingQ.html">MappingQ</a> class and set the <code>use_mapping_q_on_all_cells</code> flags in the contructor call to <code>true</code> . For further details on the connection of <a class="el" href="classMappingQ.html">MappingQ</a> and <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> you may read the detailed description of these classes.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>                mapping;</div></div><!-- fragment --><p>As usual we then define the Lagrangian finite elements <a class="el" href="classFE__Q.html">FE_Q</a> and a <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div></div><!-- fragment --><p>For the linearized discrete system we define an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects and the <code>system_matrix</code> , which is in this example represented as a matrix-free operator.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"><span class="keyword">using</span> SystemMatrixType = JacobianOperator&lt;dim, fe_degree, double&gt;;</div><div class="line">SystemMatrixType system_matrix;</div></div><!-- fragment --><p>The multilevel object is also based on the matrix-free operator for the Jacobian. Since we need to evaluate the Jacobian with the last Newton step, we also need to evaluate the level operator with the last Newton step for the preconditioner. Thus in addition to <code>mg_matrices</code> , we also need a <a class="el" href="classMGLevelObject.html">MGLevelObject</a> to store the interpolated solution vector on each level. As in <a class="el" href="step_37.html">step-37</a> we use float precision for the preconditioner. Moreover, we define the <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> object as a class variable, since we need to set it up only once when the triangulation has changed and can then use it again in each Newton step.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"><span class="keyword">using</span> LevelMatrixType = JacobianOperator&lt;dim, fe_degree, float&gt;;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a>                           mg_matrices;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_solution;</div><div class="line"><a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>                         mg_transfer;</div></div><!-- fragment --><p>Of course we also need vectors holding the <code>solution</code> , the <code>newton_update</code> and the <code>system_rhs</code> . In that way we can always store the last Newton step in the solution vector and just add the update to get the next Newton step.</p>
<div class="fragment"><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> newton_update;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div></div><!-- fragment --><p>Finally we have a variable for the number of iterations of the linear solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linear_iterations;</div></div><!-- fragment --><p>For the output in programs running in parallel with MPI, we use the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> class to avoid multiple output of the same data by different MPI ranks.</p>
<div class="fragment"><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div></div><!-- fragment --><p>Finally for the time measurement we use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object, which prints the elapsed CPU and wall times for each function in a nicely formatted table after the program has finished.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the <code>GelfandProblem</code> initializes the class variables. In particular, we set up the multilevel support for the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, set the mapping degree equal to the finite element degree, initialize the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and tell the <a class="el" href="classTimerOutput.html">TimerOutput</a> that we want to see the wall times only on demand.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">GelfandProblem&lt;dim, fe_degree&gt;::GelfandProblem()</div><div class="line">  : triangulation(MPI_COMM_WORLD,</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">                  <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;</div><div class="line">                    dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">  , mapping(fe_degree)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">  , computing_timer(MPI_COMM_WORLD,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemmake_grid"></a> </p><h4>GelfandProblem::make_grid</h4>
<p>As the computational domain we use the <code>dim</code> -dimensional unit ball. We follow the instructions for the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class and also assign a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> for the boundary. Finally, we refine the initial mesh 3</p>
<ul>
<li><code>dim</code> times globally.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;make grid&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>                boundary_manifold;</div><div class="line">  <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> inner_manifold;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(1);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, boundary_manifold);</div><div class="line"></div><div class="line">  inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, inner_manifold);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3</div><div class="line"></div><div class="line">- dim);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemsetup_system"></a> </p><h4>GelfandProblem::setup_system</h4>
<p>The <code>setup_system()</code> function is quasi identical to the one in <a class="el" href="step_37.html">step-37</a> . The only differences are obviously the time measurement with only one <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> instead of measuring each part individually, and more importantly the initialization of the <a class="el" href="classMGLevelObject.html">MGLevelObject</a> for the interpolated solution vector of the previous Newton step. Another important change is the setup of the <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> object, which we can reuse in each Newton step as the <code>triangulation</code> will not be not changed. Note how we can use the same <a class="el" href="classMatrixFree.html">MatrixFree</a> object twice, for the <code>JacobianOperator</code> and the multigrid preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup system&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  mg_matrices.clear_elements();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">      <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::partition_color</a>;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <span class="keyword">auto</span> system_mf_storage = std::make_shared&lt;MatrixFree&lt;dim, double&gt;&gt;();</div><div class="line">    system_mf_storage-&gt;reinit(mapping,</div><div class="line">                              dof_handler,</div><div class="line">                              constraints,</div><div class="line">                              <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                              additional_data);</div><div class="line"></div><div class="line">    system_matrix.initialize(system_mf_storage);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(solution);</div><div class="line">  system_matrix.initialize_dof_vector(newton_update);</div><div class="line">  system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">  mg_matrices.resize(0, nlevels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_solution.resize(0, nlevels</div><div class="line"></div><div class="line">- 1);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">  dirichlet_boundary.insert(0);</div><div class="line">  mg_constrained_dofs.initialize(dof_handler);</div><div class="line">  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                     dirichlet_boundary);</div><div class="line"></div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a69e2b416ab209936f94db08e865cd92b">initialize_constraints</a>(mg_constrained_dofs);</div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                    level,</div><div class="line">                                                    relevant_dofs);</div><div class="line"></div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">        mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::partition_color</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">      <span class="keyword">auto</span> mg_mf_storage_level = std::make_shared&lt;MatrixFree&lt;dim, float&gt;&gt;();</div><div class="line">      mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                  dof_handler,</div><div class="line">                                  level_constraints,</div><div class="line">                                  <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                  additional_data);</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                    mg_constrained_dofs,</div><div class="line">                                    level);</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize_dof_vector(mg_solution[level]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemevaluate_residual"></a> </p><h4>GelfandProblem::evaluate_residual</h4>
<p>Next we implement a function which evaluates the nonlinear discrete residual for a given input vector ( \(\texttt{dst} = F(\texttt{src})\) ). This function is then used for the assembly of the right hand side of the linearized system and later for the computation of the residual of the next Newton step to check if we already reached the error tolerance. As this function should not affect any class variable we define it as a constant function. Internally we exploit the fast finite element evaluation through the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class and the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>, similar to <code>apply_add()</code> function of the <code>JacobianOperator</code> . First we create a pointer to the <a class="el" href="classMatrixFree.html">MatrixFree</a> object, which is stored in the <code>system_matrix</code> . Then we pass the worker function <code>local_evaluate_residual()</code> for the cell wise evaluation of the residual together with the input and output vector to the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>. In addition, we enable the zero out of the output vector in the loop, which is more efficient than calling <code>dst = 0.0</code> separately before. Note that with this approach we do not have to take care about the MPI related data exchange, since all the bookkeeping is done by the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::evaluate_residual(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">auto</span> matrix_free = system_matrix.get_matrix_free();</div><div class="line"></div><div class="line">  matrix_free-&gt;cell_loop(</div><div class="line">    &amp;GelfandProblem::local_evaluate_residual, <span class="keyword">this</span>, dst, src, <span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemlocal_evaluate_residual"></a> </p><h4>GelfandProblem::local_evaluate_residual</h4>
<p>This is the internal worker function for the evaluation of the residual. Essentially it has the same structure as the <code>local_apply()</code> function of the <code>JacobianOperator</code> and evaluates the residual for the input vector <code>src</code> on the given set of cells <code>cell_range</code> . The difference to the above mentioned <code>local_apply()</code> function is, that we split the <a class="el" href="classFEEvaluation.html#ab53d5c08f460cfe6c9830ac14a427115">FEEvaluation::gather_evaluate()</a> function into <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> and <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a>, since the input vector might have constrained DOFs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::local_evaluate_residual(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line"></div><div class="line">      phi.read_dof_values_plain(src);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_value(-std::exp(phi.get_value(q)), q);</div><div class="line">          phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">        }</div><div class="line"></div><div class="line">      phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                            dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemassemble_rhs"></a> </p><h4>GelfandProblem::assemble_rhs</h4>
<p>Using the above function <code>evaluate_residual()</code> to evaluate the nonlinear residual, the assembly of the right hand side of the linearized system becomes now a very easy task. We just call the <code>evaluate_residual()</code> function and multiply the result with minus one. Experiences show that using the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class is much faster than a classical implementation with <a class="el" href="classFEValues.html">FEValues</a> and co.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assemble right hand side&quot;</span>);</div><div class="line"></div><div class="line">  evaluate_residual(system_rhs, solution);</div><div class="line"></div><div class="line">  system_rhs=</div><div class="line"></div><div class="line">-1.0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_residual"></a> </p><h4>GelfandProblem::compute_residual</h4>
<p>According to <a class="el" href="step_15.html">step-15</a> the following function computes the norm of the nonlinear residual for the solution \(u_h^n + \alpha s_h^n\) with the help of the <code>evaluate_residual()</code> function. The Newton step length \(\alpha\) becomes important if we would use an adaptive version of the Newton method. Then for example we would compute the residual for different step lengths and compare the residuals. However, for our problem the full Newton step with \(\alpha=1\) is the best we can do. An adaptive version of Newton's method becomes interesting if we have no good initial value. Note that in theory Newton's method converges with quadratic order, but only if we have an appropriate initial value. For unsuitable initial values the Newton method diverges even with quadratic order. A common way is then to use a damped version \(\alpha&lt;1\) until the Newton step is good enough and the full Newton step can be performed. This was also discussed in <a class="el" href="step_15.html">step-15</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute residual&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> residual;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> evaluation_point;</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(residual);</div><div class="line">  system_matrix.initialize_dof_vector(evaluation_point);</div><div class="line"></div><div class="line">  evaluation_point = solution;</div><div class="line">  <span class="keywordflow">if</span> (alpha &gt; 1e-12)</div><div class="line">    {</div><div class="line">      evaluation_point.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a>(alpha, newton_update);</div><div class="line">    }</div><div class="line"></div><div class="line">  evaluate_residual(residual, evaluation_point);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_update"></a> </p><h4>GelfandProblem::compute_update</h4>
<p>In order to compute the Newton updates in each Newton step we solve the linear system with the CG algorithm together with a geometric multigrid preconditioner. For this we first set up the <a class="el" href="classPreconditionMG.html">PreconditionMG</a> object with a Chebyshev smoother like we did in <a class="el" href="step_37.html">step-37</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div></div><!-- fragment --><p>We remember that the Jacobian depends on the last Newton step stored in the solution vector. So we update the ghost values of the Newton step and pass it to the <code>JacobianOperator</code> to store the information.</p>
<div class="fragment"><div class="line">solution.update_ghost_values();</div><div class="line"></div><div class="line">system_matrix.evaluate_newton_step(solution);</div></div><!-- fragment --><p>Next we also have to pass the last Newton step to the multilevel operators. Therefore, we need to interpolate the Newton step to all levels of the triangulation. This is done with the <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>.</p>
<div class="fragment"><div class="line">mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div></div><!-- fragment --><p>Now we can set up the preconditioner. We define the smoother and pass the interpolated vectors of the Newton step to the multilevel operators.</p>
<div class="fragment"><div class="line">  <span class="keyword">using</span> SmootherType =</div><div class="line">    <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                          LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line">  <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                         LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                       mg_smoother;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">  smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>()</div><div class="line"></div><div class="line">- 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">       ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">        {</div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 4;</div><div class="line">          smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          smoother_data[0].smoothing_range = 1e-3;</div><div class="line">          smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">          smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">        }</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line"></div><div class="line">      smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">    }</div><div class="line">  mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line">  <a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">    mg_coarse;</div><div class="line">  mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">    mg_matrices);</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">    mg_interface_matrices;</div><div class="line">  mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>()</div><div class="line"></div><div class="line">- 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">       ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_matrices[level]);</div><div class="line">    }</div><div class="line">  <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">    mg_interface_matrices);</div><div class="line"></div><div class="line">  <a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">    mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">  <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">                 LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">                 <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">    preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>Finally we set up the <a class="el" href="classSolverControl.html">SolverControl</a> and the <a class="el" href="classSolverCG.html">SolverCG</a> to solve the linearized problem for the current Newton update. An important fact of the implementation of <a class="el" href="classSolverCG.html">SolverCG</a> or also <a class="el" href="classSolverGMRES.html">SolverGMRES</a> is, that the vector holding the solution of the linear system (here <code>newton_update</code> ) can be used to pass a starting value. In order to start the iterative solver always with a zero vector we reset the <code>newton_update</code> explicitly before calling <a class="el" href="classSolverCG.html#aa52469650d9b9ef2f4cb4884caeb0723">SolverCG::solve()</a>. Afterwards we distribute the Dirichlet boundary conditions stored in <code>constraints</code> and store the number of iteration steps for the later output.</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1.e-12);</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">newton_update = 0.0;</div><div class="line"></div><div class="line">cg.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(newton_update);</div><div class="line"></div><div class="line">linear_iterations = solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>();</div></div><!-- fragment --><p>Then for bookkeeping we zero out the ghost values.</p>
<div class="fragment"><div class="line">  solution.zero_out_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemsolve"></a> </p><h4>GelfandProblem::solve</h4>
<p>Now we implement the actual Newton solver for the nonlinear problem.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>);</div></div><!-- fragment --><p>We define a maximal number of Newton steps and tolerances for the convergence criterion. Usually, with good starting values, the Newton method converges in three to six steps, so maximal ten steps should be totally sufficient. As tolerances we use \(\|F(u^n_h)\|&lt;\text{TOL}_f = 10^{-12}\) for the norm of the residual and \(\|s_h^n\| &lt; \text{TOL}_x = 10^{-10}\) for the norm of the Newton update. This seems a bit over the top, but we will see that, for our example, we will achieve these tolerances after a few steps.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> itmax = 10;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       TOLf  = 1e-12;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       TOLx  = 1e-10;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTimer.html">Timer</a> solver_timer;</div><div class="line">solver_timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div></div><!-- fragment --><p>Now we start the actual Newton iteration.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= itmax; ++newton_step)</div><div class="line">  {</div></div><!-- fragment --><p>We assemble the right hand side of the linearized problem and compute the Newton update.</p>
<div class="fragment"><div class="line">assemble_rhs();</div><div class="line">compute_update();</div></div><!-- fragment --><p>Then we compute the errors, namely the norm of the Newton update and the residual. Note that at this point one could incorporate a step size control for the Newton method by varying the input parameter \(\alpha\) for the compute_residual function. However, here we just use \(\alpha\) equal to one for a plain Newton iteration.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> ERRx = newton_update.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> ERRf = compute_residual(1.0);</div></div><!-- fragment --><p>Next we advance the Newton step by adding the Newton update to the current Newton step.</p>
<div class="fragment"><div class="line">solution.add(1.0, newton_update);</div></div><!-- fragment --><p>A short output will inform us on the current Newton step.</p>
<div class="fragment"><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Nstep &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot;, errf = &quot;</span> &lt;&lt; ERRf</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;, errx = &quot;</span> &lt;&lt; ERRx &lt;&lt; <span class="stringliteral">&quot;, it = &quot;</span> &lt;&lt; linear_iterations</div><div class="line">      &lt;&lt; std::endl;</div></div><!-- fragment --><p>After each Newton step we check the convergence criteria. If at least one of those is fulfilled we are done and end the loop. If we haven't found a satisfying solution after the maximal amount of Newton iterations, we inform the user about this shortcoming.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (ERRf &lt; TOLf || ERRx &lt; TOLx)</div><div class="line">        {</div><div class="line">          solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;Convergence step &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; value &quot;</span> &lt;&lt; ERRf</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; (used wall time: &quot;</span> &lt;&lt; solver_timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s)&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == itmax)</div><div class="line">        {</div><div class="line">          solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;WARNING: No convergence of Newton&#39;s method after &quot;</span></div><div class="line">                &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; steps.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_solution_norm"></a> </p><h4>GelfandProblem::compute_solution_norm</h4>
<p>The computation of the H1-seminorm of the solution can be done in the same way as in <a class="el" href="step_59.html">step-59</a> . We update the ghost values and use the function <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. In the end we gather all computations from all MPI ranks and return the norm.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_solution_norm()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  solution.update_ghost_values();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> norm_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                    norm_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">  solution.zero_out_ghost_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                           norm_per_cell,</div><div class="line">                                           <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemoutput_results"></a> </p><h4>GelfandProblem::output_results</h4>
<p>We generate the graphical output files in vtu format together with a pvtu master file at once by calling the <a class="el" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">DataOut::write_vtu_with_pvtu_record()</a> function in the same way as in <a class="el" href="step_37.html">step-37</a> . In addition, as in <a class="el" href="step_40.html">step-40</a> , we query the <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> of each cell and write the distribution of the triangulation among the MPI ranks into the output file. Finally, we generate the patches of the solution by calling <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. However, since we have a computational domain with a curved boundary, we additionally pass the <code>mapping</code> and the finite element degree as number of subdivision. But this is still not enough for the correct representation of the solution, for example in ParaView, because we attached a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to the inner cells, which results in curved cells in the interior. Therefore we pass as third argument the <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ad8379a354d5bd6484471f6bf755cd111">DataOut::curved_inner_cells</a> option, such that also the inner cells use the corresponding manifold description to build the patches. Note that we could handle the higher order elements with the flag <a class="el" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">DataOutBase::VtkFlags::write_higher_order_cells</a>. However, due to the limited compatibility to previous version of ParaView and the missing support by VisIt, we left this option for a future version.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">GelfandProblem&lt;dim, fe_degree&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1e6)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  solution.update_ghost_values();</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">    {</div><div class="line">      subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">    }</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                         fe.degree,</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <span class="stringliteral">&quot;d&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">  solution.zero_out_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemrun"></a> </p><h4>GelfandProblem::run</h4>
<p>The last missing function of the solver class for the <em>Gelfand problem</em> is the run function. In the beginning we print information about the system specifications and the finite element space we use. The problem is solved several times on a successively refined mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">GelfandProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_ranks =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 <span class="keyword">sizeof</span>(double) n_vect_doubles;</div><div class="line"></div><div class="line">    std::string DAT_header = <span class="stringliteral">&quot;START DATE: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#aff548b3b9b7a035ea112729700ef7c64">Utilities::System::get_date</a>() +</div><div class="line">                             <span class="stringliteral">&quot;, TIME: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">Utilities::System::get_time</a>();</div><div class="line">    std::string MPI_header = <span class="stringliteral">&quot;Running with &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_ranks) +</div><div class="line">                             <span class="stringliteral">&quot; MPI process&quot;</span> + (n_ranks &gt; 1 ? <span class="stringliteral">&quot;es&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    std::string VEC_header =</div><div class="line">      <span class="stringliteral">&quot;Vectorization over &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_doubles) +</div><div class="line">      <span class="stringliteral">&quot; doubles = &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_bits) + <span class="stringliteral">&quot; bits (&quot;</span> +</div><div class="line">      <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() +</div><div class="line">      <span class="stringliteral">&quot;), VECTORIZATION_LEVEL=&quot;</span> +</div><div class="line">      <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="config_8h.html#a32dc208a29f23d1f031fb40b0d21e60e">DEAL_II_COMPILER_VECTORIZATION_LEVEL</a>);</div><div class="line">    std::string SOL_header = <span class="stringliteral">&quot;Finite element space: &quot;</span> + fe.get_name();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; DAT_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; MPI_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; VEC_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; SOL_header &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9</div><div class="line"></div><div class="line">- dim; ++cycle)</div><div class="line">    {</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>The first task in actually solving the problem is to generate or refine the triangulation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cycle == 0)</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">  }</div></div><!-- fragment --><p>Now we set up the system and solve the problem. These steps are accompanied by time measurement and textual output.</p>
<div class="fragment"><div class="line"><a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Set up system...&quot;</span> &lt;&lt; std::endl;</div><div class="line">setup_system();</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Triangulation: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot; cells&quot;</span> &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   DoFHandler:    &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; DoFs&quot;</span></div><div class="line">      &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Solve using Newton&#39;s method...&quot;</span> &lt;&lt; std::endl;</div><div class="line">solve();</div><div class="line">pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Time for setup+solve (CPU/Wall) &quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span></div><div class="line">      &lt;&lt; timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s&quot;</span> &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div></div><!-- fragment --><p>After the problem was solved we compute the norm of the solution and generate the graphical output files.</p>
<div class="fragment"><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Output results...&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> norm = compute_solution_norm();</div><div class="line">output_results(cycle);</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;  H1 seminorm: &quot;</span> &lt;&lt; norm &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div></div><!-- fragment --><p>Finally after each cycle we print the timing information.</p>
<div class="fragment"><div class="line">      computing_timer.print_summary();</div><div class="line">      computing_timer.reset();</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step66</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>As typical for programs running in parallel with MPI we set up the MPI framework and disable shared-memory parallelization by limiting the number of threads to one. Finally to run the solver for the <em>Gelfand problem</em> we create an object of the <code>GelfandProblem</code> class and call the run function. Exemplarily we solve the problem once in 2D and once in 3D each with fourth-order Lagrangian finite elements.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>Step66;</div><div class="line"></div><div class="line">    <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">    {</div><div class="line">      GelfandProblem&lt;2, 4&gt; gelfand_problem;</div><div class="line">      gelfand_problem.run();</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      GelfandProblem&lt;3, 4&gt; gelfand_problem;</div><div class="line">      gelfand_problem.run();</div><div class="line">    }</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The aim of this tutorial step was to demonstrate the solution of a nonlinearPDE with the matrix-free framework.</p>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>Running the program on two processes in release mode via </p><div class="fragment"><div class="line">cmake . &amp;&amp; make release &amp;&amp; make &amp;&amp; mpirun</div><div class="line"></div><div class="line">-n 2 ./step-66</div></div><!-- fragment --><p> gives the following output on the console </p><div class="fragment"><div class="line">================================================================================</div><div class="line">START DATE: 2021/5/18, TIME: 16:25:48</div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Running with 2 MPI processes</div><div class="line">Vectorization over 4 doubles = 256 bits (AVX), VECTORIZATION_LEVEL=2</div><div class="line">Finite element space: <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>(4)</div><div class="line">================================================================================</div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Cycle 0</div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Set up system...</div><div class="line">Triangulation: 20 cells</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler</a>:    337 DoFs</div><div class="line"></div><div class="line">Solve <span class="keyword">using</span> Newton<span class="stringliteral">&#39;s method...</span></div><div class="line"><span class="stringliteral">Nstep 1, errf = 0.00380835, errx = 3.61904, it = 7</span></div><div class="line"><span class="stringliteral">Nstep 2, errf = 3.80167e-06, errx = 0.104353, it = 6</span></div><div class="line"><span class="stringliteral">Nstep 3, errf = 3.97939e-12, errx = 0.00010511, it = 4</span></div><div class="line"><span class="stringliteral">Nstep 4, errf = 2.28859e-13, errx = 1.07726e-10, it = 1</span></div><div class="line"><span class="stringliteral">Convergence step 4 value 2.28859e-13 (used wall time: 0.0096409 s)</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Time for setup+solve (CPU/Wall) 0.015617/0.0156447 s</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Output results...</span></div><div class="line"><span class="stringliteral">H1 seminorm: 0.773426</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">+---------------------------------------------+------------+------------+</span></div><div class="line"><span class="stringliteral">| Total wallclock time elapsed since start    |    0.0286s |            |</span></div><div class="line"><span class="stringliteral">|                                             |            |            |</span></div><div class="line"><span class="stringliteral">| Section                         | no. calls |  wall time | % of total |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral">| assemble right hand side        |         4 |  9.71e-05s |      0.34% |</span></div><div class="line"><span class="stringliteral">| compute residual                |         4 |  0.000137s |      0.48% |</span></div><div class="line"><span class="stringliteral">| compute update                  |         4 |   0.00901s |        32% |</span></div><div class="line"><span class="stringliteral">| make grid                       |         1 |   0.00954s |        33% |</span></div><div class="line"><span class="stringliteral">| setup system                    |         1 |   0.00585s |        20% |</span></div><div class="line"><span class="stringliteral">| solve                           |         1 |   0.00966s |        34% |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">--------------------------------------------------------------------------------</span></div><div class="line"><span class="stringliteral">Cycle 6</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">--------------------------------------------------------------------------------</span></div><div class="line"><span class="stringliteral">Set up system...</span></div><div class="line"><span class="stringliteral">Triangulation: 81920 cells</span></div><div class="line"><span class="stringliteral">DoFHandler:    1311745 DoFs</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Solve using Newton&#39;</span>s method...</div><div class="line">Nstep 1, errf = 5.90478e-05, errx = 231.427, it = 9</div><div class="line">Nstep 2, errf = 5.89991e-08, errx = 6.67102, it = 6</div><div class="line">Nstep 3, errf = 4.28813e-13, errx = 0.0067188, it = 4</div><div class="line">Convergence step 3 value 4.28813e-13 (used wall time: 4.82953 s)</div><div class="line"></div><div class="line">Time <span class="keywordflow">for</span> setup+solve (CPU/Wall) 6.25094/6.37174 s</div><div class="line"></div><div class="line">Output results...</div><div class="line">H1 seminorm: 0.773426</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      9.04s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| <a class="code" href="namespaceinternal.html#a2b3d48efdf7c94da455dc6a3553bab79">assemble</a> right hand side        |         3 |    0.0827s |      0.91% |</div><div class="line">| compute residual                |         3 |    0.0909s |         1% |</div><div class="line">| compute update                  |         3 |      4.65s |        51% |</div><div class="line">| setup system                    |         1 |      1.54s |        17% |</div><div class="line">| solve                           |         1 |      4.83s |        53% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line">================================================================================</div><div class="line">START DATE: 2021/5/18, TIME: 16:26:00</div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Running with 2 MPI processes</div><div class="line">Vectorization over 4 doubles = 256 bits (AVX), VECTORIZATION_LEVEL=2</div><div class="line">Finite element space: <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(4)</div><div class="line">================================================================================</div><div class="line"></div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Cycle 5</div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Set up system...</div><div class="line">Triangulation: 229376 cells</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler</a>:    14729857 DoFs</div><div class="line"></div><div class="line">Solve <span class="keyword">using</span> Newton<span class="stringliteral">&#39;s method...</span></div><div class="line"><span class="stringliteral">Nstep 1, errf = 6.30096e-06, errx = 481.74, it = 8</span></div><div class="line"><span class="stringliteral">Nstep 2, errf = 4.25607e-10, errx = 4.14315, it = 6</span></div><div class="line"><span class="stringliteral">Nstep 3, errf = 7.29563e-13, errx = 0.000321775, it = 2</span></div><div class="line"><span class="stringliteral">Convergence step 3 value 7.29563e-13 (used wall time: 133.793 s)</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Time for setup+solve (CPU/Wall) 226.809/232.615 s</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Output results...</span></div><div class="line"><span class="stringliteral">H1 seminorm: 0.588667</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">+---------------------------------------------+------------+------------+</span></div><div class="line"><span class="stringliteral">| Total wallclock time elapsed since start    |       390s |            |</span></div><div class="line"><span class="stringliteral">|                                             |            |            |</span></div><div class="line"><span class="stringliteral">| Section                         | no. calls |  wall time | % of total |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral">| assemble right hand side        |         3 |      2.06s |      0.53% |</span></div><div class="line"><span class="stringliteral">| compute residual                |         3 |      2.46s |      0.63% |</span></div><div class="line"><span class="stringliteral">| compute update                  |         3 |       129s |        33% |</span></div><div class="line"><span class="stringliteral">| setup system                    |         1 |      98.8s |        25% |</span></div><div class="line"><span class="stringliteral">| solve                           |         1 |       134s |        34% |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div></div><!-- fragment --><p>We show the solution for the two- and three-dimensional problem in thefollowing figure. </p><div class="twocolumn" style="width: 80%; text-align:
 center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-66.solution-2d.png" alt="Solution of the two-dimensional Gelfand problem." width="100%"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-66.solution-3d.png" alt="Solution of the three-dimensional Gelfand problem." width="100%"/>
</div>
 </div> </div><p><a class="anchor" id="Newtonsolver"></a></p><h3>Newton solver</h3>
<p>In the program output above we find some interesting information about theNewton iterations. The terminal output in each refinement cycle presentsdetailed diagnostics of the Newton method, which show first of all the numberof Newton steps and for each step the norm of the residual \(\|F(u_h^{n+1})\|\) ,the norm of the Newton update \(\|s_h^n\|\) , and the number of CG iterations <code>it</code> . We observe that for all cases the Newton method converges in approximatelythree to four steps, which shows the quadratic convergence of the Newton methodwith a full step length \(\alpha = 1\) . However, be aware that for a badly choseninitial guess \(u_h^0\) , the Newton method will also diverge quadratically.Usually if you do not have an appropriate initial guess, you try a few dampedNewton steps with a reduced step length \(\alpha &lt; 1\) until the Newton step isagain in the quadratic convergence domain. This damping and relaxation of theNewton step length truly requires a more sophisticated implementation of theNewton method, which we designate to you as a possible extension of thetutorial. Furthermore, we see that the number of CG iterations is approximately constantwith successive mesh refinements and an increasing number of DoFs. This is ofcourse due to the geometric multigrid preconditioner and similar to theobservations made in other tutorials that use this method, e.g., <a class="el" href="step_16.html">step-16</a> and <a class="el" href="step_37.html">step-37</a> . Just to give an example, in the three-dimensional case after fiverefinements, we have approximately 14.7 million distributed DoFs withfourth-order Lagrangian finite elements, but the number of CG iterations isstill less than ten. In addition, there is one more very useful optimization that we applied andthat should be mentioned here. In the <code>compute_update()</code> function weexplicitly reset the vector holding the Newton update before passing it as theoutput vector to the solver. In that case we use a starting value of zero forthe CG method, which is more suitable than the previous Newton update, theactual content of the <code>newton_update</code> before resetting, and thusreduces the number of CG iterations by a few steps.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>A couple of possible extensions are available concerning minor updates fo thepresent code as well as a deeper numerical investigation of the Gelfand problem. <a class="anchor" id="MoresophisticatedNewtoniteration"></a></p><h4>More sophisticated Newton iteration</h4>
<p>Beside a step size controlled version of the Newton iteration as mentionedalready in <a class="el" href="step_15.html">step-15</a> , one could also implement a more flexible stopping criterionfor the Newton iteration. For example one could replace the fixed tolerancesfor the residual <code>TOLf</code> and for the Newton updated <code>TOLx</code> and implement a mixed error control with a given absolute and relativetolerance, such that the Newton iteration exists with success as, e.g., </p><p class="formulaDsp">
\begin{align*} \|F(u_h^{n+1})\| \leq \texttt{RelTol} \|u_h^{n+1}\| + \texttt{AbsTol}. \end{align*}
</p>
<p> For more advanced applications with many nonlinear systems to solve, forexample at each time step for a time-dependent problem, it turns out that it isnot necessary to set up and assemble the Jacobian anew at every single Newtonstep or even for each time step. Instead, the existing Jacobian from a previousstep can be used for the Newton iteration. The Jacobian is then only rebuiltif, for example, the Newton iteration converges too slowly. Such an idea yieldsa <a href="https://en.wikipedia.org/wiki/Quasi-Newton_method">quasi-Newton method</a>. Admittedly, when using the matrix-free framework, the assembly ofthe Jacobian is omitted anyway, but with in this way one can try to optimizethe reassembly of the geometric multigrid preconditioner. Remember that eachtime the solution from the old Newton step must be distributed to all levelsand the mutligrid preconditioner must be reinitialized. <a class="anchor" id="Parallelscalabilityandthreadparallelism"></a></p><h4>Parallel scalability and thread parallelism</h4>
<p>In the results section of <a class="el" href="step_37.html">step-37</a> and others, the parallel scalability of thematrix-free framework on a large number of processors has already beendemonstrated very impressively. In the nonlinear case we consider here, we notethat one of the bottlenecks could become the transfer and evaluation of thematrix-free Jacobi operator and its multistage operators in the previous Newtonstep, since we need to transfer the old solution at all stages in each step. Afirst parallel scalability analysis in <b>[castelli2021numerical]</b> shows quitegood strong scalability when the problem size is large enough. However, a moredetailed analysis needs to be performed for reliable results. Moreover, theproblem has been solved only with MPI so far, without using the possibilitiesof shared memory parallelization with threads. Therefore, for this example, youcould try hybrid parallelization with MPI and threads, such as described in <a class="el" href="step_48.html">step-48</a> . <a class="anchor" id="Comparisontomatrixbasedmethods"></a></p><h4>Comparison to matrix-based methods</h4>
<p>Analogously to <a class="el" href="step_50.html">step-50</a> and the mentioned possible extension of <a class="el" href="step_75.html">step-75</a> , you canconvince yourself which method is faster. <a class="anchor" id="Eigenvalueproblem"></a></p><h4>Eigenvalue problem</h4>
<p>One can consider the corresponding eigenvalue problem, which is called Bratuproblem. For example, if we define a fixed eigenvalue \(\lambda\in[0,6]\) , we cancompute the corresponding discrete eigenfunction. You will notice that thenumber of Newton steps will increase with increasing \(\lambda\) . To reduce thenumber of Newton steps you can use the following trick: start from a certain \(\lambda\) , compute the eigenfunction, increase \(\lambda=\lambda + \delta_\lambda\) , and then use the previous solution as an initial guess for theNewton iteration. In the end you can plot the \(H^1(\Omega)\) -norm over theeigenvalue \(\lambda \mapsto \|u_h\|_{H^1(\Omega)}\) . What do you observe forfurther increasing \(\lambda&gt;7\) ?</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Fabian Castelli, Karlsruhe Institute of Technology (KIT)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vectorization_8h.html">deal.II/base/vectorization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__accessor_8h.html">deal.II/grid/tria_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__iterator_8h.html">deal.II/grid/tria_iterator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tools_8h.html">deal.II/matrix_free/tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step66</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keyword">class </span>JacobianOperator</div><div class="line">    : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">        Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> FECellIntegrator =</div><div class="line">      <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a>;</div><div class="line"></div><div class="line">    JacobianOperator();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_newton_step(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">                <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">                <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_compute_diagonal(FECellIntegrator &amp;integrator) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; nonlinear_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  JacobianOperator&lt;dim, fe_degree, number&gt;::JacobianOperator()</div><div class="line">    : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                                <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">Vector</a>&lt;number&gt;&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">  {</div><div class="line">    nonlinear_values.reinit(0, 0);</div><div class="line">    <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">      clear();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">    FECellIntegrator   phi(*this-&gt;data);</div><div class="line"></div><div class="line">    nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        phi.read_dof_values_plain(newton_step);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    FECellIntegrator phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                        phi.get_matrix_free().n_cell_batches());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line"></div><div class="line">        phi.gather_evaluate(src,</div><div class="line">                            <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">            phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">          }</div><div class="line"></div><div class="line">        phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                                <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                              dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;JacobianOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">    FECellIntegrator &amp;phi)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                    phi.get_matrix_free().n_cell_batches());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = phi.get_current_cell_index();</div><div class="line"></div><div class="line">    phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">      {</div><div class="line">        phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">        phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">      }</div><div class="line"></div><div class="line">    phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">JacobianOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">  {</div><div class="line">    this-&gt;inverse_diagonal_entries.reset(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">      this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal</a>(*this-&gt;data,</div><div class="line">                                      inverse_diagonal,</div><div class="line">                                      &amp;JacobianOperator::local_compute_diagonal,</div><div class="line">                                      <span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;diagonal_element : inverse_diagonal)</div><div class="line">      {</div><div class="line">        diagonal_element = (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(diagonal_element) &gt; 1.0e-10) ?</div><div class="line">                             (1.0 / diagonal_element) :</div><div class="line">                             1.0;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keyword">class </span>GelfandProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    GelfandProblem();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_residual(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_evaluate_residual(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">      <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> compute_update();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_solution_norm() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>                mapping;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType = JacobianOperator&lt;dim, fe_degree, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = JacobianOperator&lt;dim, fe_degree, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a>                           mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_solution;</div><div class="line">    <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>                         mg_transfer;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> newton_update;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linear_iterations;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  GelfandProblem&lt;dim, fe_degree&gt;::GelfandProblem()</div><div class="line">    : triangulation(MPI_COMM_WORLD,</div><div class="line">                    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">                    <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;</div><div class="line">                      dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    , mapping(fe_degree)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    , computing_timer(MPI_COMM_WORLD,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;make grid&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>                boundary_manifold;</div><div class="line">    <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> inner_manifold;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(1);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, boundary_manifold);</div><div class="line"></div><div class="line">    inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, inner_manifold);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup system&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    mg_matrices.clear_elements();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::partition_color</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      <span class="keyword">auto</span> system_mf_storage = std::make_shared&lt;MatrixFree&lt;dim, double&gt;&gt;();</div><div class="line">      system_mf_storage-&gt;reinit(mapping,</div><div class="line">                                dof_handler,</div><div class="line">                                constraints,</div><div class="line">                                <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                additional_data);</div><div class="line"></div><div class="line">      system_matrix.initialize(system_mf_storage);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(solution);</div><div class="line">    system_matrix.initialize_dof_vector(newton_update);</div><div class="line">    system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">    mg_matrices.resize(0, nlevels - 1);</div><div class="line">    mg_solution.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">    dirichlet_boundary.insert(0);</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary);</div><div class="line"></div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a69e2b416ab209936f94db08e865cd92b">initialize_constraints</a>(mg_constrained_dofs);</div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      relevant_dofs);</div><div class="line"></div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">        <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">          <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::partition_color</a>;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">          (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">        <span class="keyword">auto</span> mg_mf_storage_level = std::make_shared&lt;MatrixFree&lt;dim, float&gt;&gt;();</div><div class="line">        mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    level_constraints,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                    additional_data);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                      mg_constrained_dofs,</div><div class="line">                                      level);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize_dof_vector(mg_solution[level]);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::evaluate_residual(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">auto</span> matrix_free = system_matrix.get_matrix_free();</div><div class="line"></div><div class="line">    matrix_free-&gt;cell_loop(</div><div class="line">      &amp;GelfandProblem::local_evaluate_residual, <span class="keyword">this</span>, dst, src, <span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::local_evaluate_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line"></div><div class="line">        phi.read_dof_values_plain(src);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            phi.submit_value(-std::exp(phi.get_value(q)), q);</div><div class="line">            phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">          }</div><div class="line"></div><div class="line">        phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                                <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                              dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assemble right hand side&quot;</span>);</div><div class="line"></div><div class="line">    evaluate_residual(system_rhs, solution);</div><div class="line"></div><div class="line">    system_rhs *= -1.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute residual&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> residual;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> evaluation_point;</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(residual);</div><div class="line">    system_matrix.initialize_dof_vector(evaluation_point);</div><div class="line"></div><div class="line">    evaluation_point = solution;</div><div class="line">    <span class="keywordflow">if</span> (alpha &gt; 1e-12)</div><div class="line">      {</div><div class="line">        evaluation_point.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a>(alpha, newton_update);</div><div class="line">      }</div><div class="line"></div><div class="line">    evaluate_residual(residual, evaluation_point);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line"></div><div class="line">    system_matrix.evaluate_newton_step(solution);</div><div class="line"></div><div class="line"></div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                            LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                           LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                         mg_smoother;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">    smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">          {</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 4;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            smoother_data[0].smoothing_range = 1e-3;</div><div class="line">            smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">          }</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line"></div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">      }</div><div class="line">    mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line">    <a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">      mg_coarse;</div><div class="line">    mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">      mg_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">      mg_interface_matrices;</div><div class="line">    mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_matrices[level]);</div><div class="line">      }</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">      mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">                   LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">                   <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1.e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    newton_update = 0.0;</div><div class="line"></div><div class="line">    cg.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(newton_update);</div><div class="line"></div><div class="line">    linear_iterations = solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>();</div><div class="line"></div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> itmax = 10;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       TOLf  = 1e-12;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       TOLx  = 1e-10;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> solver_timer;</div><div class="line">    solver_timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= itmax; ++newton_step)</div><div class="line">      {</div><div class="line">        assemble_rhs();</div><div class="line">        compute_update();</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ERRx = newton_update.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ERRf = compute_residual(1.0);</div><div class="line"></div><div class="line"></div><div class="line">        solution.add(1.0, newton_update);</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Nstep &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot;, errf = &quot;</span> &lt;&lt; ERRf</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, errx = &quot;</span> &lt;&lt; ERRx &lt;&lt; <span class="stringliteral">&quot;, it = &quot;</span> &lt;&lt; linear_iterations</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (ERRf &lt; TOLf || ERRx &lt; TOLx)</div><div class="line">          {</div><div class="line">            solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;Convergence step &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; value &quot;</span> &lt;&lt; ERRf</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; (used wall time: &quot;</span> &lt;&lt; solver_timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s)&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == itmax)</div><div class="line">          {</div><div class="line">            solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;WARNING: No convergence of Newton&#39;s method after &quot;</span></div><div class="line">                  &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; steps.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_solution_norm()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    solution.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values</a>();</div><div class="line"></div><div class="line">    Vector&lt;float&gt; norm_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                      norm_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                             norm_per_cell,</div><div class="line">                                             <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  GelfandProblem&lt;dim, fe_degree&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1e6)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      {</div><div class="line">        subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">      }</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                           fe.degree,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">    flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <span class="stringliteral">&quot;d&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">GelfandProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_ranks =</div><div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(double) * n_vect_doubles;</div><div class="line"></div><div class="line">      std::string DAT_header = <span class="stringliteral">&quot;START DATE: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#aff548b3b9b7a035ea112729700ef7c64">Utilities::System::get_date</a>() +</div><div class="line">                               <span class="stringliteral">&quot;, TIME: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">Utilities::System::get_time</a>();</div><div class="line">      std::string MPI_header = <span class="stringliteral">&quot;Running with &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_ranks) +</div><div class="line">                               <span class="stringliteral">&quot; MPI process&quot;</span> + (n_ranks &gt; 1 ? <span class="stringliteral">&quot;es&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">      std::string VEC_header =</div><div class="line">        <span class="stringliteral">&quot;Vectorization over &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_doubles) +</div><div class="line">        <span class="stringliteral">&quot; doubles = &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_bits) + <span class="stringliteral">&quot; bits (&quot;</span> +</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() +</div><div class="line">        <span class="stringliteral">&quot;), VECTORIZATION_LEVEL=&quot;</span> +</div><div class="line">        <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="config_8h.html#a32dc208a29f23d1f031fb40b0d21e60e">DEAL_II_COMPILER_VECTORIZATION_LEVEL</a>);</div><div class="line">      std::string SOL_header = <span class="stringliteral">&quot;Finite element space: &quot;</span> + fe.get_name();</div><div class="line"></div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; DAT_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      pcout &lt;&lt; MPI_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; VEC_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; SOL_header &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            make_grid();</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Set up system...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Triangulation: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; cells&quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   DoFHandler:    &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; DoFs&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Solve using Newton&#39;s method...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Time for setup+solve (CPU/Wall) &quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span></div><div class="line">              &lt;&lt; timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s&quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Output results...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> norm = compute_solution_norm();</div><div class="line">        output_results(cycle);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;  H1 seminorm: &quot;</span> &lt;&lt; norm &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step66</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step66;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;2, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;3, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a>, <a class="el" href="step_37.html">step-37</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemformulation">Problem formulation</a>
        <li><a href="#Discretizationwithfiniteelements">Discretization with finite elements</a>
        <li><a href="#Numericallinearalgebra">Numerical linear algebra</a>
        <li><a href="#Triangulation">Triangulation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#MatrixfreeJacobianOperator">Matrix-free JacobianOperator</a>
      <ul>
        <li><a href="#EvaluationoftheoldNewtonstep">Evaluation of the old Newton step</a>
        <li><a href="#Nonlinearmatrixfreeoperatorapplication">Nonlinear matrix-free operator application</a>
        <li><a href="#DiagonaloftheJacobianOperator">Diagonal of the JacobianOperator</a>
      </ul>
        <li><a href="#GelfandProblemclass">GelfandProblem class</a>
      <ul>
        <li><a href="#GelfandProblemmake_grid">GelfandProblem::make_grid</a>
        <li><a href="#GelfandProblemsetup_system">GelfandProblem::setup_system</a>
        <li><a href="#GelfandProblemevaluate_residual">GelfandProblem::evaluate_residual</a>
        <li><a href="#GelfandProblemlocal_evaluate_residual">GelfandProblem::local_evaluate_residual</a>
        <li><a href="#GelfandProblemassemble_rhs">GelfandProblem::assemble_rhs</a>
        <li><a href="#GelfandProblemcompute_residual">GelfandProblem::compute_residual</a>
        <li><a href="#GelfandProblemcompute_update">GelfandProblem::compute_update</a>
        <li><a href="#GelfandProblemsolve">GelfandProblem::solve</a>
        <li><a href="#GelfandProblemcompute_solution_norm">GelfandProblem::compute_solution_norm</a>
        <li><a href="#GelfandProblemoutput_results">GelfandProblem::output_results</a>
        <li><a href="#GelfandProblemrun">GelfandProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Programoutput">Program output</a>
        <li><a href="#Newtonsolver">Newton solver</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#MoresophisticatedNewtoniteration">More sophisticated Newton iteration</a>
        <li><a href="#Parallelscalabilityandthreadparallelism">Parallel scalability and thread parallelism</a>
        <li><a href="#Comparisontomatrixbasedmethods">Comparison to matrix-based methods</a>
        <li><a href="#Eigenvalueproblem">Eigenvalue problem</a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-66/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Fabian Castelli.</em></p>
<p><em>A version of this code was presented and discussed in <b>[castelli2021numerical]</b> G.F. Castelli: Numerical Investigation of Cahn-Hilliard-Type Phase-Field Models for Battery Active <a class="el" href="namespaceParticles.html">Particles</a>, PhD thesis, Karlsruhe Institute of Technology (KIT), 2021. (To be published)</em></p>
<p><em>Fabian Castelli acknowledges financial support by the German Research Foundation (DFG) through the Research Training Group 2218 SiMET &ndash; Simulation of mechano-electro-thermal processes in lithium-ion batteries, project number 281041241.</em></p>
<p><em>Finally Fabian Castelli would like to thank Timo Heister for the encouragement and advice in writing this tutorial. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>本教程程序的目的是演示如何在无矩阵框架内使用牛顿方法解决一个非线性问题。本教程结合了在步骤15、步骤16、步骤37、步骤48和其他中已经介绍的几种技术。</p>
<p><a class="anchor" id="Problemformulation"></a></p><h3>Problem formulation</h3>
<p>在单位圆 \(\Omega = \bigl\{ x \in \mathbb{R}^2 : \|x\| \leq 1 \bigr\}\) 上，我们考虑以下非线性椭圆边界值问题，受制于同质狄里奇边界条件。找到一个函数 \(u\colon\Omega\to\mathbb{R}\) ，使其成立。</p>
<p class="formulaDsp">
\begin{align*} - \Delta u &amp;= \exp(u) &amp; \quad &amp; \text{in } \Omega,\\ u &amp;= 0 &amp; \quad &amp; \text{on } \partial\Omega. \end{align*}
</p>
<p>这个问题也被称为 <em>Gelfand problem</em> ，是燃烧理论问题的一个典型例子，例如见 <b>[bebernes1989mathematical]</b> 。</p>
<p><a class="anchor" id="Discretizationwithfiniteelements"></a></p><h3>Discretization with finite elements</h3>
<p>像往常一样，我们首先推导出这个问题的弱式公式，用一个光滑的测试函数 \(v\colon\Omega\to\mathbb{R}\) 乘以边界条件，在域 \(\Omega\) 上积分。通过部分积分，并将右边的项放到左边，就得到了弱式计算。找到一个函数 \(u\colon\Omega\to\mathbb{R}\) ，使其对所有测试函数 \(v\) 都成立。</p>
<p class="formulaDsp">
\begin{align*} \int_\Omega \nabla v \cdot \nabla u \,\mathrm{d}x - \int_\Omega v \exp(u) \,\mathrm{d}x = 0. \end{align*}
</p>
<p>选择拉格朗日有限元空间 \(V_h \dealcoloneq \bigl\{ v \in C(\overline{\Omega}) : v|_Q \in \mathbb{Q}_p \text{ for all } Q \in \mathcal{T}_h \bigr\} \cap H_0^1(\Omega)\) ，它直接包含了同质Dirichlet边界条件，我们可以定义一个基 \(\{\varphi_i\}_{i=1,\dots,N}\) ，因此只需用这些基函数进行测试。因此离散的问题如下。找到 \(u_h\in V_h\) ，使得对所有 \(i=1,\dots,N\) 都成立。</p>
<p class="formulaDsp">
\begin{align*} F(u_h) \dealcoloneq \int_\Omega \nabla \varphi_i \cdot \nabla u_h \,\mathrm{d}x - \int_\Omega \varphi_i \exp(u_h) \,\mathrm{d}x \stackrel{!}{=} 0. \end{align*}
</p>
<p>由于每个有限元函数是基函数 \(\{\varphi_i\}_{i=1,\dots,N}\) 的线性组合，我们可以通过 \(\mathbb{R}^N\) 中由每个自由度（DOF）中的未知值组成的向量来确定有限元解决方案。因此，我们定义非线性函数 \(F\colon\mathbb{R}^N\to\mathbb{R}^N\) 代表离散非线性问题。</p>
<p>为了解决这个非线性问题，我们使用牛顿方法。因此，给定一个初始猜测 \(u_h^0\in V_h\) ，它已经满足了Dirichlet边界条件，我们通过连续应用以下方案确定一连串的牛顿步骤 \(\bigl( u_h^n \bigr)_n\) 。</p>
<p class="formulaDsp">
\begin{align*} &amp;\text{Solve for } s_h^n\in V_h: \quad &amp; F&#39;(u_h^n)[s_h^n] &amp;= -F(u_h^n),\\ &amp;\text{Update: } &amp; u_h^{n+1} &amp;= u_h^n + s_h^n. \end{align*}
</p>
<p>因此，在每个牛顿步骤中，我们必须解决一个线性问题 \(A\,x = b\) ，其中系统矩阵 \(A\) 由雅各布 \(F&#39;(u_h^n)[\,\cdot\,]\colon\mathbb{R}^N\to\mathbb{R}^N\) 表示，右手 \(b\) 由负残差 \(-F(u_h^n)\) 表示。在这种情况下，解向量 \(x\) 是 \(n\) 的第1个牛顿步骤的牛顿更新。注意，我们假设初始猜测 \(u_h^0\) ，它已经满足了问题公式中的迪里希特边界条件（事实上这也可能是一个不均匀的迪里希特边界条件），因此牛顿更新 \(s_h\) 满足一个均匀的迪里希特条件。</p>
<p>到目前为止，我们只测试了基函数，然而，我们也可以将 \(V_h\) 的任何函数表示为基函数的线性组合。在数学上，这意味着 \(V_h\) 的每个元素都可以通过表示公式与向量 \(U\in\mathbb{R}^N\) 相识别。 \(u_h = \sum_{i=1}^N U_i \varphi_i\) .因此，利用这一点我们可以给出离散雅各布和残差的表达式。</p>
<p class="formulaDsp">
\begin{align*} A_{i,j} = \bigl( F&#39;(u_h^n) \bigr)_{i,j} &amp;= \int_\Omega \nabla\varphi_i \cdot \nabla \varphi_j \,\mathrm{d} x - \int_\Omega \varphi_i \, \exp( u_h ) \varphi_j \,\mathrm{d} x,\\ b_{i} = \bigl( F(u_h^n) \bigr)_{i} &amp;= \int_\Omega \nabla\varphi_i \cdot \nabla u_h^n \,\mathrm{d} x - \int_\Omega \varphi_i \, \exp( u_h^n ) \,\mathrm{d} x. \end{align*}
</p>
<p>与第15步相比，我们也可以形成与问题的强表述相对应的非线性函数的Frech{'e}t导数，并在之后将其离散化。然而，最终我们会得到相同的离散方程组。</p>
<p><a class="anchor" id="Numericallinearalgebra"></a></p><h3>Numerical linear algebra</h3>
<p>注意，系统矩阵，实际上是Jacobian，如何取决于前一个牛顿步骤 \(A = F&#39;(u^n)\) 。因此，我们需要告诉计算系统矩阵的函数关于最后一个牛顿步骤的解决方案。在一个经典的 <code>assemble_system()</code> 函数的实现中，我们将通过使用成员函数 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 和 <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValuesBase::get_function_gradients()</a>. 从装配过程中的最后一个牛顿步骤中收集这些信息，然后 <code>assemble_system()</code> 函数看起来像。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0;</div><div class="line">  system_rhs    = 0;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell);</div><div class="line">  Vector&lt;double&gt;                       cell_rhs(dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; newton_step_gradients(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         newton_step_values(n_q_points);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix = 0.0;</div><div class="line">      cell_rhs    = 0.0;</div><div class="line"></div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, newton_step_values);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(solution, newton_step_gradients);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> nonlinearity = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(newton_step_values[q]);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> dx           = fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line"></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i      = fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i = fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line"></div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_j      = fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q);</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_j = fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q);</div><div class="line"></div><div class="line"></div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (grad_phi_i * grad_phi_j - phi_i * nonlinearity * phi_j) *</div><div class="line">                    dx;</div><div class="line">                }</div><div class="line"></div><div class="line"></div><div class="line">              cell_rhs(i) += (-grad_phi_i * newton_step_gradients[q] +</div><div class="line">                              phi_i * newton_step_values[q]) *</div><div class="line">                             dx;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line"></div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(</div><div class="line">        cell_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>由于我们想在不存储矩阵的情况下解决这个问题，我们需要在使用之前告诉无矩阵算子这些信息。因此在派生类 <code>JacobianOperator</code> 中，我们将实现一个名为 <code>evaluate_newton_step</code> 的函数，它将在使用矩阵-向量实现之前处理最后一个牛顿步骤的信息。此外，我们想对线性求解器使用几何多网格（GMG）预处理，所以为了应用多级算子，我们需要将最后一个牛顿步骤也传递给这些算子。这是一项棘手的任务，因为包含最后一个牛顿步骤的向量必须被插值到三角形的所有层面。在代码中，这项任务将由函数 <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>. 完成。注意，与之前的案例有一个根本的区别，即我们设置并使用了一个几何多网格预处理程序，我们可以重复使用MGTransferMatrixFree对象来计算所有牛顿步。所以我们在这里可以通过定义一个类变量，使用已经设置好的MGTransferMatrixFree对象 <code>mg_transfer</code> ，并在 <code>setup_system()</code> 函数中初始化，从而节省一些工作。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">  solution.update_ghost_values();</div><div class="line"></div><div class="line"></div><div class="line">  system_matrix.evaluate_newton_step(solution);</div><div class="line"></div><div class="line"></div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Set up options for the multilevel preconditioner</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Define the actual preconditioner</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Solve the linear system</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>评估非线性的函数与评估系数函数的步骤37的函数 <code>evaluate_coefficient</code> 的工作方式基本相同。我们的想法是使用一个FEEvaluation对象来评估牛顿步骤，并将所有单元和所有正交点的表达式存储在一个表中。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a> phi(*this-&gt;data);</div><div class="line"></div><div class="line"></div><div class="line">  nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values_plain(newton_step);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Triangulation"></a></p><h3><a class="el" href="classTriangulation.html">Triangulation</a></h3>
<p>正如在步骤37中所说，如果我们选择高阶有限元空间，无矩阵方法会变得更有效率。由于我们想在 \(d\) 维的单位球上解决问题，最好有一个适当的边界近似来克服收敛问题。出于这个原因，我们使用MappingQGeneric类的等参数方法来恢复平滑边界以及内单元的映射。此外，为了得到一个好的三角形，我们使用了TransfiniteInterpolationManifold。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First we include the typical headers of the deal.II library needed for this tutorial:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vectorization_8h.html">deal.II/base/vectorization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__accessor_8h.html">deal.II/grid/tria_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__iterator_8h.html">deal.II/grid/tria_iterator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>In particular, we need to include the headers for the matrix-free framework:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tools_8h.html">deal.II/matrix_free/tools.h</a>&gt;</span></div></div><!-- fragment --><p>And since we want to use a geometric multigrid preconditioner, we need also the multilevel headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div></div><!-- fragment --><p>Finally some common C++ headers for in and output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step66</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="MatrixfreeJacobianOperator"></a> </p><h3>Matrix-free JacobianOperator</h3>
<p>In the beginning we define the matrix-free operator for the Jacobian. As a guideline we follow the tutorials <a class="el" href="step_37.html">step-37</a> and <a class="el" href="step_48.html">step-48</a>, where the precise interface of the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class was extensively documented.</p>
<p>Since we want to use the Jacobian as system matrix and pass it to the linear solver as well as to the multilevel preconditioner classes, we derive the <code>JacobianOperator</code> class from the <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a> class, such that we have already the right interface. The two functions we need to override from the base class are the <a class="el" href="classMatrixFreeOperators_1_1Base.html#abc81493aad390198580330cc99203b3c">MatrixFreeOperators::Base::apply_add()</a> and the <a class="el" href="classMatrixFreeOperators_1_1Base.html#a16d883c49c69eef468b39b2e991d8b0d">MatrixFreeOperators::Base::compute_diagonal()</a> function. To allow preconditioning with float precision we define the number type as template argument.</p>
<p>As mentioned already in the introduction, we need to evaluate the Jacobian \(F&#39;\) at the last Newton step \(u_h^n\) for the computation of the Newton update \(s_h^n\). To get the information of the last Newton step \(u_h^n\) we do pretty much the same as in <a class="el" href="step_37.html">step-37</a>, where we stored the values of a coefficient function in a table <code>nonlinear_values</code> once before we use the matrix-free operator. Instead of a function <code>evaluate_coefficient()</code>, we here implement a function <code>evaluate_newton_step()</code>.</p>
<p>As additional private member functions of the <code>JacobianOperator</code> we implement the <code>local_apply()</code> and the <code>local_compute_diagonal()</code> function. The first one is the actual worker function for the matrix-vector application, which we pass to the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> in the <code>apply_add()</code> function. The later one is the worker function to compute the diagonal, which we pass to the <a class="el" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal()</a> function.</p>
<p>For better readability of the source code we further define an alias for the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keyword">class </span>JacobianOperator</div><div class="line">  : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">      Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> FECellIntegrator =</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a>;</div><div class="line"></div><div class="line">  JacobianOperator();</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_newton_step(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">              <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">              <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_compute_diagonal(FECellIntegrator &amp;integrator) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; nonlinear_values;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the <code>JacobianOperator</code> just calls the constructor of the base class <a class="el" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base</a>, which is itself derived from the <a class="el" href="classSubscriptor.html">Subscriptor</a> class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">JacobianOperator&lt;dim, fe_degree, number&gt;::JacobianOperator()</div><div class="line">  : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                              <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="classVector.html">Vector</a>&lt;number&gt;&gt;()</div><div class="line">{}</div></div><!-- fragment --><p>The <code>clear()</code> function resets the table holding the values for the nonlinearity and call the <code>clear()</code> function of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">{</div><div class="line">  nonlinear_values.reinit(0, 0);</div><div class="line">  <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">    clear();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EvaluationoftheoldNewtonstep"></a> </p><h4>Evaluation of the old Newton step</h4>
<p>The following <code>evaluate_newton_step()</code> function is based on the <code>evaluate_coefficient()</code> function from <a class="el" href="step_37.html">step-37</a>. However, it does not evaluate a function object, but evaluates a vector representing a finite element function, namely the last Newton step needed for the Jacobian. Therefore we set up a <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object and evaluate the finite element function in the quadrature points with the <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> and <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a> functions. We store the evaluated values of the finite element function directly in the <code>nonlinear_values</code> table.</p>
<p>This will work well and in the <code>local_apply()</code> function we can use the values stored in the table to apply the matrix-vector product. However, we can also optimize the implementation of the Jacobian at this stage. We can directly evaluate the nonlinear function <code>std::exp(newton_step[q])</code> and store these values in the table. This skips all evaluations of the nonlinearity in each call of the <code>vmult()</code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">  FECellIntegrator   phi(*this-&gt;data);</div><div class="line"></div><div class="line">  nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line">      phi.read_dof_values_plain(newton_step);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Nonlinearmatrixfreeoperatorapplication"></a> </p><h4>Nonlinear matrix-free operator application</h4>
<p>Now in the <code>local_apply()</code> function, which actually implements the cell wise action of the system matrix, we can use the information of the last Newton step stored in the table <code>nonlinear_values</code>. The rest of this function is basically the same as in <a class="el" href="step_37.html">step-37</a>. We set up the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object, gather and evaluate the values and gradients of the input vector <code>src</code>, submit the values and gradients according to the form of the Jacobian and finally call <a class="el" href="classFEEvaluation.html#a491779be7bd032d277e41f1dda8dc584">FEEvaluation::integrate_scatter()</a> to perform the cell integration and distribute the local contributions into the global vector <code> dst</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  FECellIntegrator phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                      phi.get_matrix_free().n_cell_batches());</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">      phi.reinit(cell);</div><div class="line"></div><div class="line">      phi.gather_evaluate(src,</div><div class="line">                          <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                            <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">          phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">        }</div><div class="line"></div><div class="line">      phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                            dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Next we use <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> to perform the actual loop over all cells computing the cell contribution to the matrix-vector product.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;JacobianOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="DiagonaloftheJacobianOperator"></a> </p><h4>Diagonal of the JacobianOperator</h4>
<p>The internal worker function <code>local_compute_diagonal()</code> for the computation of the diagonal is similar to the above worker function <code>local_apply()</code>. However, as major difference we do not read values from a input vector or distribute any local results to an output vector. Instead the only input argument is the used <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">  FECellIntegrator &amp;phi)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                  phi.get_matrix_free().n_cell_batches());</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = phi.get_current_cell_index();</div><div class="line"></div><div class="line">  phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">    {</div><div class="line">      phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">      phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">    }</div><div class="line"></div><div class="line">  phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">}</div></div><!-- fragment --><p>Finally we override the <a class="el" href="classMatrixFreeOperators_1_1Base.html#a16d883c49c69eef468b39b2e991d8b0d">MatrixFreeOperators::Base::compute_diagonal()</a> function of the base class of the <code>JacobianOperator</code>. Although the name of the function suggests just the computation of the diagonal, this function does a bit more. Because we only really need the inverse of the matrix diagonal elements for the Chebyshev smoother of the multigrid preconditioner, we compute the diagonal and store the inverse elements. Therefore we first initialize the <code>inverse_diagonal_entries</code>. Then we compute the diagonal by passing the worker function <code>local_compute_diagonal()</code> to the <a class="el" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal()</a> function. In the end we loop over the diagonal and invert the elements by hand. Note, that during this loop we catch the constrained DOFs and set them manually to one.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">JacobianOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">{</div><div class="line">  this-&gt;inverse_diagonal_entries.reset(</div><div class="line">    <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">    this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">  this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal</a>(*this-&gt;data,</div><div class="line">                                    inverse_diagonal,</div><div class="line">                                    &amp;JacobianOperator::local_compute_diagonal,</div><div class="line">                                    <span class="keyword">this</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;diagonal_element : inverse_diagonal)</div><div class="line">    {</div><div class="line">      diagonal_element = (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(diagonal_element) &gt; 1.0e-10) ?</div><div class="line">                           (1.0 / diagonal_element) :</div><div class="line">                           1.0;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemclass"></a> </p><h3>GelfandProblem class</h3>
<p>After implementing the matrix-free operators we can now define the solver class for the <em>Gelfand problem</em>. This class is based on the common structure of all previous tutorial programs, in particular it is based on <a class="el" href="step_15.html">step-15</a>, solving also a nonlinear problem. Since we are using the matrix-free framework, we no longer need an assemble_system function any more, instead the information of the matrix is rebuilt in every call of the <code>vmult()</code> function. However, for the application of the Newton scheme we need to assemble the right hand side of the linearized problems and compute the residuals. Therefore, we implement an additional function <code>evaluate_residual()</code>, which we later call in the <code>assemble_rhs()</code> and the <code>compute_residual()</code> function. Finally, the typical <code>solve()</code> function here implements the Newton method, whereas the solution of the linearized system is computed in the function <code>compute_update()</code>. As the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework handles the polynomial degree of the Lagrangian finite element method as a template parameter, we declare it also as a template parameter for the problem solver class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>GelfandProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  GelfandProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> evaluate_residual(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_evaluate_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> compute_update();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_solution_norm() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div></div><!-- fragment --><p>For the parallel computation we define a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. As the computational domain is a circle in 2D and a ball in 3D, we assign in addition to the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> for boundary cells a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> object for the mapping of the inner cells, which takes care of the inner cells. In this example we use an isoparametric finite element approach and thus use the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> class. Note, that we could also create an instance of the <a class="el" href="classMappingQ.html">MappingQ</a> class and set the <code>use_mapping_q_on_all_cells</code> flags in the contructor call to <code>true</code>. For further details on the connection of <a class="el" href="classMappingQ.html">MappingQ</a> and <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> you may read the detailed description of these classes.</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>                mapping;</div></div><!-- fragment --><p>As usual we then define the Lagrangian finite elements <a class="el" href="classFE__Q.html">FE_Q</a> and a <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div></div><!-- fragment --><p>For the linearized discrete system we define an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects and the <code>system_matrix</code>, which is in this example represented as a matrix-free operator.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"><span class="keyword">using</span> SystemMatrixType = JacobianOperator&lt;dim, fe_degree, double&gt;;</div><div class="line">SystemMatrixType system_matrix;</div></div><!-- fragment --><p>The multilevel object is also based on the matrix-free operator for the Jacobian. Since we need to evaluate the Jacobian with the last Newton step, we also need to evaluate the level operator with the last Newton step for the preconditioner. Thus in addition to <code>mg_matrices</code>, we also need a <a class="el" href="classMGLevelObject.html">MGLevelObject</a> to store the interpolated solution vector on each level. As in <a class="el" href="step_37.html">step-37</a> we use float precision for the preconditioner. Moreover, we define the <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> object as a class variable, since we need to set it up only once when the triangulation has changed and can then use it again in each Newton step.</p>
<div class="fragment"><div class="line"><a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line"><span class="keyword">using</span> LevelMatrixType = JacobianOperator&lt;dim, fe_degree, float&gt;;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a>                           mg_matrices;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_solution;</div><div class="line"><a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>                         mg_transfer;</div></div><!-- fragment --><p>Of course we also need vectors holding the <code>solution</code>, the <code>newton_update</code> and the <code>system_rhs</code>. In that way we can always store the last Newton step in the solution vector and just add the update to get the next Newton step.</p>
<div class="fragment"><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> newton_update;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div></div><!-- fragment --><p>Finally we have a variable for the number of iterations of the linear solver.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linear_iterations;</div></div><!-- fragment --><p>For the output in programs running in parallel with MPI, we use the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> class to avoid multiple output of the same data by different MPI ranks.</p>
<div class="fragment"><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div></div><!-- fragment --><p>Finally for the time measurement we use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object, which prints the elapsed CPU and wall times for each function in a nicely formatted table after the program has finished.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the <code>GelfandProblem</code> initializes the class variables. In particular, we set up the multilevel support for the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, set the mapping degree equal to the finite element degree, initialize the <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> and tell the <a class="el" href="classTimerOutput.html">TimerOutput</a> that we want to see the wall times only on demand.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">GelfandProblem&lt;dim, fe_degree&gt;::GelfandProblem()</div><div class="line">  : triangulation(MPI_COMM_WORLD,</div><div class="line">                  <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">                  <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;</div><div class="line">                    dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">  , mapping(fe_degree)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">  , computing_timer(MPI_COMM_WORLD,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemmake_grid"></a> </p><h4>GelfandProblem::make_grid</h4>
<p>As the computational domain we use the <code>dim</code>-dimensional unit ball. We follow the instructions for the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class and also assign a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> for the boundary. Finally, we refine the initial mesh 3 - <code>dim</code> times globally.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;make grid&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>                boundary_manifold;</div><div class="line">  <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> inner_manifold;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(1);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, boundary_manifold);</div><div class="line"></div><div class="line">  inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, inner_manifold);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemsetup_system"></a> </p><h4>GelfandProblem::setup_system</h4>
<p>The <code>setup_system()</code> function is quasi identical to the one in <a class="el" href="step_37.html">step-37</a>. The only differences are obviously the time measurement with only one <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> instead of measuring each part individually, and more importantly the initialization of the <a class="el" href="classMGLevelObject.html">MGLevelObject</a> for the interpolated solution vector of the previous Newton step. Another important change is the setup of the <a class="el" href="classMGTransferMatrixFree.html">MGTransferMatrixFree</a> object, which we can reuse in each Newton step as the <code>triangulation</code> will not be not changed.</p>
<p>Note how we can use the same <a class="el" href="classMatrixFree.html">MatrixFree</a> object twice, for the <code>JacobianOperator</code> and the multigrid preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup system&quot;</span>);</div><div class="line"></div><div class="line">  system_matrix.clear();</div><div class="line">  mg_matrices.clear_elements();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">      <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::partition_color</a>;</div><div class="line">    additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">      (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <span class="keyword">auto</span> system_mf_storage = std::make_shared&lt;MatrixFree&lt;dim, double&gt;&gt;();</div><div class="line">    system_mf_storage-&gt;reinit(mapping,</div><div class="line">                              dof_handler,</div><div class="line">                              constraints,</div><div class="line">                              <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                              additional_data);</div><div class="line"></div><div class="line">    system_matrix.initialize(system_mf_storage);</div><div class="line">  }</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(solution);</div><div class="line">  system_matrix.initialize_dof_vector(newton_update);</div><div class="line">  system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">  mg_matrices.resize(0, nlevels - 1);</div><div class="line">  mg_solution.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">  dirichlet_boundary.insert(0);</div><div class="line">  mg_constrained_dofs.initialize(dof_handler);</div><div class="line">  mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                     dirichlet_boundary);</div><div class="line"></div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a69e2b416ab209936f94db08e865cd92b">initialize_constraints</a>(mg_constrained_dofs);</div><div class="line">  mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                    level,</div><div class="line">                                                    relevant_dofs);</div><div class="line"></div><div class="line">      <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">        mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">      level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::partition_color</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">      <span class="keyword">auto</span> mg_mf_storage_level = std::make_shared&lt;MatrixFree&lt;dim, float&gt;&gt;();</div><div class="line">      mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                  dof_handler,</div><div class="line">                                  level_constraints,</div><div class="line">                                  <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                  additional_data);</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                    mg_constrained_dofs,</div><div class="line">                                    level);</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize_dof_vector(mg_solution[level]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemevaluate_residual"></a> </p><h4>GelfandProblem::evaluate_residual</h4>
<p>Next we implement a function which evaluates the nonlinear discrete residual for a given input vector ( \(\texttt{dst} = F(\texttt{src})\)). This function is then used for the assembly of the right hand side of the linearized system and later for the computation of the residual of the next Newton step to check if we already reached the error tolerance. As this function should not affect any class variable we define it as a constant function. Internally we exploit the fast finite element evaluation through the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class and the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>, similar to <code>apply_add()</code> function of the <code>JacobianOperator</code>.</p>
<p>First we create a pointer to the <a class="el" href="classMatrixFree.html">MatrixFree</a> object, which is stored in the <code>system_matrix</code>. Then we pass the worker function <code>local_evaluate_residual()</code> for the cell wise evaluation of the residual together with the input and output vector to the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>. In addition, we enable the zero out of the output vector in the loop, which is more efficient than calling <code>dst = 0.0</code> separately before.</p>
<p>Note that with this approach we do not have to take care about the MPI related data exchange, since all the bookkeeping is done by the <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::evaluate_residual(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">auto</span> matrix_free = system_matrix.get_matrix_free();</div><div class="line"></div><div class="line">  matrix_free-&gt;cell_loop(</div><div class="line">    &amp;GelfandProblem::local_evaluate_residual, <span class="keyword">this</span>, dst, src, <span class="keyword">true</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemlocal_evaluate_residual"></a> </p><h4>GelfandProblem::local_evaluate_residual</h4>
<p>This is the internal worker function for the evaluation of the residual. Essentially it has the same structure as the <code>local_apply()</code> function of the <code>JacobianOperator</code> and evaluates the residual for the input vector <code>src</code> on the given set of cells <code>cell_range</code>. The difference to the above mentioned <code>local_apply()</code> function is, that we split the <a class="el" href="classFEEvaluation.html#ab53d5c08f460cfe6c9830ac14a427115">FEEvaluation::gather_evaluate()</a> function into <a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">FEEvaluation::read_dof_values_plain()</a> and <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a>, since the input vector might have constrained DOFs.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::local_evaluate_residual(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">  <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a> phi(data);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">    {</div><div class="line">      phi.reinit(cell);</div><div class="line"></div><div class="line">      phi.read_dof_values_plain(src);</div><div class="line">      phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">        {</div><div class="line">          phi.submit_value(-std::exp(phi.get_value(q)), q);</div><div class="line">          phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">        }</div><div class="line"></div><div class="line">      phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                            dst);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemassemble_rhs"></a> </p><h4>GelfandProblem::assemble_rhs</h4>
<p>Using the above function <code>evaluate_residual()</code> to evaluate the nonlinear residual, the assembly of the right hand side of the linearized system becomes now a very easy task. We just call the <code>evaluate_residual()</code> function and multiply the result with minus one.</p>
<p>Experiences show that using the <a class="el" href="classFEEvaluation.html">FEEvaluation</a> class is much faster than a classical implementation with <a class="el" href="classFEValues.html">FEValues</a> and co.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assemble right hand side&quot;</span>);</div><div class="line"></div><div class="line">  evaluate_residual(system_rhs, solution);</div><div class="line"></div><div class="line">  system_rhs *= -1.0;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_residual"></a> </p><h4>GelfandProblem::compute_residual</h4>
<p>According to <a class="el" href="step_15.html">step-15</a> the following function computes the norm of the nonlinear residual for the solution \(u_h^n + \alpha s_h^n\) with the help of the <code>evaluate_residual()</code> function. The Newton step length \(\alpha\) becomes important if we would use an adaptive version of the Newton method. Then for example we would compute the residual for different step lengths and compare the residuals. However, for our problem the full Newton step with \(\alpha=1\) is the best we can do. An adaptive version of Newton's method becomes interesting if we have no good initial value. Note that in theory Newton's method converges with quadratic order, but only if we have an appropriate initial value. For unsuitable initial values the Newton method diverges even with quadratic order. A common way is then to use a damped version \(\alpha&lt;1\) until the Newton step is good enough and the full Newton step can be performed. This was also discussed in <a class="el" href="step_15.html">step-15</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute residual&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> residual;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> evaluation_point;</div><div class="line"></div><div class="line">  system_matrix.initialize_dof_vector(residual);</div><div class="line">  system_matrix.initialize_dof_vector(evaluation_point);</div><div class="line"></div><div class="line">  evaluation_point = solution;</div><div class="line">  <span class="keywordflow">if</span> (alpha &gt; 1e-12)</div><div class="line">    {</div><div class="line">      evaluation_point.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a>(alpha, newton_update);</div><div class="line">    }</div><div class="line"></div><div class="line">  evaluate_residual(residual, evaluation_point);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_update"></a> </p><h4>GelfandProblem::compute_update</h4>
<p>In order to compute the Newton updates in each Newton step we solve the linear system with the CG algorithm together with a geometric multigrid preconditioner. For this we first set up the <a class="el" href="classPreconditionMG.html">PreconditionMG</a> object with a Chebyshev smoother like we did in <a class="el" href="step_37.html">step-37</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div></div><!-- fragment --><p>We remember that the Jacobian depends on the last Newton step stored in the solution vector. So we update the ghost values of the Newton step and pass it to the <code>JacobianOperator</code> to store the information.</p>
<div class="fragment"><div class="line">solution.update_ghost_values();</div><div class="line"></div><div class="line">system_matrix.evaluate_newton_step(solution);</div></div><!-- fragment --><p>Next we also have to pass the last Newton step to the multilevel operators. Therefore, we need to interpolate the Newton step to all levels of the triangulation. This is done with the <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>.</p>
<div class="fragment"><div class="line">mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div></div><!-- fragment --><p>Now we can set up the preconditioner. We define the smoother and pass the interpolated vectors of the Newton step to the multilevel operators.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> SmootherType =</div><div class="line">  <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                        LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                       LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                     mg_smoother;</div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">      {</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 4;</div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        smoother_data[0].smoothing_range = 1e-3;</div><div class="line">        smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">        smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">      }</div><div class="line"></div><div class="line">    mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line">    mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line"></div><div class="line">    smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">  }</div><div class="line">mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line"><a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">  mg_coarse;</div><div class="line">mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">  mg_matrices);</div><div class="line"></div><div class="line"><a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">  mg_interface_matrices;</div><div class="line">mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">     ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">  {</div><div class="line">    mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_matrices[level]);</div><div class="line">  }</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">  mg_interface_matrices);</div><div class="line"></div><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">               LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">               <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>Finally we set up the <a class="el" href="classSolverControl.html">SolverControl</a> and the <a class="el" href="classSolverCG.html">SolverCG</a> to solve the linearized problem for the current Newton update. An important fact of the implementation of <a class="el" href="classSolverCG.html">SolverCG</a> or also <a class="el" href="classSolverGMRES.html">SolverGMRES</a> is, that the vector holding the solution of the linear system (here <code>newton_update</code>) can be used to pass a starting value. In order to start the iterative solver always with a zero vector we reset the <code>newton_update</code> explicitly before calling <a class="el" href="classSolverCG.html#aa52469650d9b9ef2f4cb4884caeb0723">SolverCG::solve()</a>. Afterwards we distribute the Dirichlet boundary conditions stored in <code>constraints</code> and store the number of iteration steps for the later output.</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1.e-12);</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">newton_update = 0.0;</div><div class="line"></div><div class="line">cg.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(newton_update);</div><div class="line"></div><div class="line">linear_iterations = solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>();</div></div><!-- fragment --><p>Then for bookkeeping we zero out the ghost values.</p>
<div class="fragment"><div class="line">  solution.zero_out_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemsolve"></a> </p><h4>GelfandProblem::solve</h4>
<p>Now we implement the actual Newton solver for the nonlinear problem.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>);</div></div><!-- fragment --><p>We define a maximal number of Newton steps and tolerances for the convergence criterion. Usually, with good starting values, the Newton method converges in three to six steps, so maximal ten steps should be totally sufficient. As tolerances we use \(\|F(u^n_h)\|&lt;\text{TOL}_f = 10^{-12}\) for the norm of the residual and \(\|s_h^n\| &lt; \text{TOL}_x = 10^{-10}\) for the norm of the Newton update. This seems a bit over the top, but we will see that, for our example, we will achieve these tolerances after a few steps.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> itmax = 10;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       TOLf  = 1e-12;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>       TOLx  = 1e-10;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTimer.html">Timer</a> solver_timer;</div><div class="line">solver_timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div></div><!-- fragment --><p>Now we start the actual Newton iteration.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= itmax; ++newton_step)</div><div class="line">  {</div></div><!-- fragment --><p>We assemble the right hand side of the linearized problem and compute the Newton update.</p>
<div class="fragment"><div class="line">assemble_rhs();</div><div class="line">compute_update();</div></div><!-- fragment --><p>Then we compute the errors, namely the norm of the Newton update and the residual. Note that at this point one could incorporate a step size control for the Newton method by varying the input parameter \(\alpha\) for the compute_residual function. However, here we just use \(\alpha\) equal to one for a plain Newton iteration.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> ERRx = newton_update.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> ERRf = compute_residual(1.0);</div></div><!-- fragment --><p>Next we advance the Newton step by adding the Newton update to the current Newton step.</p>
<div class="fragment"><div class="line">solution.add(1.0, newton_update);</div></div><!-- fragment --><p>A short output will inform us on the current Newton step.</p>
<div class="fragment"><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Nstep &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot;, errf = &quot;</span> &lt;&lt; ERRf</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot;, errx = &quot;</span> &lt;&lt; ERRx &lt;&lt; <span class="stringliteral">&quot;, it = &quot;</span> &lt;&lt; linear_iterations</div><div class="line">      &lt;&lt; std::endl;</div></div><!-- fragment --><p>After each Newton step we check the convergence criteria. If at least one of those is fulfilled we are done and end the loop. If we haven't found a satisfying solution after the maximal amount of Newton iterations, we inform the user about this shortcoming.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (ERRf &lt; TOLf || ERRx &lt; TOLx)</div><div class="line">        {</div><div class="line">          solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;Convergence step &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; value &quot;</span> &lt;&lt; ERRf</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; (used wall time: &quot;</span> &lt;&lt; solver_timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s)&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == itmax)</div><div class="line">        {</div><div class="line">          solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;WARNING: No convergence of Newton&#39;s method after &quot;</span></div><div class="line">                &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; steps.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemcompute_solution_norm"></a> </p><h4>GelfandProblem::compute_solution_norm</h4>
<p>The computation of the H1-seminorm of the solution can be done in the same way as in <a class="el" href="step_59.html">step-59</a>. We update the ghost values and use the function <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. In the end we gather all computations from all MPI ranks and return the norm.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_solution_norm()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  solution.update_ghost_values();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> norm_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                    norm_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">  solution.zero_out_ghost_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                           norm_per_cell,</div><div class="line">                                           <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemoutput_results"></a> </p><h4>GelfandProblem::output_results</h4>
<p>We generate the graphical output files in vtu format together with a pvtu master file at once by calling the <a class="el" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">DataOut::write_vtu_with_pvtu_record()</a> function in the same way as in <a class="el" href="step_37.html">step-37</a>. In addition, as in <a class="el" href="step_40.html">step-40</a>, we query the <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> of each cell and write the distribution of the triangulation among the MPI ranks into the output file. Finally, we generate the patches of the solution by calling <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. However, since we have a computational domain with a curved boundary, we additionally pass the <code>mapping</code> and the finite element degree as number of subdivision. But this is still not enough for the correct representation of the solution, for example in ParaView, because we attached a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to the inner cells, which results in curved cells in the interior. Therefore we pass as third argument the <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ad8379a354d5bd6484471f6bf755cd111">DataOut::curved_inner_cells</a> option, such that also the inner cells use the corresponding manifold description to build the patches.</p>
<p>Note that we could handle the higher order elements with the flag <a class="el" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">DataOutBase::VtkFlags::write_higher_order_cells</a>. However, due to the limited compatibility to previous version of ParaView and the missing support by VisIt, we left this option for a future version.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">GelfandProblem&lt;dim, fe_degree&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1e6)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  solution.update_ghost_values();</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">    {</div><div class="line">      subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">    }</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                         fe.degree,</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <span class="stringliteral">&quot;d&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">  solution.zero_out_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="GelfandProblemrun"></a> </p><h4>GelfandProblem::run</h4>
<p>The last missing function of the solver class for the <em>Gelfand problem</em> is the run function. In the beginning we print information about the system specifications and the finite element space we use. The problem is solved several times on a successively refined mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">GelfandProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_ranks =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(double) * n_vect_doubles;</div><div class="line"></div><div class="line">    std::string DAT_header = <span class="stringliteral">&quot;START DATE: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#aff548b3b9b7a035ea112729700ef7c64">Utilities::System::get_date</a>() +</div><div class="line">                             <span class="stringliteral">&quot;, TIME: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">Utilities::System::get_time</a>();</div><div class="line">    std::string MPI_header = <span class="stringliteral">&quot;Running with &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_ranks) +</div><div class="line">                             <span class="stringliteral">&quot; MPI process&quot;</span> + (n_ranks &gt; 1 ? <span class="stringliteral">&quot;es&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">    std::string VEC_header =</div><div class="line">      <span class="stringliteral">&quot;Vectorization over &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_doubles) +</div><div class="line">      <span class="stringliteral">&quot; doubles = &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_bits) + <span class="stringliteral">&quot; bits (&quot;</span> +</div><div class="line">      <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() +</div><div class="line">      <span class="stringliteral">&quot;), VECTORIZATION_LEVEL=&quot;</span> +</div><div class="line">      <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="config_8h.html#a32dc208a29f23d1f031fb40b0d21e60e">DEAL_II_COMPILER_VECTORIZATION_LEVEL</a>);</div><div class="line">    std::string SOL_header = <span class="stringliteral">&quot;Finite element space: &quot;</span> + fe.get_name();</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; DAT_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; MPI_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; VEC_header &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; SOL_header &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">    {</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>The first task in actually solving the problem is to generate or refine the triangulation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cycle == 0)</div><div class="line">  {</div><div class="line">    make_grid();</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">  }</div></div><!-- fragment --><p>Now we set up the system and solve the problem. These steps are accompanied by time measurement and textual output.</p>
<div class="fragment"><div class="line"><a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Set up system...&quot;</span> &lt;&lt; std::endl;</div><div class="line">setup_system();</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   Triangulation: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">      &lt;&lt; <span class="stringliteral">&quot; cells&quot;</span> &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;   DoFHandler:    &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; DoFs&quot;</span></div><div class="line">      &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Solve using Newton&#39;s method...&quot;</span> &lt;&lt; std::endl;</div><div class="line">solve();</div><div class="line">pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Time for setup+solve (CPU/Wall) &quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span></div><div class="line">      &lt;&lt; timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s&quot;</span> &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div></div><!-- fragment --><p>After the problem was solved we compute the norm of the solution and generate the graphical output files.</p>
<div class="fragment"><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;Output results...&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> norm = compute_solution_norm();</div><div class="line">output_results(cycle);</div><div class="line"></div><div class="line">pcout &lt;&lt; <span class="stringliteral">&quot;  H1 seminorm: &quot;</span> &lt;&lt; norm &lt;&lt; std::endl;</div><div class="line">pcout &lt;&lt; std::endl;</div></div><!-- fragment --><p>Finally after each cycle we print the timing information.</p>
<div class="fragment"><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step66</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>As typical for programs running in parallel with MPI we set up the MPI framework and disable shared-memory parallelization by limiting the number of threads to one. Finally to run the solver for the <em>Gelfand problem</em> we create an object of the <code>GelfandProblem</code> class and call the run function. Exemplarily we solve the problem once in 2D and once in 3D each with fourth-order Lagrangian finite elements.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step66;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;2, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;3, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-66/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>这个教程步骤的目的是演示用无矩阵框架解决一个非线性PDE。</p>
<p><a class="anchor" id="Programoutput"></a></p><h3>Program output</h3>
<p>在两个进程上以释放模式运行程序，通过</p>
<div class="fragment"><div class="line">cmake . &amp;&amp; make release &amp;&amp; make &amp;&amp; mpirun -n 2 ./step-66</div></div><!-- fragment --><p>在控制台给出了以下输出</p>
<div class="fragment"><div class="line">================================================================================</div><div class="line">START DATE: 2021/5/18, TIME: 16:25:48</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Running with 2 MPI processes</div><div class="line">Vectorization over 4 doubles = 256 bits (AVX), VECTORIZATION_LEVEL=2</div><div class="line">Finite element space: <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a>(4)</div><div class="line">================================================================================</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Cycle 0</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Set up system...</div><div class="line">   <a class="code" href="classTriangulation.html">Triangulation</a>: 20 cells</div><div class="line">   <a class="code" href="classDoFHandler.html">DoFHandler</a>:    337 DoFs</div><div class="line"></div><div class="line"></div><div class="line">Solve <span class="keyword">using</span> Newton<span class="stringliteral">&#39;s method...</span></div><div class="line"><span class="stringliteral">   Nstep 1, errf = 0.00380835, errx = 3.61904, it = 7</span></div><div class="line"><span class="stringliteral">   Nstep 2, errf = 3.80167e-06, errx = 0.104353, it = 6</span></div><div class="line"><span class="stringliteral">   Nstep 3, errf = 3.97939e-12, errx = 0.00010511, it = 4</span></div><div class="line"><span class="stringliteral">   Nstep 4, errf = 2.28859e-13, errx = 1.07726e-10, it = 1</span></div><div class="line"><span class="stringliteral">Convergence step 4 value 2.28859e-13 (used wall time: 0.0096409 s)</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Time for setup+solve (CPU/Wall) 0.015617/0.0156447 s</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Output results...</span></div><div class="line"><span class="stringliteral">  H1 seminorm: 0.773426</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">+---------------------------------------------+------------+------------+</span></div><div class="line"><span class="stringliteral">| Total wallclock time elapsed since start    |    0.0286s |            |</span></div><div class="line"><span class="stringliteral">|                                             |            |            |</span></div><div class="line"><span class="stringliteral">| Section                         | no. calls |  wall time | % of total |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral">| assemble right hand side        |         4 |  9.71e-05s |      0.34% |</span></div><div class="line"><span class="stringliteral">| compute residual                |         4 |  0.000137s |      0.48% |</span></div><div class="line"><span class="stringliteral">| compute update                  |         4 |   0.00901s |        32% |</span></div><div class="line"><span class="stringliteral">| make grid                       |         1 |   0.00954s |        33% |</span></div><div class="line"><span class="stringliteral">| setup system                    |         1 |   0.00585s |        20% |</span></div><div class="line"><span class="stringliteral">| solve                           |         1 |   0.00966s |        34% |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral">.</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">--------------------------------------------------------------------------------</span></div><div class="line"><span class="stringliteral">Cycle 6</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">--------------------------------------------------------------------------------</span></div><div class="line"><span class="stringliteral">Set up system...</span></div><div class="line"><span class="stringliteral">   Triangulation: 81920 cells</span></div><div class="line"><span class="stringliteral">   DoFHandler:    1311745 DoFs</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Solve using Newton&#39;</span>s method...</div><div class="line">   Nstep 1, errf = 5.90478e-05, errx = 231.427, it = 9</div><div class="line">   Nstep 2, errf = 5.89991e-08, errx = 6.67102, it = 6</div><div class="line">   Nstep 3, errf = 4.28813e-13, errx = 0.0067188, it = 4</div><div class="line">Convergence step 3 value 4.28813e-13 (used wall time: 4.82953 s)</div><div class="line"></div><div class="line"></div><div class="line">Time <span class="keywordflow">for</span> setup+solve (CPU/Wall) 6.25094/6.37174 s</div><div class="line"></div><div class="line"></div><div class="line">Output results...</div><div class="line">  H1 seminorm: 0.773426</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      9.04s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| <a class="code" href="namespaceinternal.html#a2b3d48efdf7c94da455dc6a3553bab79">assemble</a> right hand side        |         3 |    0.0827s |      0.91% |</div><div class="line">| compute residual                |         3 |    0.0909s |         1% |</div><div class="line">| compute update                  |         3 |      4.65s |        51% |</div><div class="line">| setup system                    |         1 |      1.54s |        17% |</div><div class="line">| solve                           |         1 |      4.83s |        53% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line">================================================================================</div><div class="line">START DATE: 2021/5/18, TIME: 16:26:00</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Running with 2 MPI processes</div><div class="line">Vectorization over 4 doubles = 256 bits (AVX), VECTORIZATION_LEVEL=2</div><div class="line">Finite element space: <a class="code" href="classFE__Q.html">FE_Q&lt;3&gt;</a>(4)</div><div class="line">================================================================================</div><div class="line"></div><div class="line"></div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Cycle 5</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------------------------------</div><div class="line">Set up system...</div><div class="line">   <a class="code" href="classTriangulation.html">Triangulation</a>: 229376 cells</div><div class="line">   <a class="code" href="classDoFHandler.html">DoFHandler</a>:    14729857 DoFs</div><div class="line"></div><div class="line"></div><div class="line">Solve <span class="keyword">using</span> Newton<span class="stringliteral">&#39;s method...</span></div><div class="line"><span class="stringliteral">   Nstep 1, errf = 6.30096e-06, errx = 481.74, it = 8</span></div><div class="line"><span class="stringliteral">   Nstep 2, errf = 4.25607e-10, errx = 4.14315, it = 6</span></div><div class="line"><span class="stringliteral">   Nstep 3, errf = 7.29563e-13, errx = 0.000321775, it = 2</span></div><div class="line"><span class="stringliteral">Convergence step 3 value 7.29563e-13 (used wall time: 133.793 s)</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Time for setup+solve (CPU/Wall) 226.809/232.615 s</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Output results...</span></div><div class="line"><span class="stringliteral">  H1 seminorm: 0.588667</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">+---------------------------------------------+------------+------------+</span></div><div class="line"><span class="stringliteral">| Total wallclock time elapsed since start    |       390s |            |</span></div><div class="line"><span class="stringliteral">|                                             |            |            |</span></div><div class="line"><span class="stringliteral">| Section                         | no. calls |  wall time | % of total |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div><div class="line"><span class="stringliteral">| assemble right hand side        |         3 |      2.06s |      0.53% |</span></div><div class="line"><span class="stringliteral">| compute residual                |         3 |      2.46s |      0.63% |</span></div><div class="line"><span class="stringliteral">| compute update                  |         3 |       129s |        33% |</span></div><div class="line"><span class="stringliteral">| setup system                    |         1 |      98.8s |        25% |</span></div><div class="line"><span class="stringliteral">| solve                           |         1 |       134s |        34% |</span></div><div class="line"><span class="stringliteral">+---------------------------------+-----------+------------+------------+</span></div></div><!-- fragment --><p>我们在下图中展示了二维和三维问题的解决方案。</p>
<div class="twocolumn" style="width: 80%; text-align: center;"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-66.solution-2d.png" alt="二维格尔凡德问题的解决方案。" width="100%"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-66.solution-3d.png" alt="三维格尔凡德问题的解决方案。" width="100%"/>
</div>
 </div> </div><p><a class="anchor" id="Newtonsolver"></a></p><h3>Newton solver</h3>
<p>在上面的程序输出中，我们发现一些关于牛顿迭代的有趣信息。每个细化周期的终端输出显示了牛顿方法的详细诊断，首先显示了牛顿步骤的数量和每一步的残差规范 \(\|F(u_h^{n+1})\|\) ，牛顿更新的规范 \(\|s_h^n\|\) ，和CG迭代的数量 <code>it</code> 。</p>
<p>我们观察到，对于所有的情况，牛顿方法大约在三到四步内收敛，这显示了牛顿方法的全步长的二次收敛 \(\alpha = 1\) 。然而，请注意，对于一个选择不好的初始猜测 \(u_h^0\) ，牛顿方法也会出现二次发散。通常情况下，如果你没有合适的初始猜测，你可以尝试几个阻尼的牛顿步骤，减少步长 \(\alpha &lt; 1\) ，直到牛顿步骤再次进入二次收敛域。这种阻尼和放松的牛顿步长确实需要一个更复杂的牛顿方法的实现，我们指定给你作为本教程的可能扩展。</p>
<p>此外，我们看到，随着连续的网格细化和DoF数量的增加，CG迭代的数量近乎恒定。这当然是由于几何多棱镜的预处理，而且与其他使用这种方法的教程中的观察结果相似，例如步骤16和步骤37。仅举一例，在三维案例中，经过五次细化后，我们有大约1470万个分布式DoFs的四阶拉格朗日有限元，但CG迭代的次数仍然少于10次。</p>
<p>此外，我们还应用了一个非常有用的优化，应该在此提及。在 <code>compute_update()</code> 函数中，我们在将持有牛顿更新的向量作为输出向量传递给求解器之前，明确地重置了它。在这种情况下，我们为CG方法使用了一个零的起始值，这比之前的牛顿更新、 <code>newton_update</code> 的实际内容在重置之前更合适，因此减少了几步CG迭代的次数。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>有几个可能的扩展是关于本代码的小更新fo以及对Gelfand问题更深入的数值调查。</p>
<p><a class="anchor" id="MoresophisticatedNewtoniteration"></a></p><h4>More sophisticated Newton iteration</h4>
<p>除了步骤15中提到的牛顿迭代的步长控制版本外，我们还可以为牛顿迭代实施一个更灵活的停止标准。例如，我们可以取代残差的固定公差 <code>TOLf</code> and for the Newton updated <code>TOLx</code> ，并实现一个具有给定绝对和相对公差的混合误差控制，这样牛顿迭代就会成功，例如。</p>
<p class="formulaDsp">
\begin{align*} \|F(u_h^{n+1})\| \leq \texttt{RelTol} \|u_h^{n+1}\| + \texttt{AbsTol}. \end{align*}
</p>
<p>对于有许多非线性系统需要解决的更高级的应用，例如，在时间依赖性问题的每个时间步骤，事实证明，没有必要在每一个牛顿步骤甚至每个时间步骤中重新设置和组装雅各布系数。相反，在牛顿迭代中可以使用前一个步骤中的现有的Jacobian。然后，只有在例如牛顿迭代收敛过慢的情况下，才会重新建立雅各布系数。这样的想法产生了一个<a href="https://en.wikipedia.org/wiki/Quasi-Newton_method">quasi-Newton method</a>。诚然，当使用无矩阵框架时，无论如何都会省略雅各布式的组装，但通过这种方式，可以尝试优化几何多网格预处理的重新组装。请记住，每次来自旧牛顿步骤的解决方案必须分布到所有层面，并且必须重新初始化多重网格预处理器。</p>
<p><a class="anchor" id="Parallelscalabilityandthreadparallelism"></a></p><h4>Parallel scalability and thread parallelism</h4>
<p>在step-37等人的结果部分，无矩阵框架在大量处理器上的并行可扩展性已经得到了非常令人印象深刻的证明。在我们这里考虑的非线性情况下，我们注意到瓶颈之一可能成为无矩阵雅可比算子及其多阶段算子在前一个牛顿步骤中的转移和评估，因为我们需要在每个步骤的所有阶段转移旧的解决方案。 <b>[castelli2021numerical]</b> 中的第一个并行可扩展性分析显示，当问题规模足够大时，有相当好的强可扩展性。然而，为了得到可靠的结果，还需要进行更详细的分析。此外，到目前为止，这个问题只用MPI来解决，没有使用线程的共享内存并行化的可能性。因此，对于这个例子，你可以尝试用MPI和线程的混合并行化，如步骤-48中所述。</p>
<p><a class="anchor" id="Comparisontomatrixbasedmethods"></a></p><h4>Comparison to matrix-based methods</h4>
<p>类似于步骤50和提到的步骤75的可能扩展，你可以说服自己哪个方法更快。</p>
<p><a class="anchor" id="Eigenvalueproblem"></a></p><h4>Eigenvalue problem</h4>
<p>我们可以考虑相应的特征值问题，这被称为布拉图问题。例如，如果我们定义一个固定的特征值 \(\lambda\in[0,6]\) ，我们可以计算相应的离散特征函数。你会注意到，牛顿步骤的数量将随着 \(\lambda\) 的增加而增加。为了减少牛顿步数，你可以使用以下技巧：从某个 \(\lambda\) 开始，计算特征函数，增加 \(\lambda=\lambda + \delta_\lambda\) ，然后使用之前的解作为牛顿迭代的初始猜测。最后你可以画出 \(H^1(\Omega)\) 在特征值 \(\lambda \mapsto \|u_h\|_{H^1(\Omega)}\) 上的正负值。对于进一步增加 \(\lambda&gt;7\) 你观察到什么？</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Fabian Castelli, Karlsruhe Institute of Technology (KIT)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vectorization_8h.html">deal.II/base/vectorization.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__accessor_8h.html">deal.II/grid/tria_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tria__iterator_8h.html">deal.II/grid/tria_iterator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__evaluation_8h.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__free_8h.html">deal.II/matrix_free/matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tools_8h.html">deal.II/matrix_free/tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer__matrix__free_8h.html">deal.II/multigrid/mg_transfer_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step66</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keyword">class </span>JacobianOperator</div><div class="line">    : <span class="keyword">public</span> <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::</div><div class="line">        Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> value_type = number;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> FECellIntegrator =</div><div class="line">      <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, number&gt;</a>;</div><div class="line"></div><div class="line">    JacobianOperator();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> clear() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_newton_step(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">compute_diagonal</a>() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> apply_add(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    local_apply(<span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">                <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">                <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_compute_diagonal(FECellIntegrator &amp;integrator) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, VectorizedArray&lt;number&gt;</a>&gt; nonlinear_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  JacobianOperator&lt;dim, fe_degree, number&gt;::JacobianOperator()</div><div class="line">    : <a class="code" href="namespaceMatrixFreeOperators.html">MatrixFreeOperators</a>::Base&lt;dim,</div><div class="line">                                <a class="code" href="namespaceLinearAlgebra.html">LinearAlgebra</a>::distributed::<a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">Vector</a>&lt;number&gt;&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::clear()</div><div class="line">  {</div><div class="line">    nonlinear_values.reinit(0, 0);</div><div class="line">    <a class="code" href="classMatrixFreeOperators_1_1Base.html">MatrixFreeOperators::Base&lt;dim, LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;::</div><div class="line">      clear();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::evaluate_newton_step(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;newton_step)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cells = this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">n_cell_batches</a>();</div><div class="line">    FECellIntegrator   phi(*this-&gt;data);</div><div class="line"></div><div class="line">    nonlinear_values.reinit(n_cells, phi.n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = 0; cell &lt; <a class="code" href="namespaceinternal_1_1TriangulationImplementation.html#a9f815604be9b560fea00beef8d720480">n_cells</a>; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line">        phi.read_dof_values_plain(newton_step);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            nonlinear_values(cell, q) = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(phi.get_value(q));</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_apply(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, number&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    FECellIntegrator phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                        phi.get_matrix_free().n_cell_batches());</div><div class="line">        <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line"></div><div class="line">        phi.reinit(cell);</div><div class="line"></div><div class="line">        phi.gather_evaluate(src,</div><div class="line">                            <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                              <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">            phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">          }</div><div class="line"></div><div class="line">        phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                                <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                              dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::apply_add(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">cell_loop</a>(&amp;JacobianOperator::local_apply, <span class="keyword">this</span>, dst, src);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> JacobianOperator&lt;dim, fe_degree, number&gt;::local_compute_diagonal(</div><div class="line">    FECellIntegrator &amp;phi)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(0),</div><div class="line">                    phi.get_matrix_free().n_cell_batches());</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(nonlinear_values.size(1), phi.n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = phi.get_current_cell_index();</div><div class="line"></div><div class="line">    phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">      {</div><div class="line">        phi.submit_value(-nonlinear_values(cell, q) * phi.get_value(q), q);</div><div class="line">        phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">      }</div><div class="line"></div><div class="line">    phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">JacobianOperator&lt;dim, fe_degree, number&gt;::compute_diagonal</a>()</div><div class="line">  {</div><div class="line">    this-&gt;inverse_diagonal_entries.reset(</div><div class="line">      <span class="keyword">new</span> <a class="code" href="classDiagonalMatrix.html">DiagonalMatrix</a>&lt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a>&gt;());</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;number&gt;</a> &amp;inverse_diagonal =</div><div class="line">      this-&gt;inverse_diagonal_entries-&gt;get_vector();</div><div class="line">    this-&gt;data-&gt;<a class="code" href="classMatrixFree.html#ab92a24942737bbaf04d7e00aceba9b57">initialize_dof_vector</a>(inverse_diagonal);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceMatrixFreeTools.html#a523190adf5671e317d745fed4b1d357f">MatrixFreeTools::compute_diagonal</a>(*this-&gt;data,</div><div class="line">                                      inverse_diagonal,</div><div class="line">                                      &amp;JacobianOperator::local_compute_diagonal,</div><div class="line">                                      <span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;diagonal_element : inverse_diagonal)</div><div class="line">      {</div><div class="line">        diagonal_element = (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(diagonal_element) &gt; 1.0e-10) ?</div><div class="line">                             (1.0 / diagonal_element) :</div><div class="line">                             1.0;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keyword">class </span>GelfandProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    GelfandProblem();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> evaluate_residual(</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> local_evaluate_residual(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">      <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">      <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> compute_update();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_solution_norm() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a>                mapping;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    <span class="keyword">using</span> SystemMatrixType = JacobianOperator&lt;dim, fe_degree, double&gt;;</div><div class="line">    SystemMatrixType system_matrix;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> mg_constrained_dofs;</div><div class="line">    <span class="keyword">using</span> LevelMatrixType = JacobianOperator&lt;dim, fe_degree, float&gt;;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LevelMatrixType&gt;</a>                           mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_solution;</div><div class="line">    <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>                         mg_transfer;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> solution;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> newton_update;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> linear_iterations;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  GelfandProblem&lt;dim, fe_degree&gt;::GelfandProblem()</div><div class="line">    : triangulation(MPI_COMM_WORLD,</div><div class="line">                    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices,</div><div class="line">                    <a class="code" href="namespaceparallel.html">parallel</a>::distributed::<a class="code" href="classTriangulation.html">Triangulation</a>&lt;</div><div class="line">                      dim&gt;::<a class="code" href="namespaceTriangulationDescription.html#aa1531298eb0a267d9ceca5eb46ada8e0acc0ed1c2dd30bca7c7576e65b4045274">construct_multigrid_hierarchy</a>)</div><div class="line">    , mapping(fe_degree)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    , computing_timer(MPI_COMM_WORLD,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;make grid&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a>                boundary_manifold;</div><div class="line">    <a class="code" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt;dim&gt;</a> inner_manifold;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(1);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, boundary_manifold);</div><div class="line"></div><div class="line">    inner_manifold.<a class="code" href="classTransfiniteInterpolationManifold.html#a34326a35d9ec4b6911d90c85c21847d8">initialize</a>(triangulation);</div><div class="line">    triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(1, inner_manifold);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3 - dim);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup system&quot;</span>);</div><div class="line"></div><div class="line">    system_matrix.clear();</div><div class="line">    mg_matrices.clear_elements();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, double&gt;::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">        <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;::AdditionalData::partition_color</a>;</div><div class="line">      additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">        (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">      <span class="keyword">auto</span> system_mf_storage = std::make_shared&lt;MatrixFree&lt;dim, double&gt;&gt;();</div><div class="line">      system_mf_storage-&gt;reinit(mapping,</div><div class="line">                                dof_handler,</div><div class="line">                                constraints,</div><div class="line">                                <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                additional_data);</div><div class="line"></div><div class="line">      system_matrix.initialize(system_mf_storage);</div><div class="line">    }</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(solution);</div><div class="line">    system_matrix.initialize_dof_vector(newton_update);</div><div class="line">    system_matrix.initialize_dof_vector(system_rhs);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">    mg_matrices.resize(0, nlevels - 1);</div><div class="line">    mg_solution.resize(0, nlevels - 1);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary;</div><div class="line">    dirichlet_boundary.insert(0);</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary);</div><div class="line"></div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a69e2b416ab209936f94db08e865cd92b">initialize_constraints</a>(mg_constrained_dofs);</div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a8f214ffade006cfa85e902a94902fc7b">build</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> relevant_dofs;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      relevant_dofs);</div><div class="line"></div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> level_constraints;</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(relevant_dofs);</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a>(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        level_constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">        <span class="keyword">typename</span> <a class="code" href="structMatrixFree_1_1AdditionalData.html">MatrixFree&lt;dim, float&gt;::AdditionalData</a> additional_data;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a0bcce2facca91b925d3e1a5a00c7704b">tasks_parallel_scheme</a> =</div><div class="line">          <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, float&gt;::AdditionalData::partition_color</a>;</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#aa5d597e6c4441d273f4100b6139a2552">mapping_update_flags</a> =</div><div class="line">          (<a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">        additional_data.<a class="code" href="structMatrixFree_1_1AdditionalData.html#a67c9ff01c51fb7fb3ada151b83cdd409">mg_level</a> = <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">        <span class="keyword">auto</span> mg_mf_storage_level = std::make_shared&lt;MatrixFree&lt;dim, float&gt;&gt;();</div><div class="line">        mg_mf_storage_level-&gt;reinit(mapping,</div><div class="line">                                    dof_handler,</div><div class="line">                                    level_constraints,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe.degree + 1),</div><div class="line">                                    additional_data);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_mf_storage_level,</div><div class="line">                                      mg_constrained_dofs,</div><div class="line">                                      level);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize_dof_vector(mg_solution[level]);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::evaluate_residual(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">auto</span> matrix_free = system_matrix.get_matrix_free();</div><div class="line"></div><div class="line">    matrix_free-&gt;cell_loop(</div><div class="line">      &amp;GelfandProblem::local_evaluate_residual, <span class="keyword">this</span>, dst, src, <span class="keyword">true</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::local_evaluate_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMatrixFree.html">MatrixFree&lt;dim, double&gt;</a> &amp;                   data,</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> &amp;src,</div><div class="line">    <span class="keyword">const</span> std::pair&lt;unsigned int, unsigned int&gt; &amp;     cell_range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a> phi(data);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell = cell_range.first; cell &lt; cell_range.second; ++cell)</div><div class="line">      {</div><div class="line">        phi.reinit(cell);</div><div class="line"></div><div class="line">        phi.read_dof_values_plain(src);</div><div class="line">        phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> | <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; phi.n_q_points; ++q)</div><div class="line">          {</div><div class="line">            phi.submit_value(-std::exp(phi.get_value(q)), q);</div><div class="line">            phi.submit_gradient(phi.get_gradient(q), q);</div><div class="line">          }</div><div class="line"></div><div class="line">        phi.integrate_scatter(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> |</div><div class="line">                                <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>,</div><div class="line">                              dst);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assemble right hand side&quot;</span>);</div><div class="line"></div><div class="line">    evaluate_residual(system_rhs, solution);</div><div class="line"></div><div class="line">    system_rhs *= -1.0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute residual&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> residual;</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double&gt;</a> evaluation_point;</div><div class="line"></div><div class="line">    system_matrix.initialize_dof_vector(residual);</div><div class="line">    system_matrix.initialize_dof_vector(evaluation_point);</div><div class="line"></div><div class="line">    evaluation_point = solution;</div><div class="line">    <span class="keywordflow">if</span> (alpha &gt; 1e-12)</div><div class="line">      {</div><div class="line">        evaluation_point.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a>(alpha, newton_update);</div><div class="line">      }</div><div class="line"></div><div class="line">    evaluate_residual(residual, evaluation_point);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_update()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;compute update&quot;</span>);</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line"></div><div class="line">    system_matrix.evaluate_newton_step(solution);</div><div class="line"></div><div class="line"></div><div class="line">    mg_transfer.<a class="code" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">interpolate_to_mg</a>(dof_handler, mg_solution, solution);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">using</span> SmootherType =</div><div class="line">      <a class="code" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;LevelMatrixType,</div><div class="line">                            LinearAlgebra::distributed::Vector&lt;float&gt;&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a>&lt;SmootherType,</div><div class="line">                           LinearAlgebra::distributed::Vector&lt;float&gt;&gt;</div><div class="line">                                                         mg_smoother;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;typename SmootherType::AdditionalData&gt;</a> smoother_data;</div><div class="line">    smoother_data.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (level &gt; 0)</div><div class="line">          {</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].smoothing_range     = 15.;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].degree              = 4;</div><div class="line">            smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].eig_cg_n_iterations = 10;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            smoother_data[0].smoothing_range = 1e-3;</div><div class="line">            smoother_data[0].degree          = <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>;</div><div class="line">            smoother_data[0].eig_cg_n_iterations = mg_matrices[0].m();</div><div class="line">          }</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].evaluate_newton_step(mg_solution[level]);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].compute_diagonal();</div><div class="line"></div><div class="line">        smoother_data[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].preconditioner =</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].get_matrix_diagonal_inverse();</div><div class="line">      }</div><div class="line">    mg_smoother.initialize(mg_matrices, smoother_data);</div><div class="line"></div><div class="line">    <a class="code" href="classMGCoarseGridApplySmoother.html">MGCoarseGridApplySmoother&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt;</div><div class="line">      mg_coarse;</div><div class="line">    mg_coarse.<a class="code" href="classMGCoarseGridApplySmoother.html#a499c7364e40031332e9943a2e5f331a2">initialize</a>(mg_smoother);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_matrix(</div><div class="line">      mg_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;MatrixFreeOperators::MGInterfaceOperator&lt;LevelMatrixType&gt;</a>&gt;</div><div class="line">      mg_interface_matrices;</div><div class="line">    mg_interface_matrices.<a class="code" href="classMGLevelObject.html#a16213121f9153bd08f49652a11886259">resize</a>(0, triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>() - 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.<a class="code" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a>();</div><div class="line">         ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].initialize(mg_matrices[level]);</div><div class="line">      }</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; mg_interface(</div><div class="line">      mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;LinearAlgebra::distributed::Vector&lt;float&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, mg_coarse, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface, mg_interface);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG</a>&lt;dim,</div><div class="line">                   LinearAlgebra::distributed::Vector&lt;float&gt;,</div><div class="line">                   <a class="code" href="classMGTransferMatrixFree.html">MGTransferMatrixFree&lt;dim, float&gt;</a>&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(100, 1.e-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">    newton_update = 0.0;</div><div class="line"></div><div class="line">    cg.solve(system_matrix, newton_update, system_rhs, preconditioner);</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(newton_update);</div><div class="line"></div><div class="line">    linear_iterations = solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>();</div><div class="line"></div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> GelfandProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> itmax = 10;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       TOLf  = 1e-12;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       TOLx  = 1e-10;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTimer.html">Timer</a> solver_timer;</div><div class="line">    solver_timer.<a class="code" href="classTimer.html#a3a8b5272198d029779dc9302a54305a8">start</a>();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= itmax; ++newton_step)</div><div class="line">      {</div><div class="line">        assemble_rhs();</div><div class="line">        compute_update();</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ERRx = newton_update.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ERRf = compute_residual(1.0);</div><div class="line"></div><div class="line"></div><div class="line">        solution.add(1.0, newton_update);</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Nstep &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot;, errf = &quot;</span> &lt;&lt; ERRf</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;, errx = &quot;</span> &lt;&lt; ERRx &lt;&lt; <span class="stringliteral">&quot;, it = &quot;</span> &lt;&lt; linear_iterations</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (ERRf &lt; TOLf || ERRx &lt; TOLx)</div><div class="line">          {</div><div class="line">            solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line"></div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;Convergence step &quot;</span> &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; value &quot;</span> &lt;&lt; ERRf</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; (used wall time: &quot;</span> &lt;&lt; solver_timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s)&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == itmax)</div><div class="line">          {</div><div class="line">            solver_timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;WARNING: No convergence of Newton&#39;s method after &quot;</span></div><div class="line">                  &lt;&lt; newton_step &lt;&lt; <span class="stringliteral">&quot; steps.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">double</span> GelfandProblem&lt;dim, fe_degree&gt;::compute_solution_norm()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    solution.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values</a>();</div><div class="line"></div><div class="line">    Vector&lt;float&gt; norm_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                      norm_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                             norm_per_cell,</div><div class="line">                                             <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  GelfandProblem&lt;dim, fe_degree&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &gt; 1e6)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    solution.update_ghost_values();</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      {</div><div class="line">        subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">      }</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping,</div><div class="line">                           fe.degree,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::curved_inner_cells</a>);</div><div class="line"></div><div class="line">    <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">    flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim) + <span class="stringliteral">&quot;d&quot;</span>, cycle, MPI_COMM_WORLD, 3);</div><div class="line"></div><div class="line">    solution.zero_out_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">GelfandProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_ranks =</div><div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_doubles = <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_vect_bits    = 8 * <span class="keyword">sizeof</span>(double) * n_vect_doubles;</div><div class="line"></div><div class="line">      std::string DAT_header = <span class="stringliteral">&quot;START DATE: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#aff548b3b9b7a035ea112729700ef7c64">Utilities::System::get_date</a>() +</div><div class="line">                               <span class="stringliteral">&quot;, TIME: &quot;</span> + <a class="code" href="namespaceUtilities_1_1System.html#a76bc1cc7649cc416723f450d24fdd91d">Utilities::System::get_time</a>();</div><div class="line">      std::string MPI_header = <span class="stringliteral">&quot;Running with &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_ranks) +</div><div class="line">                               <span class="stringliteral">&quot; MPI process&quot;</span> + (n_ranks &gt; 1 ? <span class="stringliteral">&quot;es&quot;</span> : <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">      std::string VEC_header =</div><div class="line">        <span class="stringliteral">&quot;Vectorization over &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_doubles) +</div><div class="line">        <span class="stringliteral">&quot; doubles = &quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(n_vect_bits) + <span class="stringliteral">&quot; bits (&quot;</span> +</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#ade631a789101336840371e3b2e2851e0">Utilities::System::get_current_vectorization_level</a>() +</div><div class="line">        <span class="stringliteral">&quot;), VECTORIZATION_LEVEL=&quot;</span> +</div><div class="line">        <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(<a class="code" href="config_8h.html#a32dc208a29f23d1f031fb40b0d21e60e">DEAL_II_COMPILER_VECTORIZATION_LEVEL</a>);</div><div class="line">      std::string SOL_header = <span class="stringliteral">&quot;Finite element space: &quot;</span> + fe.get_name();</div><div class="line"></div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; DAT_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      pcout &lt;&lt; MPI_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; VEC_header &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; SOL_header &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 9 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::string(80, <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            make_grid();</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">          }</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classTimer.html">Timer</a> timer;</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Set up system...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Triangulation: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; cells&quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   DoFHandler:    &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; <span class="stringliteral">&quot; DoFs&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Solve using Newton&#39;s method...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve();</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        timer.<a class="code" href="classTimer.html#a988f79aa183d9d5473c13106f5babe48">stop</a>();</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Time for setup+solve (CPU/Wall) &quot;</span> &lt;&lt; timer.<a class="code" href="classTimer.html#a4e3933a78790d7455daff5acab3f8432">cpu_time</a>() &lt;&lt; <span class="stringliteral">&quot;/&quot;</span></div><div class="line">              &lt;&lt; timer.<a class="code" href="classTimer.html#a6f3e76707411b51e7d7e7bfa5755cf02">wall_time</a>() &lt;&lt; <span class="stringliteral">&quot; s&quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Output results...&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> norm = compute_solution_norm();</div><div class="line">        output_results(cycle);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;  H1 seminorm: &quot;</span> &lt;&lt; norm &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step66</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step66;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;2, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        GelfandProblem&lt;3, 4&gt; gelfand_problem;</div><div class="line">        gelfand_problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
