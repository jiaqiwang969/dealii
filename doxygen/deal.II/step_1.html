<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_1.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-1 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-1 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Aboutthetutorial"> About the tutorial </a>
        <li><a href="#Videolecturesontutorialprograms"> Video lectures on tutorial programs </a>
        <li><a href="#Whatthisprogramdoes"> What this program does </a>
        <li><a href="#Aboutscientificcomputingingeneral"> About scientific computing in general </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Creatingthefirstmesh">Creating the first mesh</a>
        <li><a href="#Creatingthesecondmesh">Creating the second mesh</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
      <ul>
        <li><a href="#Differentadaptiverefinementstrategies"> Different adaptive refinement strategies </a>
        <li><a href="#Differentgeometries"> Different geometries </a>
        <li><a href="#Commentsaboutprogramminganddebugging"> Comments about programming and debugging </a>
        <li><a href="#Moreaboutgraphicaloutput"> More about graphical output </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Aboutthetutorial"></a></p><h3>About the tutorial </h3>
<p>Since this is the first tutorial program, let us comment first on how this tutorial and the rest of the deal.II documentation is supposed to work. The documentation for deal.II comes essentially at three different levels:</p><ul>
<li>The tutorial: This is a collection of programs that shows how deal.II is used in practice. It doesn't typically discuss individual functions at the level of individual arguments, but rather wants to give the big picture of how things work together. In other words, it discusses "concepts": what are the building blocks of deal.II and how are they used together in finite element programs.</li>
<li>The manual: This is the documentation of every single class and every single (member) function in deal.II. You get there if, for example, you click on the "Main page" or "Classes" tab at the top of this page. This is the place where you would look up what the second argument of <a class="el" href="classTriangulation.html#ada18f9251ebb60ac0200eafeeddb78c5">Triangulation::create_triangulation_compatibility</a> means, to give just one slightly obscure example. You need this level of documentation for when you know what you want to do, but forgot how exactly the function was named, what its arguments are, or what it returns. Note that you also get into the manual whenever you read through the tutorial and click on any of the class or function names, i.e. the tutorial contains a great many links into the manual for whenever you need a more detailed description of a function or class. On the other hand, the manual is not a good place to learn deal.II since it gives you a microscopic view of things without telling you how a function might fit into the bigger picture.</li>
<li>Modules: These are groups of classes and functions that work together or have related functionality. If you click on the "Modules" tab at the top of this page, you end up on a page that lists a number of such groups. Each module discusses the underlying principles of these classes; for example, the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module talks about all sorts of different issues related to storing sparsity patterns of matrices. This is documentation at an intermediate level: they give you an overview of what's there in a particular area. For example when you wonder what finite element classes exist, you would take a look at the <a class="el" href="group__fe.html">Finite element space descriptions</a> module. The modules are, of course, also cross-linked to the manual (and, at times, to the tutorial); if you click on a class name, say on <a class="el" href="classTriangulation.html">Triangulation</a>, would will also at the very top right under the class name get a link to the modules this class is a member of if you want to learn more about its context.</li>
</ul>
<p>Let's come back to the tutorial, since you are looking at the first program (or "step") of it. Each tutorial program is subdivided into the following sections: </p><ol>
<li>
<b>Introduction:</b> This is a discussion of what the program does, including the mathematical model, and what programming techniques are new compared to previous tutorial programs. </li>
<li>
<b>The commented program:</b> An extensively documented listing of the source code. Here, we often document individual lines, or blocks of code, and discuss what they do, how they do it, and why. The comments frequently reference the introduction, i.e. you have to understand <em>what</em> the program wants to achieve (a goal discussed in the introduction) before you can understand <em>how</em> it intends to get there. </li>
<li>
<b>Results:</b> The output of the program, with comments and interpretation. This section also frequently has a subsection that gives suggestions on how to extend the program in various direction; in the earlier programs, this is intended to give you directions for little experiments designed to make your familiar with deal.II, while in later programs it is more about how to use more advanced numerical techniques. </li>
<li>
<b>The plain program:</b> The source code stripped of all comments. This is useful if you want to see the "big
       picture" of the code, since the commented version of the program has so much text in between that it is often difficult to see the entire code of a single function on the screen at once. </li>
</ol>
<p>The tutorials are not only meant to be static documentation, but you should play with them. To this end, go to the <code>examples/step-1</code> directory (or whatever the number of the tutorial is that you're interested in) and type </p><div class="fragment"><div class="line">cmake .</div><div class="line">make</div><div class="line">make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p> The first command sets up the files that describe which include files this tutorial program depends on, how to compile it and how to run it. This command should find the installed deal.II libraries as well that were generated when you compiled and installed everything as described in the <a href="../../readme.html" target="body">README</a> file. If this command should fail to find the deal.II library, then you need to provide the path to the installation using the command </p><div class="fragment"><div class="line">cmake -DDEAL_II_DIR=/path/to/installed/deal.II .</div></div><!-- fragment --><p> instead.</p>
<p>The second of the commands above compiles the sources into an executable, while the last one executes it (strictly speaking, <code>make run</code> will also compile the code if the executable doesn't exist yet, so you could have skipped the second command if you wanted). This is all that's needed to run the code and produce the output that is discussed in the "Results" section of the tutorial programs. This sequence needs to be repeated in all of the tutorial directories you want to play with.</p>
<p>When learning the library, you need to play with it and see what happens. To this end, open the <code>examples/step-1/step-1.cc</code> source file with your favorite editor and modify it in some way, save it and run it as above. A few suggestions for possibly modifications are given at the end of the results section of this program, where we also provide a few links to other useful pieces of information.</p>
<p><a class="anchor" id="Videolecturesontutorialprograms"></a></p><h3>Video lectures on tutorial programs </h3>
<p>This and several of the other tutorial programs are also discussed and demonstrated in <a href="http://www.math.colostate.edu/~bangerth/videos.html">Wolfgang Bangerth's video lectures</a> on deal.II and computational science. In particular, you can see the steps he executes to run this and other programs, and you will get a much better idea of the tools that can be used to work with deal.II. In particular, lectures 2 and 4 give an overview of deal.II and of the building blocks of any finite element code. (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.html">video lecture 2</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.4.html">video lecture 4</a>.)</p>
<p>If you are not yet familiar with using Linux and running things on the command line, you may be interested in watching lectures 2.9 and 2.91. (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.9.html">video lecture 2.9</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.91.html">video lecture 2.91</a>.) These give overviews over the command line and on what happens when compiling programs, respectively.</p>
<p>Note that deal.II is actively developed, and in the course of this development we occasionally rename or deprecate functions or classes that are still referenced in these video lectures. For example, the <a class="el" href="step_1.html">step-1</a> code shown in video lecture 5 uses a class HyperShellBoundary which was replaced with <a class="el" href="classSphericalManifold.html">SphericalManifold</a> class later on. Additionally, as of deal.II version 9.0, <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> now automatically attaches a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to the <a class="el" href="classTriangulation.html">Triangulation</a>. Otherwise the rest of the lecture material is relevant.</p>
<p><a class="anchor" id="Whatthisprogramdoes"></a></p><h3>What this program does </h3>
<p>Let's come back to <a class="el" href="step_1.html">step-1</a>, the current program. In this first example, we don't actually do very much, but show two techniques: what is the syntax to generate triangulation objects, and some elements of simple loops over all cells. We create two grids, one which is a regularly refined square (not very exciting, but a common starting grid for some problems), and one more geometric attempt: a ring-shaped domain, which is refined towards the inner edge. Through this, you will get to know three things every finite element program will have to have somewhere: An object of type <a class="el" href="classTriangulation.html">Triangulation</a> for the mesh; a call to the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions to generate a mesh; and loops over all cells that involve iterators (iterators are a generalization of pointers and are frequently used in the C++ standard library; in the context of deal.II, the <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> module talks about them).</p>
<p>The program is otherwise small enough that it doesn't need a whole lot of introduction.</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.5.html">video lecture 5</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.6.html">video lecture 6</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p><a class="anchor" id="Aboutscientificcomputingingeneral"></a></p><h3>About scientific computing in general </h3>
<p>If you are reading through this tutorial program, chances are that you are interested in continuing to use deal.II for your own projects. Thus, you are about to embark on an exercise in programming using a large-scale scientific computing library. Unless you are already an experienced user of large-scale programming methods, this may be new territory for you &mdash; with all the new rules that go along with it such as the fact that you will have to deal with code written by others, that you may have to think about documenting your own code because you may not remember what exactly it is doing a year down the road (or because others will be using it as well), or coming up with ways to test that your program is doing the right thing. None of this is something that we typically train mathematicians, engineers, or scientists in but that is important when you start writing software of more than a few hundred lines. Remember: Producing software is not the same as just writing code.</p>
<p>To make your life easier on this journey let us point to some resources that are worthwhile browsing through before you start any large-scale programming:</p>
<ul>
<li>The <a href="https://github.com/dealii/dealii/wiki/Frequently-Asked-Questions">deal.II FAQ</a> has a good number of answers to questions about particular aspects of deal.II, but also to more general questions such as "How
  do I debug scientific computing codes?" or "Can I train myself to write code
  that has fewer bugs?".</li>
<li>You will benefit from becoming a better programmer. An excellent resource to this end is the book <a href="https://en.wikipedia.org/wiki/Code_Complete">Code Complete</a> by Steve McConnell <b>[CodeComplete]</b> . It's already a few years old, with the last edition published in 2004, but it has lost none of its appeal as a guide to good programming practices, and some of the principal developers use it as a group reading project with every generation of their research group members.</li>
<li>The <a href="http://software-carpentry.org/">Software Carpentry project</a> that provides introductions to many topics that are important to dealing with software, such as version control, make files, testing, etc. It is specifically written for scientists and engineers, not for computer scientists, and has a focus on short, practical lessons.</li>
<li>The <a href="https://bssw.io/">Better Scientific Software project</a> has a lot of resources (and interesting blog posts) that cover many aspects of writing scientific software.</li>
<li>The <a href="https://ideas-productivity.org/">IDEAS project</a> also has resources on software development, in particular for parallel computing. In the "Events" section on that site are recorded tutorials and webinars that cover many interesting topics.</li>
<li>An article on <a href="http://arxiv.org/abs/1210.0530">Best Practices for Scientific Computing</a> that gives an introduction to many of the ways by which you can make sure you are an efficient programmer writing programs that work.</li>
</ul>
<p>As a general recommendation: If you expect to spend more than a few days writing software in the future, do yourself the favor of learning tools that can make your life more productive, in particular debuggers and integrated development environments. (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.7.html">video lecture 7</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.8.html">video lecture 8</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.8.01.html">video lecture 8.01</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.25.html">video lecture 25</a>.) You will find that you will get the time spent learning these tools back severalfold soon by being more productive! Several of the video lectures referenced above show how to use tools such as integrated development environments or debuggers.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The most fundamental class in the library is the <a class="el" href="classTriangulation.html">Triangulation</a> class, which is declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div></div><!-- fragment --><p>Here are some functions to generate standard grids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>Output of grids in various graphics formats:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div></div><!-- fragment --><p>This is needed for C++ output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>And this for the declarations of the <code>std::sqrt</code> and <code>std::fabs</code> functions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div></div><!-- fragment --><p>The final step in importing deal.II is this: All deal.II functions and classes are in a namespace <code>dealii</code>, to make sure they don't clash with symbols from other libraries you may want to use in conjunction with deal.II. One could use these functions and classes by prefixing every use of these names by <code>::</code>, but that would quickly become cumbersome and annoying. Rather, we simply import the entire deal.II namespace for general use:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefirstmesh"></a> </p><h3>Creating the first mesh</h3>
<p>In the following, first function, we simply use the unit square as domain and produce a globally refined grid from it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> first_grid()</div><div class="line">{</div></div><!-- fragment --><p>The first thing to do is to define an object for a triangulation of a two-dimensional domain:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>Here and in many following cases, the string "&lt;2&gt;" after a class name indicates that this is an object that shall work in two space dimensions. Likewise, there are versions of the triangulation class that are working in one ("&lt;1&gt;") and three ("&lt;3&gt;") space dimensions. The way this works is through some template magic that we will investigate in some more detail in later example programs; there, we will also see how to write programs in an essentially dimension independent way.</p>
<p>Next, we want to fill the triangulation with a single cell for a square domain. The triangulation is the refined four times, to yield \(4^4=256\) cells in total:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div></div><!-- fragment --><p>Now we want to write a graphical representation of the mesh to an output file. The <a class="el" href="classGridOut.html">GridOut</a> class of deal.II can do that in a number of different output formats; here, we choose scalable vector graphics (SVG) format that you can visualize using the web browser of your choice:</p>
<div class="fragment"><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-1.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-1.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthesecondmesh"></a> </p><h3>Creating the second mesh</h3>
<p>The grid in the following, second function is slightly more complicated in that we use a ring domain and refine the result once globally.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> second_grid()</div><div class="line">{</div></div><!-- fragment --><p>We start again by defining an object for a triangulation of a two-dimensional domain:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>We then fill it with a ring domain. The center of the ring shall be the point (1,0), and inner and outer radius shall be 0.5 and 1. The number of circumferential cells could be adjusted automatically by this function, but we choose to set it explicitly to 10 as the last argument:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">  triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 10);</div></div><!-- fragment --><p>By default, the triangulation assumes that all boundaries are straight lines, and all cells are bi-linear quads or tri-linear hexes, and that they are defined by the cells of the coarse grid (which we just created). Unless we do something special, when new points need to be introduced the domain is assumed to be delineated by the straight lines of the coarse mesh, and new points will simply be in the middle of the surrounding ones. Here, however, we know that the domain is curved, and we would like to have the <a class="el" href="classTriangulation.html">Triangulation</a> place new points according to the underlying geometry. Fortunately, some good soul implemented an object which describes a spherical domain, of which the ring is a section; it only needs the center of the ring and automatically figures out how to instruct the <a class="el" href="classTriangulation.html">Triangulation</a> where to place the new points. The way this works in deal.II is that you tag parts of the triangulation you want to be curved with a number that is usually referred to as "manifold indicator" and then tell the triangulation to use a particular "manifold object" for all places with this manifold indicator. How exactly this works is not important at this point (you can read up on it in <a class="el" href="step_53.html">step-53</a> and <a class="el" href="group__manifold.html">Manifold description for triangulations</a>). The functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> handle this for us in most circumstances: they attach the correct manifold to a domain so that when the triangulation is refined new cells are placed in the correct places. In the present case <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> attaches a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to all cells: this causes cells to be refined with calculations in spherical coordinates (so new cells have edges that are either radial or lie along concentric circles around the origin).</p>
<p>By default (i.e., for a <a class="el" href="classTriangulation.html">Triangulation</a> created by hand or without a call to a <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function like <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> or <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>), all cells and faces of the <a class="el" href="classTriangulation.html">Triangulation</a> have their manifold_id set to <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, which is the default if you want a manifold that produces straight edges, but you can change this number for individual cells and faces. In that case, the curved manifold thus associated with number zero will not apply to those parts with a non-zero manifold indicator, but other manifold description objects can be associated with those non-zero indicators. If no manifold description is associated with a particular manifold indicator, a manifold that produces straight edges is implied. (<a class="el" href="classManifold.html">Manifold</a> indicators are a slightly complicated topic; if you're confused about what exactly is happening here, you may want to look at the <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">glossary entry on this</a> topic".) Since the default chosen by <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> is reasonable we leave things alone.</p>
<p>In order to demonstrate how to write a loop over all cells, we will refine the grid in five steps towards the inner circle of the domain:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 5; ++step)</div><div class="line">  {</div></div><!-- fragment --><p>Next, we need to loop over the active cells of the triangulation. You can think of a triangulation as a collection of cells. If it were an array, you would just get a pointer that you increment from one element to the next using the operator <code>++</code>. The cells of a triangulation aren't stored as a simple array, but the concept of an <em>iterator</em> generalizes how pointers work to arbitrary collections of objects (see <a href="http://en.wikipedia.org/wiki/Iterator#C.2B.2B">wikipedia</a> for more information). Typically, any container type in C++ will return an iterator pointing to the start of the collection with a method called <code>begin</code>, and an iterator point to 1 past the end of the collection with a method called <code>end</code>. We can increment an iterator <code>it</code> with the operator <code>++it</code>, dereference it to get the underlying data with <code>*it</code>, and check to see if we're done by comparing <code>it != <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">collection.end()</a></code>.</p>
<p>The second important piece is that we only need the active cells. Active cells are those that are not further refined, and the only ones that can be marked for further refinement. deal.II provides iterator categories that allow us to iterate over <em>all</em> cells (including the parent cells of active ones) or only over the active cells. Because we want the latter, we need to call the method <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>.</p>
<p>Putting all of this together, we can loop over all the active cells of a triangulation with </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it = triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>().begin();</div><div class="line">     it != triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>().end();</div><div class="line">     ++it)</div><div class="line">  {</div><div class="line">    <span class="keyword">auto</span> cell = *it;</div><div class="line">    <span class="comment">// Then a miracle occurs...</span></div><div class="line">  }</div></div><!-- fragment --> </div><p> In the initializer of this loop, we've used the <code>auto</code> keyword for the type of the iterator <code>it</code>. The <code>auto</code> keyword means that the type of the object being declared will be inferred from the context. This keyword is useful when the actual type names are long or possibly even redundant. If you're unsure of what the type is and want to look up what operations the result supports, you can go to the documentation for the method <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>. In this case, the type of <code>it</code> is <code><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a></code>.</p>
<p>While the <code>auto</code> keyword can save us from having to type out long names of data types, we still have to type a lot of redundant declarations about the start and end iterator and how to increment it. Instead of doing that, we'll use <a href="http://en.cppreference.com/w/cpp/language/range-for">range- based for loops</a>, which wrap up all of the syntax shown above into a much shorter form:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>See <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> for more information about the iterator classes used in deal.II, and <a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> for more information about range-based for loops and the <code>auto</code> keyword.</dd></dl>
<p>Next, we loop over all vertices of the cells. For that purpose we query an iterator over the vertex indices (in 2d, this is an array that contains the elements <code>{0,1,2,3}</code>, but since <code>cell-&gt;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices()</a></code> knows the dimension the cell lives in, the array so returned is correct in all dimensions and this enables this code to be correct whether we run it in 2d or 3d, i.e., it enables "dimension-independent programming" &ndash; a big part of what we will discuss in <a class="el" href="step_4.html">step-4</a>).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">  {</div></div><!-- fragment --><p>If this cell is at the inner boundary, then at least one of its vertices must sit on the inner ring and therefore have a radial distance from the center of exactly 0.5, up to floating point accuracy. So we compute this distance, and if we find a vertex with this property, we flag this cell for later refinement. We can then also break the loop over all vertices and move on to the next cell.</p>
<p>Because the distance from the center is computed as a floating point number, we have to expect that whatever we compute is only accurate to within <a href="https://en.wikipedia.org/wiki/Round-off_error">round-off</a>. As a consequence, we can never expect to compare the distance with the inner radius by equality: A statement such as <code>if (distance_from_center == inner_radius)</code> will fail unless we get exceptionally lucky. Rather, we need to do this comparison with a certain tolerance, and the usual way to do this is to write it as <code>if (std::abs(distance_from_center - inner_radius) &lt;= tolerance)</code> where <code>tolerance</code> is some small number larger than round-off. The question is how to choose it: We could just pick, say, <code>1e-10</code>, but this is only appropriate if the objects we compare are of size one. If we had created a mesh with cells of size <code>1e+10</code>, then <code>1e-10</code> would be far lower than round-off and, as before, the comparison will only succeed if we get exceptionally lucky. Rather, it is almost always useful to make the tolerance <em>relative</em> to a typical "scale" of the objects being compared. Here, the "scale" would be the inner radius, or maybe the diameter of cells. We choose the former and set the tolerance equal to \(10^{-6}\) times the inner radius of the annulus.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">        <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">          1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">        {</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now that we have marked all the cells that we want refined, we let the triangulation actually do this refinement. The function that does so owes its long name to the fact that one can also mark cells for coarsening, and the function does coarsening and refinement all at once:</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p>Finally, after these five iterations of refinement, we want to again write the resulting mesh to a file, again in SVG format. This works just as above:</p>
<div class="fragment"><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-2.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-2.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call the two subfunctions, which produce the two grids.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  first_grid();</div><div class="line">  second_grid();</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the program produces graphics of two grids (grid-1.svg and grid-2.svg). You can open these with most every web browser &ndash; in the simplest case, just open the current directory in your file system explorer and click on the file. If you like working on the command line, you call your web browser with the file: <code>firefox grid-1.svg</code>, <code>google-chrome grid-1.svg</code>, or whatever the name of your browser is. If you do this, the two meshes should look like this:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-1.grid-1-r9.2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-1.grid-2-r9.2.png"/>
</div>
   </td></tr>
</table>
<p>The left one, well, is not very exciting. The right one is &mdash; at least &mdash; unconventional. The pictures color-code the "refinement level" of each cell: How many times did a coarse mesh cell have to be subdivided to obtain the given cell. In the left image, this is boring since the mesh was refined globally a number of times, i.e., <em>every</em> cell was refined the same number of times.</p>
<p>(While the second mesh is entirely artificial and made-up, and certainly not very practical in applications, to everyone's surprise it has found its way into the literature: see <b>[Mu05]</b>. Apparently it is good for some things at least.)</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="Differentadaptiverefinementstrategies"></a></p><h4>Different adaptive refinement strategies </h4>
<p>This program obviously does not have a whole lot of functionality, but in particular the <code>second_grid</code> function has a bunch of places where you can play with it. For example, you could modify the criterion by which we decide which cells to refine. An example would be to change the condition to this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell: triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt; 0)</div><div class="line">    cell-&gt;set_refine_flag ();</div></div><!-- fragment --><p> This would refine all cells for which the \(y\)-coordinate of the cell's center is greater than zero (the <code><a class="el" href="classTriaAccessor.html#a8b045bcae58de112897824f4f08d1713">TriaAccessor::center</a></code> function that we call by dereferencing the <code>cell</code> iterator returns a <a class="el" href="classPoint.html">Point&lt;2&gt;</a> object; subscripting <code>[0]</code> would give the \(x\)-coordinate, subscripting <code>[1]</code> the \(y\)-coordinate). By looking at the functions that <a class="el" href="classTriaAccessor.html">TriaAccessor</a> provides, you can also use more complicated criteria for refinement.</p>
<p>In general, what you can do with operations of the form <code>cell-&gt;something()</code> is a bit difficult to find in the documentation because <code>cell</code> is not a pointer but an iterator. The functions you can call on a cell can be found in the documentation of the classes <code><a class="el" href="classTriaAccessor.html">TriaAccessor</a></code> (which has functions that can also be called on faces of cells or, more generally, all sorts of geometric objects that appear in a triangulation), and <code><a class="el" href="classCellAccessor.html">CellAccessor</a></code> (which adds a few functions that are specific to <em>cells</em>).</p>
<p>A more thorough description of the whole iterator concept can be found in the <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> documentation module.</p>
<p><a class="anchor" id="Differentgeometries"></a></p><h4>Different geometries </h4>
<p>Another possibility would be to generate meshes of entirely different geometries altogether. While for complex geometries there is no way around using meshes obtained from mesh generators, there is a good number of geometries for which deal.II can create meshes using the functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace. Many of these geometries (such as the one used in this example program) contain cells with curved faces: put another way, we expect the new vertices placed on the boundary to lie along a circle. deal.II handles complex geometries with the <a class="el" href="classManifold.html">Manifold</a> class (and classes inheriting from it); in particular, the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> corresponding to non-Cartesian grids (such as <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> or <a class="el" href="namespaceGridGenerator.html#ae63c93351f77276c20de07c91d3c1e48">GridGenerator::truncated_cone</a>) attach a <a class="el" href="classManifold.html">Manifold</a> object to the part of the triangulation that should be curved (<a class="el" href="classSphericalManifold.html">SphericalManifold</a> and <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a>, respectively) and use another manifold on the parts that should be flat (<a class="el" href="classFlatManifold.html">FlatManifold</a>). See the documentation of <a class="el" href="classManifold.html">Manifold</a> or the <a class="el" href="group__manifold.html">manifold module</a> for descriptions of the design philosophy and interfaces of these classes. Take a look at what they provide and see how they could be used in a program like this.</p>
<p>We also discuss a variety of other ways to create and manipulate meshes (and describe the process of attaching <a class="el" href="namespaceManifolds.html">Manifolds</a>) in <a class="el" href="step_49.html">step-49</a>.</p>
<p><a class="anchor" id="Commentsaboutprogramminganddebugging"></a></p><h4>Comments about programming and debugging </h4>
<p>We close with a comment about modifying or writing programs with deal.II in general. When you start working with tutorial programs or your own applications, you will find that mistakes happen: your program will contain code that either aborts the program right away or bugs that simply lead to wrong results. In either case, you will find it extremely helpful to know how to work with a debugger: you may get by for a while by just putting debug output into your program, compiling it, and running it, but ultimately finding bugs with a debugger is much faster, much more convenient, and more reliable because you don't have to recompile the program all the time and because you can inspect the values of variables and how they change.</p>
<p>Rather than postponing learning how to use a debugger till you really can't see any other way to find a bug, here's the one piece of advice we will provide in this program: learn how to use a debugger as soon as possible. It will be time well invested. (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.25.html">video lecture 25</a>.) The deal.II Frequently Asked Questions (FAQ) page linked to from the top-level <a href="http://www.dealii.org/">deal.II webpage</a> also provides a good number of hints on debugging deal.II programs.</p>
<p><a class="anchor" id="Moreaboutgraphicaloutput"></a></p><h4>More about graphical output </h4>
<p>It is often useful to include meshes into your theses or publications. For this, it may not be very useful to color-code the cells by refinement level, and to print the cell number onto each cell. But it doesn't have to be that way &ndash; the <a class="el" href="classGridOut.html">GridOut</a> class allows setting flags for each possible output format (see the classes in the <a class="el" href="namespaceGridOutFlags.html">GridOutFlags</a> namespace) that control how exactly a mesh is plotted. You can of course also choose other output file formats such as VTK or VTU; this is particularly useful for 3d meshes where a 2d format such as SVG is not particular useful because it fixes a particular viewpoint onto the 3d object. As a consequence, you might want to explore other options in the <a class="el" href="classGridOut.html">GridOut</a> class.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> first_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-1.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-1.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> second_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 10);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 5; ++step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">                <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">                  1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">                {</div><div class="line">                  cell-&gt;set_refine_flag();</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-2.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-2.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  first_grid();</div><div class="line">  second_grid();</div><div class="line">}</div></div><!-- fragment --><p> <table class="tutorial" width="50%"> <tr><th
 colspan="2"><b><small>Table of contents</small></b><b><small>Table of
 contents</small></b></th></tr> <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Aboutthetutorial"> About the tutorial </a><a
 href="#Aboutthetutorial"> About the tutorial </a>
 <li><a href="#Videolecturesontutorialprograms"> Video lectures on tutorial
 programs </a><a href="#Videolecturesontutorialprograms"> Video lectures on
 tutorial programs </a>
 <li><a href="#Whatthisprogramdoes"> What this program does </a><a
 href="#Whatthisprogramdoes"> What this program does </a>
 <li><a href="#Aboutscientificcomputingingeneral"> About scientific
 computing in general </a><a href="#Aboutscientificcomputingingeneral">
 About scientific computing in general </a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#Creatingthefirstmesh">Creating the first mesh</a><a
 href="#Creatingthefirstmesh">Creating the first mesh</a>
 <li><a href="#Creatingthesecondmesh">Creating the second mesh</a><a
 href="#Creatingthesecondmesh">Creating the second mesh</a>
 <li><a href="#Themainfunction">The main function</a><a
 href="#Themainfunction">The main function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a>
 <ul>
 <li><a href="#Differentadaptiverefinementstrategies"> Different adaptive
 refinement strategies </a><a href="#Differentadaptiverefinementstrategies">
 Different adaptive refinement strategies </a>
 <li><a href="#Differentgeometries"> Different geometries </a><a
 href="#Differentgeometries"> Different geometries </a>
 <li><a href="#Commentsaboutprogramminganddebugging"> Comments about
 programming and debugging </a><a
 href="#Commentsaboutprogramminganddebugging"> Comments about programming
 and debugging </a>
 <li><a href="#Moreaboutgraphicaloutput"> More about graphical output </a><a
 href="#Moreaboutgraphicaloutput"> More about graphical output </a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Aboutthetutorial"></a></p><h3>About the tutorial </h3>
<p>Since this is the first tutorial program, let us comment first on howthis tutorial and the rest of the deal.II documentation is supposed towork. The documentation for deal.II comes essentially at threedifferent levels:</p>
<ul>
<li>The tutorial: This is a collection of programs that shows how deal.II is used in practice. It doesn't typically discuss individual functions at the level of individual arguments, but rather wants to give the big picture of how things work together. In other words, it discusses "concepts": what are the building blocks of deal.II and how are they used together in finite element programs.</li>
<li>The manual: This is the documentation of every single class and every single (member) function in deal.II. You get there if, for example, you click on the "Main page" or "Classes" tab at the top of this page. This is the place where you would look up what the second argument of <a class="el" href="classTriangulation.html#ada18f9251ebb60ac0200eafeeddb78c5">Triangulation::create_triangulation_compatibility</a> means, to give just one slightly obscure example. You need this level of documentation for when you know what you want to do, but forgot how exactly the function was named, what its arguments are, or what it returns. Note that you also get into the manual whenever you read through the tutorial and click on any of the class or function names, i.e. the tutorial contains a great many links into the manual for whenever you need a more detailed description of a function or class. On the other hand, the manual is not a good place to learn deal.II since it gives you a microscopic view of things without telling you how a function might fit into the bigger picture.</li>
<li>Modules: These are groups of classes and functions that work together or have related functionality. If you click on the "Modules" tab at the top of this page, you end up on a page that lists a number of such groups. Each module discusses the underlying principles of these classes; for example, the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module talks about all sorts of different issues related to storing sparsity patterns of matrices. This is documentation at an intermediate level: they give you an overview of what's there in a particular area. For example when you wonder what finite element classes exist, you would take a look at the <a class="el" href="group__fe.html">Finite element space descriptions</a> module. The modules are, of course, also cross-linked to the manual (and, at times, to the tutorial); if you click on a class name, say on <a class="el" href="classTriangulation.html">Triangulation</a>, would will also at the very top right under the class name get a link to the modules this class is a member of if you want to learn more about its context. Let's come back to the tutorial, since you are looking at the first program(or "step") of it. Each tutorial program is subdivided into the followingsections: <ol>
<li>
<b>Introduction:</b> This is a discussion of what the program does, including the mathematical model, and what programming techniques are new compared to previous tutorial programs. </li>
<li>
<b>The commented program:</b> An extensively documented listing of the source code. Here, we often document individual lines, or blocks of code, and discuss what they do, how they do it, and why. The comments frequently reference the introduction, i.e. you have to understand <em>what</em> the program wants to achieve (a goal discussed in the introduction) before you can understand <em>how</em> it intends to get there. </li>
<li>
<b>Results:</b> The output of the program, with comments and interpretation. This section also frequently has a subsection that gives suggestions on how to extend the program in various direction; in the earlier programs, this is intended to give you directions for little experiments designed to make your familiar with deal.II, while in later programs it is more about how to use more advanced numerical techniques. </li>
<li>
<b>The plain program:</b> The source code stripped of all comments. This is useful if you want to see the "big       picture" of the code, since the commented version of the program has so much text in between that it is often difficult to see the entire code of a single function on the screen at once. </li>
</ol>
The tutorials are not only meant to be static documentation, but youshould play with them. To this end, go to the <code>examples/step-1</code> directory (or whatever the number of thetutorial is that you're interested in) and type <div class="fragment"><div class="line">cmake .</div><div class="line">make</div><div class="line">make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --> The first command sets up the files that describe which include files thistutorial program depends on, how to compile it and how to run it. This commandshould find the installed deal.II libraries as well that were generated whenyou compiled and installed everything as described in the<a href="../../readme.html" target="body">README</a> file.If this command should fail to find the deal.II library, then you need toprovide the path to the installation using the command <div class="fragment"><div class="line">cmake</div><div class="line"></div><div class="line">-DDEAL_II_DIR=/path/to/installed/deal.II .</div></div><!-- fragment --> instead. The second of the commands above compiles the sources into an executable, while thelast one executes it (strictly speaking, <code>make run</code> will alsocompile the code if the executable doesn't exist yet, so you couldhave skipped the second command if you wanted). This is all that'sneeded to run the code and produce the output that is discussed in the"Results" section of the tutorial programs. This sequence needs to be repeatedin all of the tutorial directories you want to play with. When learning the library, you need to play with it and see whathappens. To this end, open the <code>examples/step-1/step-1.cc</code> source file with your favorite editor and modify it in some way, save it andrun it as above. A few suggestions for possibly modifications are given at theend of the results section of this program, where we also provide a few linksto other useful pieces of information.</li>
</ul>
<p><a class="anchor" id="Videolecturesontutorialprograms"></a></p><h3>Video lectures on tutorial programs </h3>
<p>This and several of the other tutorial programs are also discussed anddemonstrated in <a href="http://www.math.colostate.edu/~bangerth/videos.html">Wolfgang Bangerth's video lectures</a> on deal.II and computational science. Inparticular, you can see the steps he executes to run this and otherprograms, and you will get a much better idea of the tools that can beused to work with deal.II. In particular, lectures 2 and 4 give an overview ofdeal.II and of the building blocks of any finite element code.( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.html">video lecture 2</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.4.html">video lecture 4</a>.) If you are not yet familiar with using Linux and running things on thecommand line, you may be interested in watching lectures 2.9 and 2.91.( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.9.html">video lecture 2.9</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.91.html">video lecture 2.91</a>.) These give overviews over the command line and on what happens when compiling programs, respectively. Note that deal.II is actively developed, and in the course of thisdevelopment we occasionally rename or deprecate functions or classesthat are still referenced in these video lectures. Forexample, the <a class="el" href="step_1.html">step-1</a> code shown in video lecture 5 uses a classHyperShellBoundary which was replaced with <a class="el" href="classSphericalManifold.html">SphericalManifold</a> classlater on. Additionally, as of deal.II version 9.0, <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> now automatically attaches a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to the <a class="el" href="classTriangulation.html">Triangulation</a>. Otherwisethe rest of the lecture material is relevant. <a class="anchor" id="Whatthisprogramdoes"></a></p><h3>What this program does </h3>
<p>Let's come back to <a class="el" href="step_1.html">step-1</a> , the current program.In this first example, we don't actually do very much, but show twotechniques: what is the syntax to generate triangulation objects, andsome elements of simple loops over all cells. We create two grids, onewhich is a regularly refined square (not very exciting, but a commonstarting grid for some problems), and one more geometric attempt: aring-shaped domain, which is refined towards the inner edge. Throughthis, you will get to know three things every finite element programwill have to have somewhere: An object of type <a class="el" href="classTriangulation.html">Triangulation</a> for themesh; a call to the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions to generate a mesh; andloops over all cells that involve iterators (iterators are ageneralization of pointers and are frequently used in the C++ standardlibrary; in the context of deal.II, the <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> module talksabout them). The program is otherwise small enough that it doesn't need a whole lotof introduction. </p><dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.5.html">video lecture 5</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.6.html">video lecture 6</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p><a class="anchor" id="Aboutscientificcomputingingeneral"></a></p><h3>About scientific computing in general </h3>
<p>If you are reading through this tutorial program, chances are that you areinterested in continuing to use deal.II for your own projects. Thus, you areabout to embark on an exercise in programming using a large-scale scientificcomputing library. Unless you are already an experienced user of large-scaleprogramming methods, this may be new territory for you &mdash; with all thenew rules that go along with it such as the fact that you will have to dealwith code written by others, that you may have to think about documenting yourown code because you may not remember what exactly it is doing a year down theroad (or because others will be using it as well), or coming up with ways totest that your program is doing the right thing. None of this is somethingthat we typically train mathematicians, engineers, or scientists in but thatis important when you start writing software of more than a few hundredlines. Remember: Producing software is not the same as just writing code. To make your life easier on this journey let us point to some resources thatare worthwhile browsing through before you start any large-scale programming:</p>
<ul>
<li>The <a href="https://github.com/dealii/dealii/wiki/Frequently-Asked-Questions">deal.II FAQ</a> has a good number of answers to questions about particular aspects of deal.II, but also to more general questions such as "How  do I
 debug scientific computing codes?" or "Can I train myself to write code
 that has fewer bugs?".</li>
<li>You will benefit from becoming a better programmer. An excellent resource to this end is the book <a href="https://en.wikipedia.org/wiki/Code_Complete">Code Complete</a> by Steve McConnell <b>[CodeComplete]</b> . It's already a few years old, with the last edition published in 2004, but it has lost none of its appeal as a guide to good programming practices, and some of the principal developers use it as a group reading project with every generation of their research group members.</li>
<li>The <a href="http://software-carpentry.org/">Software Carpentry project</a> that provides introductions to many topics that are important to dealing with software, such as version control, make files, testing, etc. It is specifically written for scientists and engineers, not for computer scientists, and has a focus on short, practical lessons.</li>
<li>The <a href="https://bssw.io/">Better Scientific Software project</a> has a lot of resources (and interesting blog posts) that cover many aspects of writing scientific software.</li>
<li>The <a href="https://ideas-productivity.org/">IDEAS project</a> also has resources on software development, in particular for parallel computing. In the "Events" section on that site are recorded tutorials and webinars that cover many interesting topics.</li>
<li>An article on <a href="http://arxiv.org/abs/1210.0530">Best Practices for Scientific Computing</a> that gives an introduction to many of the ways by which you can make sure you are an efficient programmer writing programs that work. As a general recommendation: If you expect to spend more than a few dayswriting software in the future, do yourself the favor of learning tools thatcan make your life more productive, in particular debuggers and integrateddevelopment environments. ( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.7.html">video lecture 7</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.8.html">video lecture 8</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.8.01.html">video lecture 8.01</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.25.html">video lecture 25</a>.) You will find that you will get the time spentlearning these tools back severalfold soon by being more productive!Several of the video lectures referenced above show how to use toolssuch as integrated development environments or debuggers.</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The most fundamental class in the library is the <a class="el" href="classTriangulation.html">Triangulation</a> class, which is declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div></div><!-- fragment --><p>Here are some functions to generate standard grids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>Output of grids in various graphics formats:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div></div><!-- fragment --><p>This is needed for C++ output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>And this for the declarations of the <code>std::sqrt</code> and <code>std::fabs</code> functions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div></div><!-- fragment --><p>The final step in importing deal.II is this: All deal.II functions and classes are in a namespace <code>dealii</code> , to make sure they don't clash with symbols from other libraries you may want to use in conjunction with deal.II. One could use these functions and classes by prefixing every use of these names by <code>::</code> , but that would quickly become cumbersome and annoying. Rather, we simply import the entire deal.II namespace for general use:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefirstmesh"></a> </p><h3>Creating the first mesh</h3>
<p>In the following, first function, we simply use the unit square as domain and produce a globally refined grid from it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> first_grid()</div><div class="line">{</div></div><!-- fragment --><p>The first thing to do is to define an object for a triangulation of a two-dimensional domain:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>Here and in many following cases, the string "&lt;2&gt;" after a class name indicates that this is an object that shall work in two space dimensions. Likewise, there are versions of the triangulation class that are working in one ("&lt;1&gt;") and three ("&lt;3&gt;") space dimensions. The way this works is through some template magic that we will investigate in some more detail in later example programs; there, we will also see how to write programs in an essentially dimension independent way.</p>
<p>Next, we want to fill the triangulation with a single cell for a square domain. The triangulation is the refined four times, to yield \(4^4=256\) cells in total:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div></div><!-- fragment --><p>Now we want to write a graphical representation of the mesh to an output file. The <a class="el" href="classGridOut.html">GridOut</a> class of deal.II can do that in a number of different output formats; here, we choose scalable vector graphics (SVG) format that you can visualize using the web browser of your choice:</p>
<div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;grid-1.svg&quot;</span>);</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-1.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthesecondmesh"></a> </p><h3>Creating the second mesh</h3>
<p>The grid in the following, second function is slightly more complicated in that we use a ring domain and refine the result once globally.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> second_grid()</div><div class="line">{</div></div><!-- fragment --><p>We start again by defining an object for a triangulation of a two-dimensional domain:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>We then fill it with a ring domain. The center of the ring shall be the point (1,0), and inner and outer radius shall be 0.5 and 1. The number of circumferential cells could be adjusted automatically by this function, but we choose to set it explicitly to 10 as the last argument:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">  triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 10);</div></div><!-- fragment --><p>By default (i.e., for a <a class="el" href="classTriangulation.html">Triangulation</a> created by hand or without a call to a <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function like <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> or <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>), all cells and faces of the <a class="el" href="classTriangulation.html">Triangulation</a> have their manifold_id set to <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, which is the default if you want a manifold that produces straight edges, but you can change this number for individual cells and faces. In that case, the curved manifold thus associated with number zero will not apply to those parts with a non-zero manifold indicator, but other manifold description objects can be associated with those non-zero indicators. If no manifold description is associated with a particular manifold indicator, a manifold that produces straight edges is implied. (<a class="el" href="classManifold.html">Manifold</a> indicators are a slightly complicated topic; if you're confused about what exactly is happening here, you may want to look at the <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">glossary entry on this topic</a>. ) Since the default chosen by <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> is reasonable we leave things alone. In order to demonstrate how to write a loop over all cells, we will refine the grid in five steps towards the inner circle of the domain:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 5; ++step)</div><div class="line">  {</div></div><!-- fragment --><p>Next, we need to loop over the active cells of the triangulation. You can think of a triangulation as a collection of cells. If it were an array, you would just get a pointer that you increment from one element to the next using the operator <code>++</code>. The cells of a triangulation aren't stored as a simple array, but the concept of an <em>iterator</em> generalizes how pointers work to arbitrary collections of objects (see <a href="http://en.wikipedia.org/wiki/Iterator#C.2B.2B">wikipedia</a> for more information). Typically, any container type in C++ will return an iterator pointing to the start of the collection with a method called <code>begin</code>, and an iterator point to 1 past the end of the collection with a method called <code>end</code>. We can increment an iterator <code>it</code> with the operator <code>++it</code>, dereference it to get the underlying data with <code>*it</code>, and check to see if we're done by comparing <code>it != <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">collection.end()</a></code>. The second important piece is that we only need the active cells. Active cells are those that are not further refined, and the only ones that can be marked for further refinement. deal.II provides iterator categories that allow us to iterate over <em>all</em> cells (including the parent cells of active ones) or only over the active cells. Because we want the latter, we need to call the method <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>. Putting all of this together, we can loop over all the active cells of a triangulation with </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it = triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>().begin();</div><div class="line">     it != triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>().end();</div><div class="line">     ++it)</div><div class="line">  {</div><div class="line">    <span class="keyword">auto</span> cell =it;</div><div class="line">    <span class="comment">// Then a miracle occurs...</span></div><div class="line">  }</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> In the initializer of this loop, we've used the <code>auto</code> keyword for the type of the iterator <code>it</code>. The <code>auto</code> keyword means that the type of the object being declared will be inferred from the context. This keyword is useful when the actual type names are long or possibly even redundant. If you're unsure of what the type is and want to look up what operations the result supports, you can go to the documentation for the method <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>. In this case, the type of <code>it</code> is <code><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a></code>. While the <code>auto</code> keyword can save us from having to type out long names of data types, we still have to type a lot of redundant declarations about the start and end iterator and how to increment it. Instead of doing that, we'll use <a href="http://en.cppreference.com/w/cpp/language/range-for">range- based for loops</a>, which wrap up all of the syntax shown above into a much shorter form:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>See <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> for more information about the iterator classes used in deal.II, and <a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> for more information about range-based for loops and the <code>auto</code> keyword. Next, we loop over all vertices of the cells. For that purpose we query an iterator over the vertex indices (in 2d, this is an array that contains the elements <code>{0,1,2,3}</code>, but since <code>cell-&gt;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices()</a></code> knows the dimension the cell lives in, the array so returned is correct in all dimensions and this enables this code to be correct whether we run it in 2d or 3d, i.e., it enables "dimension-independent programming"</dd></dl>
<ul>
<li>a big part of what we will discuss in <a class="el" href="step_4.html">step-4</a> ).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">  {</div></div><!-- fragment --><p>If this cell is at the inner boundary, then at least one of its vertices must sit on the inner ring and therefore have a radial distance from the center of exactly 0.5, up to floating point accuracy. So we compute this distance, and if we find a vertex with this property, we flag this cell for later refinement. We can then also break the loop over all vertices and move on to the next cell. Because the distance from the center is computed as a floating point number, we have to expect that whatever we compute is only accurate to within <a href="https://en.wikipedia.org/wiki/Round-off_error">round-off</a>. As a consequence, we can never expect to compare the distance with the inner radius by equality: A statement such as <code>if (distance_from_center == inner_radius)</code> will fail unless we get exceptionally lucky. Rather, we need to do this comparison with a certain tolerance, and the usual way to do this is to write it as `if (std::abs(distance_from_center</p>
<ul>
<li>inner_radius) &lt;= tolerance)<code>where</code>tolerance<code>is some small number larger than round-off. The question is how to choose it: We could just pick, say,</code>1e-10<code>, but this is only appropriate if the objects we compare are of size one. If we had created a mesh with cells of size</code>1e+10<code>, then</code>1e-10` would be far lower than round-off and, as before, the comparison will only succeed if we get exceptionally lucky. Rather, it is almost always useful to make the tolerancerelative* to a typical "scale" of the objects being compared. Here, the "scale" would be the inner radius, or maybe the diameter of cells. We choose the former and set the tolerance equal to \(10^{-6}\) times the inner radius of the annulus.</li>
</ul>
<div class="fragment"><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">              <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center</div><div class="line"></div><div class="line">- inner_radius) &lt;=</div><div class="line">                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 inner_radius)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div></div><!-- fragment --><p>Now that we have marked all the cells that we want refined, we let the triangulation actually do this refinement. The function that does so owes its long name to the fact that one can also mark cells for coarsening, and the function does coarsening and refinement all at once:</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p>Finally, after these five iterations of refinement, we want to again write the resulting mesh to a file, again in SVG format. This works just as above:</p>
<div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;grid-2.svg&quot;</span>);</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-2.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call the two subfunctions, which produce the two grids.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">first_grid();</div><div class="line">second_grid();</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the program produces graphics of two grids (grid-1.svg and grid-2.svg).You can open these with most every web browser</p>
<ul>
<li>in the simplest case,just open the current directory in your file system explorer and clickon the file. If you like working on the command line, you call yourweb browser with the file: <code>firefox grid-1.svg</code>, <code>google-chrome grid-1.svg</code>,or whatever the name of your browser is. If you do this, the two meshesshould look like this: <table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-1.grid-1-r9.2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-1.grid-2-r9.2.png"/>
</div>
   </td></tr>
</table>
The left one, well, is not very exciting. The right one is &mdash; at least&mdash; unconventional. The pictures color-code the "refinement level" of eachcell: How many times did a coarse mesh cell have to be subdivided to obtainthe given cell. In the left image, this is boring since the mesh wasrefined globally a number of times, i.e., <em>every</em> cell wasrefined the same number of times. (While the second mesh is entirely artificial and made-up, andcertainly not very practical in applications, to everyone's surprise ithas found its way into the literature: see <b>[Mu05]</b> . Apparently it isgood for some things at least.)</li>
</ul>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="Differentadaptiverefinementstrategies"></a></p><h4>Different adaptive refinement strategies </h4>
<p>This program obviously does not have a whole lot of functionality, butin particular the <code>second_grid</code> function has a bunch ofplaces where you can play with it. For example, you could modify thecriterion by which we decide which cells to refine. An example wouldbe to change the condition to this: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell: triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt; 0)</div><div class="line">    cell-&gt;set_refine_flag ();</div></div><!-- fragment --><p> This would refine all cells for which the \(y\) -coordinate of the cell'scenter is greater than zero (the <code><a class="el" href="classTriaAccessor.html#a8b045bcae58de112897824f4f08d1713">TriaAccessor::center</a></code> function that we call by dereferencing the <code>cell</code> iteratorreturns a <a class="el" href="classPoint.html">Point&lt;2&gt;</a> object; subscripting <code>[0]</code> would givethe \(x\) -coordinate, subscripting <code>[1]</code> the \(y\) -coordinate). By looking at the functions that TriaAccessorprovides, you can also use more complicated criteria for refinement. In general, what you can do with operations of the form<code>cell-&gt;something()</code> is a bit difficult to find in the documentationbecause <code>cell</code> is not a pointer but an iterator. The functions you cancall on a cell can be found in the documentation of the classes<code><a class="el" href="classTriaAccessor.html">TriaAccessor</a></code> (which has functions that can also be called on facesof cells or, more generally, all sorts of geometric objects thatappear in a triangulation), and <code><a class="el" href="classCellAccessor.html">CellAccessor</a></code> (which adds a fewfunctions that are specific tocells*). A more thorough description of the whole iterator concept can be foundin the <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> documentation module.</p>
<p><a class="anchor" id="Differentgeometries"></a></p><h4>Different geometries </h4>
<p>Another possibility would be to generate meshes of entirely differentgeometries altogether. While for complex geometries there is no way aroundusing meshes obtained from mesh generators, there is a good number ofgeometries for which deal.II can create meshes using the functions in theGridGenerator namespace. Many of these geometries (such as the one used in thisexample program) contain cells with curved faces: put another way, we expect thenew vertices placed on the boundary to lie along a circle. deal.II handles complexgeometries with the <a class="el" href="classManifold.html">Manifold</a> class (and classes inheriting from it); in particular,the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> corresponding to non-Cartesian grids (such as <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> or <a class="el" href="namespaceGridGenerator.html#ae63c93351f77276c20de07c91d3c1e48">GridGenerator::truncated_cone</a>) attach a Manifoldobject to the part of the triangulation that should be curved (SphericalManifoldand <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a>, respectively) and use another manifold on the parts thatshould be flat (<a class="el" href="classFlatManifold.html">FlatManifold</a>). See the documentationof <a class="el" href="classManifold.html">Manifold</a> or the <a class="el" href="group__manifold.html">manifold module</a> for descriptions of the designphilosophy and interfaces of these classes. Take a look at what they provide andsee how they could be used in a program like this. We also discuss a variety of other ways to create and manipulate meshes (anddescribe the process of attaching <a class="el" href="namespaceManifolds.html">Manifolds</a>) in <a class="el" href="step_49.html">step-49</a> .</p>
<p><a class="anchor" id="Commentsaboutprogramminganddebugging"></a></p><h4>Comments about programming and debugging </h4>
<p>We close with a comment about modifying or writing programs with deal.II ingeneral. When you start working with tutorial programs or your ownapplications, you will find that mistakes happen: your program will containcode that either aborts the program right away or bugs that simply lead towrong results. In either case, you will find it extremely helpful to know howto work with a debugger: you may get by for a while by just putting debugoutput into your program, compiling it, and running it, but ultimately findingbugs with a debugger is much faster, much more convenient, and more reliablebecause you don't have to recompile the program all the time and because youcan inspect the values of variables and how they change. Rather than postponing learning how to use a debugger till you really can'tsee any other way to find a bug, here's the one piece ofadvice we will provide in this program: learn how to use a debugger as soon aspossible. It will be time well invested.( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.25.html">video lecture 25</a>.) The deal.II Frequently Asked Questions (FAQ) page linked to from the top-level <a href="http://www.dealii.org/">deal.II webpage</a> also provides a good numberof hints on debugging deal.II programs.</p>
<p><a class="anchor" id="Moreaboutgraphicaloutput"></a></p><h4>More about graphical output </h4>
<p>It is often useful to include meshes into your theses or publications.For this, it may not be very useful to color-code the cells byrefinement level, and to print the cell number onto each cell. Butit doesn't have to be that way</p>
<ul>
<li>the <a class="el" href="classGridOut.html">GridOut</a> class allows setting flagsfor each possible output format (see the classes in the GridOutFlagsnamespace) that control how exactly a mesh is plotted. You can ofcourse also choose other output file formats such as VTK or VTU; thisis particularly useful for 3d meshes where a 2d format such as SVGis not particular useful because it fixes a particular viewpoint ontothe 3d object. As a consequence, you might want to explore otheroptions in the <a class="el" href="classGridOut.html">GridOut</a> class.</li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> first_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-1.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-1.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> second_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 10);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 5; ++step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">                <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">                  1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">                {</div><div class="line">                  cell-&gt;set_refine_flag();</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-2.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-2.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  first_grid();</div><div class="line">  second_grid();</div><div class="line">}</div></div><!-- fragment --><p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Aboutthetutorial"> About the tutorial </a>
        <li><a href="#Videolecturesontutorialprograms"> Video lectures on tutorial programs </a>
        <li><a href="#Whatthisprogramdoes"> What this program does </a>
        <li><a href="#Aboutscientificcomputingingeneral"> About scientific computing in general </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Creatingthefirstmesh">Creating the first mesh</a>
        <li><a href="#Creatingthesecondmesh">Creating the second mesh</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
      <ul>
        <li><a href="#Differentadaptiverefinementstrategies"> Different adaptive refinement strategies </a>
        <li><a href="#Differentgeometries"> Different geometries </a>
        <li><a href="#Commentsaboutprogramminganddebugging"> Comments about programming and debugging </a>
        <li><a href="#Moreaboutgraphicaloutput"> More about graphical output </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-1/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Aboutthetutorial"></a></p><h3>About the tutorial </h3>
<p>由于这是第一个教程程序，让我们首先评论一下这个教程和deal.II的其他文档应该如何工作。deal.II的文档基本上有三个不同的层次。</p>
<ul>
<li>该教程。这是一个程序集，展示了deal.II在实践中的应用。它通常不在单个参数的层面上讨论单个函数，而是希望给出事物如何共同工作的大画面。换句话说，它讨论的是 "概念"：什么是deal.II的构件，它们如何在有限元程序中一起使用。</li>
<li>该手册。这是deal.II中每一个类和每一个（成员）函数的文档。例如，如果你点击本页顶部的 "主页 "或 "类 "选项卡，你就可以看到。在这里你可以查到 <a class="el" href="classTriangulation.html#ada18f9251ebb60ac0200eafeeddb78c5">Triangulation::create_triangulation_compatibility</a> 的第二个参数是什么意思，这只是一个略显晦涩的例子。当你知道你要做什么，但忘记了函数到底是怎么命名的，它的参数是什么，或者它的返回值是什么时，你就需要这种级别的文档。请注意，当你读完教程并点击任何一个类或函数名称时，你也会进入手册，也就是说，当你需要对某个函数或类进行更详细的描述时，教程包含了大量进入手册的链接。另一方面，手册并不是学习deal.II的好地方，因为它只给你一个微观的观点，而没有告诉你一个函数是如何融入大局的。</li>
<li>模块。这些是一起工作或具有相关功能的类和函数组。如果你点击本页顶部的 "模块 "标签，你就会进入一个列出许多此类组的页面。每个模块都讨论了这些类的基本原理；例如， <a class="el" href="group__Sparsity.html">Sparsity patterns</a> 模块讨论了与存储矩阵的稀疏模式有关的各种不同问题。这就是中级水平的文档：它们给你一个特定领域的概述。例如，当你想知道存在哪些有限元类时，你会看一下 <a class="el" href="group__fe.html">Finite element space descriptions</a> 模块。当然，这些模块也与手册（有时也与教程）有交叉链接；如果你点击一个类的名字，比如说三角法，如果你想了解更多关于这个类的背景，也会在类名的右上方得到一个指向这个类所属模块的链接。</li>
</ul>
<p>让我们回到教程中来，因为你正在看的是它的第一个程序（或 "步骤"）。每个教程的程序都被细分为以下几个部分。</p><ol>
<li>
<b>Introduction:</b> 这是讨论程序的作用，包括数学模型，以及与以前的教程程序相比有哪些新的编程技术。 </li>
<li>
<b>The commented program:</b> 广泛地记录了源代码的清单。在这里，我们经常记录个别行或代码块，并讨论它们做什么，如何做，以及为什么。评论中经常提到介绍，也就是说，你必须先了解<em>what</em>程序想要达到的目标（介绍中讨论的目标），然后才能了解<em>how</em>它想要达到的目标。 </li>
<li>
<b>Results:</b> 程序的输出，包括注释和解释。这一部分也经常有一个小节，给出如何在不同方向上扩展程序的建议；在早期的程序中，这是为了给你提供小实验的方向，旨在使你熟悉deal.II，而在后来的程序中，更多的是关于如何使用更高级的数值技术。 </li>
<li>
<b>The plain program:</b> 剥去所有注释的源代码。如果你想看到代码的 "全貌"，这很有用，因为程序的注释版本中间有很多文字，往往很难在屏幕上一次看到单个函数的全部代码。 </li>
</ol>
<p>教程不仅意味着是静态文档，而且你应该玩玩它们。为此，进入 <code>example/step-1</code> 目录（或任何你感兴趣的教程的编号），然后输入</p>
<div class="fragment"><div class="line">cmake .</div><div class="line">make</div><div class="line">make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div></div><!-- fragment --><p>第一条命令设置了描述本教程程序所依赖的包含文件、如何编译以及如何运行的文件。这条命令应该也能找到已安装的deal.II库，这些库是在你按照<a href="../../readme.html" target="body">README</a>文件中描述的方式编译和安装一切时产生的。如果这个命令不能找到deal.II库，那么你需要用命令提供安装的路径</p>
<div class="fragment"><div class="line">cmake -DDEAL_II_DIR=/path/to/installed/deal.II .</div></div><!-- fragment --><p>而不是。</p>
<p>上述命令中的第二条将源代码编译成可执行文件，而最后一条则是执行它（严格来说，如果可执行文件还不存在， <code>make run</code> 也会编译代码，所以如果你想的话，你可以跳过第二条命令）。这就是运行代码和产生输出所需的全部内容，在教程程序的 "结果 "部分讨论。这个顺序需要在你想玩的所有教程目录中重复。</p>
<p>当学习这个库时，你需要玩玩它，看看会发生什么。为此，用你喜欢的编辑器打开 <code>example/step-1/step-1.cc</code> 的源文件，并以某种方式进行修改，保存它并按上述方式运行它。在这个程序的结果部分的末尾给出了一些可能的修改建议，在那里我们还提供了一些其他有用信息的链接。</p>
<p><a class="anchor" id="Videolecturesontutorialprograms"></a></p><h3>Video lectures on tutorial programs </h3>
<p>在关于deal.II和计算科学的<a href="http://www.math.colostate.edu/~bangerth/videos.html">Wolfgang Bangerth video lectures</a>中也讨论和演示了这个和其他几个教程程序。特别是，你可以看到他为运行这个和其他程序所执行的步骤，你会对可以用来处理deal.II的工具有一个更好的了解。特别是，第2和第4讲概述了deal.II和任何有限元代码的构建模块。( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.html">video lecture 2</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.4.html">video lecture 4</a>.)</p>
<p>如果你还不熟悉使用Linux和在命令行上运行东西，你可能会有兴趣观看讲座2.9和2.91。( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.9.html">video lecture 2.9</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.2.91.html">video lecture 2.91</a>.) These give overviews over the command 行和关于编译程序时发生的事情，分别。</p>
<p>请注意，deal.II正在积极开发，在开发过程中，我们偶尔会对这些视频讲座中仍然引用的函数或类进行重新命名或废弃。 例如，视频讲座5中的步骤1代码使用了一个HyperShellBoundary类，后来被SphericalManifold类取代。此外，从deal.II 9.0版本开始， <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> 现在自动将SphericalManifold附加到Triangulation上。否则，讲座材料的其余部分都是相关的。</p>
<p><a class="anchor" id="Whatthisprogramdoes"></a></p><h3>What this program does </h3>
<p>让我们回到步骤1，即当前的程序。在这第一个例子中，我们实际上并没有做很多事情，而是展示了两种技术：生成三角形对象的语法是什么，以及所有单元格上简单循环的一些元素。我们创建了两个网格，一个是有规律地细化的正方形（不是很刺激，但对于一些问题来说是常见的起始网格），还有一个是更多的几何尝试：一个环形域，向内边缘细化。通过这些，你将了解到每一个有限元程序都必须有的三样东西。一个用于网格的Triangulation类型的对象；对GridGenerator函数的调用以生成网格；以及涉及迭代器的所有单元的循环（迭代器是指针的泛化，在C++标准库中经常使用；在deal.II的背景下， <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> 模块谈到了它们）。</p>
<p>该程序在其他方面足够小，不需要大量的介绍。</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.5.html">video lecture 5</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.6.html">video lecture 6</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p><a class="anchor" id="Aboutscientificcomputingingeneral"></a></p><h3>About scientific computing in general </h3>
<p>如果你正在阅读这个教程程序，很可能你有兴趣继续使用deal.II来完成你自己的项目。因此，你即将开始一个使用大规模科学计算库的编程练习。除非你已经是大规模编程方法的资深用户，否则这对你来说可能是一个新的领域；伴随着所有的新规则，比如你将不得不处理别人写的代码，你可能不得不考虑记录自己的代码，因为你可能在一年后不记得它到底在做什么（或者因为别人也会使用它），或者想出一些方法来测试你的程序是否在做正确的事情。这些都不是我们通常训练数学家、工程师或科学家的东西，但当你开始编写超过几百行的软件时，这些就很重要了。请记住。制作软件并不等同于仅仅编写代码。</p>
<p>为了使你在这一旅程中生活得更轻松，让我们指出一些资源，这些资源在你开始任何大规模的编程之前是值得浏览的。</p>
<ul>
<li>在<a href="https://github.com/dealii/dealii/wiki/Frequently-Asked-Questions">deal.II FAQ</a>中，有大量关于deal.II特定方面问题的答案，但也有一些更普遍的问题，如 "我如何调试科学计算代码？"或 "我能否训练自己写出错误更少的代码？"。</li>
<li>你将从成为一个更好的程序员中受益。为此，一个很好的资源是Steve McConnell的<a href="https://en.wikipedia.org/wiki/Code_Complete">Code Complete</a> <b>[CodeComplete]</b> 。这本书已经有几年的历史了，最后一版是在2004年出版的，但它作为良好的编程实践指南的吸引力丝毫不减，一些主要的开发者把它作为他们研究小组每一代成员的集体阅读项目。</li>
<li><a href="http://software-carpentry.org/">Software Carpentry project</a>，提供了处理软件的许多重要主题的介绍，如版本控制、make文件、测试等。它是专门为科学家和工程师编写的，而不是为计算机科学家编写的，并以简短的、实用的课程为重点。</li>
<li><a href="https://bssw.io/">Better Scientific Software project</a>有大量的资源（和有趣的博文），涵盖了编写科学软件的许多方面。</li>
<li><a href="https://ideas-productivity.org/">IDEAS project</a>也有关于软件开发的资源，特别是用于并行计算。在该网站的 "活动 "部分有录制的教程和网络研讨会，涉及许多有趣的主题。</li>
<li>一篇关于<a href="http://arxiv.org/abs/1210.0530">Best Practices for Scientific Computing</a>的文章，介绍了许多方法，通过这些方法，你可以确保你是一个高效的程序员，写出的程序可以正常工作。</li>
</ul>
<p>作为一个一般性建议。如果你期望在未来花几天时间来编写软件，请帮你自己的忙，学习能够使你的生活更有效率的工具，特别是调试器和集成开发环境。( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.7.html">video lecture 7</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.8.html">video lecture 8</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.8.01.html">video lecture 8.01</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.25.html">video lecture 25</a>.) 你会发现，通过提高工作效率，你很快就会把学习这些工具的时间拿回来几倍!上面提到的几个视频讲座展示了如何使用集成开发环境或调试器等工具。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The most fundamental class in the library is the <a class="el" href="classTriangulation.html">Triangulation</a> class, which is declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div></div><!-- fragment --><p>Here are some functions to generate standard grids:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>Output of grids in various graphics formats:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div></div><!-- fragment --><p>This is needed for C++ output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>And this for the declarations of the <code>std::sqrt</code> and <code>std::fabs</code> functions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div></div><!-- fragment --><p>The final step in importing deal.II is this: All deal.II functions and classes are in a namespace <code>dealii</code>, to make sure they don't clash with symbols from other libraries you may want to use in conjunction with deal.II. One could use these functions and classes by prefixing every use of these names by <code>::</code>, but that would quickly become cumbersome and annoying. Rather, we simply import the entire deal.II namespace for general use:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Creatingthefirstmesh"></a> </p><h3>Creating the first mesh</h3>
<p>In the following, first function, we simply use the unit square as domain and produce a globally refined grid from it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> first_grid()</div><div class="line">{</div></div><!-- fragment --><p>The first thing to do is to define an object for a triangulation of a two-dimensional domain:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>Here and in many following cases, the string "&lt;2&gt;" after a class name indicates that this is an object that shall work in two space dimensions. Likewise, there are versions of the triangulation class that are working in one ("&lt;1&gt;") and three ("&lt;3&gt;") space dimensions. The way this works is through some template magic that we will investigate in some more detail in later example programs; there, we will also see how to write programs in an essentially dimension independent way.</p>
<p>Next, we want to fill the triangulation with a single cell for a square domain. The triangulation is the refined four times, to yield \(4^4=256\) cells in total:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div></div><!-- fragment --><p>Now we want to write a graphical representation of the mesh to an output file. The <a class="el" href="classGridOut.html">GridOut</a> class of deal.II can do that in a number of different output formats; here, we choose scalable vector graphics (SVG) format that you can visualize using the web browser of your choice:</p>
<div class="fragment"><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-1.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-1.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatingthesecondmesh"></a> </p><h3>Creating the second mesh</h3>
<p>The grid in the following, second function is slightly more complicated in that we use a ring domain and refine the result once globally.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> second_grid()</div><div class="line">{</div></div><!-- fragment --><p>We start again by defining an object for a triangulation of a two-dimensional domain:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div></div><!-- fragment --><p>We then fill it with a ring domain. The center of the ring shall be the point (1,0), and inner and outer radius shall be 0.5 and 1. The number of circumferential cells could be adjusted automatically by this function, but we choose to set it explicitly to 10 as the last argument:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">  triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 10);</div></div><!-- fragment --><p>By default, the triangulation assumes that all boundaries are straight lines, and all cells are bi-linear quads or tri-linear hexes, and that they are defined by the cells of the coarse grid (which we just created). Unless we do something special, when new points need to be introduced the domain is assumed to be delineated by the straight lines of the coarse mesh, and new points will simply be in the middle of the surrounding ones. Here, however, we know that the domain is curved, and we would like to have the <a class="el" href="classTriangulation.html">Triangulation</a> place new points according to the underlying geometry. Fortunately, some good soul implemented an object which describes a spherical domain, of which the ring is a section; it only needs the center of the ring and automatically figures out how to instruct the <a class="el" href="classTriangulation.html">Triangulation</a> where to place the new points. The way this works in deal.II is that you tag parts of the triangulation you want to be curved with a number that is usually referred to as "manifold indicator" and then tell the triangulation to use a particular "manifold object" for all places with this manifold indicator. How exactly this works is not important at this point (you can read up on it in <a class="el" href="step_53.html">step-53</a> and <a class="el" href="group__manifold.html">Manifold description for triangulations</a>). The functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> handle this for us in most circumstances: they attach the correct manifold to a domain so that when the triangulation is refined new cells are placed in the correct places. In the present case <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> attaches a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to all cells: this causes cells to be refined with calculations in spherical coordinates (so new cells have edges that are either radial or lie along concentric circles around the origin).</p>
<p>By default (i.e., for a <a class="el" href="classTriangulation.html">Triangulation</a> created by hand or without a call to a <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function like <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> or <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>), all cells and faces of the <a class="el" href="classTriangulation.html">Triangulation</a> have their manifold_id set to <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, which is the default if you want a manifold that produces straight edges, but you can change this number for individual cells and faces. In that case, the curved manifold thus associated with number zero will not apply to those parts with a non-zero manifold indicator, but other manifold description objects can be associated with those non-zero indicators. If no manifold description is associated with a particular manifold indicator, a manifold that produces straight edges is implied. (<a class="el" href="classManifold.html">Manifold</a> indicators are a slightly complicated topic; if you're confused about what exactly is happening here, you may want to look at the <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">glossary entry on this</a> topic".) Since the default chosen by <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> is reasonable we leave things alone.</p>
<p>In order to demonstrate how to write a loop over all cells, we will refine the grid in five steps towards the inner circle of the domain:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 5; ++step)</div><div class="line">  {</div></div><!-- fragment --><p>Next, we need to loop over the active cells of the triangulation. You can think of a triangulation as a collection of cells. If it were an array, you would just get a pointer that you increment from one element to the next using the operator <code>++</code>. The cells of a triangulation aren't stored as a simple array, but the concept of an <em>iterator</em> generalizes how pointers work to arbitrary collections of objects (see <a href="http://en.wikipedia.org/wiki/Iterator#C.2B.2B">wikipedia</a> for more information). Typically, any container type in C++ will return an iterator pointing to the start of the collection with a method called <code>begin</code>, and an iterator point to 1 past the end of the collection with a method called <code>end</code>. We can increment an iterator <code>it</code> with the operator <code>++it</code>, dereference it to get the underlying data with <code>*it</code>, and check to see if we're done by comparing <code>it != <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">collection.end()</a></code>.</p>
<p>The second important piece is that we only need the active cells. Active cells are those that are not further refined, and the only ones that can be marked for further refinement. deal.II provides iterator categories that allow us to iterate over <em>all</em> cells (including the parent cells of active ones) or only over the active cells. Because we want the latter, we need to call the method <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>.</p>
<p>Putting all of this together, we can loop over all the active cells of a triangulation with </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it = triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>().begin();</div><div class="line">     it != triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>().end();</div><div class="line">     ++it)</div><div class="line">  {</div><div class="line">    <span class="keyword">auto</span> cell = *it;</div><div class="line">    <span class="comment">// Then a miracle occurs...</span></div><div class="line">  }</div></div><!-- fragment --> </div><p> In the initializer of this loop, we've used the <code>auto</code> keyword for the type of the iterator <code>it</code>. The <code>auto</code> keyword means that the type of the object being declared will be inferred from the context. This keyword is useful when the actual type names are long or possibly even redundant. If you're unsure of what the type is and want to look up what operations the result supports, you can go to the documentation for the method <a class="el" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">Triangulation::active_cell_iterators()</a>. In this case, the type of <code>it</code> is <code><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a></code>.</p>
<p>While the <code>auto</code> keyword can save us from having to type out long names of data types, we still have to type a lot of redundant declarations about the start and end iterator and how to increment it. Instead of doing that, we'll use <a href="http://en.cppreference.com/w/cpp/language/range-for">range- based for loops</a>, which wrap up all of the syntax shown above into a much shorter form:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>See <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> for more information about the iterator classes used in deal.II, and <a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> for more information about range-based for loops and the <code>auto</code> keyword.</dd></dl>
<p>Next, we loop over all vertices of the cells. For that purpose we query an iterator over the vertex indices (in 2d, this is an array that contains the elements <code>{0,1,2,3}</code>, but since <code>cell-&gt;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices()</a></code> knows the dimension the cell lives in, the array so returned is correct in all dimensions and this enables this code to be correct whether we run it in 2d or 3d, i.e., it enables "dimension-independent programming" &ndash; a big part of what we will discuss in <a class="el" href="step_4.html">step-4</a>).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">  {</div></div><!-- fragment --><p>If this cell is at the inner boundary, then at least one of its vertices must sit on the inner ring and therefore have a radial distance from the center of exactly 0.5, up to floating point accuracy. So we compute this distance, and if we find a vertex with this property, we flag this cell for later refinement. We can then also break the loop over all vertices and move on to the next cell.</p>
<p>Because the distance from the center is computed as a floating point number, we have to expect that whatever we compute is only accurate to within <a href="https://en.wikipedia.org/wiki/Round-off_error">round-off</a>. As a consequence, we can never expect to compare the distance with the inner radius by equality: A statement such as <code>if (distance_from_center == inner_radius)</code> will fail unless we get exceptionally lucky. Rather, we need to do this comparison with a certain tolerance, and the usual way to do this is to write it as <code>if (std::abs(distance_from_center - inner_radius) &lt;= tolerance)</code> where <code>tolerance</code> is some small number larger than round-off. The question is how to choose it: We could just pick, say, <code>1e-10</code>, but this is only appropriate if the objects we compare are of size one. If we had created a mesh with cells of size <code>1e+10</code>, then <code>1e-10</code> would be far lower than round-off and, as before, the comparison will only succeed if we get exceptionally lucky. Rather, it is almost always useful to make the tolerance <em>relative</em> to a typical "scale" of the objects being compared. Here, the "scale" would be the inner radius, or maybe the diameter of cells. We choose the former and set the tolerance equal to \(10^{-6}\) times the inner radius of the annulus.</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">        <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">          1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">        {</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Now that we have marked all the cells that we want refined, we let the triangulation actually do this refinement. The function that does so owes its long name to the fact that one can also mark cells for coarsening, and the function does coarsening and refinement all at once:</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p>Finally, after these five iterations of refinement, we want to again write the resulting mesh to a file, again in SVG format. This works just as above:</p>
<div class="fragment"><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-2.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-2.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call the two subfunctions, which produce the two grids.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  first_grid();</div><div class="line">  second_grid();</div><div class="line">}</div></div><!-- fragment --><p> examples/step-1/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>运行该程序会产生两个网格的图形（grid-1.svg和grid-2.svg）。你可以用大多数网络浏览器打开它们&ndash;在最简单的情况下，只要在文件系统资源管理器中打开当前目录，然后点击文件。如果你喜欢在命令行上工作，你可以用该文件调用你的网络浏览器。<code>firefox grid-1.svg</code>，<code>google-chrome grid-1.svg</code>，或者任何你的浏览器的名字。如果你这样做，这两个网格应该是这样的。</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-1.grid-1-r9.2.png"/>
</div>
  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-1.grid-2-r9.2.png"/>
</div>
   </td></tr>
</table>
<p>左边那个，嗯，不是很刺激。右边的是&amp;mdash；至少是&amp;mdash；非传统的。这些图片对每个单元的 "细化水平 "进行了颜色编码。一个粗略的网格单元要被细分多少次才能得到给定的单元。在左图中，这是无聊的，因为网格被全局细化了若干次，也就是说，<em>every</em>单元被细化的次数相同。</p>
<p>(虽然第二个网状结构完全是人为捏造的，当然在应用中也不太实用，但令大家惊讶的是，它已经进入了文献：见 <b>[Mu05]</b> 。显然，它至少对某些事情是有好处的）。)</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="Differentadaptiverefinementstrategies"></a></p><h4>Different adaptive refinement strategies </h4>
<p>这个程序显然没有太多的功能，但特别是 <code>second_grid</code> 函数有一堆你可以玩弄它的地方。例如，你可以修改我们决定细化哪些单元格的标准。一个例子是把条件改成这样。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell: triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt; 0)</div><div class="line">    cell-&gt;set_refine_flag ();</div></div><!-- fragment --><p>这将细化所有单元中心的 \(y\) 坐标大于零的单元（我们通过解除引用 <code>cell</code> 迭代器调用的 <code><a class="el" href="classTriaAccessor.html#a8b045bcae58de112897824f4f08d1713">TriaAccessor::center</a></code> 函数返回一个Point&lt;2&gt;对象；下标 <code>[0]</code> 将得到 \(x\) 坐标，下标 <code>[1]</code> 得到 \(y\) 坐标）。通过查看TriaAccessor提供的函数，你也可以使用更复杂的标准进行细化。</p>
<p>一般来说，你能用<code>cell-&gt;something()</code>形式的操作做什么，在文档中有点困难，因为<code>cell</code>不是一个指针，而是一个迭代器。你可以在单元格上调用的函数可以在<code><a class="el" href="classTriaAccessor.html">TriaAccessor</a>'类的文档中找到（它的函数也可以在单元格的面或更普遍的、出现在三角形中的各种几何对象上调用），以及</code><a class="el" href="classCellAccessor.html">CellAccessor</a>'（它增加了一些专门针对*单元格的函数）。</p>
<p>对整个迭代器概念的更彻底的描述可以在 <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> 文档模块中找到。</p>
<p><a class="anchor" id="Differentgeometries"></a></p><h4>Different geometries </h4>
<p>另一种可能性是生成完全不同几何形状的网格。虽然对于复杂的几何体来说，使用网格生成器获得的网格是没有办法的，但是有大量的几何体，deal.II可以使用GridGenerator命名空间的函数来创建网格。许多这样的几何体（如本例程序中使用的几何体）包含有弯曲面的单元：换句话说，我们希望放置在边界上的新顶点位于一个圆上。deal.II通过Manifold类（以及从它继承的类）处理复杂的几何体；尤其是GridGenerator中对应于非笛卡尔网格的函数（如 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> 或 <a class="el" href="namespaceGridGenerator.html#ae63c93351f77276c20de07c91d3c1e48">GridGenerator::truncated_cone</a>) 将一个Manifold对象附加到三角网格中应该是曲线的部分（分别为SphericalManifold和CylindricalManifold），并在应该是平面的部分使用另一个Manifold（FlatManifold）。关于这些类的设计理念和接口的描述，请参见Manifold的文档或 <a class="el" href="group__manifold.html">manifold模块</a>。看看它们提供了什么，看看如何在这样的程序中使用它们。</p>
<p>我们还在第49步中讨论了其他各种创建和操作网格的方法（并描述了附加Manifolds的过程）。</p>
<p><a class="anchor" id="Commentsaboutprogramminganddebugging"></a></p><h4>Comments about programming and debugging </h4>
<p>最后，我们对用deal.II修改或编写程序做一个总体的评论。当你开始使用教程程序或你自己的应用程序时，你会发现错误会发生：你的程序会包含一些代码，这些代码要么是立即中止程序，要么是一些简单地导致错误结果的bug。无论哪种情况，你都会发现知道如何使用调试器是非常有帮助的：你可能会通过把调试输出放到你的程序中，编译它，然后运行它来应付一段时间，但最终用调试器寻找错误会更快，更方便，更可靠，因为你不必总是重新编译程序，而且你可以检查变量的值和它们的变化。</p>
<p>与其推迟学习如何使用调试器，直到你真的看不到任何其他方法来发现一个错误，这里是我们将在这个项目中提供的一个建议：尽快学习如何使用调试器。这将是很好的时间投资。( 从顶层的<a href="http://www.dealii.org/">deal.II webpage</a>链接到的 See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.25.html">video lecture 25</a>.) The deal.II Frequently Asked 问题（FAQ）页面也提供了大量关于调试deal.II程序的提示。</p>
<p><a class="anchor" id="Moreaboutgraphicaloutput"></a></p><h4>More about graphical output </h4>
<p>在你的论文或出版物中包含网格往往是有用的。为此，按细化级别对单元格进行颜色编码，并在每个单元格上打印单元格号，可能不是很有用。但这并不意味着一定要这样做 &ndash; GridOut类允许为每种可能的输出格式设置标志（参见GridOutFlags命名空间中的类），以控制网格的具体绘制方式。当然，你也可以选择其他的输出文件格式，如VTK或VTU；这对三维网格特别有用，因为二维格式如SVG并不特别有用，因为它固定了三维物体的特定视角。因此，你可能想探索GridOut类中的其他选项。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> first_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-1.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-1.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> second_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 10);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 5; ++step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">                <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">                  1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">                {</div><div class="line">                  cell-&gt;set_refine_flag();</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;grid-2.svg&quot;</span>);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a1fa6434f6a8d8cda104d47728d30c657">write_svg</a>(triangulation, out);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Grid written to grid-2.svg&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  first_grid();</div><div class="line">  second_grid();</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
