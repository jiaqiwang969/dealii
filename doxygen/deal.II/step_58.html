<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_58.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-58 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-58 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_26.html">step-26</a>, <a class="el" href="step_29.html">step-29</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Anoteaboutthecharacteroftheequations">A note about the character of the equations</a>
        <li><a href="#Thegeneralideaofoperatorsplitting">The general idea of operator splitting</a>
        <li><a href="#OperatorsplittingtheLiesplittingapproach">Operator splitting: the "Lie splitting" approach</a>
        <li><a href="#OperatorsplittingtheStrangsplittingapproach">Operator splitting: the "Strang splitting" approach</a>
        <li><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Spatialdiscretizationanddealingwithcomplexvariables">Spatial discretization and dealing with complex variables</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Definitionofthetestcase">Definition of the test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeNonlinearSchroedingerEquationcodeclass">The <code>NonlinearSchroedingerEquation</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeNonlinearSchroedingerEquationcodeclass">Implementation of the <code>NonlinearSchroedingerEquation</code> class</a>
      <ul>
        <li><a href="#Settingupdatastructuresandassemblingmatrices">Setting up data structures and assembling matrices</a>
        <li><a href="#ImplementingtheStrangsplittingsteps">Implementing the Strang splitting steps</a>
        <li><a href="#Creatinggraphicaloutput">Creating graphical output</a>
        <li><a href="#Runningthesimulation">Running the simulation</a>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Visualizingthesolution">Visualizing the solution</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Betterlinearsolvers"> Better linear solvers </a>
        <li><a href="#Boundaryconditions"> Boundary conditions </a>
        <li><a href="#Adaptivemeshes"> Adaptive meshes </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Wolfgang Bangerth (Colorado State University) and Yong-Yong Cai (<a href="http://www.csrc.ac.cn/en/">Beijing Computational Science Research Center</a>, CSRC) and is the result of the first author's time as a visitor at CSRC.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The <a href="https://en.wikipedia.org/wiki/Nonlinear_Schr%C3%B6dinger_equation">Nonlinear Schr&ouml;dinger Equation (NLSE)</a> for a function \(\psi=\psi(\mathbf x,t)\) and a potential \(V=V(\mathbf x)\) is a model often used in quantum mechanics and nonlinear optics. If one measures in appropriate quantities (so that \(\hbar=1\)), then it reads as follows: </p><p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi + V \psi + \kappa |\psi|^2 \psi &amp;= 0 \qquad\qquad &amp; \text{in}\; \Omega\times (0,T), \\ \psi(\mathbf x,0) &amp;= \psi_0(\mathbf x) &amp; \text{in}\; \Omega, \\ \psi(\mathbf x,t) &amp;= 0 &amp; \text{on}\; \partial\Omega\times (0,T). \end{align*}
</p>
<p> If there is no potential, i.e. \(V(\mathbf x)=0\), then it can be used to describe the propagation of light in optical fibers. If \(V(\mathbf x)\neq 0\), the equation is also sometimes called the <a href="https://en.wikipedia.org/wiki/Gross%E2%80%93Pitaevskii_equation">Gross-Pitaevskii equation</a> and can be used to model the time dependent behavior of <a href="https://en.wikipedia.org/wiki/Bose%E2%80%93Einstein_condensate">Bose-Einstein condensates</a>.</p>
<p>For this particular tutorial program, the physical interpretation of the equation is not of much concern to us. Rather, we want to use it as a model that allows us to explain two aspects:</p><ul>
<li>It is a <b>complex-valued equation</b> for \(\psi \in H^1(\Omega,{\mathbb C})\). We have previously seen complex-valued equations in <a class="el" href="step_29.html">step-29</a>, but there have opted to split the equations into real and imaginary parts and consequently ended up solving a system of two real-valued equations. In contrast, the goal here is to show how to solve problems in which we keep everything as complex numbers.</li>
<li>The equation is a nice model problem to explain how <b>operator splitting methods</b> work. This is because it has terms with fundamentally different character: on the one hand, \(- \frac 12 \Delta \psi\) is a regular spatial operator in the way we have seen many times before; on the other hand, \(\kappa |\psi(\mathbf x,t)|^2 \psi\) has no spatial or temporal derivatives, i.e., it is a purely local operator. It turns out that we have efficient methods for each of these terms (in particular, we have analytic solutions for the latter), and that we may be better off treating these terms differently and separately. We will explain this in more detail below.</li>
</ul>
<p><a class="anchor" id="Anoteaboutthecharacteroftheequations"></a></p><h3>A note about the character of the equations</h3>
<p>At first glance, the equations appear to be parabolic and similar to the heat equation (see <a class="el" href="step_26.html">step-26</a>) as there is only a single time derivative and two spatial derivatives. But this is misleading. Indeed, that this is not the correct interpretation is more easily seen if we assume for a moment that the potential \(V=0\) and \(\kappa=0\). Then we have the equation </p><p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi &amp;= 0. \end{align*}
</p>
<p> If we separate the solution into real and imaginary parts, \(\psi=v+iw\), with \(v=\textrm{Re}\;\psi,\; w=\textrm{Im}\;\psi\), then we can split the one equation into its real and imaginary parts in the same way as we did in <a class="el" href="step_29.html">step-29</a>: </p><p class="formulaDsp">
\begin{align*} \frac{\partial w}{\partial t} - \frac 12 \Delta v &amp;= 0, \\ -\frac{\partial v}{\partial t} - \frac 12 \Delta w &amp;= 0. \end{align*}
</p>
<p> Not surprisingly, the factor \(i\) in front of the time derivative couples the real and imaginary parts of the equation. If we want to understand this equation further, take the time derivative of one of the equations, say </p><p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} - \frac 12 \Delta \frac{\partial v}{\partial t} &amp;= 0, \end{align*}
</p>
<p> (where we have assumed that, at least in some formal sense, we can commute the spatial and temporal derivatives), and then insert the other equation into it: </p><p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} + \frac 14 \Delta^2 w &amp;= 0. \end{align*}
</p>
<p> This equation is hyperbolic and similar in character to the wave equation. (This will also be obvious if you look at the video in the "Results" section of this program.) Furthermore, we could have arrived at the same equation for \(v\) as well. Consequently, a better assumption for the NLSE is to think of it as a hyperbolic, wave-propagation equation than as a diffusion equation such as the heat equation. (You may wonder whether it is correct that the operator \(\Delta^2\) appears with a positive sign whereas in the wave equation, \(\Delta\) has a negative sign. This is indeed correct: After multiplying by a test function and integrating by parts, we want to come out with a positive (semi-)definite form. So, from \(-\Delta u\) we obtain \(+(\nabla v,\nabla u)\). Likewise, after integrating by parts twice, we obtain from \(+\Delta^2 u\) the form \(+(\Delta v,\Delta u)\). In both cases do we get the desired positive sign.)</p>
<p>The real NLSE, of course, also has the terms \(V\psi\) and \(\kappa|\psi|^2\psi\). However, these are of lower order in the spatial derivatives, and while they are obviously important, they do not change the character of the equation.</p>
<p>In any case, the purpose of this discussion is to figure out what time stepping scheme might be appropriate for the equation. The conclusions is that, as a hyperbolic-kind of equation, we need to choose a time step that satisfies a CFL-type condition. If we were to use an explicit method (which we will not), we would have to investigate the eigenvalues of the matrix that corresponds to the spatial operator. If you followed the discussions of the video lectures (See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.26.html">video lecture 26</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.27.html">video lecture 27</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html">video lecture 28</a>.) then you will remember that the pattern is that one needs to make sure that \(k^s \propto h^t\) where \(k\) is the time step, \(h\) the mesh width, and \(s,t\) are the orders of temporal and spatial derivatives. Whether you take the original equation ( \(s=1,t=2\)) or the reformulation for only the real or imaginary part, the outcome is that we would need to choose \(k \propto h^2\) if we were to use an explicit time stepping method. This is not feasible for the same reasons as in <a class="el" href="step_26.html">step-26</a> for the heat equation: It would yield impractically small time steps for even only modestly refined meshes. Rather, we have to use an implicit time stepping method and can then choose a more balanced \(k \propto h\). Indeed, we will use the implicit Crank-Nicolson method as we have already done in <a class="el" href="step_23.html">step-23</a> before for the regular wave equation.</p>
<p><a class="anchor" id="Thegeneralideaofoperatorsplitting"></a></p><h3>The general idea of operator splitting</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.30.25.html">video lecture 30.25</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>If one thought of the NLSE as an ordinary differential equation in which the right hand side happens to have spatial derivatives, i.e., write it as </p><p class="formulaDsp">
\begin{align*} \frac{d\psi}{dt} &amp;= i\frac 12 \Delta \psi -i V \psi -i\kappa |\psi|^2 \psi, \qquad\qquad &amp; \text{for}\; t \in (0,T), \\ \psi(0) &amp;= \psi_0, \end{align*}
</p>
<p> one may be tempted to "formally solve" it by integrating both sides over a time interval \([t_{n},t_{n+1}]\) and obtain </p><p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) -i V \psi(t) -i\kappa |\psi(t)|^2 \psi(t) \right) \; dt. \end{align*}
</p>
<p> Of course, it's not that simple: the \(\psi(t)\) in the integrand is still changing over time in accordance with the differential equation, so we cannot just evaluate the integral (or approximate it easily via quadrature) because we don't know \(\psi(t)\). But we can write this with separate contributions as follows, and this will allow us to deal with different terms separately: </p><p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi(t)|^2 \,\psi(t) \right) \; dt. \end{align*}
</p>
<p> The way this equation can now be read is as follows: For each time interval \([t_{n},t_{n+1}]\), the change \(\psi(t_{n+1})-\psi(t_{n})\) in the solution consists of three contributions:</p><ul>
<li>The contribution of the Laplace operator.</li>
<li>The contribution of the potential \(V\).</li>
<li>The contribution of the "phase" term \(-i\kappa |\psi(t)|^2\,\psi(t)\).</li>
</ul>
<p><em>Operator splitting</em> is now an approximation technique that allows us to treat each of these contributions separately. (If we want: In practice, we will treat the first two together, and the last one separate. But that is a detail, conceptually we could treat all of them differently.) To this end, let us introduce three separate "solutions": </p><p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p>These three "solutions" can be thought of as satisfying the following differential equations: </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n). \end{align*}
</p>
<p> In other words, they are all trajectories \(\psi^{(k)}\) that start at \(\psi(t_n)\) and integrate up the effects of exactly one of the three terms. The increments resulting from each of these terms over our time interval are then \(I^{(1)}=\psi^{(1)}(t_{n+1})-\psi(t_n)\), \(I^{(2)}=\psi^{(2)}(t_{n+1})-\psi(t_n)\), and \(I^{(3)}=\psi^{(3)}(t_{n+1})-\psi(t_n)\).</p>
<p>It is now reasonable to assume (this is an approximation!) that the change due to all three of the effects in question is well approximated by the sum of the three separate increments: </p><p class="formulaDsp">
\begin{align*} \psi(t_{n+1})-\psi(t_n) \approx I^{(1)} + I^{(2)} + I^{(3)}. \end{align*}
</p>
<p> This intuition is indeed correct, though the approximation is not exact: the difference between the exact left hand side and the term \(I^{(1)}+I^{(2)}+I^{(3)}\) (i.e., the difference between the <em>exact</em> increment for the exact solution \(\psi(t)\) when moving from \(t_n\) to \(t_{n+1}\), and the increment composed of the three parts on the right hand side), is proportional to \(\Delta t=t_{n+1}-t_{n}\). In other words, this approach introduces an error of size \({\cal O}(\Delta t)\). Nothing we have done so far has discretized anything in time or space, so the <em>overall</em> error is going to be \({\cal O}(\Delta t)\) plus whatever error we commit when approximating the integrals (the temporal discretization error) plus whatever error we commit when approximating the spatial dependencies of \(\psi\) (the spatial error).</p>
<p>Before we continue with discussions about operator splitting, let us talk about why one would even want to go this way? The answer is simple: For some of the separate equations for the \(\psi^{(k)}\), we may have ways to solve them more efficiently than if we throw everything together and try to solve it at once. For example, and particularly pertinent in the current case: The equation for \(\psi^{(3)}\), i.e., </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, \qquad\qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n), \end{align*}
</p>
<p> or equivalently, </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt, \end{align*}
</p>
<p> can be solved exactly: the equation is solved by </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t) = e^{-i\kappa|\psi(t_n)|^2 (t-t_{n})} \psi(t_n). \end{align*}
</p>
<p> This is easy to see if (i) you plug this solution into the differential equation, and (ii) realize that the magnitude \(|\psi^{(3)}|\) is constant, i.e., the term \(|\psi(t_n)|^2\) in the exponent is in fact equal to \(|\psi^{(3)}(t)|^2\). In other words, the solution of the ODE for \(\psi^{(3)}(t)\) only changes its <em>phase</em>, but the <em>magnitude</em> of the complex-valued function \(\psi^{(3)}(t)\) remains constant. This makes computing \(I^{(3)}\) particularly convenient: we don't actually need to solve any ODE, we can write the solution down by hand. Using the operator splitting approach, none of the methods to compute \(I^{(1)},I^{(2)}\) therefore have to deal with the nonlinear term and all of the associated unpleasantries: we can get away with solving only <em>linear</em> problems, as long as we allow ourselves the luxury of using an operator splitting approach.</p>
<p>Secondly, one often uses operator splitting if the different physical effects described by the different terms have different time scales. Imagine, for example, a case where we really did have some sort of diffusion equation. Diffusion acts slowly, but if \(\kappa\) is large, then the "phase rotation" by the term \(-i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t)\) acts quickly. If we treated everything together, this would imply having to take rather small time steps. But with operator splitting, we can take large time steps \(\Delta t=t_{n+1}-t_{n}\) for the diffusion, and (assuming we didn't have an analytic solution) use an ODE solver with many small time steps to integrate the "phase rotation" equation for \(\psi^{(3)}\) from \(t_n\) to \(t_{n+1}\). In other words, operator splitting allows us to decouple slow and fast time scales and treat them differently, with methods adjusted to each case.</p>
<p><a class="anchor" id="OperatorsplittingtheLiesplittingapproach"></a></p><h3>Operator splitting: the "Lie splitting" approach</h3>
<p>While the method above allows to compute the three contributions \(I^{(k)}\) in parallel, if we want, the method can be made slightly more accurate and easy to implement if we don't let the trajectories for the \(\psi^{(k)}\) start all at \(\psi(t_n)\), but instead let the trajectory for \(\psi^{(2)}\) start at the <em>end point</em> of the trajectory for \(\psi^{(1)}\), namely \(\psi^{(1)}(t_{n+1})\); similarly, we will start the trajectory for \(\psi^{(3)}\) start at the end point of the trajectory for \(\psi^{(2)}\), namely \(\psi^{(2)}(t_{n+1})\). This method is then called "Lie splitting" and has the same order of error as the method above, i.e., the splitting error is \({\cal O}(\Delta t)\).</p>
<p>This variation of operator splitting can be written as follows (carefully compare the initial conditions to the ones above): </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p> (Obviously, while the formulas above imply that we should solve these problems in this particular order, it is equally valid to first solve for trajectory 3, then 2, then 1, or any other permutation.)</p>
<p>The integrated forms of these equations are then </p><p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi^{(1)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi^{(2)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p> From a practical perspective, this has the advantage that we need to keep around fewer solution vectors: Once \(\psi^{(1)}(t_n)\) has been computed, we don't need \(\psi(t_n)\) any more; once \(\psi^{(2)}(t_n)\) has been computed, we don't need \(\psi^{(1)}(t_n)\) any more. And once \(\psi^{(3)}(t_n)\) has been computed, we can just call it \(\psi(t_{n+1})\) because, if you insert the first into the second, and then into the third equation, you see that the right hand side of \(\psi^{(3)}(t_n)\) now contains the contributions of all three physical effects: </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt+ \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p> (Compare this again with the "exact" computation of \(\psi(t_{n+1})\): It only differs in how we approximate \(\psi(t)\) in each of the three integrals.) In other words, Lie splitting is a lot simpler to implement that the original method outlined above because data handling is so much simpler.</p>
<p><a class="anchor" id="OperatorsplittingtheStrangsplittingapproach"></a></p><h3>Operator splitting: the "Strang splitting" approach</h3>
<p>As mentioned above, Lie splitting is only \({\cal O}(\Delta t)\) accurate. This is acceptable if we were to use a first order time discretization, for example using the explicit or implicit Euler methods to solve the differential equations for \(\psi^{(k)}\). This is because these time integration methods introduce an error proportional to \(\Delta t\) themselves, and so the splitting error is proportional to an error that we would introduce anyway, and does not diminish the overall convergence order.</p>
<p>But we typically want to use something higher order &ndash; say, a <a href="https://en.wikipedia.org/wiki/Crank%E2%80%93Nicolson_method">Crank-Nicolson</a> or <a href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">BDF2</a> method &ndash; since these are often not more expensive than a simple Euler method. It would be a shame if we were to use a time stepping method that is \({\cal O}(\Delta t^2)\), but then lose the accuracy again through the operator splitting.</p>
<p>This is where the <a href="https://en.wikipedia.org/wiki/Strang_splitting">Strang splitting</a> method comes in. It is easier to explain if we had only two parts, and so let us combine the effects of the Laplace operator and of the potential into one, and the phase rotation into a second effect. (Indeed, this is what we will do in the code since solving the equation with the Laplace equation with or without the potential costs the same &ndash; so we merge these two steps.) The Lie splitting method from above would then do the following: It computes solutions of the following two ODEs, </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)} -i V \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i\kappa |\psi^{(2)}|^2 \,\psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \end{align*}
</p>
<p> and then uses the approximation \(\psi(t_{n+1}) \approx \psi^{(2)}(t_{n+1})\). In other words, we first make one full time step for physical effect one, then one full time step for physical effect two. The solution at the end of the time step is simply the sum of the increments due to each of these physical effects separately.</p>
<p>In contrast, <a href="https://en.wikipedia.org/wiki/Gilbert_Strang">Gil Strang</a> (one of the titans of numerical analysis starting in the mid-20th century) figured out that it is more accurate to first do one half-step for one physical effect, then a full time step for the other physical effect, and then another half step for the first. Which one is which does not matter, but because it is so simple to do the phase rotation, we will use this effect for the half steps and then only need to do one spatial solve with the Laplace operator plus potential. This operator splitting method is now \({\cal O}(\Delta t^2)\) accurate. Written in formulas, this yields the following sequence of steps: </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= -i\kappa |\psi^{(1)}|^2 \,\psi^{(1)}, &amp;&amp; \text{for}\; t \in (t_n,t_n+\tfrac 12\Delta t), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= i\frac 12 \Delta \psi^{(2)} -i V \psi^{(2)}, \qquad &amp;&amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_n+\tfrac 12\Delta t), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp;&amp; \text{for}\; t \in (t_n+\tfrac 12\Delta t,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p> As before, the first and third step can be computed exactly for this particular equation, yielding </p><p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_n+\tfrac 12\Delta t) &amp;= e^{-i\kappa|\psi(t_n)|^2 \tfrac 12\Delta t} \; \psi(t_n), \\ \psi^{(3)}(t_{n+1}) &amp;= e^{-i\kappa|\psi^{(2)}(t_{n+1})|^2 \tfrac 12\Delta t} \; \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p>This is then how we are going to implement things in this program: In each time step, we execute three steps, namely</p><ul>
<li>Update the solution value at each node by analytically integrating the phase rotation equation by one half time step;</li>
<li>Solving the space-time equation that corresponds to the full step for \(\psi^{(2)}\), namely \(-i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0\), with initial conditions equal to the solution of the first half step above.</li>
<li>Update the solution value at each node by analytically integrating the phase rotation equation by another half time step.</li>
</ul>
<p>This structure will be reflected in an obvious way in the main time loop of the program.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>From the discussion above, it should have become clear that the only partial differential equation we have to solve in each time step is </p><p class="formulaDsp">
\begin{align*} -i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0. \end{align*}
</p>
<p> This equation is linear. Furthermore, we only have to solve it from \(t_n\) to \(t_{n+1}\), i.e., for exactly one time step.</p>
<p>To do this, we will apply the second order accurate Crank-Nicolson scheme that we have already used in some of the other time dependent codes (specifically: <a class="el" href="step_23.html">step-23</a> and <a class="el" href="step_26.html">step-26</a>). It reads as follows: </p><p class="formulaDsp">
\begin{align*} -i\frac{\psi^{(n,2)}-\psi^{(n,1)}}{k_{n+1}} - \frac 12 \Delta \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] + V \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] = 0. \end{align*}
</p>
<p> Here, the "previous" solution \(\psi^{(n,1)}\) (or the "initial
condition" for this part of the time step) is the output of the first phase rotation half-step; the output of the current step will be denoted by \(\psi^{(n,2)}\). \(k_{n+1}=t_{n+1}-t_n\) is the length of the time step. (One could argue whether \(\psi^{(n,1)}\) and \(\psi^{(n,1)}\) live at time step \(n\) or \(n+1\) and what their upper indices should be. This is a philosophical discussion without practical impact, and one might think of \(\psi^{(n,1)}\) as something like \(\psi^{(n+\tfrac 13)}\), and \(\psi^{(n,2)}\) as \(\psi^{(n+\tfrac 23)}\) if that helps clarify things &ndash; though, again \(n+\frac 13\) is not to be understood as "one third time step after
 \form#384" but more like "we've already done one third of the work necessary
for time step \form#2653".)</p>
<p>If we multiply the whole equation with \(k_{n+1}\) and sort terms with the unknown \(\psi^{(n+1,2)}\) to the left and those with the known \(\psi^{(n,2)}\) to the right, then we obtain the following (spatial) partial differential equation that needs to be solved in each time step: </p><p class="formulaDsp">
\begin{align*} -i\psi^{(n,2)} - \frac 14 k_{n+1} \Delta \psi^{(n,2)} + \frac 12 k_{n+1} V \psi^{(n,2)} = -i\psi^{(n,1)} + \frac 14 k_{n+1} \Delta \psi^{(n,1)} - \frac 12 k_{n+1} V \psi^{(n,1)}. \end{align*}
</p>
<p><a class="anchor" id="Spatialdiscretizationanddealingwithcomplexvariables"></a></p><h3>Spatial discretization and dealing with complex variables</h3>
<p>As mentioned above, the previous tutorial program dealing with complex-valued solutions (namely, <a class="el" href="step_29.html">step-29</a>) separated real and imaginary parts of the solution. It thus reduced everything to real arithmetic. In contrast, we here want to keep things complex-valued.</p>
<p>The first part of this is that we need to define the discretized solution as \(\psi_h^n(\mathbf x)=\sum_j \Psi^n_j \varphi_j(\mathbf x) \approx \psi(\mathbf x,t_n)\) where the \(\varphi_j\) are the usual shape functions (which are real valued) but the expansion coefficients \(\Psi^n_j\) at time step \(n\) are now complex-valued. This is easily done in deal.II: We just have to use <a class="el" href="classVector.html">Vector</a>&lt;std::complex&lt;double&gt;&gt; instead of <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> to store these coefficients.</p>
<p>Of more interest is how to build and solve the linear system. Obviously, this will only be necessary for the second step of the Strang splitting discussed above, with the time discretization of the previous subsection. We obtain the fully discrete version through straightforward substitution of \(\psi^n\) by \(\psi^n_h\) and multiplication by a test function: </p><p class="formulaDsp">
\begin{align*} -iM\Psi^{(n,2)} + \frac 14 k_{n+1} A \Psi^{(n,2)} + \frac 12 k_{n+1} W \Psi^{(n,2)} = -iM\Psi^{(n+1,1)} - \frac 14 k_{n+1} A \Psi^{(n,1)} - \frac 12 k_{n+1} W \Psi^{(n,1)}, \end{align*}
</p>
<p> or written in a more compact way: </p><p class="formulaDsp">
\begin{align*} \left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}. \end{align*}
</p>
<p> Here, the matrices are defined in their obvious ways: </p><p class="formulaDsp">
\begin{align*} M_{ij} &amp;= (\varphi_i,\varphi_j), \\ A_{ij} &amp;= (\nabla\varphi_i,\nabla\varphi_j), \\ W_{ij} &amp;= (\varphi_i,V \varphi_j). \end{align*}
</p>
<p> Note that all matrices individually are in fact symmetric, real-valued, and at least positive semidefinite, though the same is obviously not true for the system matrix \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) and the corresponding matrix \(R = -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W\) on the right hand side.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.34.html">video lecture 34</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>The only remaining important question about the solution procedure is how to solve the complex-valued linear system </p><p class="formulaDsp">
\begin{align*} C \Psi^{(n+1,2)} = R \Psi^{(n+1,1)}, \end{align*}
</p>
<p> with the matrix \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) and a right hand side that is easily computed as the product of a known matrix and the previous part-step's solution. As usual, this comes down to the question of what properties the matrix \(C\) has. If it is symmetric and positive definite, then we can for example use the Conjugate Gradient method.</p>
<p>Unfortunately, the matrix's only useful property is that it is complex symmetric, i.e., \(C_{ij}=C_{ji}\), as is easy to see by recalling that \(M,A,W\) are all symmetric. It is not, however, <a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian</a>, which would require that \(C_{ij}=\bar C_{ji}\) where the bar indicates complex conjugation.</p>
<p>Complex symmetry can be exploited for iterative solvers as a quick literature search indicates. We will here not try to become too sophisticated (and indeed leave this to the <a href="#extensions">Possibilities for extensions</a> section below) and instead simply go with the good old standby for problems without properties: A direct solver. That's not optimal, especially for large problems, but it shall suffice for the purposes of a tutorial program. Fortunately, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class allows solving complex-valued problems.</p>
<p><a class="anchor" id="Definitionofthetestcase"></a></p><h3>Definition of the test case</h3>
<p>Initial conditions for the NLSE are typically chosen to represent particular physical situations. This is beyond the scope of this program, but suffice it to say that these initial conditions are (i) often superpositions of the wave functions of particles located at different points, and that (ii) because \(|\psi(\mathbf x,t)|^2\) corresponds to a particle density function, the integral </p><p class="formulaDsp">
\[ N(t) = \int_\Omega |\psi(\mathbf x,t)|^2 \]
</p>
<p> corresponds to the number of particles in the system. (Clearly, if one were to be physically correct, \(N(t)\) better be a constant if the system is closed, or \(\frac{dN}{dt}&lt;0\) if one has absorbing boundary conditions.) The important point is that one should choose initial conditions so that </p><p class="formulaDsp">
\[ N(0) = \int_\Omega |\psi_0(\mathbf x)|^2 \]
</p>
<p> makes sense.</p>
<p>What we will use here, primarily because it makes for good graphics, is the following: </p><p class="formulaDsp">
\[ \psi_0(\mathbf x) = \sqrt{\sum_{k=1}^4 \alpha_k e^{-\frac{r_k^2}{R^2}}}, \]
</p>
<p> where \(r_k = |\mathbf x-\mathbf x_k|\) is the distance from the (fixed) locations \(\mathbf x_k\), and \(\alpha_k\) are chosen so that each of the Gaussians that we are adding up adds an integer number of particles to \(N(0)\). We achieve this by making sure that </p><p class="formulaDsp">
\[ \int_\Omega \alpha_k e^{-\frac{r_k^2}{R^2}} \]
</p>
<p> is a positive integer. In other words, we need to choose \(\alpha\) as an integer multiple of </p><p class="formulaDsp">
\[ \left(\int_\Omega e^{-\frac{r_k^2}{R^2}}\right)^{-1} = \left(R^d\sqrt{\pi^d}\right)^{-1}, \]
</p>
<p> assuming for the moment that \(\Omega={\mathbb R}^d\) &ndash; which is of course not the case, but we'll ignore the small difference in integral.</p>
<p>Thus, we choose \(\alpha_k=\left(R^d\sqrt{\pi^d}\right)^{-1}\) for all, and \(R=0.1\). This \(R\) is small enough that the difference between the exact (infinite) integral and the integral over \(\Omega\) should not be too concerning. We choose the four points \(\mathbf x_k\) as \((\pm 0.3, 0), (0, \pm 0.3)\) &ndash; also far enough away from the boundary of \(\Omega\) to keep ourselves on the safe side.</p>
<p>For simplicity, we pose the problem on the square \([-1,1]^2\). For boundary conditions, we will use time-independent Neumann conditions of the form </p><p class="formulaDsp">
\[ \nabla\psi(\mathbf x,t)\cdot \mathbf n=0 \qquad\qquad \forall \mathbf x\in\partial\Omega. \]
</p>
<p> This is not a realistic choice of boundary conditions but sufficient for what we want to demonstrate here. We will comment further on this in the <a href="#extensions">Possibilities for extensions</a> section below.</p>
<p>Finally, we choose \(\kappa=1\), and the potential as </p><p class="formulaDsp">
\[ V(\mathbf x) = \begin{cases} 0 &amp; \text{if}\; |\mathbf x|&lt;0.7 \\ 1000 &amp; \text{otherwise}. \end{cases} \]
</p>
<p> Using a large potential makes sure that the wave function \(\psi\) remains small outside the circle of radius 0.7. All of the Gaussians that make up the initial conditions are within this circle, and the solution will mostly oscillate within it, with a small amount of energy radiating into the outside. The use of a large potential also makes sure that the nonphysical boundary condition does not have too large an effect.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The program starts with the usual include files, all of which you should have seen before by now:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Then the usual placing of all content of this program into a namespace and the importation of the deal.II namespace into the one we will work in:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step58</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>The <code>NonlinearSchroedingerEquation</code> class</h3>
<p>Then the main class. It looks very much like the corresponding classes in <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a>, with the only exception that the matrices and vectors and everything else related to the linear system are now storing elements of type <code>std::complex&lt;double&gt;</code> instead of just <code>double</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>NonlinearSchroedingerEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  NonlinearSchroedingerEquation();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_matrices();</div><div class="line">  <span class="keywordtype">void</span> do_half_phase_step();</div><div class="line">  <span class="keywordtype">void</span> do_full_spatial_step();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; rhs_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; system_rhs;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time;</div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> kappa;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial values, as well as a right hand side class. (We will reuse the initial conditions also for the boundary values, which we simply keep constant.) We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not look surprising. The only point of interest is that we here have a complex-valued problem, so we have to provide the second template argument of the <a class="el" href="classFunction.html">Function</a> class (which would otherwise default to <code>double</code>). Furthermore, the return type of the <code>value()</code> functions is then of course also complex.</p>
<p>What precisely these functions return has been discussed at the end of the Introduction section.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim, <a class="code" href="namespacestd.html">std</a>::complex&lt;<a class="code" href="classdouble.html">double</a>&gt;&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::complex&lt;double&gt;</div><div class="line">  <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::complex&lt;double&gt;</div><div class="line">InitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  static_assert(dim == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div><div class="line"></div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0, -0.3},</div><div class="line">                                                  {0, +0.3},</div><div class="line">                                                  {+0.3, 0},</div><div class="line">                                                  {-0.3, 0}};</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha =</div><div class="line">    1. / (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(numbers::PI, dim / 2.));</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> sum = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = p - vortex_center;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">      sum += alpha * <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r * r) / (R * R));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(sum), 0.};</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Potential() = <span class="keywordflow">default</span>;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Potential&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(p) &gt; 0.7 ? 1000 : 0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>Implementation of the <code>NonlinearSchroedingerEquation</code> class</h3>
<p>We start by specifying the implementation of the constructor of the class. There is nothing of surprise to see here except perhaps that we choose quadratic ( \(Q_2\)) Lagrange elements &ndash; the solution is expected to be smooth, so we choose a higher polynomial degree than the bare minimum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation()</div><div class="line">  : fe(2)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time(0)</div><div class="line">  , time_step(1. / 128)</div><div class="line">  , timestep_number(0)</div><div class="line">  , kappa(1)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Settingupdatastructuresandassemblingmatrices"></a> </p><h4>Setting up data structures and assembling matrices</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(6);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  rhs_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.close();</div><div class="line">}</div></div><!-- fragment --><p>Next, we assemble the relevant matrices. The way we have written the Crank-Nicolson discretization of the spatial step of the Strang splitting (i.e., the second of the three partial steps in each time step), we were led to the linear system \(\left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}\). In other words, there are two matrices in play here &ndash; one for the left and one for the right hand side. We build these matrices separately. (One could avoid building the right hand side matrix and instead just form the <em>action</em> of the matrix on \(\Psi^{(n,1)}\) in each time step. This may or may not be more efficient, but efficiency is not foremost on our minds for this program.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;                  potential_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div><div class="line">      cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      potential.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           potential_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> std::complex&lt;double&gt; i = {0, 1};</div><div class="line"></div><div class="line">                  cell_matrix_lhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                    (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                     time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                     time_step / 2 * potential_values[q_index] *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line"></div><div class="line">                  cell_matrix_rhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                    (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                     time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                     time_step / 2 * potential_values[q_index] *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.distribute_local_to_global(cell_matrix_lhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             system_matrix);</div><div class="line">      constraints.distribute_local_to_global(cell_matrix_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             rhs_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementingtheStrangsplittingsteps"></a> </p><h4>Implementing the Strang splitting steps</h4>
<p>Having set up all data structures above, we are now in a position to implement the partial steps that form the Strang splitting scheme. We start with the half-step to advance the phase, and that is used as the first and last part of each time step.</p>
<p>To this end, recall that for the first half step, we needed to compute \(\psi^{(n,1)} = e^{-i\kappa|\psi^{(n,0)}|^2 \tfrac 12\Delta t} \; \psi^{(n,0)}\). Here, \(\psi^{(n,0)}=\psi^{(n)}\) and \(\psi^{(n,1)}\) are functions of space and correspond to the output of the previous complete time step and the result of the first of the three part steps, respectively. A corresponding solution must be computed for the third of the part steps, i.e. \(\psi^{(n,3)} = e^{-i\kappa|\psi^{(n,2)}|^2 \tfrac 12\Delta t} \; \psi^{(n,2)}\), where \(\psi^{(n,3)}=\psi^{(n+1)}\) is the result of the time step as a whole, and its input \(\psi^{(n,2)}\) is the result of the spatial step of the Strang splitting.</p>
<p>An important realization is that while \(\psi^{(n,0)}(\mathbf x)\) may be a finite element function (i.e., is piecewise polynomial), this may not necessarily be the case for the "rotated" function in which we have updated the phase using the exponential factor (recall that the amplitude of that function remains constant as part of that step). In other words, we could compute* \(\psi^{(n,1)}(\mathbf x)\) at every point \(\mathbf x\in\Omega\), but we can't represent it on a mesh because it is not a piecewise polynomial function. The best we can do in a discrete setting is to compute a projection or interpolation. In other words, we can compute \(\psi_h^{(n,1)}(\mathbf x) = \Pi_h \left(e^{-i\kappa|\psi_h^{(n,0)}(\mathbf x)|^2 \tfrac 12\Delta t} \; \psi_h^{(n,0)}(\mathbf x) \right)\) where \(\Pi_h\) is a projection or interpolation operator. The situation is particularly simple if we choose the interpolation: Then, all we need to compute is the value of the right hand side <em>at the node points</em> and use these as nodal values for the vector \(\Psi^{(n,1)}\) of degrees of freedom. This is easily done because evaluating the right hand side at node points for a Lagrange finite element as used here requires us to only look at a single (complex-valued) entry of the node vector. In other words, what we need to do is to compute \(\Psi^{(n,1)}_j = e^{-i\kappa|\Psi^{(n,0)}_j|^2 \tfrac 12\Delta t} \; \Psi^{(n,0)}_j\) where \(j\) loops over all of the entries of our solution vector. This is what the function below does &ndash; in fact, it doesn't even use separate vectors for \(\Psi^{(n,0)}\) and \(\Psi^{(n,1)}\), but just updates the same vector as appropriate.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : solution)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; i         = {0, 1};</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(value);</div><div class="line"></div><div class="line">      value = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-i * kappa * magnitude * magnitude * (time_step / 2)) *</div><div class="line">              value;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The next step is to solve for the linear system in each time step, i.e., the second half step of the Strang splitting we use. Recall that it had the form \(C\Psi^{(n,2)} = R\Psi^{(n,1)}\) where \(C\) and \(R\) are the matrices we assembled earlier.</p>
<p>The way we solve this here is using a direct solver. We first form the right hand side \(r=R\Psi^{(n,1)}\) using the <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult()</a> function and put the result into the <code>system_rhs</code> variable. We then call SparseDirectUMFPACK::solver() which takes as argument the matrix \(C\) and the right hand side vector and returns the solution in the same vector <code>system_rhs</code>. The final step is then to put the solution so computed back into the <code>solution</code> variable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step()</div><div class="line">{</div><div class="line">  rhs_matrix.vmult(system_rhs, solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">  solution = system_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatinggraphicaloutput"></a> </p><h4>Creating graphical output</h4>
<p>The last of the helper functions and classes we ought to discuss are the ones that create graphical output. The result of running the half and full steps for the local and spatial parts of the Strang splitting is that we have updated the <code>solution</code> vector \(\Psi^n\) to the correct value at the end of each time step. Its entries contain complex numbers for the solution at the nodes of the finite element mesh.</p>
<p>Complex numbers are not easily visualized. We can output their real and imaginary parts, i.e., the fields \(\text{Re}(\psi_h^{(n)}(\mathbf x))\) and \(\text{Im}(\psi_h^{(n)}(\mathbf x))\), and that is exactly what the <a class="el" href="classDataOut.html">DataOut</a> class does when one attaches as complex-valued vector via <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> and then calls <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. That is indeed what we do below.</p>
<p>But oftentimes we are not particularly interested in real and imaginary parts of the solution vector, but instead in derived quantities such as the magnitude \(|\psi|\) and phase angle \(\text{arg}(\psi)\) of the solution. In the context of quantum systems such as here, the magnitude itself is not so interesting, but instead it is the "amplitude", \(|\psi|^2\) that is a physical property: it corresponds to the probability density of finding a particle in a particular place of state. The way to put computed quantities into output files for visualization &ndash; as used in numerous previous tutorial programs &ndash; is to use the facilities of the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> and derived classes. Specifically, both the amplitude of a complex number and its phase angles are scalar quantities, and so the <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> class is the right tool to base what we want to do on.</p>
<p>Consequently, what we do here is to implement two classes <code>ComplexAmplitude</code> and <code>ComplexPhase</code> that compute for each point at which <a class="el" href="classDataOut.html">DataOut</a> decides to generate output, the amplitudes \(|\psi_h|^2\) and phases \(\text{arg}(\psi_h)\) of the solution for visualization. There is a fair amount of boiler-plate code below, with the only interesting parts of the first of these two classes being how its <code>evaluate_vector_field()</code> function computes the <code>computed_quantities</code> object.</p>
<p>(There is also the rather awkward fact that the <a href="https://en.cppreference.com/w/cpp/numeric/complex/norm">std::norm()</a> function does not compute what one would naively imagine, namely \(|\psi|\), but returns \(|\psi|^2\) instead. It's certainly quite confusing to have a standard function mis-named in such a way...)</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>DataPostprocessors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComplexAmplitude();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                       inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1));</div><div class="line">        computed_quantities[q](0) = <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm</a>(psi);</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>The second of these postprocessor classes computes the phase angle of the complex-valued solution at each point. In other words, if we represent \(\psi(\mathbf x,t)=r(\mathbf x,t) e^{i\varphi(\mathbf x,t)}\), then this class computes \(\varphi(\mathbf x,t)\). The function <a href="https://en.cppreference.com/w/cpp/numeric/complex/arg">std::arg</a> does this for us, and returns the angle as a real number between \(-\pi\) and \(+\pi\).</p>
<p>For reasons that we will explain in detail in the results section, we do not actually output this value at each location where output is generated. Rather, we take the maximum over all evaluation points of the phase and then fill each evaluation point's output field with this maximum &ndash; in essence, we output the phase angle as a piecewise constant field, where each cell has its own constant value. The reasons for this will become clear once you read through the discussion further down below.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComplexPhase();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComplexPhase&lt;dim&gt;::ComplexPhase()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_phase = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">        max_phase =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_phase,</div><div class="line">                   std::arg(</div><div class="line">                     std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                          inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1))));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;output : computed_quantities)</div><div class="line">      output(0) = max_phase;</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace DataPostprocessors</span></div></div><!-- fragment --><p>Having so implemented these post-processors, we create output as we always do. As in many other time-dependent tutorial programs, we attach flags to <a class="el" href="classDataOut.html">DataOut</a> that indicate the number of the time step and the current simulation time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div><div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;Psi&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_magnitude);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_phase);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, timestep_number));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Runningthesimulation"></a> </p><h4>Running the simulation</h4>
<p>The remaining step is how we set up the overall logic for this program. It's really relatively simple: Set up the data structures; interpolate the initial conditions onto finite element space; then iterate over all time steps, and on each time step perform the three parts of the Strang splitting method. Every tenth time step, we generate graphical output. That's it.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line">    assemble_matrices();</div><div class="line"></div><div class="line">    time = 0;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), solution);</div><div class="line">    output_results();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div><div class="line">    <span class="keywordflow">for</span> (; time &lt;= end_time; time += time_step)</div><div class="line">      {</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        do_half_phase_step();</div><div class="line">        do_full_spatial_step();</div><div class="line">        do_half_phase_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div><div class="line">          output_results();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step58</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The main() function</h4>
<p>The rest is again boiler plate and exactly as in almost all of the previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step58;</div><div class="line"></div><div class="line">      NonlinearSchroedingerEquation&lt;2&gt; nse;</div><div class="line">      nse.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the code results in screen output like the following: </p><div class="fragment"><div class="line">Number of active cells: 4096</div><div class="line">Number of degrees of freedom: 16641</div><div class="line"></div><div class="line">Time step 1 at t=0</div><div class="line">Time step 2 at t=0.00390625</div><div class="line">Time step 3 at t=0.0078125</div><div class="line">Time step 4 at t=0.0117188</div><div class="line">[...]</div></div><!-- fragment --><p> Running the program also yields a good number of output files that we will visualize in the following.</p>
<p><a class="anchor" id="Visualizingthesolution"></a></p><h3>Visualizing the solution</h3>
<p>The <code>output_results()</code> function of this program generates output files that consist of a number of variables: The solution (split into its real and imaginary parts), the amplitude, and the phase. If we visualize these four fields, we get images like the following after a few time steps (at time \(t=0.242\), to be precise:</p>
<div class="twocolumn" style="width: 80%"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.re.png" alt="Real part of the solution at t=0.242" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.im.png" alt="Imaginary part of the solution at t=0.242" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.magnitude.png" alt="Amplitude of the solution at t=0.242" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.phase.png" alt="Phase of the solution at t=0.242" width="400"/>
</div>
 </div> </div><p>While the real and imaginary parts of the solution shown above are not particularly interesting (because, from a physical perspective, the global offset of the phase and therefore the balance between real and imaginary components, is meaningless), it is much more interesting to visualize the amplitude \(|\psi(\mathbf x,t)|^2\) and phase \(\text{arg}(\psi(\mathbf x,t))\) of the solution and, in particular, their evolution. This leads to pictures like the following:</p>
<p>The phase picture shown here clearly has some flaws:</p><ul>
<li>First, phase is a "cyclic quantity", but the color scale uses a fundamentally different color for values close to \(-\pi\) than for values close to \(+\pi\). This is a nuisance &ndash; what we need is a "cyclic color map" that uses the same colors for the two extremes of the range of the phase. Such color maps exist, see <a href="https://nicoguaro.github.io/posts/cyclic_colormaps/">this blog post of Nicolás Guarín-Zapata</a> or <a href="https://stackoverflow.com/questions/23712207/cyclic-colormap-without-visual-distortions-for-use-in-phase-angle-plots">this StackExchange post</a>, for example. The problem is that the author's favorite one of the two big visualization packages, VisIt, does not have any of these color maps built in. In an act of desperation, I therefore had to resort to using Paraview given that it has several of the color maps mentioned in the post above implemented. The picture below uses the <code>nic_Edge</code> map in which both of the extreme values are shown as black.</li>
<li>There is a problem on cells in which the phase wraps around. If at some evaluation point of the cell the phase value is close to \(-\pi\) and at another evaluation point it is close to \(+\pi\), then what we would really like to happen is for the entire cell to have a color close to the extremes. But, instead, visualization programs produce a linear interpolation in which the values within the cell, i.e., between the evaluation points, is linearly interpolated between these two values, covering essentially the entire range of possible phase values and, consequently, cycling through the entire rainbow of colors from dark red to dark green over the course of one cell. The solution to this problem is to just output the phase value on each cell as a piecewise constant. Because averaging values close to the \(-\pi\) and \(+\pi\) is going to result in an average that has nothing to do with the actual phase angle, the <code>ComplexPhase</code> class just uses the <em>maximal</em> phase angle encountered on each cell.</li>
</ul>
<p>With these modifications, the phase plot now looks as follows:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.phase-cyclic.png" alt="Phase of the solution at t=0.242, with a cyclic color map" width="400"/>
</div>
 <p>Finally, we can generate a movie out of this. (To be precise, the video uses two more global refinement cycles and a time step half the size of what is used in the program above.) The author of these lines made the movie with VisIt, because that's what he's more familiar with, and using a hacked color map that is also cyclic &ndash; though this color map lacks all of the skill employed by the people who wrote the posts mentioned in the links above. It does, however, show the character of the solution as a wave equation if you look at the shaded part of the domain outside the circle of radius 0.7 in which the potential is zero &ndash; you can see how every time one of the bumps (showing the amplitude \(|\psi_h(\mathbf x,t)|^2\)) bumps into the area where the potential is large: a wave travels outbound from there. Take a look at the video:</p>
<p> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nraszP3GZHk"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</p>
<p>So why did I end up shading the area where the potential \(V(\mathbf x)\) is large? In that outside region, the solution is relatively small. It is also relatively smooth. As a consequence, to some approximate degree, the equation in that region simplifies to </p><p class="formulaDsp">
\[ - i \frac{\partial \psi}{\partial t} + V \psi \approx 0, \]
</p>
<p> or maybe easier to read: </p><p class="formulaDsp">
\[ \frac{\partial \psi}{\partial t} \approx - i V \psi. \]
</p>
<p> To the degree to which this approximation is valid (which, among other things, eliminates the traveling waves you can see in the video), this equation has a solution </p><p class="formulaDsp">
\[ \psi(\mathbf x, t) = \psi(\mathbf x, 0) e^{-i V t}. \]
</p>
<p> Because \(V\) is large, this means that the phase <em>rotates quite rapidly</em>. If you focus on the semi-transparent outer part of the domain, you can see that. If one colors this region in the same way as the inner part of the domain, this rapidly flashing outer part may be psychedelic, but is also distracting of what's happening on the inside; it's also quite hard to actually see the radiating waves that are easy to see at the beginning of the video.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Betterlinearsolvers"></a></p><h4>Better linear solvers </h4>
<p>The solver chosen here is just too simple. It is also not efficient. What we do here is give the matrix to a sparse direct solver in every time step and let it find the solution of the linear system. But we know that we could do far better:</p>
<ul>
<li>First, we should make use of the fact that the matrix doesn't actually change from time step to time step. This is an artifact of the fact that we here have constant boundary values and that we don't change the time step size &ndash; two assumptions that might not be true in actual applications. But at least in cases where this does happen to be the case, it would make sense to only factorize the matrix once (i.e., compute \(L\) and \(U\) factors once) and then use these factors for all following time steps until the matrix \(C\) changes and requires a new factorization. The interface of the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class allows for this.</li>
<li>Ultimately, however, sparse direct solvers are only efficient for relatively small problems, say up to a few 100,000 unknowns. Beyond this, one needs iterative solvers such as the Conjugate Gradient method (for symmetric and positive definite problems) or GMRES. We have used many of these in other tutorial programs. In all cases, they need to be accompanied by good preconditioners. For the current case, one could in principle use GMRES &ndash; a method that does not require any specific properties of the matrix &ndash; but would be better advised to implement an iterative scheme that exploits the one structural feature we know is true for this problem: That the matrix is complex-symmetric (albeit not Hermitian).</li>
</ul>
<p><a class="anchor" id="Boundaryconditions"></a></p><h4>Boundary conditions </h4>
<p>In order to be usable for actual, realistic problems, solvers for the nonlinear Schr&ouml;dinger equation need to utilize boundary conditions that make sense for the problem at hand. We have here restricted ourselves to simple Neumann boundary conditions &ndash; but these do not actually make sense for the problem. Indeed, the equations are generally posed on an infinite domain. But, since we can't compute on infinite domains, we need to truncate it somewhere and instead pose boundary conditions that make sense for this artificially small domain. The approach widely used is to use the <a href="https://en.wikipedia.org/wiki/Perfectly_matched_layer">Perfectly Matched Layer</a> method that corresponds to a particular kind of attenuation. It is, in a different context, also used in <a class="el" href="step_62.html">step-62</a>.</p>
<p><a class="anchor" id="Adaptivemeshes"></a></p><h4>Adaptive meshes </h4>
<p>Finally, we know from experience and many other tutorial programs that it is worthwhile to use adaptively refined meshes, rather than the uniform meshes used here. It would, in fact, not be very difficult to add this here: It just requires periodic remeshing and transfer of the solution from one mesh to the next. <a class="el" href="step_26.html">step-26</a> will be a good guide for how this could be implemented.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University</span></div><div class="line"><span class="comment"> *         Yong-Yong Cai, Beijing Computational Science Research Center</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step58</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>NonlinearSchroedingerEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    NonlinearSchroedingerEquation();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_matrices();</div><div class="line">    <span class="keywordtype">void</span> do_half_phase_step();</div><div class="line">    <span class="keywordtype">void</span> do_full_spatial_step();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; rhs_matrix;</div><div class="line"></div><div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; solution;</div><div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> kappa;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim, <a class="code" href="namespacestd.html">std</a>::complex&lt;<a class="code" href="classdouble.html">double</a>&gt;&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::complex&lt;double&gt;</div><div class="line">    value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::complex&lt;double&gt;</div><div class="line">  InitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    static_assert(dim == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div><div class="line"></div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0, -0.3},</div><div class="line">                                                    {0, +0.3},</div><div class="line">                                                    {+0.3, 0},</div><div class="line">                                                    {-0.3, 0}};</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha =</div><div class="line">      1. / (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(numbers::PI, dim / 2.));</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = p - vortex_center;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">        sum += alpha * <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r * r) / (R * R));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(sum), 0.};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Potential() = <span class="keywordflow">default</span>;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Potential&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(p) &gt; 0.7 ? 1000 : 0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation()</div><div class="line">    : fe(2)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time(0)</div><div class="line">    , time_step(1. / 128)</div><div class="line">    , timestep_number(0)</div><div class="line">    , kappa(1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(6);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    rhs_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(dofs_per_cell,</div><div class="line">                                                     dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(dofs_per_cell,</div><div class="line">                                                     dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  potential_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div><div class="line">        cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        potential.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             potential_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> std::complex&lt;double&gt; i = {0, 1};</div><div class="line"></div><div class="line">                    cell_matrix_lhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                      (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                       time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                       time_step / 2 * potential_values[q_index] *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line"></div><div class="line">                    cell_matrix_rhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                      (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                       time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                       time_step / 2 * potential_values[q_index] *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix_lhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               rhs_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : solution)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; i         = {0, 1};</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(value);</div><div class="line"></div><div class="line">        value = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-i * kappa * magnitude * magnitude * (time_step / 2)) *</div><div class="line">                value;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step()</div><div class="line">  {</div><div class="line">    rhs_matrix.vmult(system_rhs, solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">    solution = system_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>DataPostprocessors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ComplexAmplitude();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">        std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div><div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                         inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1));</div><div class="line">          computed_quantities[q](0) = <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm</a>(psi);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ComplexPhase();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">        std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ComplexPhase&lt;dim&gt;::ComplexPhase()</div><div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> max_phase = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">          max_phase =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_phase,</div><div class="line">                     std::arg(</div><div class="line">                       std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                            inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1))));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;output : computed_quantities)</div><div class="line">        output(0) = max_phase;</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace DataPostprocessors</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div><div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;Psi&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_magnitude);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_phase);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, timestep_number));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line">    assemble_matrices();</div><div class="line"></div><div class="line">    time = 0;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), solution);</div><div class="line">    output_results();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div><div class="line">    <span class="keywordflow">for</span> (; time &lt;= end_time; time += time_step)</div><div class="line">      {</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        do_half_phase_step();</div><div class="line">        do_full_spatial_step();</div><div class="line">        do_half_phase_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div><div class="line">          output_results();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step58</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step58;</div><div class="line"></div><div class="line">      NonlinearSchroedingerEquation&lt;2&gt; nse;</div><div class="line">      nse.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_26.html">step-26</a> , <a class="el" href="step_29.html">step-29</a> . <table
 class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Anoteaboutthecharacteroftheequations">A note about the
 character of the equations</a><a
 href="#Anoteaboutthecharacteroftheequations">A note about the character of
 the equations</a>
 <li><a href="#Thegeneralideaofoperatorsplitting">The general idea of
 operator splitting</a><a href="#Thegeneralideaofoperatorsplitting">The
 general idea of operator splitting</a>
 <li><a href="#OperatorsplittingtheLiesplittingapproach">Operator splitting:
 the "Lie splitting" approach</a><a
 href="#OperatorsplittingtheLiesplittingapproach">Operator splitting: the
 "Lie splitting" approach</a>
 <li><a href="#OperatorsplittingtheStrangsplittingapproach">Operator
 splitting: the "Strang splitting" approach</a><a
 href="#OperatorsplittingtheStrangsplittingapproach">Operator splitting: the
 "Strang splitting" approach</a>
 <li><a href="#Timediscretization">Time discretization</a><a
 href="#Timediscretization">Time discretization</a>
 <li><a href="#Spatialdiscretizationanddealingwithcomplexvariables">Spatial
 discretization and dealing with complex variables</a><a
 href="#Spatialdiscretizationanddealingwithcomplexvariables">Spatial
 discretization and dealing with complex variables</a>
 <li><a href="#Linearsolvers">Linear solvers</a><a
 href="#Linearsolvers">Linear solvers</a>
 <li><a href="#Definitionofthetestcase">Definition of the test case</a><a
 href="#Definitionofthetestcase">Definition of the test case</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#ThecodeNonlinearSchroedingerEquationcodeclass">The
 <code>NonlinearSchroedingerEquation</code> class</a><a
 href="#ThecodeNonlinearSchroedingerEquationcodeclass">The
 <code>NonlinearSchroedingerEquation</code> class</a>
 <li><a href="#Equationdata">Equation data</a><a
 href="#Equationdata">Equation data</a>
 <li><a
 href="#ImplementationofthecodeNonlinearSchroedingerEquationcodeclass">Implementation
 of the <code>NonlinearSchroedingerEquation</code> class</a><a
 href="#ImplementationofthecodeNonlinearSchroedingerEquationcodeclass">Implementation
 of the <code>NonlinearSchroedingerEquation</code> class</a>
 <ul>
 <li><a href="#Settingupdatastructuresandassemblingmatrices">Setting up data
 structures and assembling matrices</a><a
 href="#Settingupdatastructuresandassemblingmatrices">Setting up data
 structures and assembling matrices</a>
 <li><a href="#ImplementingtheStrangsplittingsteps">Implementing the Strang
 splitting steps</a><a
 href="#ImplementingtheStrangsplittingsteps">Implementing the Strang
 splitting steps</a>
 <li><a href="#Creatinggraphicaloutput">Creating graphical output</a><a
 href="#Creatinggraphicaloutput">Creating graphical output</a>
 <li><a href="#Runningthesimulation">Running the simulation</a><a
 href="#Runningthesimulation">Running the simulation</a>
 <li><a href="#Themainfunction">The main() function</a><a
 href="#Themainfunction">The main() function</a>
 </ul>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Visualizingthesolution">Visualizing the solution</a><a
 href="#Visualizingthesolution">Visualizing the solution</a>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 <ul>
 <li><a href="#Betterlinearsolvers"> Better linear solvers </a><a
 href="#Betterlinearsolvers"> Better linear solvers </a>
 <li><a href="#Boundaryconditions"> Boundary conditions </a><a
 href="#Boundaryconditions"> Boundary conditions </a>
 <li><a href="#Adaptivemeshes"> Adaptive meshes </a><a
 href="#Adaptivemeshes"> Adaptive meshes </a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Wolfgang Bangerth (Colorado State University) and Yong-Yong Cai (<a href="http://www.csrc.ac.cn/en/">Beijing Computational Science Research Center</a><a href="http://www.csrc.ac.cn/en/">Beijing Computational Science Research Center</a>, CSRC) and is the result of the first author's time as a visitor at CSRC.</em></p>
<p><em> This material is based upon work partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The <a href="https://en.wikipedia.org/wiki/Nonlinear_Schr%C3%B6dinger_equation">Nonlinear Schr&ouml;dinger Equation (NLSE)</a> for a function \(\psi=\psi(\mathbf x,t)\) and a potential \(V=V(\mathbf x)\) is a model often used inquantum mechanics and nonlinear optics. If one measures in appropriatequantities (so that \(\hbar=1\) ), then it reads as follows: </p><p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi + V \psi + \kappa |\psi|^2 \psi &amp;= 0 \qquad\qquad &amp; \text{in}\; \Omega\times (0,T), \\ \psi(\mathbf x,0) &amp;= \psi_0(\mathbf x) &amp; \text{in}\; \Omega, \\ \psi(\mathbf x,t) &amp;= 0 &amp; \text{on}\; \partial\Omega\times (0,T). \end{align*}
</p>
<p> If there is no potential, i.e. \(V(\mathbf x)=0\) , then it can be usedto describe the propagation of light in optical fibers. If \(V(\mathbf x)\neq 0\) , the equation is also sometimes called the <a href="https://en.wikipedia.org/wiki/Gross%E2%80%93Pitaevskii_equation">Gross-Pitaevskii equation</a> and can be used to model the time dependent behavior of<a href="https://en.wikipedia.org/wiki/Bose%E2%80%93Einstein_condensate">Bose-Einstein condensates</a>. For this particular tutorial program, the physical interpretation ofthe equation is not of much concern to us. Rather, we want to use itas a model that allows us to explain two aspects:</p>
<ul>
<li>It is a <b>complex-valued equation</b> for \(\psi \in H^1(\Omega,{\mathbb C})\) . We have previously seen complex-valued equations in <a class="el" href="step_29.html">step-29</a> , but there have opted to split the equations into real and imaginary parts and consequently ended up solving a system of two real-valued equations. In contrast, the goal here is to show how to solve problems in which we keep everything as complex numbers.</li>
<li>The equation is a nice model problem to explain how <b>operator splitting methods</b> work. This is because it has terms with fundamentally different character: on the one hand, \(- \frac 12 \Delta \psi\) is a regular spatial operator in the way we have seen many times before; on the other hand, \(\kappa |\psi(\mathbf x,t)|^2 \psi\) has no spatial or temporal derivatives, i.e., it is a purely local operator. It turns out that we have efficient methods for each of these terms (in particular, we have analytic solutions for the latter), and that we may be better off treating these terms differently and separately. We will explain this in more detail below.</li>
</ul>
<p><a class="anchor" id="Anoteaboutthecharacteroftheequations"></a></p><h3>A note about the character of the equations</h3>
<p>At first glance, the equations appear to be parabolic and similar tothe heat equation (see <a class="el" href="step_26.html">step-26</a> ) as there is only a single timederivative and two spatial derivatives. But this is misleading.Indeed, that this is not the correct interpretation ismore easily seen if we assume for a moment that the potential \(V=0\) and \(\kappa=0\) . Then we have the equation </p><p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi &amp;= 0. \end{align*}
</p>
<p> If we separate the solution into real and imaginary parts, \(\psi=v+iw\) ,with \(v=\textrm{Re}\;\psi,\; w=\textrm{Im}\;\psi\) ,then we can split the one equation into its real and imaginary partsin the same way as we did in <a class="el" href="step_29.html">step-29</a> : </p><p class="formulaDsp">
\begin{align*} \frac{\partial w}{\partial t} - \frac 12 \Delta v &amp;= 0, \\ -\frac{\partial v}{\partial t} - \frac 12 \Delta w &amp;= 0. \end{align*}
</p>
<p> Not surprisingly, the factor \(i\) in front of the time derivativecouples the real and imaginary parts of the equation. If we want tounderstand this equation further, take the time derivative of one ofthe equations, say </p><p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} - \frac 12 \Delta \frac{\partial v}{\partial t} &amp;= 0, \end{align*}
</p>
<p> (where we have assumed that, at least in some formal sense, we cancommute the spatial and temporal derivatives), and then insert theother equation into it: </p><p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} + \frac 14 \Delta^2 w &amp;= 0. \end{align*}
</p>
<p> This equation is hyperbolic and similar in character to the waveequation. (This will also be obvious if you look at the videoin the "Results" section of this program.) Furthermore, we couldhave arrived at the same equation for \(v\) as well.Consequently, a better assumption for the NLSE is to think ofit as a hyperbolic, wave-propagation equation than as a diffusionequation such as the heat equation. (You may wonder whether it iscorrect that the operator \(\Delta^2\) appears with a positive signwhereas in the wave equation, \(\Delta\) has a negative sign. This isindeed correct: After multiplying by a test function and integratingby parts, we want to come out with a positive (semi-)definiteform. So, from \(-\Delta u\) we obtain \(+(\nabla v,\nabla u)\) . Likewise,after integrating by parts twice, we obtain from \(+\Delta^2 u\) theform \(+(\Delta v,\Delta u)\) . In both cases do we get the desired positivesign.) The real NLSE, of course, also has the terms \(V\psi\) and \(\kappa|\psi|^2\psi\) . However, these are of lower order in the spatialderivatives, and while they are obviously important, they do notchange the character of the equation. In any case, the purpose of this discussion is to figure outwhat time stepping scheme might be appropriate for the equation. Theconclusions is that, as a hyperbolic-kind of equation, we need tochoose a time step that satisfies a CFL-type condition. If we were touse an explicit method (which we will not), we would have to investigatethe eigenvalues of the matrix that corresponds to the spatialoperator. If you followed the discussions of the video lectures( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.26.html">video lecture 26</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.27.html">video lecture 27</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html">video lecture 28</a>.) then you will remember that the pattern is that one needs to make surethat \(k^s \propto h^t\) where \(k\) is the time step, \(h\) the mesh width,and \(s,t\) are the orders of temporal and spatial derivatives.Whether you take the original equation ( \(s=1,t=2\) ) or the reformulationfor only the real or imaginary part, the outcome is that we would need tochoose \(k \propto h^2\) if we were to use an explicit time steppingmethod. This is not feasible for the same reasons as in <a class="el" href="step_26.html">step-26</a> forthe heat equation: It would yield impractically small time stepsfor even only modestly refined meshes. Rather, we have to use animplicit time stepping method and can then choose a more balanced \(k \propto h\) . Indeed, we will use the implicit Crank-Nicolsonmethod as we have already done in <a class="el" href="step_23.html">step-23</a> before for the regularwave equation.</p>
<p><a class="anchor" id="Thegeneralideaofoperatorsplitting"></a></p><h3>The general idea of operator splitting</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.30.25.html">video lecture 30.25</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) If one thought of the NLSE as an ordinary differential equation inwhich the right hand side happens to have spatial derivatives, i.e.,write it as <p class="formulaDsp">
\begin{align*} \frac{d\psi}{dt} &amp;= i\frac 12 \Delta \psi -i V \psi -i\kappa |\psi|^2 \psi, \qquad\qquad &amp; \text{for}\; t \in (0,T), \\ \psi(0) &amp;= \psi_0, \end{align*}
</p>
 one may be tempted to "formally solve" it by integrating both sidesover a time interval \([t_{n},t_{n+1}]\) and obtain <p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) -i V \psi(t) -i\kappa |\psi(t)|^2 \psi(t) \right) \; dt. \end{align*}
</p>
 Of course, it's not that simple: the \(\psi(t)\) in the integrand isstill changing over time in accordance with the differential equation,so we cannot just evaluate the integral (or approximate it easily viaquadrature) because we don't know \(\psi(t)\) .But we can write this with separate contributions asfollows, and this will allow us to deal with different terms separately: <p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi(t)|^2 \,\psi(t) \right) \; dt. \end{align*}
</p>
 The way this equation can now be read is as follows: For each time interval \([t_{n},t_{n+1}]\) , the change \(\psi(t_{n+1})-\psi(t_{n})\) in thesolution consists of three contributions:</dd></dl>
<ul>
<li>The contribution of the Laplace operator.</li>
<li>The contribution of the potential \(V\) .</li>
<li>The contribution of the "phase" term \(-i\kappa |\psi(t)|^2\,\psi(t)\) . <em>Operator splitting</em> is now an approximation technique thatallows us to treat each of these contributions separately. (If wewant: In practice, we will treat the first two together, and the lastone separate. But that is a detail, conceptually we could treat all ofthem differently.) To this end, let us introduce three separate "solutions": <p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
</li>
</ul>
<p>These three "solutions" can be thought of as satisfying the followingdifferential equations: </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n). \end{align*}
</p>
<p> In other words, they are all trajectories \(\psi^{(k)}\) that start at \(\psi(t_n)\) and integrate up the effects of exactly one of the threeterms. The increments resulting from each of these terms over our timeinterval are then \(I^{(1)}=\psi^{(1)}(t_{n+1})-\psi(t_n)\) , \(I^{(2)}=\psi^{(2)}(t_{n+1})-\psi(t_n)\) , and \(I^{(3)}=\psi^{(3)}(t_{n+1})-\psi(t_n)\) . It is now reasonable to assume (this is an approximation!) that thechange due to all three of the effects in question is well approximatedby the sum of the three separate increments: </p><p class="formulaDsp">
\begin{align*} \psi(t_{n+1})-\psi(t_n) \approx I^{(1)} + I^{(2)} + I^{(3)}. \end{align*}
</p>
<p> This intuition is indeed correct, though the approximation is notexact: the difference between the exact left hand side and the term \(I^{(1)}+I^{(2)}+I^{(3)}\) (i.e., the difference between the <em>exact</em> incrementfor the exact solution \(\psi(t)\) when moving from \(t_n\) to \(t_{n+1}\) ,and the increment composed of the three parts on the right hand side),is proportional to \(\Delta t=t_{n+1}-t_{n}\) . In other words, thisapproach introduces an error of size \({\cal O}(\Delta t)\) . Nothing wehave done so far has discretized anything in time or space, so the<em>overall</em> error is going to be \({\cal O}(\Delta t)\) plus whatevererror we commit when approximating the integrals (the temporaldiscretization error) plus whatever error we commit when approximatingthe spatial dependencies of \(\psi\) (the spatial error). Before we continue with discussions about operator splitting, let ustalk about why one would even want to go this way? The answer issimple: For some of the separate equations for the \(\psi^{(k)}\) , wemay have ways to solve them more efficiently than if we throweverything together and try to solve it at once. For example, andparticularly pertinent in the current case: The equation for \(\psi^{(3)}\) , i.e., </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, \qquad\qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n), \end{align*}
</p>
<p> or equivalently, </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt, \end{align*}
</p>
<p> can be solved exactly: the equation is solved by </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t) = e^{-i\kappa|\psi(t_n)|^2 (t-t_{n})} \psi(t_n). \end{align*}
</p>
<p> This is easy to see if (i) you plug this solution into thedifferential equation, and (ii) realize that the magnitude \(|\psi^{(3)}|\) is constant, i.e., the term \(|\psi(t_n)|^2\) in theexponent is in fact equal to \(|\psi^{(3)}(t)|^2\) . In other words, thesolution of the ODE for \(\psi^{(3)}(t)\) only changes its <em>phase</em>,but the <em>magnitude</em> of the complex-valued function \(\psi^{(3)}(t)\) remains constant. This makes computing \(I^{(3)}\) particularly convenient:we don't actually need to solve any ODE, we can write the solutiondown by hand. Using the operator splitting approach, none of themethods to compute \(I^{(1)},I^{(2)}\) therefore have to deal with the nonlinearterm and all of the associated unpleasantries: we can get away withsolving only <em>linear</em> problems, as long as we allow ourselves theluxury of using an operator splitting approach. Secondly, one often uses operator splitting if the different physicaleffects described by the different terms have different timescales. Imagine, for example, a case where we really did have somesort of diffusion equation. Diffusion acts slowly, but if \(\kappa\) islarge, then the "phase rotation" by the term \(-i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t)\) acts quickly. If we treatedeverything together, this would imply having to take rather small timesteps. But with operator splitting, we can take large time steps \(\Delta t=t_{n+1}-t_{n}\) for the diffusion, and (assuming we didn'thave an analytic solution) use an ODE solver with many small timesteps to integrate the "phase rotation" equation for \(\psi^{(3)}\) from \(t_n\) to \(t_{n+1}\) . In other words, operator splitting allows us todecouple slow and fast time scales and treat them differently, withmethods adjusted to each case.</p>
<p><a class="anchor" id="OperatorsplittingtheLiesplittingapproach"></a></p><h3>Operator splitting: the "Lie splitting" approach</h3>
<p>While the method above allows to compute the three contributions \(I^{(k)}\) in parallel, if we want, the method can be made slightlymore accurate and easy to implement if we don't let the trajectoriesfor the \(\psi^{(k)}\) start all at \(\psi(t_n)\) , but instead let thetrajectory for \(\psi^{(2)}\) start at the <em>end point</em> of thetrajectory for \(\psi^{(1)}\) , namely \(\psi^{(1)}(t_{n+1})\) ; similarly,we will start the trajectory for \(\psi^{(3)}\) start at the end pointof the trajectory for \(\psi^{(2)}\) , namely \(\psi^{(2)}(t_{n+1})\) . Thismethod is then called "Lie splitting" and has the same order of erroras the method above, i.e., the splitting error is \({\cal O}(\Delta t)\) . This variation of operator splitting can be written asfollows (carefully compare the initial conditions to the ones above): </p><p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p> (Obviously, while the formulas above imply that we should solve theseproblems in this particular order, it is equally valid to first solvefor trajectory 3, then 2, then 1, or any other permutation.) The integrated forms of these equations are then </p><p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi^{(1)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi^{(2)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p> From a practical perspective, this has the advantage that we needto keep around fewer solution vectors: Once \(\psi^{(1)}(t_n)\) has beencomputed, we don't need \(\psi(t_n)\) any more; once \(\psi^{(2)}(t_n)\) has been computed, we don't need \(\psi^{(1)}(t_n)\) any more. And once \(\psi^{(3)}(t_n)\) has been computed, we can just call it \(\psi(t_{n+1})\) because, if you insert the first into the second, andthen into the third equation, you see that the right hand side of \(\psi^{(3)}(t_n)\) now contains the contributions of all three physicaleffects: </p><p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt+ \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p> (Compare this again with the "exact" computation of \(\psi(t_{n+1})\) :It only differs in how we approximate \(\psi(t)\) in each of the three integrals.)In other words, Lie splitting is a lot simpler to implement that theoriginal method outlined above because data handling is so muchsimpler.</p>
<p><a class="anchor" id="OperatorsplittingtheStrangsplittingapproach"></a></p><h3>Operator splitting: the "Strang splitting" approach</h3>
<p>As mentioned above, Lie splitting is only \({\cal O}(\Delta t)\) accurate. This is acceptable if we were to use a first order timediscretization, for example using the explicit or implicit Eulermethods to solve the differential equations for \(\psi^{(k)}\) . This isbecause these time integration methods introduce an error proportionalto \(\Delta t\) themselves, and so the splitting error is proportionalto an error that we would introduce anyway, and does not diminish theoverall convergence order. But we typically want to use something higher order</p>
<ul>
<li>say, a<a href="https://en.wikipedia.org/wiki/Crank%E2%80%93Nicolson_method">Crank-Nicolson</a>or<a href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">BDF2</a>method</li>
<li>since these are often not more expensive than asimple Euler method. It would be a shame if we were to use a timestepping method that is \({\cal O}(\Delta t^2)\) , but then lose theaccuracy again through the operator splitting. This is where the <a href="https://en.wikipedia.org/wiki/Strang_splitting">Strang splitting</a> method comes in. It is easier to explain if we had onlytwo parts, and so let us combine the effects of the Laplace operatorand of the potential into one, and the phase rotation into a secondeffect. (Indeed, this is what we will do in the code since solving theequation with the Laplace equation with or without the potential coststhe same</li>
<li>so we merge these two steps.) The Lie splitting methodfrom above would then do the following: It computes solutions of thefollowing two ODEs, <p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)} -i V \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i\kappa |\psi^{(2)}|^2 \,\psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \end{align*}
</p>
 and then uses the approximation \(\psi(t_{n+1}) \approx \psi^{(2)}(t_{n+1})\) . In other words, we first make one full time stepfor physical effect one, then one full time step for physical effecttwo. The solution at the end of the time step is simply the sum of theincrements due to each of these physical effects separately. In contrast,<a href="https://en.wikipedia.org/wiki/Gilbert_Strang">Gil Strang</a>(one of the titans of numerical analysis starting in the mid-20thcentury) figured out that it is more accurate to first doone half-step for one physical effect, then a full time step for theother physical effect, and then another half step for the first. Whichone is which does not matter, but because it is so simple to do thephase rotation, we will use this effect for the half steps and thenonly need to do one spatial solve with the Laplace operator pluspotential. This operator splitting method is now \({\cal O}(\Delta t^2)\) accurate. Written in formulas, this yields the followingsequence of steps: <p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= -i\kappa |\psi^{(1)}|^2 \,\psi^{(1)}, &amp;&amp; \text{for}\; t \in (t_n,t_n+\tfrac 12\Delta t), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= i\frac 12 \Delta \psi^{(2)} -i V \psi^{(2)}, \qquad &amp;&amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_n+\tfrac 12\Delta t), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp;&amp; \text{for}\; t \in (t_n+\tfrac 12\Delta t,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
 As before, the first and third step can be computed exactly for thisparticular equation, yielding <p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_n+\tfrac 12\Delta t) &amp;= e^{-i\kappa|\psi(t_n)|^2 \tfrac 12\Delta t} \; \psi(t_n), \\ \psi^{(3)}(t_{n+1}) &amp;= e^{-i\kappa|\psi^{(2)}(t_{n+1})|^2 \tfrac 12\Delta t} \; \psi^{(2)}(t_{n+1}). \end{align*}
</p>
</li>
</ul>
<p>This is then how we are going to implement things in this program:In each time step, we execute three steps, namely</p>
<ul>
<li>Update the solution value at each node by analytically integrating the phase rotation equation by one half time step;</li>
<li>Solving the space-time equation that corresponds to the full step for \(\psi^{(2)}\) , namely \(-i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0\) , with initial conditions equal to the solution of the first half step above.</li>
<li>Update the solution value at each node by analytically integrating the phase rotation equation by another half time step. This structure will be reflected in an obvious way in the main timeloop of the program.</li>
</ul>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>From the discussion above, it should have become clear that the onlypartial differential equation we have to solve in each time step is </p><p class="formulaDsp">
\begin{align*} -i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0. \end{align*}
</p>
<p> This equation is linear. Furthermore, we only have to solve it from \(t_n\) to \(t_{n+1}\) , i.e., for exactly one time step. To do this, we will apply the second order accurate Crank-Nicolsonscheme that we have already used in some of the other time dependentcodes (specifically: <a class="el" href="step_23.html">step-23</a> and <a class="el" href="step_26.html">step-26</a> ). It reads as follows: </p><p class="formulaDsp">
\begin{align*} -i\frac{\psi^{(n,2)}-\psi^{(n,1)}}{k_{n+1}} - \frac 12 \Delta \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] + V \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] = 0. \end{align*}
</p>
<p> Here, the "previous" solution \(\psi^{(n,1)}\) (or the "initialcondition" for this part of the time step) is the output of thefirst phase rotation half-step; the output of the current step willbe denoted by \(\psi^{(n,2)}\) . \(k_{n+1}=t_{n+1}-t_n\) isthe length of the time step. (One could argue whether \(\psi^{(n,1)}\) and \(\psi^{(n,1)}\) live at time step \(n\) or \(n+1\) and what their upperindices should be. This is a philosophical discussion without practicalimpact, and one might think of \(\psi^{(n,1)}\) as something like \(\psi^{(n+\tfrac 13)}\) , and \(\psi^{(n,2)}\) as \(\psi^{(n+\tfrac 23)}\) if that helps clarify things</p>
<ul>
<li>though, again \(n+\frac 13\) is not to be understood as "one third time step after  @f$t_n@f$  " but more like "we've already done one third of the work necessaryfor time step   @f$n+1@f$  ".) If we multiply the whole equation with \(k_{n+1}\) and sort terms withthe unknown \(\psi^{(n+1,2)}\) to the left and those with the known \(\psi^{(n,2)}\) to the right, then we obtain the following (spatial)partial differential equation that needs to be solved in each timestep: <p class="formulaDsp">
\begin{align*} -i\psi^{(n,2)} - \frac 14 k_{n+1} \Delta \psi^{(n,2)} + \frac 12 k_{n+1} V \psi^{(n,2)} = -i\psi^{(n,1)} + \frac 14 k_{n+1} \Delta \psi^{(n,1)} - \frac 12 k_{n+1} V \psi^{(n,1)}. \end{align*}
</p>
</li>
</ul>
<p><a class="anchor" id="Spatialdiscretizationanddealingwithcomplexvariables"></a></p><h3>Spatial discretization and dealing with complex variables</h3>
<p>As mentioned above, the previous tutorial program dealing withcomplex-valued solutions (namely, <a class="el" href="step_29.html">step-29</a> ) separated real and imaginaryparts of the solution. It thus reduced everything to realarithmetic. In contrast, we here want to keep thingscomplex-valued. The first part of this is that we need to define the discretizedsolution as \(\psi_h^n(\mathbf x)=\sum_j \Psi^n_j \varphi_j(\mathbf x) \approx \psi(\mathbf x,t_n)\) where the \(\varphi_j\) are the usual shape functions (which arereal valued) but the expansion coefficients \(\Psi^n_j\) at time step \(n\) are now complex-valued. This is easily done in deal.II: We justhave to use <a class="el" href="classVector.html">Vector</a>&lt;std::complex&lt;double&gt;&gt; instead of <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> tostore these coefficients. Of more interest is how to build and solve the linearsystem. Obviously, this will only be necessary for the second step ofthe Strang splitting discussed above, with the time discretization ofthe previous subsection. We obtain the fully discrete version throughstraightforward substitution of \(\psi^n\) by \(\psi^n_h\) andmultiplication by a test function: </p><p class="formulaDsp">
\begin{align*} -iM\Psi^{(n,2)} + \frac 14 k_{n+1} A \Psi^{(n,2)} + \frac 12 k_{n+1} W \Psi^{(n,2)} = -iM\Psi^{(n+1,1)} - \frac 14 k_{n+1} A \Psi^{(n,1)} - \frac 12 k_{n+1} W \Psi^{(n,1)}, \end{align*}
</p>
<p> or written in a more compact way: </p><p class="formulaDsp">
\begin{align*} \left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}. \end{align*}
</p>
<p> Here, the matrices are defined in their obvious ways: </p><p class="formulaDsp">
\begin{align*} M_{ij} &amp;= (\varphi_i,\varphi_j), \\ A_{ij} &amp;= (\nabla\varphi_i,\nabla\varphi_j), \\ W_{ij} &amp;= (\varphi_i,V \varphi_j). \end{align*}
</p>
<p> Note that all matrices individually are in fact symmetric,real-valued, and at least positive semidefinite, though the same isobviously not true forthe system matrix \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) and the corresponding matrix \(R = -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W\) on the right hand side.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.34.html">video lecture 34</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) The only remaining important question about the solution procedure ishow to solve the complex-valued linear system <p class="formulaDsp">
\begin{align*} C \Psi^{(n+1,2)} = R \Psi^{(n+1,1)}, \end{align*}
</p>
 with the matrix \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) and a right hand side that is easily computed as the product ofa known matrix and the previous part-step's solution.As usual, this comes down to the question of what properties thematrix \(C\) has. If it is symmetric and positive definite, then we canfor example use the Conjugate Gradient method. Unfortunately, the matrix's only useful property is that it is complexsymmetric, i.e., \(C_{ij}=C_{ji}\) , as is easy to see by recalling that \(M,A,W\) are all symmetric. It is not, however,<a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian</a>,which would require that \(C_{ij}=\bar C_{ji}\) where the bar indicates complexconjugation. Complex symmetry can be exploited for iterative solvers as a quickliterature search indicates. We will here not try to become toosophisticated (and indeed leave this to the <a href="#extensions">Possibilities for extensions</a> section below) andinstead simply go with the good old standby for problems withoutproperties: A direct solver. That's not optimal, especially for largeproblems, but it shall suffice for the purposes of a tutorial program.Fortunately, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class allows solving complex-valuedproblems.</dd></dl>
<p><a class="anchor" id="Definitionofthetestcase"></a></p><h3>Definition of the test case</h3>
<p>Initial conditions for the NLSE are typically chosen to representparticular physical situations. This is beyond the scope of thisprogram, but suffice it to say that these initial conditions are(i) often superpositions of the wave functions of particles locatedat different points, and that (ii) because \(|\psi(\mathbf x,t)|^2\) corresponds to a particle density function, the integral </p><p class="formulaDsp">
\[ N(t) = \int_\Omega |\psi(\mathbf x,t)|^2 \]
</p>
<p> to the number of particles in the system. (Clearly, ifone were to be physically correct, \(N(t)\) better be a constant ifthe system is closed, or \(\frac{dN}{dt}&lt;0\) if one has absorbingboundary conditions.) The important point is that one should chooseinitial conditions so that </p><p class="formulaDsp">
\[ N(0) = \int_\Omega |\psi_0(\mathbf x)|^2 \]
</p>
<p> sense. What we will use here, primarily because it makes for good graphics,is the following: </p><p class="formulaDsp">
\[ \psi_0(\mathbf x) = \sqrt{\sum_{k=1}^4 \alpha_k e^{-\frac{r_k^2}{R^2}}}, \]
</p>
<p> \(r_k = |\mathbf x-\mathbf x_k|\) is the distance from the (fixed)locations \(\mathbf x_k\) , and \(\alpha_k\) are chosen so that each of the Gaussians that we areadding up adds an integer number of particles to \(N(0)\) . We achievethis by making sure that </p><p class="formulaDsp">
\[ \int_\Omega \alpha_k e^{-\frac{r_k^2}{R^2}} \]
</p>
<p> a positive integer. In other words, we need to choose \(\alpha\) as an integer multiple of </p><p class="formulaDsp">
\[ \left(\int_\Omega e^{-\frac{r_k^2}{R^2}}\right)^{-1} = \left(R^d\sqrt{\pi^d}\right)^{-1}, \]
</p>
<p> for the moment that \(\Omega={\mathbb R}^d\)</p>
<ul>
<li>which isof course not the case, but we'll ignore the small difference inintegral. Thus, we choose \(\alpha_k=\left(R^d\sqrt{\pi^d}\right)^{-1}\) for all, and \(R=0.1\) . This \(R\) is small enough that the difference between theexact (infinite) integral and the integral over \(\Omega\) should not betoo concerning.We choose the four points \(\mathbf x_k\) as \((\pm 0.3, 0), (0, \pm 0.3)\)</li>
<li>also far enough away from the boundary of \(\Omega\) to keepourselves on the safe side. For simplicity, we pose the problem on the square \([-1,1]^2\) . Forboundary conditions, we will use time-independent Neumann conditions of theform <p class="formulaDsp">
\[ \nabla\psi(\mathbf x,t)\cdot \mathbf n=0 \qquad\qquad \forall \mathbf x\in\partial\Omega. \]
</p>
 is not a realistic choice of boundary conditions but sufficientfor what we want to demonstrate here. We will comment further on thisin the <a href="#extensions">Possibilities for extensions</a> section below. Finally, we choose \(\kappa=1\) , and the potential as <p class="formulaDsp">
\[ V(\mathbf x) = \begin{cases} 0 &amp; \text{if}\; |\mathbf x|&lt;0.7 \\ 1000 &amp; \text{otherwise}. \end{cases} \]
</p>
 a large potential makes sure that the wave function \(\psi\) remainssmall outside the circle of radius 0.7. All of the Gaussians that makeup the initial conditions are within this circle, and the solution willmostly oscillate within it, with a small amount of energy radiating intothe outside. The use of a large potential also makes sure that the nonphysicalboundary condition does not have too large an effect.</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The program starts with the usual include files, all of which you should have seen before by now:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Then the usual placing of all content of this program into a namespace and the importation of the deal.II namespace into the one we will work in:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step58</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>The <code>NonlinearSchroedingerEquation</code> class</h3>
<p>Then the main class. It looks very much like the corresponding classes in <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a> , with the only exception that the matrices and vectors and everything else related to the linear system are now storing elements of type <code>std::complex&lt;double&gt;</code> instead of just <code>double</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>NonlinearSchroedingerEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  NonlinearSchroedingerEquation();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_matrices();</div><div class="line">  <span class="keywordtype">void</span> do_half_phase_step();</div><div class="line">  <span class="keywordtype">void</span> do_full_spatial_step();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; rhs_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; system_rhs;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time;</div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> kappa;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial values, as well as a right hand side class. (We will reuse the initial conditions also for the boundary values, which we simply keep constant.) We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not look surprising. The only point of interest is that we here have a complex-valued problem, so we have to provide the second template argument of the <a class="el" href="classFunction.html">Function</a> class (which would otherwise default to <code>double</code>). Furthermore, the return type of the <code>value()</code> functions is then of course also complex. What precisely these functions return has been discussed at the end of the Introduction section.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim, <a class="code" href="namespacestd.html">std</a>::complex&lt;<a class="code" href="classdouble.html">double</a>&gt;&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::complex&lt;double&gt;</div><div class="line">  <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::complex&lt;double&gt;</div><div class="line">InitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  static_assert(dim == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div><div class="line"></div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0,</div><div class="line"></div><div class="line">-0.3},</div><div class="line">                                                  {0, +0.3},</div><div class="line">                                                  {+0.3, 0},</div><div class="line">                                                  {-0.3, 0}};</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha =</div><div class="line">    1. / (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, dim) <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(numbers::PI, dim / 2.));</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> sum = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = p</div><div class="line"></div><div class="line">- vortex_center;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">      sum += alpha <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r r) / (R R));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(sum), 0.};</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Potential() = <span class="keywordflow">default</span>;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Potential&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(p) &gt; 0.7 ? 1000 : 0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>Implementation of the <code>NonlinearSchroedingerEquation</code> class</h3>
<p>We start by specifying the implementation of the constructor of the class. There is nothing of surprise to see here except perhaps that we choose quadratic ( \(Q_2\) ) Lagrange elements</p>
<ul>
<li>the solution is expected to be smooth, so we choose a higher polynomial degree than the bare minimum.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation()</div><div class="line">  : fe(2)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time(0)</div><div class="line">  , time_step(1. / 128)</div><div class="line">  , timestep_number(0)</div><div class="line">  , kappa(1)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Settingupdatastructuresandassemblingmatrices"></a> </p><h4>Setting up data structures and assembling matrices</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation,</div><div class="line"></div><div class="line">-1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(6);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  rhs_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.close();</div><div class="line">}</div></div><!-- fragment --><p>Next, we assemble the relevant matrices. The way we have written the Crank-Nicolson discretization of the spatial step of the Strang splitting (i.e., the second of the three partial steps in each time step), we were led to the linear system \(\left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}\) . In other words, there are two matrices in play here</p>
<ul>
<li>one for the left and one for the right hand side. We build these matrices separately. (One could avoid building the right hand side matrix and instead just form theaction* of the matrix on \(\Psi^{(n,1)}\) in each time step. This may or may not be more efficient, but efficiency is not foremost on our minds for this program.)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;                  potential_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div><div class="line">      cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      potential.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           potential_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> std::complex&lt;double&gt; i = {0, 1};</div><div class="line"></div><div class="line">                  cell_matrix_lhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                    (-i fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index)</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                     time_step / 4 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index)</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                     time_step / 2 potential_values[q_index]</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index)</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index))</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line"></div><div class="line">                  cell_matrix_rhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                    (-i fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index)</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)</div><div class="line"></div><div class="line">-</div><div class="line">                     time_step / 4 fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index)</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)</div><div class="line"></div><div class="line">-</div><div class="line">                     time_step / 2 potential_values[q_index]</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index)</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index))</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.distribute_local_to_global(cell_matrix_lhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             system_matrix);</div><div class="line">      constraints.distribute_local_to_global(cell_matrix_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             rhs_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementingtheStrangsplittingsteps"></a> </p><h4>Implementing the Strang splitting steps</h4>
<p>Having set up all data structures above, we are now in a position to implement the partial steps that form the Strang splitting scheme. We start with the half-step to advance the phase, and that is used as the first and last part of each time step. To this end, recall that for the first half step, we needed to compute \(\psi^{(n,1)} = e^{-i\kappa|\psi^{(n,0)}|^2 \tfrac 12\Delta t} \; \psi^{(n,0)}\) . Here, \(\psi^{(n,0)}=\psi^{(n)}\) and \(\psi^{(n,1)}\) are functions of space and correspond to the output of the previous complete time step and the result of the first of the three part steps, respectively. A corresponding solution must be computed for the third of the part steps, i.e. \(\psi^{(n,3)} = e^{-i\kappa|\psi^{(n,2)}|^2 \tfrac 12\Delta t} \; \psi^{(n,2)}\) , where \(\psi^{(n,3)}=\psi^{(n+1)}\) is the result of the time step as a whole, and its input \(\psi^{(n,2)}\) is the result of the spatial step of the Strang splitting. An important realization is that while \(\psi^{(n,0)}(\mathbf x)\) may be a finite element function (i.e., is piecewise polynomial), this may not necessarily be the case for the "rotated" function in which we have updated the phase using the exponential factor (recall that the amplitude of that function remains constant as part of that step). In other words, we couldcompute* \(\psi^{(n,1)}(\mathbf x)\) at every point \(\mathbf x\in\Omega\) , but we can't represent it on a mesh because it is not a piecewise polynomial function. The best we can do in a discrete setting is to compute a projection or interpolation. In other words, we can compute \(\psi_h^{(n,1)}(\mathbf x) = \Pi_h \left(e^{-i\kappa|\psi_h^{(n,0)}(\mathbf x)|^2 \tfrac 12\Delta t} \; \psi_h^{(n,0)}(\mathbf x) \right)\) where \(\Pi_h\) is a projection or interpolation operator. The situation is particularly simple if we choose the interpolation: Then, all we need to compute is the value of the right hand sideat the node points* and use these as nodal values for the vector \(\Psi^{(n,1)}\) of degrees of freedom. This is easily done because evaluating the right hand side at node points for a Lagrange finite element as used here requires us to only look at a single (complex-valued) entry of the node vector. In other words, what we need to do is to compute \(\Psi^{(n,1)}_j = e^{-i\kappa|\Psi^{(n,0)}_j|^2 \tfrac 12\Delta t} \; \Psi^{(n,0)}_j\) where \(j\) loops over all of the entries of our solution vector. This is what the function below does</p>
<ul>
<li>in fact, it doesn't even use separate vectors for \(\Psi^{(n,0)}\) and \(\Psi^{(n,1)}\) , but just updates the same vector as appropriate.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : solution)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; i         = {0, 1};</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(value);</div><div class="line"></div><div class="line">      value = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-i kappa magnitude magnitude (time_step / 2))</div><div class="line">              value;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The next step is to solve for the linear system in each time step, i.e., the second half step of the Strang splitting we use. Recall that it had the form \(C\Psi^{(n,2)} = R\Psi^{(n,1)}\) where \(C\) and \(R\) are the matrices we assembled earlier. The way we solve this here is using a direct solver. We first form the right hand side \(r=R\Psi^{(n,1)}\) using the <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult()</a> function and put the result into the <code>system_rhs</code> variable. We then call SparseDirectUMFPACK::solver() which takes as argument the matrix \(C\) and the right hand side vector and returns the solution in the same vector <code>system_rhs</code>. The final step is then to put the solution so computed back into the <code>solution</code> variable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step()</div><div class="line">{</div><div class="line">  rhs_matrix.vmult(system_rhs, solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">  solution = system_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatinggraphicaloutput"></a> </p><h4>Creating graphical output</h4>
<p>The last of the helper functions and classes we ought to discuss are the ones that create graphical output. The result of running the half and full steps for the local and spatial parts of the Strang splitting is that we have updated the <code>solution</code> vector \(\Psi^n\) to the correct value at the end of each time step. Its entries contain complex numbers for the solution at the nodes of the finite element mesh. Complex numbers are not easily visualized. We can output their real and imaginary parts, i.e., the fields \(\text{Re}(\psi_h^{(n)}(\mathbf x))\) and \(\text{Im}(\psi_h^{(n)}(\mathbf x))\) , and that is exactly what the <a class="el" href="classDataOut.html">DataOut</a> class does when one attaches as complex-valued vector via <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> and then calls <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. That is indeed what we do below.</p>
<p>But oftentimes we are not particularly interested in real and imaginary parts of the solution vector, but instead in derived quantities such as the magnitude \(|\psi|\) and phase angle \(\text{arg}(\psi)\) of the solution. In the context of quantum systems such as here, the magnitude itself is not so interesting, but instead it is the "amplitude", \(|\psi|^2\) that is a physical property: it corresponds to the probability density of finding a particle in a particular place of state. The way to put computed quantities into output files for visualization</p>
<ul>
<li>as used in numerous previous tutorial programs</li>
<li>is to use the facilities of the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> and derived classes. Specifically, both the amplitude of a complex number and its phase angles are scalar quantities, and so the <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> class is the right tool to base what we want to do on. Consequently, what we do here is to implement two classes <code>ComplexAmplitude</code> and <code>ComplexPhase</code> that compute for each point at which <a class="el" href="classDataOut.html">DataOut</a> decides to generate output, the amplitudes \(|\psi_h|^2\) and phases \(\text{arg}(\psi_h)\) of the solution for visualization. There is a fair amount of boiler-plate code below, with the only interesting parts of the first of these two classes being how its <code>evaluate_vector_field()</code> function computes the <code>computed_quantities</code> object. (There is also the rather awkward fact that the <a href="https://en.cppreference.com/w/cpp/numeric/complex/norm">std::norm()</a> function does not compute what one would naively imagine, namely \(|\psi|\) , but returns \(|\psi|^2\) instead. It's certainly quite confusing to have a standard function mis-named in such a way...)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>DataPostprocessors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComplexAmplitude();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                       inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1));</div><div class="line">        computed_quantities[q](0) = <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm</a>(psi);</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>The second of these postprocessor classes computes the phase angle of the complex-valued solution at each point. In other words, if we represent \(\psi(\mathbf x,t)=r(\mathbf x,t) e^{i\varphi(\mathbf x,t)}\) , then this class computes \(\varphi(\mathbf x,t)\) . The function <a href="https://en.cppreference.com/w/cpp/numeric/complex/arg">std::arg</a> does this for us, and returns the angle as a real number between \(-\pi\) and \(+\pi\) . For reasons that we will explain in detail in the results section, we do not actually output this value at each location where output is generated. Rather, we take the maximum over all evaluation points of the phase and then fill each evaluation point's output field with this maximum</p>
<ul>
<li>in essence, we output the phase angle as a piecewise constant field, where each cell has its own constant value. The reasons for this will become clear once you read through the discussion further down below.</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComplexPhase();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComplexPhase&lt;dim&gt;::ComplexPhase()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_phase =</div><div class="line"></div><div class="line">-<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">        max_phase =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_phase,</div><div class="line">                   std::arg(</div><div class="line">                     std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                          inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1))));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;output : computed_quantities)</div><div class="line">      output(0) = max_phase;</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace DataPostprocessors</span></div></div><!-- fragment --><p>Having so implemented these post-processors, we create output as we always do. As in many other time-dependent tutorial programs, we attach flags to <a class="el" href="classDataOut.html">DataOut</a> that indicate the number of the time step and the current simulation time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div><div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;Psi&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_magnitude);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_phase);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, timestep_number));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Runningthesimulation"></a> </p><h4>Running the simulation</h4>
<p>The remaining step is how we set up the overall logic for this program. It's really relatively simple: Set up the data structures; interpolate the initial conditions onto finite element space; then iterate over all time steps, and on each time step perform the three parts of the Strang splitting method. Every tenth time step, we generate graphical output. That's it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  setup_system();</div><div class="line">  assemble_matrices();</div><div class="line"></div><div class="line">  time = 0;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), solution);</div><div class="line">  output_results();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div><div class="line">  <span class="keywordflow">for</span> (; time &lt;= end_time; time += time_step)</div><div class="line">    {</div><div class="line">      ++timestep_number;</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      do_half_phase_step();</div><div class="line">      do_full_spatial_step();</div><div class="line">      do_half_phase_step();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div><div class="line">        output_results();</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step58</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The main() function</h4>
<p>The rest is again boiler plate and exactly as in almost all of the previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>Step58;</div><div class="line"></div><div class="line">    NonlinearSchroedingerEquation&lt;2&gt; nse;</div><div class="line">    nse.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Running the code results in screen output like the following:```Number of active cells: 4096Number of degrees of freedom: 16641 Time step 1 at t=0Time step 2 at t=0.00390625Time step 3 at t=0.0078125Time step 4 at t=0.0117188[...]```Running the program also yields a good number of output files that we willvisualize in the following.</p>
<p><a class="anchor" id="Visualizingthesolution"></a></p><h3>Visualizing the solution</h3>
<p>The <code>output_results()</code> function of this program generates output files thatconsist of a number of variables: The solution (split into its real and imaginaryparts), the amplitude, and the phase. If we visualize these four fields, we getimages like the following after a few time steps (at time \(t=0.242\) , to beprecise: </p><div class="twocolumn" style="width: 80%"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.re.png" alt="Real part of the solution at t=0.242" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.im.png" alt="Imaginary part of the solution at t=0.242" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.magnitude.png" alt="Amplitude of the solution at t=0.242" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.phase.png" alt="Phase of the solution at t=0.242" width="400"/>
</div>
 </div> </div><p> While the real and imaginary parts of the solution shown above are notparticularly interesting (because, from a physical perspective, theglobal offset of the phase and therefore the balance between real andimaginary components, is meaningless), it is much more interesting tovisualize the amplitude \(|\psi(\mathbf x,t)|^2\) and phase \(\text{arg}(\psi(\mathbf x,t))\) of the solution and, in particular,their evolution. This leads to pictures like the following: The phase picture shown here clearly has some flaws:</p>
<ul>
<li>First, phase is a "cyclic quantity", but the color scale uses a fundamentally different color for values close to \(-\pi\) than for values close to \(+\pi\) . This is a nuisance</li>
<li>what we need is a "cyclic color map" that uses the same colors for the two extremes of the range of the phase. Such color maps exist, see <a href="https://nicoguaro.github.io/posts/cyclic_colormaps/">this blog post of Nicolás Guarín-Zapata</a> or <a href="https://stackoverflow.com/questions/23712207/cyclic-colormap-without-visual-distortions-for-use-in-phase-angle-plots">this StackExchange post</a>, for example. The problem is that the author's favorite one of the two big visualization packages, VisIt, does not have any of these color maps built in. In an act of desperation, I therefore had to resort to using Paraview given that it has several of the color maps mentioned in the post above implemented. The picture below uses the <code>nic_Edge</code> map in which both of the extreme values are shown as black.</li>
<li>There is a problem on cells in which the phase wraps around. If at some evaluation point of the cell the phase value is close to \(-\pi\) and at another evaluation point it is close to \(+\pi\) , then what we would really like to happen is for the entire cell to have a color close to the extremes. But, instead, visualization programs produce a linear interpolation in which the values within the cell, i.e., between the evaluation points, is linearly interpolated between these two values, covering essentially the entire range of possible phase values and, consequently, cycling through the entire rainbow of colors from dark red to dark green over the course of one cell. The solution to this problem is to just output the phase value on each cell as a piecewise constant. Because averaging values close to the \(-\pi\) and \(+\pi\) is going to result in an average that has nothing to do with the actual phase angle, the <code>ComplexPhase</code> class just uses themaximal* phase angle encountered on each cell. With these modifications, the phase plot now looks as follows: </li>
</ul>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.phase-cyclic.png" alt="Phase of the solution at t=0.242, with a cyclic color map" width="400"/>
</div>
 <p>Finally, we can generate a movie out of this. (To be precise, the videouses two more global refinement cycles and a time step half the sizeof what is used in the program above.) The author of these linesmade the movie with VisIt,because that's what he's more familiar with, and using a hacked color mapthat is also cyclic</p>
<ul>
<li>though this color map lacks all of the skill employed bythe people who wrote the posts mentioned in the links above. Itdoes, however, show the character of the solution as a wave equationif you look at the shaded part of the domain outside the circle ofradius 0.7 in which the potential is zero</li>
<li>you can see how every timeone of the bumps (showing the amplitude \(|\psi_h(\mathbf x,t)|^2\) )bumps into the area where the potential is large: a wave travelsoutbound from there. Take a look at the video:  <p align="center"> <iframe width="560" height="315"
 src="https://www.youtube.com/embed/nraszP3GZHk" frameborder="0"
 allow="accelerometer; autoplay; encrypted-media; gyroscope;
 picture-in-picture" allowfullscreen></iframe> </p> </li>
</ul>
<p>So why did I end up shading the area where the potential \(V(\mathbf x)\) islarge? In that outside region, the solution is relatively small. It is alsorelatively smooth. As a consequence, to some approximate degree, theequation in that region simplifies to </p><p class="formulaDsp">
\[ - i \frac{\partial \psi}{\partial t} + V \psi \approx 0, \]
</p>
<p> maybe easier to read: </p><p class="formulaDsp">
\[ \frac{\partial \psi}{\partial t} \approx - i V \psi. \]
</p>
<p> the degree to which this approximation is valid (which, among other things,eliminates the traveling waves you can see in the video), this equation hasa solution </p><p class="formulaDsp">
\[ \psi(\mathbf x, t) = \psi(\mathbf x, 0) e^{-i V t}. \]
</p>
<p> \(V\) is large, this means that the phaserotates quite rapidly*.If you focus on the semi-transparent outer part of the domain, you cansee that. If one colors this region in the same way as the inner part ofthe domain, this rapidly flashing outer part may be psychedelic, but is alsodistracting of what's happening on the inside; it's also quite hard toactually see the radiating waves that are easy to see at the beginningof the video.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Betterlinearsolvers"></a></p><h4>Better linear solvers </h4>
<p>The solver chosen here is just too simple. It is also not efficient.What we do here is give the matrix to a sparse direct solver in everytime step and let it find the solution of the linear system. But weknow that we could do far better:</p>
<ul>
<li>First, we should make use of the fact that the matrix doesn't actually change from time step to time step. This is an artifact of the fact that we here have constant boundary values and that we don't change the time step size</li>
<li>two assumptions that might not be true in actual applications. But at least in cases where this does happen to be the case, it would make sense to only factorize the matrix once (i.e., compute \(L\) and \(U\) factors once) and then use these factors for all following time steps until the matrix \(C\) changes and requires a new factorization. The interface of the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class allows for this.</li>
<li>Ultimately, however, sparse direct solvers are only efficient for relatively small problems, say up to a few 100,000 unknowns. Beyond this, one needs iterative solvers such as the Conjugate Gradient method (for symmetric and positive definite problems) or GMRES. We have used many of these in other tutorial programs. In all cases, they need to be accompanied by good preconditioners. For the current case, one could in principle use GMRES</li>
<li>a method that does not require any specific properties of the matrix</li>
<li>but would be better advised to implement an iterative scheme that exploits the one structural feature we know is true for this problem: That the matrix is complex-symmetric (albeit not Hermitian).</li>
</ul>
<p><a class="anchor" id="Boundaryconditions"></a></p><h4>Boundary conditions </h4>
<p>In order to be usable for actual, realistic problems, solvers for thenonlinear Schr&ouml;dinger equation need to utilize boundary conditionsthat make sense for the problem at hand. We have here restricted ourselvesto simple Neumann boundary conditions</p>
<ul>
<li>but these do not actually makesense for the problem. Indeed, the equations are generally posed on aninfinite domain. But, since we can't compute on infinite domains, we needto truncate it somewhere and instead pose boundary conditions that makesense for this artificially small domain. The approach widely used is touse the <a href="https://en.wikipedia.org/wiki/Perfectly_matched_layer">Perfectly Matched Layer</a> method that corresponds to a particularkind of attenuation. It is, in a different context, also used in <a class="el" href="step_62.html">step-62</a> .</li>
</ul>
<p><a class="anchor" id="Adaptivemeshes"></a></p><h4>Adaptive meshes </h4>
<p>Finally, we know from experience and many other tutorial programs thatit is worthwhile to use adaptively refined meshes, rather than the uniformmeshes used here. It would, in fact, not be very difficult to add thishere: It just requires periodic remeshing and transfer of the solutionfrom one mesh to the next. <a class="el" href="step_26.html">step-26</a> will be a good guide for how thiscould be implemented.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University</span></div><div class="line"><span class="comment"> *         Yong-Yong Cai, Beijing Computational Science Research Center</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step58</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>NonlinearSchroedingerEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    NonlinearSchroedingerEquation();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_matrices();</div><div class="line">    <span class="keywordtype">void</span> do_half_phase_step();</div><div class="line">    <span class="keywordtype">void</span> do_full_spatial_step();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; rhs_matrix;</div><div class="line"></div><div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; solution;</div><div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> kappa;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim, <a class="code" href="namespacestd.html">std</a>::complex&lt;<a class="code" href="classdouble.html">double</a>&gt;&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::complex&lt;double&gt;</div><div class="line">    value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::complex&lt;double&gt;</div><div class="line">  InitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    static_assert(dim == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div><div class="line"></div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0, -0.3},</div><div class="line">                                                    {0, +0.3},</div><div class="line">                                                    {+0.3, 0},</div><div class="line">                                                    {-0.3, 0}};</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha =</div><div class="line">      1. / (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(numbers::PI, dim / 2.));</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = p - vortex_center;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">        sum += alpha * <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r * r) / (R * R));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(sum), 0.};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Potential() = <span class="keywordflow">default</span>;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Potential&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(p) &gt; 0.7 ? 1000 : 0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation()</div><div class="line">    : fe(2)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time(0)</div><div class="line">    , time_step(1. / 128)</div><div class="line">    , timestep_number(0)</div><div class="line">    , kappa(1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(6);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    rhs_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(dofs_per_cell,</div><div class="line">                                                     dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(dofs_per_cell,</div><div class="line">                                                     dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  potential_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div><div class="line">        cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        potential.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             potential_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> std::complex&lt;double&gt; i = {0, 1};</div><div class="line"></div><div class="line">                    cell_matrix_lhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                      (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                       time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                       time_step / 2 * potential_values[q_index] *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line"></div><div class="line">                    cell_matrix_rhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                      (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                       time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                       time_step / 2 * potential_values[q_index] *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix_lhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               rhs_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : solution)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; i         = {0, 1};</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(value);</div><div class="line"></div><div class="line">        value = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-i * kappa * magnitude * magnitude * (time_step / 2)) *</div><div class="line">                value;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step()</div><div class="line">  {</div><div class="line">    rhs_matrix.vmult(system_rhs, solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">    solution = system_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>DataPostprocessors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ComplexAmplitude();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">        std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div><div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                         inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1));</div><div class="line">          computed_quantities[q](0) = <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm</a>(psi);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ComplexPhase();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">        std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ComplexPhase&lt;dim&gt;::ComplexPhase()</div><div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> max_phase = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">          max_phase =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_phase,</div><div class="line">                     std::arg(</div><div class="line">                       std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                            inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1))));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;output : computed_quantities)</div><div class="line">        output(0) = max_phase;</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace DataPostprocessors</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div><div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;Psi&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_magnitude);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_phase);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, timestep_number));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line">    assemble_matrices();</div><div class="line"></div><div class="line">    time = 0;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), solution);</div><div class="line">    output_results();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div><div class="line">    <span class="keywordflow">for</span> (; time &lt;= end_time; time += time_step)</div><div class="line">      {</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        do_half_phase_step();</div><div class="line">        do_full_spatial_step();</div><div class="line">        do_half_phase_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div><div class="line">          output_results();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step58</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step58;</div><div class="line"></div><div class="line">      NonlinearSchroedingerEquation&lt;2&gt; nse;</div><div class="line">      nse.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_26.html">step-26</a>, <a class="el" href="step_29.html">step-29</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Anoteaboutthecharacteroftheequations">A note about the character of the equations</a>
        <li><a href="#Thegeneralideaofoperatorsplitting">The general idea of operator splitting</a>
        <li><a href="#OperatorsplittingtheLiesplittingapproach">Operator splitting: the "Lie splitting" approach</a>
        <li><a href="#OperatorsplittingtheStrangsplittingapproach">Operator splitting: the "Strang splitting" approach</a>
        <li><a href="#Timediscretization">Time discretization</a>
        <li><a href="#Spatialdiscretizationanddealingwithcomplexvariables">Spatial discretization and dealing with complex variables</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
        <li><a href="#Definitionofthetestcase">Definition of the test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeNonlinearSchroedingerEquationcodeclass">The <code>NonlinearSchroedingerEquation</code> class</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#ImplementationofthecodeNonlinearSchroedingerEquationcodeclass">Implementation of the <code>NonlinearSchroedingerEquation</code> class</a>
      <ul>
        <li><a href="#Settingupdatastructuresandassemblingmatrices">Setting up data structures and assembling matrices</a>
        <li><a href="#ImplementingtheStrangsplittingsteps">Implementing the Strang splitting steps</a>
        <li><a href="#Creatinggraphicaloutput">Creating graphical output</a>
        <li><a href="#Runningthesimulation">Running the simulation</a>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Visualizingthesolution">Visualizing the solution</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Betterlinearsolvers"> Better linear solvers </a>
        <li><a href="#Boundaryconditions"> Boundary conditions </a>
        <li><a href="#Adaptivemeshes"> Adaptive meshes </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-58/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Wolfgang Bangerth (Colorado State University) and Yong-Yong Cai (<a href="http://www.csrc.ac.cn/en/">Beijing Computational Science Research Center</a><a href="http://www.csrc.ac.cn/en/">Beijing Computational Science Research Center</a>, CSRC) and is the result of the first author's time as a visitor at CSRC.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> 。</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>一个函数 \(\psi=\psi(\mathbf x,t)\) 和一个势 \(V=V(\mathbf x)\) 的<a href="https://en.wikipedia.org/wiki/Nonlinear_Schr%C3%B6dinger_equation">Nonlinear Schr&ouml;dinger Equation (NLSE)</a>是量子力学和非线性光学中经常使用的一个模型。如果用适当的量来测量（以便 \(\hbar=1\) ），那么它的内容如下。</p>
<p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi + V \psi + \kappa |\psi|^2 \psi &amp;= 0 \qquad\qquad &amp; \text{in}\; \Omega\times (0,T), \\ \psi(\mathbf x,0) &amp;= \psi_0(\mathbf x) &amp; \text{in}\; \Omega, \\ \psi(\mathbf x,t) &amp;= 0 &amp; \text{on}\; \partial\Omega\times (0,T). \end{align*}
</p>
<p>如果没有电位，即 \(V(\mathbf x)=0\) ，那么它可以用来描述光在光纤中的传播。如果 \(V(\mathbf x)\neq 0\) ，该方程有时也被称为<a href="https://en.wikipedia.org/wiki/Gross%E2%80%93Pitaevskii_equation">Gross-Pitaevskii equation</a>，可用于模拟<a href="https://en.wikipedia.org/wiki/Bose%E2%80%93Einstein_condensate">Bose-Einstein condensates</a>的时间依赖行为。</p>
<p>对于这个特定的辅导项目，我们对该方程的物理解释并不太关心。相反，我们想把它作为一个模型，让我们解释两个方面。</p>
<ul>
<li>这是一个<b>complex-valued equation</b>的 \(\psi \in H^1(\Omega,{\mathbb C})\) 。我们以前在<a class="el" href="step_29.html">step-29</a>中看到过复值方程，但那里选择了将方程分成实数和虚数部分，结果是解决了两个实值方程的系统。相比之下，这里的目标是展示如何解决我们保持一切为复数的问题。</li>
<li>这个方程是一个很好的模型问题，可以解释<b>operator splitting methods</b>如何工作。这是因为它有一些具有根本不同性质的项：一方面， \(- \frac 12 \Delta \psi\) 是一个常规的空间算子，其方式我们以前已经见过多次；另一方面， \(\kappa |\psi(\mathbf x,t)|^2 \psi\) 没有空间或时间导数，也就是说，它是一个纯粹的局部算子。事实证明，我们对这些项中的每一项都有有效的方法（特别是，我们对后者有分析解），而且我们可能最好对这些项进行不同的、单独的处理。我们将在下文中更详细地解释这一点。</li>
</ul>
<p><a class="anchor" id="Anoteaboutthecharacteroftheequations"></a></p><h3>A note about the character of the equations</h3>
<p>乍一看，这些方程似乎是抛物线，与热力方程相似（见步骤26），因为只有一个时间导数和两个空间导数。但这是一种误导。事实上，如果我们暂时假设势 \(V=0\) 和 \(\kappa=0\) ，这不是正确的解释，更容易看出。那么我们就有这样的方程</p>
<p class="formulaDsp">
\begin{align*} - i \frac{\partial \psi}{\partial t} - \frac 12 \Delta \psi &amp;= 0. \end{align*}
</p>
<p>如果我们把解分成实部和虚部， \(\psi=v+iw\) ，与 \(v=\textrm{Re}\;\psi,\; w=\textrm{Im}\;\psi\) ，那么我们就可以按照步骤29中的方法，把一个方程分成实部和虚部。</p>
<p class="formulaDsp">
\begin{align*} \frac{\partial w}{\partial t} - \frac 12 \Delta v &amp;= 0, \\ -\frac{\partial v}{\partial t} - \frac 12 \Delta w &amp;= 0. \end{align*}
</p>
<p>毫不奇怪，时间导数前面的因子 \(i\) 耦合了方程的实部和虚部。如果我们想进一步理解这个方程，可以取其中一个方程的时间导数，例如</p>
<p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} - \frac 12 \Delta \frac{\partial v}{\partial t} &amp;= 0, \end{align*}
</p>
<p>在这里我们假设，至少在某种正式意义上，我们可以将空间和时间导数进行换算），然后将另一个方程插入其中。</p>
<p class="formulaDsp">
\begin{align*} \frac{\partial^2 w}{\partial t^2} + \frac 14 \Delta^2 w &amp;= 0. \end{align*}
</p>
<p>这个方程是双曲线的，与波浪方程的性质相似。如果你看一下本程序的 "结果 "部分的视频，这一点也会很明显）。此外，我们也可以得出 \(v\) 的相同方程。因此，对于NLSE来说，一个更好的假设是把它看成是一个双曲的波传播方程，而不是像热方程那样的扩散方程。你可能会问，算子 \(\Delta^2\) 以正号出现，而在波浪方程中， \(\Delta\) 有一个负号，这是否正确？这确实是正确的。在与测试函数相乘并通过部分积分后，我们希望得到一个正（半）定式。因此，从 \(-\Delta u\) 我们得到 \(+(\nabla v,\nabla u)\) 。同样，经过两次积分，我们从 \(+\Delta^2 u\) 得到 \(+(\Delta v,\Delta u)\) 的形式。在这两种情况下，我们都能得到所需的正号）。)</p>
<p>当然，真正的NLSE也有 \(V\psi\) 和 \(\kappa|\psi|^2\psi\) 等项。然而，这些是空间导数中的低阶项，虽然它们显然很重要，但它们并不改变方程的特征。</p>
<p>在任何情况下，本讨论的目的是要弄清楚什么时间步长方案可能适合于该方程。结论是，作为一个双曲类型的方程，我们需要选择一个满足CFL类型条件的时间步长。如果我们使用显式方法（我们不会这样做），我们将不得不研究与空间算子相对应的矩阵的特征值。如果你跟随视频讲座的讨论( See also <a href="http://www.math.colostate.edu/~bangerth/videos.676.26.html">video lecture 26</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.27.html">video lecture 27</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.28.html">video lecture 28</a>.) ，那么你会记得，模式是需要确保 \(k^s \propto h^t\) ，其中 \(k\) 是时间步长， \(h\) 是网格宽度， \(s,t\) 是时间和空间导数的顺序。无论你采取原始方程( \(s=1,t=2\) )还是只对实部或虚部进行重构，其结果是，如果我们要使用显式时间步进方法，我们需要选择 \(k \propto h^2\) 。这是不可行的，原因与热方程的步骤26相同。它将产生不切实际的小的时间步长，甚至只对适度精细的网格。相反，我们必须使用隐式时间步进方法，然后可以选择一个更平衡的 \(k \propto h\) 。事实上，我们将使用隐式的Crank-Nicolson方法，正如我们之前在步骤23中对常规波方程所做的那样。</p>
<p><a class="anchor" id="Thegeneralideaofoperatorsplitting"></a></p><h3>The general idea of operator splitting</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.30.25.html">video lecture 30.25</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>如果我们把NLSE看作是一个普通微分方程，其中的右手边恰好有空间导数，即把它写成</p>
<p class="formulaDsp">
\begin{align*} \frac{d\psi}{dt} &amp;= i\frac 12 \Delta \psi -i V \psi -i\kappa |\psi|^2 \psi, \qquad\qquad &amp; \text{for}\; t \in (0,T), \\ \psi(0) &amp;= \psi_0, \end{align*}
</p>
<p>人们可能会想通过在时间间隔 \([t_{n},t_{n+1}]\) 上对两边进行积分来 "正式求解"，并得到</p>
<p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) -i V \psi(t) -i\kappa |\psi(t)|^2 \psi(t) \right) \; dt. \end{align*}
</p>
<p>当然，这不是那么简单的：积分中的 \(\psi(t)\) 仍在按照微分方程随时间变化，所以我们不能直接评估积分（或通过正交轻松近似它），因为我们不知道 \(\psi(t)\) 。但是我们可以把这个写成如下的独立贡献，这将使我们能够分别处理不同的项。</p>
<p class="formulaDsp">
\begin{align*} \psi(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi(t)|^2 \,\psi(t) \right) \; dt. \end{align*}
</p>
<p>现在可以将这个方程解读如下。对于每个时间间隔 \([t_{n},t_{n+1}]\) ，溶液中的变化 \(\psi(t_{n+1})-\psi(t_{n})\) 由三个贡献组成。</p>
<ul>
<li>拉普拉斯算子的贡献。</li>
<li>势的贡献 \(V\) 。</li>
<li>相 "项的贡献 \(-i\kappa |\psi(t)|^2\,\psi(t)\) 。</li>
</ul>
<p><em>Operator splitting</em>现在是一种近似技术，允许我们分别处理这些贡献中的每一个。(如果我们想的话。在实践中，我们将把前两个放在一起处理，而最后一个则分开处理。但这是一个细节，从概念上讲，我们可以以不同的方式处理所有这些贡献）。)为此，让我们介绍三个独立的 "解决方案"。</p>
<p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p>这三个 "解决方案 "可以被认为是满足以下微分方程。</p>
<p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n). \end{align*}
</p>
<p>换句话说，它们都是以 \(\psi(t_n)\) 为起点的轨迹 \(\psi^{(k)}\) ，并且正好整合了三个条款中的一个条款的影响。在我们的时间区间内，这些条款中的每一项产生的增量是 \(I^{(1)}=\psi^{(1)}(t_{n+1})-\psi(t_n)\) 、 \(I^{(2)}=\psi^{(2)}(t_{n+1})-\psi(t_n)\) 和 \(I^{(3)}=\psi^{(3)}(t_{n+1})-\psi(t_n)\) 。</p>
<p>现在可以合理地假设（这是一个近似值！），由于所有三个有关的影响而产生的变化很好地近似于三个单独的增量的总和。</p>
<p class="formulaDsp">
\begin{align*} \psi(t_{n+1})-\psi(t_n) \approx I^{(1)} + I^{(2)} + I^{(3)}. \end{align*}
</p>
<p>这种直觉确实是正确的，尽管近似并不精确：精确的左手边和项 \(I^{(1)}+I^{(2)}+I^{(3)}\) 之间的差异（即从 \(t_n\) 到 \(t_{n+1}\) 时，精确解 \(\psi(t)\) 的<em>exact</em>增量与右手边三部分组成的增量之间的差异），正比于 \(\Delta t=t_{n+1}-t_{n}\) 。换句话说，这种方法引入了一个大小为 \({\cal O}(\Delta t)\) 的误差。到目前为止，我们所做的一切都没有在时间或空间上离散化，所以<em>overall</em>的误差将是 \({\cal O}(\Delta t)\) 加上我们在近似积分时的任何误差（时间离散化误差）加上我们在近似 \(\psi\) 的空间依赖时的任何误差（空间误差）。</p>
<p>在我们继续讨论运算符拆分之前，让我们谈谈为什么要走这条路？答案很简单。对于 \(\psi^{(k)}\) 的一些独立方程，我们可能有办法比把所有东西放在一起并试图一次解决它们更有效。例如，在目前的情况下，特别相关的是。 \(\psi^{(3)}\) 的方程，即。</p>
<p class="formulaDsp">
\begin{align*} \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, \qquad\qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi(t_n), \end{align*}
</p>
<p>或等价的。</p>
<p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt, \end{align*}
</p>
<p>可以精确求解：方程的解法是</p>
<p class="formulaDsp">
\begin{align*} \psi^{(3)}(t) = e^{-i\kappa|\psi(t_n)|^2 (t-t_{n})} \psi(t_n). \end{align*}
</p>
<p>这很容易看出，如果（i）你把这个解插入微分方程，（ii）意识到幅度 \(|\psi^{(3)}|\) 是常数，即指数中的项 \(|\psi(t_n)|^2\) 实际上等于 \(|\psi^{(3)}(t)|^2\) 。换句话说， \(\psi^{(3)}(t)\) 的ODE的解只是改变了它的<em>phase</em>，但复值函数 \(\psi^{(3)}(t)\) 的<em>magnitude</em>保持不变。这使得计算 \(I^{(3)}\) 特别方便：我们实际上不需要解决任何ODE，我们可以用手写下解。使用算子拆分方法，计算 \(I^{(1)},I^{(2)}\) 的方法都不必处理非线性项和所有相关的不愉快：只要我们允许自己使用算子拆分方法，就可以摆脱只解决<em>linear</em>问题。</p>
<p>其次，如果不同项所描述的不同物理效应具有不同的时间尺度，人们通常会使用算子拆分。例如，想象一下，我们确实有某种扩散方程的情况。扩散作用缓慢，但如果 \(\kappa\) 很大，那么 \(-i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t)\) 项的 "相位旋转 "就会迅速发挥作用。如果我们把所有的东西放在一起处理，这将意味着必须采取相当小的时间步长。但是有了算子分割，我们可以对扩散采取大的时间步数 \(\Delta t=t_{n+1}-t_{n}\) ，并且（假设我们没有分析解）使用具有许多小时间步数的ODE求解器来整合 \(\psi^{(3)}\) 从 \(t_n\) 到 \(t_{n+1}\) 的 "相变 "方程。换句话说，算子分裂允许我们将慢速和快速的时间尺度解耦，并对它们进行不同的处理，方法根据每种情况进行调整。</p>
<p><a class="anchor" id="OperatorsplittingtheLiesplittingapproach"></a></p><h3>Operator splitting: the "Lie splitting" approach</h3>
<p>虽然上述方法允许并行计算三个贡献 \(I^{(k)}\) ，但如果我们愿意，如果我们不让 \(\psi^{(k)}\) 的轨迹全部从 \(\psi(t_n)\) 开始，而是让 \(\psi^{(2)}\) 的轨迹从 \(\psi^{(1)}\) 的<em>end point</em>开始，可以使该方法稍微准确和容易实现。]，而是让 \(\psi^{(2)}\) 的轨迹从 \(\psi^{(1)}\) 的轨迹的<em>end point</em>开始，即 \(\psi^{(1)}(t_{n+1})\) ；同样，我们将从 \(\psi^{(3)}\) 的轨迹的终点开始，即 \(\psi^{(2)}(t_{n+1})\) 。这种方法就被称为 "Lie splitting"，其误差顺序与上面的方法相同，即分割误差为 \({\cal O}(\Delta t)\) 。</p>
<p>运算符拆分的这种变化可以写成如下形式（仔细比较上面的初始条件）。</p>
<p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i V \psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p>显然，虽然上面的公式意味着我们应该以这种特定的顺序来解决这些问题，但首先解决轨迹3，然后是2，然后是1，或任何其他的排列组合也同样有效）。</p>
<p>那么这些方程的综合形式是</p>
<p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt, \\ \psi^{(2)}(t_{n+1}) &amp;= \psi^{(1)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt, \\ \psi^{(3)}(t_{n+1}) &amp;= \psi^{(2)}(t_{n+1}) + \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p>从实际的角度来看，这样做的好处是我们需要保持较少的解向量。一旦 \(\psi^{(1)}(t_n)\) 被计算出来，我们就不再需要 \(\psi(t_n)\) 了；一旦 \(\psi^{(2)}(t_n)\) 被计算出来，我们就不再需要 \(\psi^{(1)}(t_n)\) 了。而一旦 \(\psi^{(3)}(t_n)\) 被计算出来，我们就可以直接称之为 \(\psi(t_{n+1})\) ，因为如果你把第一个方程插入第二个方程，然后再插入第三个方程，你会看到 \(\psi^{(3)}(t_n)\) 的右边现在包含所有三个物理效应的贡献。</p>
<p class="formulaDsp">
\begin{align*} \psi^{(3)}(t_{n+1}) &amp;= \psi(t_n) + \int_{t_n}^{t_{n+1}} \left( i\frac 12 \Delta \psi^{(1)}(t) \right) \; dt + \int_{t_n}^{t_{n+1}} \left( -i V \psi^{(2)}(t) \right) \; dt+ \int_{t_n}^{t_{n+1}} \left( -i\kappa |\psi^{(3)}(t)|^2 \,\psi^{(3)}(t) \right) \; dt. \end{align*}
</p>
<p>(再与 \(\psi(t_{n+1})\) 的 "精确 "计算进行比较：它只在我们如何在三个积分中的每一个中近似 \(\psi(t)\) 方面有所不同)。换句话说，Lie拆分的实现比上述原始方法要简单得多，因为数据处理要简单得多。</p>
<p><a class="anchor" id="OperatorsplittingtheStrangsplittingapproach"></a></p><h3>Operator splitting: the "Strang splitting" approach</h3>
<p>如上所述，Lie拆分只有 \({\cal O}(\Delta t)\) 的准确性。如果我们使用一阶时间离散化，例如使用显式或隐式欧拉方法来解决 \(\psi^{(k)}\) 的微分方程，这是可接受的。这是因为这些时间积分方法引入了与 \(\Delta t\) 本身成正比的误差，因此分裂误差与我们无论如何都会引入的误差成正比，并不会削弱整体收敛顺序。</p>
<p>但我们通常希望使用高阶的方法&ndash;比如，<a href="https://en.wikipedia.org/wiki/Crank%E2%80%93Nicolson_method">Crank-Nicolson</a>或<a href="https://en.wikipedia.org/wiki/Backward_differentiation_formula">BDF2</a>方法&ndash;因为这些方法通常不会比简单的欧拉方法更昂贵。如果我们使用 \({\cal O}(\Delta t^2)\) 的时间步长方法，但由于算子分裂又失去了精度，那就太可惜了。</p>
<p>这就是<a href="https://en.wikipedia.org/wiki/Strang_splitting">Strang splitting</a>方法的用处。如果我们只有两部分，就更容易解释了，所以让我们把拉普拉斯算子和势的影响合二为一，把相位旋转合为第二个影响。事实上，这就是我们在代码中要做的事情，因为用拉普拉斯方程求解，不管有没有电势，代价都是一样的&ndash;所以我们把这两步合并起来）。上面的Lie拆分方法将做以下工作。它计算出以下两个ODE的解。</p>
<p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= i\frac 12 \Delta \psi^{(1)} -i V \psi^{(1)}, \qquad &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= -i\kappa |\psi^{(2)}|^2 \,\psi^{(2)}, &amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_{n+1}), \end{align*}
</p>
<p>然后使用近似值 \(\psi(t_{n+1}) \approx \psi^{(2)}(t_{n+1})\) 。换句话说，我们首先为物理效应一做一个完整的时间步骤，然后为物理效应二做一个完整的时间步骤。时间步数结束时的解只是分别由这些物理效应引起的增量的总和。</p>
<p>相比之下，<a href="https://en.wikipedia.org/wiki/Gilbert_Strang">Gil Strang</a>（20世纪中期开始的数值分析领域的泰斗之一）发现，先对一个物理效应做一个半步，然后对另一个物理效应做一个完整的时间步骤，再对第一个物理效应做一个半步，这样更准确。哪个是哪个并不重要，但由于做相位旋转非常简单，我们将用这个效应做半步，然后只需要用拉普拉斯算子加势做一次空间解。这种算子拆分方法现在是 \({\cal O}(\Delta t^2)\) 准确的。写在公式里，这就产生了以下的步骤序列。</p>
<p class="formulaDsp">
\begin{align*} \frac{d\psi^{(1)}}{dt} &amp;= -i\kappa |\psi^{(1)}|^2 \,\psi^{(1)}, &amp;&amp; \text{for}\; t \in (t_n,t_n+\tfrac 12\Delta t), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(1)}(t_n) &amp;= \psi(t_n), \\ \frac{d\psi^{(2)}}{dt} &amp;= i\frac 12 \Delta \psi^{(2)} -i V \psi^{(2)}, \qquad &amp;&amp; \text{for}\; t \in (t_n,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(2)}(t_n) &amp;= \psi^{(1)}(t_n+\tfrac 12\Delta t), \\ \frac{d\psi^{(3)}}{dt} &amp;= -i\kappa |\psi^{(3)}|^2 \,\psi^{(3)}, &amp;&amp; \text{for}\; t \in (t_n+\tfrac 12\Delta t,t_{n+1}), \qquad\qquad&amp;\text{with initial condition}\; \psi^{(3)}(t_n) &amp;= \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p>如前所述，对于这个特殊的方程，第一和第三步可以精确计算，得出的结果是</p>
<p class="formulaDsp">
\begin{align*} \psi^{(1)}(t_n+\tfrac 12\Delta t) &amp;= e^{-i\kappa|\psi(t_n)|^2 \tfrac 12\Delta t} \; \psi(t_n), \\ \psi^{(3)}(t_{n+1}) &amp;= e^{-i\kappa|\psi^{(2)}(t_{n+1})|^2 \tfrac 12\Delta t} \; \psi^{(2)}(t_{n+1}). \end{align*}
</p>
<p>那么这就是我们在这个程序中要实现的事情。在每个时间步骤中，我们执行三个步骤，即</p>
<ul>
<li>通过分析整合相位旋转方程的半个时间步长，更新每个节点的解值。</li>
<li>解决与 \(\psi^{(2)}\) 的全步骤相对应的时空方程，即 \(-i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0\) ，初始条件等于上述第一个半步骤的解决方案。</li>
<li>通过对相位旋转方程再进行半个时间步长的分析积分，更新每个节点的解值。</li>
</ul>
<p>这种结构将以明显的方式反映在程序的主时间循环中。</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization</h3>
<p>从上面的讨论中可以看出，我们在每个时间步骤中要解决的唯一偏微分方程是</p>
<p class="formulaDsp">
\begin{align*} -i\frac{\partial\psi^{(2)}}{\partial t} - \frac 12 \Delta \psi^{(2)} + V \psi^{(2)} = 0. \end{align*}
</p>
<p>这个方程是线性的。此外，我们只需要解决从 \(t_n\) 到 \(t_{n+1}\) 的问题，也就是说，正好是一个时间步骤。</p>
<p>为了做到这一点，我们将应用二阶精确的Crank-Nicolson方案，我们已经在其他一些时间相关的代码中使用过该方案（具体为：步骤23和步骤26）。它的内容如下。</p>
<p class="formulaDsp">
\begin{align*} -i\frac{\psi^{(n,2)}-\psi^{(n,1)}}{k_{n+1}} - \frac 12 \Delta \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] + V \left[\frac 12 \left(\psi^{(n,2)}+\psi^{(n,1)}\right)\right] = 0. \end{align*}
</p>
<p>这里，"先前 "的解决方案 \(\psi^{(n,1)}\) （或这部分时间步长的 "初始条件"）是第一个阶段旋转半步的输出；当前步骤的输出将用 \(\psi^{(n,2)}\) 表示。 \(k_{n+1}=t_{n+1}-t_n\) 是时间步骤的长度。人们可以争论 \(\psi^{(n,1)}\) 和 \(\psi^{(n,1)}\) 是生活在时间步长 \(n\) 还是 \(n+1\) ，以及它们的上指数应该是什么。这是一个没有实际影响的哲学讨论，人们可以把 \(\psi^{(n,1)}\) 看作是 \(\psi^{(n+\tfrac 13)}\) ，而把 \(\psi^{(n,2)}\) 看作是 \(\psi^{(n+\tfrac 23)}\) ，如果这有助于澄清问题的话&ndash;不过， \(n+\frac 13\) 也不能理解为" @f$t_n@f$ 之后的三分之一时间步骤"，而更像是 "我们已经完成了时间步骤 @f$n+1@f$ 所需工作的三分之一。")</p>
<p>如果我们将整个方程与 \(k_{n+1}\) 相乘，并将未知的 \(\psi^{(n+1,2)}\) 项排序到左边，将已知的 \(\psi^{(n,2)}\) 项排序到右边，那么我们得到以下（空间）偏微分方程，需要在每个时间步骤中解决。</p>
<p class="formulaDsp">
\begin{align*} -i\psi^{(n,2)} - \frac 14 k_{n+1} \Delta \psi^{(n,2)} + \frac 12 k_{n+1} V \psi^{(n,2)} = -i\psi^{(n,1)} + \frac 14 k_{n+1} \Delta \psi^{(n,1)} - \frac 12 k_{n+1} V \psi^{(n,1)}. \end{align*}
</p>
<p><a class="anchor" id="Spatialdiscretizationanddealingwithcomplexvariables"></a></p><h3>Spatial discretization and dealing with complex variables</h3>
<p>如上所述，之前处理复值解的教程程序（即<a class="el" href="step_29.html">step-29</a>）将解的实部和虚部分开。因此，它将一切都简化为实数运算。相比之下，我们在这里希望保持复值的东西。</p>
<p>第一部分是我们需要将离散的解决方案定义为 \(\psi_h^n(\mathbf x)=\sum_j \Psi^n_j \varphi_j(\mathbf x) \approx \psi(\mathbf x,t_n)\) ，其中 \(\varphi_j\) 是通常的形状函数（是实值的），但在时间步长 \(n\) 的扩展系数 \(\Psi^n_j\) 现在是复值的。这在deal.II中很容易做到：我们只需要用 <a class="el" href="classVector.html">Vector</a>&lt;std::complex&lt;double&gt;&gt; 而不是Vector&lt;double&gt;来存储这些系数。</p>
<p>更感兴趣的是如何建立和解决线性系统。很明显，这只对上面讨论的斯特朗分割的第二步有必要，即上一小节的时间离散化。我们通过将 \(\psi^n\) 直接替换为 \(\psi^n_h\) 并乘以一个测试函数，得到完全离散的版本。</p>
<p class="formulaDsp">
\begin{align*} -iM\Psi^{(n,2)} + \frac 14 k_{n+1} A \Psi^{(n,2)} + \frac 12 k_{n+1} W \Psi^{(n,2)} = -iM\Psi^{(n+1,1)} - \frac 14 k_{n+1} A \Psi^{(n,1)} - \frac 12 k_{n+1} W \Psi^{(n,1)}, \end{align*}
</p>
<p>或以更紧凑的方式书写。</p>
<p class="formulaDsp">
\begin{align*} \left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}. \end{align*}
</p>
<p>在这里，矩阵是以其明显的方式定义的。</p>
<p class="formulaDsp">
\begin{align*} M_{ij} &amp;= (\varphi_i,\varphi_j), \\ A_{ij} &amp;= (\nabla\varphi_i,\nabla\varphi_j), \\ W_{ij} &amp;= (\varphi_i,V \varphi_j). \end{align*}
</p>
<p>请注意，所有单独的矩阵实际上都是对称的、实值的，而且至少是正半无限的，尽管对于系统矩阵 \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) 和右手边的相应矩阵 \(R = -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W\) 来说显然不是这样的。</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h3>Linear solvers</h3>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.34.html">video lecture 34</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>关于解决程序的唯一剩下的重要问题是如何解决复值线性系统</p>
<p class="formulaDsp">
\begin{align*} C \Psi^{(n+1,2)} = R \Psi^{(n+1,1)}, \end{align*}
</p>
<p>矩阵 \(C = -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W\) ，右手边很容易计算为已知矩阵与上一步骤解决方案的乘积。像往常一样，这归结于矩阵 \(C\) 具有什么属性的问题。如果它是对称和正定的，那么我们可以使用共轭梯度法。</p>
<p>不幸的是，该矩阵唯一有用的属性是它是复数对称的，即 \(C_{ij}=C_{ji}\) ，通过回顾 \(M,A,W\) 都是对称的就很容易看出。然而，它不是<a href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian</a>，这就要求 \(C_{ij}=\bar C_{ji}\) ，其中的横杠表示复数共轭。</p>
<p>复杂的对称性可以被用于迭代求解器，正如快速的文献搜索所显示的。我们在这里不会试图变得太复杂（实际上是把这个问题留给下面的<a href="#extensions">Possibilities for extensions</a>部分），而是简单地用好的老办法来解决没有属性的问题。一个直接的解算器。这不是最好的，特别是对于大问题，但对于一个教程程序来说，这已经足够了。幸运的是，SparseDirectUMFPACK类允许解决复杂值的问题。</p>
<p><a class="anchor" id="Definitionofthetestcase"></a></p><h3>Definition of the test case</h3>
<p>NLSE的初始条件通常被选择来代表特定的物理情况。这超出了本程序的范围，但只要说这些初始条件是（i）位于不同点的粒子的波函数的叠加，以及（ii）因为 \(|\psi(\mathbf x,t)|^2\) 对应于一个粒子密度函数，积分</p>
<p class="formulaDsp">
\[ N(t) = \int_\Omega |\psi(\mathbf x,t)|^2 \]
</p>
<p>对应于系统中粒子的数量。显然，如果要在物理上正确，如果系统是封闭的， \(N(t)\) 最好是一个常数，或者如果有吸收性边界条件， \(\frac{dN}{dt}&lt;0\) 最好是常数）。重要的一点是，我们应该选择初始条件，以使</p>
<p class="formulaDsp">
\[ N(0) = \int_\Omega |\psi_0(\mathbf x)|^2 \]
</p>
<p>有道理。</p>
<p>我们在这里将使用的，主要是因为它能做出好的图形，是以下内容。</p>
<p class="formulaDsp">
\[ \psi_0(\mathbf x) = \sqrt{\sum_{k=1}^4 \alpha_k e^{-\frac{r_k^2}{R^2}}}, \]
</p>
<p>其中 \(r_k = |\mathbf x-\mathbf x_k|\) 是与（固定）位置 \(\mathbf x_k\) 的距离， \(\alpha_k\) 的选择是为了使我们要加起来的每个高斯在 \(N(0)\) 中增加整数个粒子。我们通过确保以下几点来实现这一点</p>
<p class="formulaDsp">
\[ \int_\Omega \alpha_k e^{-\frac{r_k^2}{R^2}} \]
</p>
<p>是一个正整数。换句话说，我们需要选择 \(\alpha\) 作为一个整数倍的</p>
<p class="formulaDsp">
\[ \left(\int_\Omega e^{-\frac{r_k^2}{R^2}}\right)^{-1} = \left(R^d\sqrt{\pi^d}\right)^{-1}, \]
</p>
<p>暂时假设 \(\Omega={\mathbb R}^d\) &ndash; 当然不是这样，但我们将忽略积分的微小差异。</p>
<p>因此，我们选择 \(\alpha_k=\left(R^d\sqrt{\pi^d}\right)^{-1}\) 为所有，以及 \(R=0.1\) 。这个 \(R\) 足够小，精确（无限）积分和 \(\Omega\) 上的积分之间的差异应该不会太引人注意。我们选择 \(\mathbf x_k\) 这四个点作为 \((\pm 0.3, 0), (0, \pm 0.3)\) &ndash;也离 \(\Omega\) 的边界足够远，以保证我们的安全。</p>
<p>为了简单起见，我们在方形 \([-1,1]^2\) 上提出问题。对于边界条件，我们将使用时间无关的诺依曼条件，其形式为</p>
<p class="formulaDsp">
\[ \nabla\psi(\mathbf x,t)\cdot \mathbf n=0 \qquad\qquad \forall \mathbf x\in\partial\Omega. \]
</p>
<p>这不是一个现实的边界条件选择，但对于我们想在这里展示的东西来说已经足够了。我们将在下面的<a href="#extensions">Possibilities for extensions</a>部分进一步评论这个问题。</p>
<p>最后，我们选择 \(\kappa=1\) ，势为</p>
<p class="formulaDsp">
\[ V(\mathbf x) = \begin{cases} 0 &amp; \text{if}\; |\mathbf x|&lt;0.7 \\ 1000 &amp; \text{otherwise}. \end{cases} \]
</p>
<p>使用一个大的势可以确保波函数 \(\psi\) 在半径为0.7的圆圈外保持很小。构成初始条件的所有高斯都在这个圆内，解决方案将主要在这个圆内振荡，有少量的能量辐射到外面。大势的使用也确保了非物理边界条件不会有太大的影响。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The program starts with the usual include files, all of which you should have seen before by now:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Then the usual placing of all content of this program into a namespace and the importation of the deal.II namespace into the one we will work in:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step58</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>The <code>NonlinearSchroedingerEquation</code> class</h3>
<p>Then the main class. It looks very much like the corresponding classes in <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a>, with the only exception that the matrices and vectors and everything else related to the linear system are now storing elements of type <code>std::complex&lt;double&gt;</code> instead of just <code>double</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>NonlinearSchroedingerEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  NonlinearSchroedingerEquation();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_matrices();</div><div class="line">  <span class="keywordtype">void</span> do_half_phase_step();</div><div class="line">  <span class="keywordtype">void</span> do_full_spatial_step();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; rhs_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; system_rhs;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time;</div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> kappa;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Before we go on filling in the details of the main class, let us define the equation data corresponding to the problem, i.e. initial values, as well as a right hand side class. (We will reuse the initial conditions also for the boundary values, which we simply keep constant.) We do so using classes derived from the <a class="el" href="classFunction.html">Function</a> class template that has been used many times before, so the following should not look surprising. The only point of interest is that we here have a complex-valued problem, so we have to provide the second template argument of the <a class="el" href="classFunction.html">Function</a> class (which would otherwise default to <code>double</code>). Furthermore, the return type of the <code>value()</code> functions is then of course also complex.</p>
<p>What precisely these functions return has been discussed at the end of the Introduction section.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim, <a class="code" href="namespacestd.html">std</a>::complex&lt;<a class="code" href="classdouble.html">double</a>&gt;&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::complex&lt;double&gt;</div><div class="line">  <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::complex&lt;double&gt;</div><div class="line">InitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  static_assert(dim == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div><div class="line"></div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0, -0.3},</div><div class="line">                                                  {0, +0.3},</div><div class="line">                                                  {+0.3, 0},</div><div class="line">                                                  {-0.3, 0}};</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha =</div><div class="line">    1. / (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(numbers::PI, dim / 2.));</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> sum = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = p - vortex_center;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">      sum += alpha * <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r * r) / (R * R));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> {<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(sum), 0.};</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Potential() = <span class="keywordflow">default</span>;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Potential&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(p) &gt; 0.7 ? 1000 : 0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeNonlinearSchroedingerEquationcodeclass"></a> </p><h3>Implementation of the <code>NonlinearSchroedingerEquation</code> class</h3>
<p>We start by specifying the implementation of the constructor of the class. There is nothing of surprise to see here except perhaps that we choose quadratic ( \(Q_2\)) Lagrange elements &ndash; the solution is expected to be smooth, so we choose a higher polynomial degree than the bare minimum.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation()</div><div class="line">  : fe(2)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , time(0)</div><div class="line">  , time_step(1. / 128)</div><div class="line">  , timestep_number(0)</div><div class="line">  , kappa(1)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Settingupdatastructuresandassemblingmatrices"></a> </p><h4>Setting up data structures and assembling matrices</h4>
<p>The next function is the one that sets up the mesh, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and matrices and vectors at the beginning of the program, i.e. before the first time step. The first few lines are pretty much standard if you've read through the tutorial programs at least up to <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(6);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  rhs_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.close();</div><div class="line">}</div></div><!-- fragment --><p>Next, we assemble the relevant matrices. The way we have written the Crank-Nicolson discretization of the spatial step of the Strang splitting (i.e., the second of the three partial steps in each time step), we were led to the linear system \(\left[ -iM + \frac 14 k_{n+1} A + \frac 12 k_{n+1} W \right] \Psi^{(n,2)} = \left[ -iM - \frac 14 k_{n+1} A - \frac 12 k_{n+1} W \right] \Psi^{(n,1)}\). In other words, there are two matrices in play here &ndash; one for the left and one for the right hand side. We build these matrices separately. (One could avoid building the right hand side matrix and instead just form the <em>action</em> of the matrix on \(\Psi^{(n,1)}\) in each time step. This may or may not be more efficient, but efficiency is not foremost on our minds for this program.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(dofs_per_cell,</div><div class="line">                                                   dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;                  potential_values(n_q_points);</div><div class="line">  <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div><div class="line">      cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      potential.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           potential_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> std::complex&lt;double&gt; i = {0, 1};</div><div class="line"></div><div class="line">                  cell_matrix_lhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                    (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                     time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                     time_step / 2 * potential_values[q_index] *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line"></div><div class="line">                  cell_matrix_rhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                    (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                     time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                     time_step / 2 * potential_values[q_index] *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.distribute_local_to_global(cell_matrix_lhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             system_matrix);</div><div class="line">      constraints.distribute_local_to_global(cell_matrix_rhs,</div><div class="line">                                             local_dof_indices,</div><div class="line">                                             rhs_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ImplementingtheStrangsplittingsteps"></a> </p><h4>Implementing the Strang splitting steps</h4>
<p>Having set up all data structures above, we are now in a position to implement the partial steps that form the Strang splitting scheme. We start with the half-step to advance the phase, and that is used as the first and last part of each time step.</p>
<p>To this end, recall that for the first half step, we needed to compute \(\psi^{(n,1)} = e^{-i\kappa|\psi^{(n,0)}|^2 \tfrac 12\Delta t} \; \psi^{(n,0)}\). Here, \(\psi^{(n,0)}=\psi^{(n)}\) and \(\psi^{(n,1)}\) are functions of space and correspond to the output of the previous complete time step and the result of the first of the three part steps, respectively. A corresponding solution must be computed for the third of the part steps, i.e. \(\psi^{(n,3)} = e^{-i\kappa|\psi^{(n,2)}|^2 \tfrac 12\Delta t} \; \psi^{(n,2)}\), where \(\psi^{(n,3)}=\psi^{(n+1)}\) is the result of the time step as a whole, and its input \(\psi^{(n,2)}\) is the result of the spatial step of the Strang splitting.</p>
<p>An important realization is that while \(\psi^{(n,0)}(\mathbf x)\) may be a finite element function (i.e., is piecewise polynomial), this may not necessarily be the case for the "rotated" function in which we have updated the phase using the exponential factor (recall that the amplitude of that function remains constant as part of that step). In other words, we could <em>compute</em> \(\psi^{(n,1)}(\mathbf x)\) at every point \(\mathbf x\in\Omega\), but we can't represent it on a mesh because it is not a piecewise polynomial function. The best we can do in a discrete setting is to compute a projection or interpolation. In other words, we can compute \(\psi_h^{(n,1)}(\mathbf x) = \Pi_h \left(e^{-i\kappa|\psi_h^{(n,0)}(\mathbf x)|^2 \tfrac 12\Delta t} \; \psi_h^{(n,0)}(\mathbf x) \right)\) where \(\Pi_h\) is a projection or interpolation operator. The situation is particularly simple if we choose the interpolation: Then, all we need to compute is the value of the right hand side <em>at the node points</em> and use these as nodal values for the vector \(\Psi^{(n,1)}\) of degrees of freedom. This is easily done because evaluating the right hand side at node points for a Lagrange finite element as used here requires us to only look at a single (complex-valued) entry of the node vector. In other words, what we need to do is to compute \(\Psi^{(n,1)}_j = e^{-i\kappa|\Psi^{(n,0)}_j|^2 \tfrac 12\Delta t} \; \Psi^{(n,0)}_j\) where \(j\) loops over all of the entries of our solution vector. This is what the function below does &ndash; in fact, it doesn't even use separate vectors for \(\Psi^{(n,0)}\) and \(\Psi^{(n,1)}\), but just updates the same vector as appropriate.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : solution)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> std::complex&lt;double&gt; i         = {0, 1};</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(value);</div><div class="line"></div><div class="line">      value = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-i * kappa * magnitude * magnitude * (time_step / 2)) *</div><div class="line">              value;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The next step is to solve for the linear system in each time step, i.e., the second half step of the Strang splitting we use. Recall that it had the form \(C\Psi^{(n,2)} = R\Psi^{(n,1)}\) where \(C\) and \(R\) are the matrices we assembled earlier.</p>
<p>The way we solve this here is using a direct solver. We first form the right hand side \(r=R\Psi^{(n,1)}\) using the <a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">SparseMatrix::vmult()</a> function and put the result into the <code>system_rhs</code> variable. We then call SparseDirectUMFPACK::solver() which takes as argument the matrix \(C\) and the right hand side vector and returns the solution in the same vector <code>system_rhs</code>. The final step is then to put the solution so computed back into the <code>solution</code> variable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step()</div><div class="line">{</div><div class="line">  rhs_matrix.vmult(system_rhs, solution);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">  direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">  solution = system_rhs;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Creatinggraphicaloutput"></a> </p><h4>Creating graphical output</h4>
<p>The last of the helper functions and classes we ought to discuss are the ones that create graphical output. The result of running the half and full steps for the local and spatial parts of the Strang splitting is that we have updated the <code>solution</code> vector \(\Psi^n\) to the correct value at the end of each time step. Its entries contain complex numbers for the solution at the nodes of the finite element mesh.</p>
<p>Complex numbers are not easily visualized. We can output their real and imaginary parts, i.e., the fields \(\text{Re}(\psi_h^{(n)}(\mathbf x))\) and \(\text{Im}(\psi_h^{(n)}(\mathbf x))\), and that is exactly what the <a class="el" href="classDataOut.html">DataOut</a> class does when one attaches as complex-valued vector via <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> and then calls <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>. That is indeed what we do below.</p>
<p>But oftentimes we are not particularly interested in real and imaginary parts of the solution vector, but instead in derived quantities such as the magnitude \(|\psi|\) and phase angle \(\text{arg}(\psi)\) of the solution. In the context of quantum systems such as here, the magnitude itself is not so interesting, but instead it is the "amplitude", \(|\psi|^2\) that is a physical property: it corresponds to the probability density of finding a particle in a particular place of state. The way to put computed quantities into output files for visualization &ndash; as used in numerous previous tutorial programs &ndash; is to use the facilities of the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> and derived classes. Specifically, both the amplitude of a complex number and its phase angles are scalar quantities, and so the <a class="el" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a> class is the right tool to base what we want to do on.</p>
<p>Consequently, what we do here is to implement two classes <code>ComplexAmplitude</code> and <code>ComplexPhase</code> that compute for each point at which <a class="el" href="classDataOut.html">DataOut</a> decides to generate output, the amplitudes \(|\psi_h|^2\) and phases \(\text{arg}(\psi_h)\) of the solution for visualization. There is a fair amount of boiler-plate code below, with the only interesting parts of the first of these two classes being how its <code>evaluate_vector_field()</code> function computes the <code>computed_quantities</code> object.</p>
<p>(There is also the rather awkward fact that the <a href="https://en.cppreference.com/w/cpp/numeric/complex/norm">std::norm()</a> function does not compute what one would naively imagine, namely \(|\psi|\), but returns \(|\psi|^2\) instead. It's certainly quite confusing to have a standard function mis-named in such a way...)</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>DataPostprocessors</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComplexAmplitude();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                       inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1));</div><div class="line">        computed_quantities[q](0) = <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm</a>(psi);</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>The second of these postprocessor classes computes the phase angle of the complex-valued solution at each point. In other words, if we represent \(\psi(\mathbf x,t)=r(\mathbf x,t) e^{i\varphi(\mathbf x,t)}\), then this class computes \(\varphi(\mathbf x,t)\). The function <a href="https://en.cppreference.com/w/cpp/numeric/complex/arg">std::arg</a> does this for us, and returns the angle as a real number between \(-\pi\) and \(+\pi\).</p>
<p>For reasons that we will explain in detail in the results section, we do not actually output this value at each location where output is generated. Rather, we take the maximum over all evaluation points of the phase and then fill each evaluation point's output field with this maximum &ndash; in essence, we output the phase angle as a piecewise constant field, where each cell has its own constant value. The reasons for this will become clear once you read through the discussion further down below.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ComplexPhase();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a>(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ComplexPhase&lt;dim&gt;::ComplexPhase()</div><div class="line">    : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_phase = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">               <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">        max_phase =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_phase,</div><div class="line">                   std::arg(</div><div class="line">                     std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                          inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1))));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;output : computed_quantities)</div><div class="line">      output(0) = max_phase;</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace DataPostprocessors</span></div></div><!-- fragment --><p>Having so implemented these post-processors, we create output as we always do. As in many other time-dependent tutorial programs, we attach flags to <a class="el" href="classDataOut.html">DataOut</a> that indicate the number of the time step and the current simulation time.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div><div class="line">  <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;Psi&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_magnitude);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_phase);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, timestep_number));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Runningthesimulation"></a> </p><h4>Running the simulation</h4>
<p>The remaining step is how we set up the overall logic for this program. It's really relatively simple: Set up the data structures; interpolate the initial conditions onto finite element space; then iterate over all time steps, and on each time step perform the three parts of the Strang splitting method. Every tenth time step, we generate graphical output. That's it.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line">    assemble_matrices();</div><div class="line"></div><div class="line">    time = 0;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), solution);</div><div class="line">    output_results();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div><div class="line">    <span class="keywordflow">for</span> (; time &lt;= end_time; time += time_step)</div><div class="line">      {</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        do_half_phase_step();</div><div class="line">        do_full_spatial_step();</div><div class="line">        do_half_phase_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div><div class="line">          output_results();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step58</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The main() function</h4>
<p>The rest is again boiler plate and exactly as in almost all of the previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step58;</div><div class="line"></div><div class="line">      NonlinearSchroedingerEquation&lt;2&gt; nse;</div><div class="line">      nse.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-58/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>运行该代码的结果是屏幕输出如下。```活动单元的数量：4096 自由度的数量：16641</p>
<p>时间步数1在t=0 时间步数2在t=0.00390625 时间步数3在t=0.0078125 时间步数4在t=0.0117188 [...] ```运行程序也会产生大量的输出文件，我们将在下面进行可视化。</p>
<p><a class="anchor" id="Visualizingthesolution"></a></p><h3>Visualizing the solution</h3>
<p>该程序的<code>output_results()</code>函数生成的输出文件由若干变量组成。解（分为实部和虚部）、振幅和相位。如果我们将这四个字段可视化，在经过几个时间步骤后（准确地说，在时间 \(t=0.242\) ，我们得到如下图像。</p>
<div class="twocolumn" style="width: 80%"> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.re.png" alt="t=0.242时溶液的实部" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.im.png" alt="t=0时溶液的虚部。242" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.magnitude.png" alt="t=0.242时解决方案的振幅" width="400"/>
</div>
 </div> <div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.phase.png" alt="t=0.242时解决方案的相位" width="400"/>
</div>
 </div> <div></div></div><div class="twocolumn" style="width: 80%"><div>虽然上面显示的解决方案的实部和虚部并不特别有趣（因为从物理角度来看，相位的全局偏移以及因此实部和虚部之间的平衡是没有意义的），但将解决方案的振幅 \(|\psi(\mathbf x,t)|^2\) 和相位 \(\text{arg}(\psi(\mathbf x,t))\) 可视化，特别是它们的演变，则要有趣得多。这就导致了如下的图片。</div></div><div class="twocolumn" style="width: 80%"><div>这里显示的相图显然有一些缺陷。</div></div><div class="twocolumn" style="width: 80%"><div><ul>
<li>首先，相位是一个 "循环量"，但色标对接近 \(-\pi\) 的值和接近 \(+\pi\) 的值使用的颜色根本不同。这是一个麻烦&ndash;我们需要的是一个 "循环色标"，对相位范围的两个极端使用相同的颜色。这样的颜色图存在，例如见<a href="https://nicoguaro.github.io/posts/cyclic_colormaps/">this blog post of Nicolás Guarín-Zapata</a>或<a href="https://stackoverflow.com/questions/23712207/cyclic-colormap-without-visual-distortions-for-use-in-phase-angle-plots">this StackExchange post</a>。问题是，笔者最喜欢的两个大的可视化软件包之一VisIt，并没有内置这些颜色图。无奈之下，我只好使用Paraview，因为它已经实现了上面帖子中提到的几种颜色地图。下图使用了<code>nic_Edge</code>地图，其中两个极端值都显示为黑色。</li>
<li>在相位缠绕的单元中存在一个问题。如果在单元格的某个评估点，相位值接近 \(-\pi\) ，而在另一个评估点，它接近 \(+\pi\) ，那么我们真正希望发生的是整个单元格的颜色接近极端值。但是，相反，可视化程序产生了一个线性插值，其中单元格内的值，即评估点之间的值，是在这两个值之间线性插值的，基本上涵盖了整个可能的相位值范围，因此，在一个单元格的过程中，从深红色到深绿色的整个彩虹色循环往复。解决这个问题的方法是将每个单元的相位值作为一个片断常数输出。因为对接近 \(-\pi\) 和 \(+\pi\) 的值进行平均，会产生一个与实际相位角无关的平均值，`ComplexPhase'类只是使用每个单元上遇到的*大相位角。</li>
</ul>
</div></div><div class="twocolumn" style="width: 80%"><div>经过这些修改，现在的相位图看起来如下。</div></div><div class="twocolumn" style="width: 80%"><div></div></div><div class="twocolumn" style="width: 80%"><div> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-58.phase-cyclic.png" alt="在t=0.242时解的相位，有一个循环的颜色图" width="400"/>
</div>
 </div></div><div class="twocolumn" style="width: 80%"><div></div></div><div class="twocolumn" style="width: 80%"><div>最后，我们可以从中生成一部电影。准确地说，这个视频又使用了两个全局细化周期，时间步长是上面程序中使用的一半）。这几行字的作者用VisIt制作了这部电影，因为这是他比较熟悉的，并使用了一个黑客的颜色地图，也是循环的&ndash;尽管这个颜色地图缺乏上面链接中提到的写帖子的人所使用的所有技巧。然而，如果你看一下半径为0.7的圆以外的域的阴影部分，其中电势为零，它确实显示了解决方案作为一个波浪方程的特征&ndash;你可以看到每次一个凸点（显示振幅 \(|\psi_h(\mathbf x,t)|^2\) ）撞到电势大的区域时：一个波从那里向外传播。看一下这个视频吧。</div></div><div class="twocolumn" style="width: 80%"><div> 
<p align="center">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/nraszP3GZHk"
   frameborder="0"
   allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
   allowfullscreen></iframe>
 </p>
</div></div><div class="twocolumn" style="width: 80%"><div>那么，为什么我最终会在势能 \(V(\mathbf x)\) 较大的区域进行遮蔽？在那个外部区域，解决方案是相对较小的。它也是相对平滑的。因此，在某种近似程度上，该区域的方程简化为</div></div><div class="twocolumn" style="width: 80%"><div> <p class="formulaDsp">
\[ - i \frac{\partial \psi}{\partial t} + V \psi \approx 0, \]
</p>
</div></div><div class="twocolumn" style="width: 80%"><div>或者说更容易阅读。</div></div><div class="twocolumn" style="width: 80%"><div> <p class="formulaDsp">
\[ \frac{\partial \psi}{\partial t} \approx - i V \psi. \]
</p>
</div></div><div class="twocolumn" style="width: 80%"><div>在这个近似值有效的程度上（除其他外，它消除了你在视频中可以看到的行波），这个方程有一个解</div></div><div class="twocolumn" style="width: 80%"><div> <p class="formulaDsp">
\[ \psi(\mathbf x, t) = \psi(\mathbf x, 0) e^{-i V t}. \]
</p>
</div></div><div class="twocolumn" style="width: 80%"><div>因为 \(V\) 很大，这意味着相位*旋转得相当快*。如果你把注意力集中在域的半透明的外部，你就可以看到这一点。如果用与域的内部相同的方式给这个区域上色，这个快速闪烁的外部部分可能是迷幻的，但也分散了内部发生的事情；也很难真正看到在视频开始时很容易看到的辐射波。</div></div><div class="twocolumn" style="width: 80%"><div><a class="anchor" id="extensions"></a></div></div><div class="twocolumn" style="width: 80%"><div><a class="anchor" id="Possibilitiesforextensions"></a><h3>Possibilities for extensions</h3>
</div></div><div class="twocolumn" style="width: 80%"><div></div></div><div class="twocolumn" style="width: 80%"><div><a class="anchor" id="Betterlinearsolvers"></a><h4>Better linear solvers </h4>
</div></div><div class="twocolumn" style="width: 80%"><div></div></div><div class="twocolumn" style="width: 80%"><div>这里选择的解算器实在是太简单了。它的效率也不高。我们在这里所做的是在每个时间步骤中把矩阵交给一个稀疏的直接求解器，让它找到线性系统的解。但我们知道，我们可以做得更好。</div></div><div class="twocolumn" style="width: 80%"><div><ul>
<li>首先，我们应该利用这样一个事实，即矩阵实际上并没有从时间步长到时间步长的变化。这是一个伪命题，因为我们在这里有恒定的边界值，而且我们不改变时间步长&ndash;这两个假设在实际应用中可能并不真实。但至少在这种情况下，只对矩阵进行一次因式分解（即计算一次 \(L\) 和 \(U\) 因子），然后在接下来的所有时间步骤中使用这些因子，直到矩阵 \(C\) 发生变化，需要进行新的因式分解。SparseDirectUMFPACK类的接口允许这样做。</li>
<li>然而，最终，稀疏直接求解器只对相对较小的问题有效，比如说最多几十万个未知数。除此之外，我们需要迭代求解器，如共轭梯度法（用于对称和正定问题）或GMRES。我们已经在其他教程程序中使用了许多这样的方法。在所有情况下，它们都需要伴随着良好的预处理程序。对于目前的情况，原则上可以使用GMRES&ndash;一种不需要矩阵的任何特定属性的方法&ndash;但最好实施一种迭代方案，利用我们知道的这个问题的一个结构特征：矩阵是复数对称的（尽管不是赫米特）。</li>
</ul>
</div></div><div class="twocolumn" style="width: 80%"><div><a class="anchor" id="Boundaryconditions"></a><h4>Boundary conditions </h4>
</div></div><div class="twocolumn" style="width: 80%"><div></div></div><div class="twocolumn" style="width: 80%"><div>为了能够用于实际的、现实的问题，非线性Schr&ouml;dinger方程的求解器需要利用对手头的问题有意义的边界条件。我们在这里将自己限制在简单的诺伊曼边界条件上&ndash;但这些条件实际上对问题没有意义。事实上，这些方程通常是在一个无限的域上提出的。但是，由于我们不能在无限域上进行计算，我们需要在某处截断它，而提出对这个人为的小域有意义的边界条件。广泛使用的方法是使用<a href="https://en.wikipedia.org/wiki/Perfectly_matched_layer">Perfectly Matched Layer</a>方法，它对应于一种特殊的衰减。在不同的背景下，它也用于步骤-62。</div></div><div class="twocolumn" style="width: 80%"><div><a class="anchor" id="Adaptivemeshes"></a><h4>Adaptive meshes </h4>
</div></div><div class="twocolumn" style="width: 80%"><div></div></div><div class="twocolumn" style="width: 80%"><div>最后，我们从经验和许多其他教程程序中知道，使用自适应细化网格是值得的，而不是这里使用的均匀网格。事实上，在这里增加这一点并不是很困难。<a class="el" href="step_26.html">step-26</a>将是一个很好的指南，说明如何实现这一点。</div></div><div class="twocolumn" style="width: 80%"><div><a class="anchor" id="PlainProg"></a> <h1>The plain program</h1>
</div></div><div class="twocolumn" style="width: 80%"><div> <div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University</span></div><div class="line"><span class="comment"> *         Yong-Yong Cai, Beijing Computational Science Research Center</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step58</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>NonlinearSchroedingerEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    NonlinearSchroedingerEquation();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_matrices();</div><div class="line">    <span class="keywordtype">void</span> do_half_phase_step();</div><div class="line">    <span class="keywordtype">void</span> do_full_spatial_step();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                    sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;std::complex&lt;double&gt;</a>&gt; rhs_matrix;</div><div class="line"></div><div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; solution;</div><div class="line">    Vector&lt;std::complex&lt;double&gt;&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> kappa;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>InitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim, <a class="code" href="namespacestd.html">std</a>::complex&lt;<a class="code" href="classdouble.html">double</a>&gt;&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::complex&lt;double&gt;</div><div class="line">    value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::complex&lt;double&gt;</div><div class="line">  InitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    static_assert(dim == 2, <span class="stringliteral">&quot;This initial condition only works in 2d.&quot;</span>);</div><div class="line"></div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt;&gt; vortex_centers = {{0, -0.3},</div><div class="line">                                                    {0, +0.3},</div><div class="line">                                                    {+0.3, 0},</div><div class="line">                                                    {-0.3, 0}};</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> R = 0.1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha =</div><div class="line">      1. / (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(R, dim) * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(numbers::PI, dim / 2.));</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> sum = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;vortex_center : vortex_centers)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> distance = p - vortex_center;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         r        = distance.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">        sum += alpha * <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(r * r) / (R * R));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> {<a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(sum), 0.};</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Potential : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Potential() = <span class="keywordflow">default</span>;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Potential&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0, <a class="code" href="group__Exceptions.html#ga0d685aad996180f9851183ae3e29019a">ExcIndexRange</a>(component, 0, 1));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>().distance(p) &gt; 0.7 ? 1000 : 0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  NonlinearSchroedingerEquation&lt;dim&gt;::NonlinearSchroedingerEquation()</div><div class="line">    : fe(2)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , time(0)</div><div class="line">    , time_step(1. / 128)</div><div class="line">    , timestep_number(0)</div><div class="line">    , kappa(1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(6);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    rhs_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::assemble_matrices()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_lhs(dofs_per_cell,</div><div class="line">                                                     dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; cell_matrix_rhs(dofs_per_cell,</div><div class="line">                                                     dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  potential_values(n_q_points);</div><div class="line">    <span class="keyword">const</span> Potential&lt;dim&gt;                 potential;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix_lhs = std::complex&lt;double&gt;(0.);</div><div class="line">        cell_matrix_rhs = std::complex&lt;double&gt;(0.);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        potential.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             potential_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> std::complex&lt;double&gt; i = {0, 1};</div><div class="line"></div><div class="line">                    cell_matrix_lhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                      (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                       time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) +</div><div class="line">                       time_step / 2 * potential_values[q_index] *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line"></div><div class="line">                    cell_matrix_rhs(k, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) +=</div><div class="line">                      (-i * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                       time_step / 4 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index) -</div><div class="line">                       time_step / 2 * potential_values[q_index] *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(k, q_index) *</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q_index)) *</div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix_lhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_matrix);</div><div class="line">        constraints.distribute_local_to_global(cell_matrix_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               rhs_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_half_phase_step()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;value : solution)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> std::complex&lt;double&gt; i         = {0, 1};</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>               magnitude = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(value);</div><div class="line"></div><div class="line">        value = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-i * kappa * magnitude * magnitude * (time_step / 2)) *</div><div class="line">                value;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::do_full_spatial_step()</div><div class="line">  {</div><div class="line">    rhs_matrix.vmult(system_rhs, solution);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> direct_solver;</div><div class="line">    direct_solver.<a class="code" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">    solution = system_rhs;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>DataPostprocessors</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ComplexAmplitude : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ComplexAmplitude();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">        std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ComplexAmplitude&lt;dim&gt;::ComplexAmplitude()</div><div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Amplitude&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ComplexAmplitude&lt;dim&gt;::evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> std::complex&lt;double&gt; psi(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                         inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1));</div><div class="line">          computed_quantities[q](0) = <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">std::norm</a>(psi);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ComplexPhase : <span class="keyword">public</span> <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ComplexPhase();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> evaluate_vector_field(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">        std::vector&lt;Vector&lt;double&gt;&gt; &amp;computed_quantities) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ComplexPhase&lt;dim&gt;::ComplexPhase()</div><div class="line">      : <a class="code" href="classDataPostprocessorScalar.html">DataPostprocessorScalar</a>&lt;dim&gt;(<span class="stringliteral">&quot;Phase&quot;</span>, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ComplexPhase&lt;dim&gt;::evaluate_vector_field(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector&lt;dim&gt;</a> &amp;inputs,</div><div class="line">      std::vector&lt;Vector&lt;double&gt;&gt; &amp;               computed_quantities)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities.size() == inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities.size(),</div><div class="line">                                  inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>.size()));</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> max_phase = -<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; computed_quantities.size(); ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(computed_quantities[q].size() == 1,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(computed_quantities[q].size(), 1));</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size() == 2,</div><div class="line">                 <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q].size(), 2));</div><div class="line"></div><div class="line">          max_phase =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_phase,</div><div class="line">                     std::arg(</div><div class="line">                       std::complex&lt;double&gt;(inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](0),</div><div class="line">                                            inputs.<a class="code" href="structDataPostprocessorInputs_1_1Vector.html#a8e034ae97f0447fb541bdb8ad0a4f599">solution_values</a>[q](1))));</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;output : computed_quantities)</div><div class="line">        output(0) = max_phase;</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace DataPostprocessors</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> NonlinearSchroedingerEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexAmplitude&lt;dim&gt; complex_magnitude;</div><div class="line">    <span class="keyword">const</span> DataPostprocessors::ComplexPhase&lt;dim&gt;     complex_phase;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;Psi&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_magnitude);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, complex_phase);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, timestep_number));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 3) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">NonlinearSchroedingerEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    setup_system();</div><div class="line">    assemble_matrices();</div><div class="line"></div><div class="line">    time = 0;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, InitialValues&lt;dim&gt;(), solution);</div><div class="line">    output_results();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time = 1;</div><div class="line">    <span class="keywordflow">for</span> (; time &lt;= end_time; time += time_step)</div><div class="line">      {</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Time step &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot; at t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        do_half_phase_step();</div><div class="line">        do_full_spatial_step();</div><div class="line">        do_half_phase_step();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 1 == 0)</div><div class="line">          output_results();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step58</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step58;</div><div class="line"></div><div class="line">      NonlinearSchroedingerEquation&lt;2&gt; nse;</div><div class="line">      nse.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div></div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
