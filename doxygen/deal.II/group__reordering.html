<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__reordering.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Grid reordering and cell orientation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Grid reordering and cell orientation<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A module describing how deal.II consistently orients <a class="el" href="classTriangulation.html">Triangulation</a> 对象。  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Grid reordering and cell orientation:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__reordering.svg" width="386" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<p>A module describing how deal.II consistently orients <a class="el" href="classTriangulation.html">Triangulation</a> 对象。 </p>
<p>A module describing how deal.II consistently orients <a class="el" href="classTriangulation.html">Triangulation</a> objects.</p>
<h3>Statement of problems</h3>
<p>在deal.II中的三角形有一个特殊的结构，即不仅有单元，而且有面，在三维中还有边，它们都是自己的对象。面和边都有独特的方向，而且它们相对于相邻的单元也有特定的方向。因此，在两个空间维度中分隔两个单元的线不仅有一个方向，而且相对于与第一条线相邻的两个四边形的其他线，它也必须有一个明确的方向。同样的定义也适用于三维单元和分隔它们的物体（线、四边形）。 例如，在二维空间中，一个四边形由四条线组成，这些线有一个方向，根据定义是这样的。 </p><pre class="fragment">* 2--&gt;--3
* |     |
* ^     ^
* |     |
* 0--&gt;--1
* </pre><p> 现在，两个相邻的单元格必须有一个顶点编号，使公边的方向相同。例如，以下两个四边形 </p><pre class="fragment">* 3---4---5
* |   |   |
* 0---1---2
* </pre><p> 可以用顶点编号&lt;tt&gt;(0 1 3 4)和<code>(1 2 4 5)</code>来描述，因为从两个单元格看，中间线会得到方向<code>1-&gt;4</code>。 编号&lt;tt&gt;(0 1 3 4)和<code>(5 4 2 1)</code>将是不允许的，因为左边的四边形会给公共线以<code>1-&gt;4</code>的方向，而右边的会想用<code>4-&gt;1</code>，导致歧义的产生。 作为附带说明，我们注意到，如果人们采纳了拥有面的方向是有用的这一观点，那么如上所示的一个单元的四个面的方向几乎是必要的。特别是，不可能使它们的方向代表（逆）时针的意义，因为那样的话，我们就不能为下面的三块细胞找到一个有效的方向。 </p><pre class="fragment">*     o
*   /   \
* o       o
* | \   / |
* |   o   |
* |   |   |
* o---o---o
* </pre><p> （读者需要尝试找到一个符合要求的线方向的选择；很快就会发现不可能存在这样的东西，即使我们允许可能存在同时具有顺时针和逆时针方向的线的单元。 有人可能会说，对面和边的唯一方向的定义，以及相对于它们所约束的单元格的方向的定义，是deal.II的一个错误特征。事实上，这使得阅读由网格生成器创建的网格变得相当困难，因为它们在生成输出时通常不会遵循这些惯例。另一方面，有很好的理由引入这些约定，因为它们在很多情况下可以使编程变得更简单，导致一些计算速度的提高，因为我们可以在很多地方避免昂贵的检查，因为面的方向是已知的，假设它是由三角法保证的。 本课的目的是为一组给定的单元格找到一个排序，使生成的三角形满足上述的所有要求。为此，我们将首先展示一些例子，说明为什么这是一个困难的问题，然后开发找到这种重新排序的算法。请注意，该算法是在一组CellData对象上操作的，这些对象是用来向三角剖分类描述一个网格的。例如，这些对象是由GridIn类在从输入文件读入网格时生成的。 作为第一节的最后一个问题：对于一个给定的领域细分为单元格，是否能保证面的这种方向总是存在？下面描述的2d的线性复杂度算法也证明了2d的答案是肯定的。对于3D，答案是否定的（这也强调了使用这种方向可能是一种</p>
<p>&ndash;不幸的是无法治愈的</p>
<ul>
<li><p class="startli">交易二的错误特征）。)一个简单的三维反例说明了这一点：取一串三维单元并将其弯曲成一个环形。由于单元中的对立线需要有相同的方向，所以对它们有一个简单的排序，例如所有的线都是径向向外，切向顺时针，和轴向向上的。然而，如果在连接细胞串的两端之前，将细胞串扭转180度，那么就不可能再有这样的方向，这一点可以很容易地检查出来。实际上，有些网格不能用于deal.II。为了克服这个问题，引入了 <code>face_rotation</code> 、 <code>face_flip</code> and <code>line_orientation</code> 标志。有了这些标志，就有可能处理所有的纯六面体网格。然而，为了减少可能的bug的影响，还是应该尝试对网格进行重新排序。只有当这个程序失败时，才应该使用原始的连接信息。</p>
<h3>Examples of problems</h3>
<p class="startli">如前所述，对单元格的顶点列表进行重新排序，从而得到的网格并不是一个微不足道的问题。特别是，只看一个单元格的邻域往往是不够的，它不能在不违反上述要求的情况下被添加到其他单元格的集合中。我们将展示两个例子，这一点很明显。 第一个这样的例子是下面的，我们将称之为 "最后的四个单元格"，因为这四个单元格靠近每一行三个垂直单元格的右端（在下面的图片中，我们只显示了左边的这样一列三个单元格，但是我们将指出如果我们延长这个列表会发生什么）。 </p><pre class="fragment">* 9---10-----11
* |   |    / |
* 6---7---8  |
* |   |   |  |
* 3---4---5  |
* |   |    \ |
* 0---1------2
* </pre><p> 假设你在左侧边界的单元格中对顶点进行了编号，从而诱导出以下线条方向。 </p><pre class="fragment">* 9-&gt;-10-----11
* ^   ^    / |
* 6-&gt;-7---8  |
* ^   ^   |  |
* 3-&gt;-4---5  |
* ^   ^    \ |
* 0-&gt;-1------2
* </pre><p> 例如，这可以通过使用索引<code>（0 1 3 4）</code>，<code>（3 4 6 7）</code>，<code>（6 7 9 10）</code>来完成。现在，你将找不到一种方法来给出正确的单元格的指数，而又不对某条线或其他线引入歧义，或者不违反每个单元格内必须有一个顶点，两条线都从这个顶点出发，而相邻的两条线都指向这个顶点。 在这种情况下，解决方案是对三个左边单元格中的一个重新编号，例如，通过对左上角单元格的编号<code>(9 6 10 7)</code>来恢复顶点7和10之间的线的意义。 </p><pre class="fragment">* 9-&gt;-10-----11
* v   v    / |
* 6-&gt;-7---8  |
* ^   ^   |  |
* 3-&gt;-4---5  |
* ^   ^    \ |
* 0-&gt;-1------2
* </pre></li>
</ul>
<p>这里的重点是：假设我们想把网格向左延长，像这样。 </p><pre class="fragment">* o---o---o---o---o------o
* |   |   |   |   |    / |
* o---o---o---o---o---o  |
* |   |   |   |   |   |  |
* o---o---o---o---o---o  |
* |   |   |   |   |    \ |
* o---o---o---o---o------o
* </pre><p> 然后我们会遇到和上面一样的问题，如果我们把左边的单元格统一排序，从而迫使我们把一个单元格（就是上面我们可以排序为<code>(9 6 7 10)</code>的那个单元格）的排序还原。然而，由于相反的线必须有相同的方向，这又会迫使我们旋转它左边的单元格，然后再旋转左边的单元格，如此反复，直到我们到达网格的左端。因此，这是一个我们必须追溯到第一列的三个单元的例子，以找到一个一致的排序，如果我们最初是均匀地排序。 作为第二个例子，请考虑下面这个简单的网格，其中单元格的编号顺序很重要。 </p><pre class="fragment">* 3-----2-----o-----o ... o-----7-----6
* |     |     |     |     |     |     |
* |  0  |  N  | N-1 | ... |  2  |  1  |
* |     |     |     |     |     |     |
* 0-----1-----o-----o ... o-----4-----5
* </pre><p> 我们在这里只指出了相关顶点的数字。假设用户通过顶点指数<code>0 1 3 2</code>和<code>6 7 5 4</code>给单元格0和1。那么，如果我们按照这个方向，为这两个单元格创建线条后的网格会是这样的。 </p><pre class="fragment">* 3--&gt;--2-----o-----o ... o-----7--&lt;--6
* |     |     |     |     |     |     |
* ^  0  ^  N  | N-1 | ... |  2  v  1  v
* |     |     |     |     |     |     |
* 0--&gt;--1-----o-----o ... o-----4--&lt;--5
* </pre><p> 现在，由于相反的线必须指向同一方向，我们只能将单元格2到N-1添加到单元格1，使所有垂直线都指向下方。然而，我们不能向任何方向添加单元格N，因为它将有两条不指向同一方向的相反线。我们必须旋转0号或1号单元格，以便能够添加所有其他单元格，从而满足交易.II三角形的要求。 这两个例子说明，如果我们在某个方向上添加了一定数量的单元格，而在添加下一个单元格时又不能不引入已经在另一个方向上添加的面，那么只旋转我们未能添加的单元格附近的单元格可能是不够的。可能有必要回到很远的地方，旋转很久以前就已经输入的单元。</p>
<h3>Solution</h3>
<p>从上面的例子可以看出，如果我们遇到一个不能被添加到已经输入的单元格中的单元格，我们通常不能指出哪个单元格是罪魁祸首，必须以不同的方向输入。此外，即使我们知道哪个单元格，也可能有大量的单元格不再适合于网格，我们也必须找到不同的方向（在上面的第二个例子中，如果我们旋转了单元格1，那么我们也必须旋转单元格1到N-1）。 解决这个问题的蛮力方法如下：如果单元格N不能被添加，那么就尝试旋转单元格N-1。如果我们不能再旋转单元格N-1，那么就尝试旋转单元格N-2，并尝试用单元格N-1的所有方向添加单元格N。以此类推。在算法上，我们可以用一个树状结构来表示，节点N有多少个子节点N+1的可能方向，就有多少个子节点（在两个空间维度上，有四个方向，每个单元可以由其四个顶点构建。例如，如果顶点指数是<code>(0 1 3 2)</code>，那么四个可能性是&lt;tt&gt;(0 1 3 2)，<code>(1 3 2 0)</code>，&lt;tt&gt;(3 2 0 1)，和<code>(2 0 1 3)</code>）。)当添加一个又一个单元格时，我们以深度优先（pre-order）的方式遍历这个树。当我们遇到从根（单元格0）到叶（最后一个单元格）的路径不允许时（也就是说，通过树的路径所编码的单元格的方向不能导致有效的三角形），我们必须追踪并尝试通过树的另一条路径。 当然，在实践中，我们并不是沿着每条路径走到最后一个节点，然后找出一条路径是否导致了有效的三角结构，而是使用一个归纳论证：如果对于所有先前添加的单元格，三角结构是有效的，那么我们可以通过检查进入当前单元格是否会引入任何具有非唯一方向的面，来找出一条穿过树的路径是否可以产生有效的三角结构；如果是这样，那么我们可以停止跟踪这一点以下的所有路径并立即追踪回去。 尽管如此，已经很明显的是，这棵树在两个空间维度上有 \(4^N\) 个叶子，因为每个 \(N\) 个单元可以在四个方向上添加。这些节点中的大部分可以被迅速丢弃，因为首先第一个单元格的方向是不相关的，其次如果我们添加的一个单元格的邻居已经被添加了，那么已经只剩下两个可能的方向了，所以我们要做的检查总数直到我们找到一个有效的方式，明显小于 \(4^N\) 。然而，该算法在时间上仍然是指数级的，在内存上是线性的（我们只需要以已经添加的单元格的方向堆栈的形式来存储当前路径的信息）。 事实上，上面的两个例子表明，指数估计并不是悲观的：我们确实要追踪到那里的一个最开始的单元格，以找到一个以一致方式添加所有单元格的方法。 这种令人沮丧的情况因以下事实而大为改善：我们有一种用于2D的替代算法，在运行时间上总是线性的（由德克萨斯大学TICAM的迈克尔-安德森在2003年发现并实现），而对于3D，我们可以找到一种算法，在实践中通常只在时间和内存上是大致线性的。我们将在下文中描述这些算法。完整的描述和理论分析见 <b>[AABB17]</b> 。</p>
<h3>The 2d linear complexity algorithm</h3>
<p>该算法使用了这样一个事实：一个单元格的相对面需要有相同的方向。所以你从一条任意的线开始，选择一个方向。那么对面的面的方向就已经固定了。然后去看我们已经固定的两个面对面的两个单元格：对它们来说，一个面已经固定了，所以我们也可以固定对面的面。继续这样做。最终，我们对一连串的单元格进行了这样的处理。然后从一个已经有两个固定面的单元格中抽取一个非固定面，再做一遍。 更详细地说，这个算法最好用一个例子来说明。我们考虑下面的网格。 </p><pre class="fragment">* 9------10-------11
* |      |        /|
* |      |       / |
* |      |      /  |
* 6------7-----8   |
* |      |     |   |
* |      |     |   |
* |      |     |   |
* 3------4-----5   |
* |      |      \  |
* |      |       \ |
* |      |        \|
* 0------1---------2
* </pre><p> 首先选择一个单元格（本例中为（0,1,3,4））。单元的一个侧面被任意地定向（3-&gt;4）。这个方向的选择然后在网格中传播，跨越边和元素。(0-&gt;1), (6-&gt;7)和(9-&gt;10)。这涉及到边跳和面跳，给出了一个以圆点显示的穿过网格的路径。 </p><pre class="fragment">* 9--&gt;--10-------11
* |  .  |        /|
* |  .  |       / |
* |  .  |      /  |
* 6--&gt;--7-----8   |
* |  .  |     |   |
* |  .  |     |   |
* |  .  |     |   |
* 3--&gt;--4-----5   |
* |  .  |      \  |
* |  X  |       \ |
* |  .  |        \|
* 0--&gt;--1---------2
* </pre><p> 然后对所选元素的其他面重复这一过程，对网格的更多面进行定向。 </p><pre class="fragment">* 9--&gt;--10-------11
* |     |        /|
* v.....v.......V |
* |     |      /. |
* 6--&gt;--7-----8 . |
* |     |     | . |
* |     |     | . |
* |     |     | . |
* 3--&gt;--4-----5 . |
* |     |      \. |
* ^..X..^.......^ |
* |     |        \|
* 0--&gt;--1---------2
* </pre><p> 一旦一个元素被完全定向，就不需要再考虑了。这些元素在图中用o来填充。然后我们转到下一个元素。 </p><pre class="fragment">* 9--&gt;--10-&gt;-----11
* | ooo |  .     /|
* v ooo v  .    V |
* | ooo |  .   /  |
* 6--&gt;--7--&gt;--8   |
* |     |  .  |   |
* |     |  .  |   |
* |     |  .  |   |
* 3--&gt;--4--&gt;--5   |
* | ooo |  .   \  |
* ^ ooo ^  X    ^ |
* | ooo |  .     \|
* 0--&gt;--1--&gt;------2
* </pre><p> 重复这样做可以得到 </p><pre class="fragment">* 9--&gt;--10-&gt;-----11
* | ooo | oooooo /|
* v ooo v ooooo V |
* | ooo | oooo /  |
* 6--&gt;--7--&gt;--8   |
* |     |     |   |
* ^.....^..X..^...^
* |     |     |   |
* 3--&gt;--4--&gt;--5   |
* | ooo | oooo \  |
* ^ ooo ^ ooooo ^ |
* | ooo | oooooo \|
* 0--&gt;--1--&gt;------2
* </pre><p> 而最终的导向网是 </p><pre class="fragment">* 9--&gt;--10-&gt;-----11
* |     |        /|
* v     v       V |
* |     |      /  |
* 6--&gt;--7--&gt;--8   |
* |     |     |   |
* ^     ^     ^   ^
* |     |     |   |
* 3--&gt;--4--&gt;--5   |
* |     |      \  |
* ^     ^       ^ |
* |     |        \|
* 0--&gt;--1--&gt;-------2
* </pre><p> 很明显，这个算法的运行时间是线性的，因为它对每个面只精确地接触一次。 刚才在二维情况下描述的算法在这个类中对二维和（通用形式）三维都有实现。三维情况下，使用片状而不是单元格串来工作。如果网格是可定向的，那么该算法能够在线性时间内完成其工作；如果它是不可定向的，那么它也会在线性时间内中止。 这两种算法在论文 "On orienting edges of unstructured two- and
  three-dimensional meshes "中描述，R. Agelek, M. Anderson, W. Bangerth, W. L. Barth, ACM Transactions on Mathematical Software, vol. 44, article 5, 2017。预印本可作为<a href="http://arxiv.org/abs/1512.02137">arxiv 1512.02137</a>使用。</p>
<h3>For the curious</h3>
<p>在实现上述算法之前（最初由Michael Anderson在2002年实现，由Wolfgang Bangerth在2016年根据 <b>[AABB17]</b> 中的工作重新实现），我们使用了一个最初由Wolfgang Bangerth在2000年实现的分支和切割算法。虽然它不再被使用，但这里是它的工作原理，以及为什么它不总是对大网格有效，因为它的运行时间在糟糕的情况下可能是指数级的。 第一个观察结果是，虽然有反例，但问题通常是局部的。例如，在上面提到的第二个例子中，如果我们对单元格进行了编号，使相邻的单元格具有相似的单元格号，那么需要的回溯量就会大大减少。因此，在算法的实施过程中，第一步是以Cuthill-McKee的方式对单元格进行重新编号：从邻居数量最少的单元格开始，给它分配单元格编号为0。然后找到这个单元格的所有邻居，再给它们分配连续的数字。然后找到它们尚未被编号的邻居，给它们编号，以此类推。从图形上看，这意味着找到连续远离初始单元的单元区，并以这种前行的方式为它们编号。这已经大大改善了问题的局部性，从而减少了必要的回溯量。 第二点是，我们可以使用一些方法来修剪树，这通常会导致所有单元的有效方向非常快。 第一个方法是基于这样的观察：如果我们不能插入一个编号为N的单元格，那么这可能不是由于单元格N-1造成的，除非N-1是N的直接邻居。原因很明显：单元格M的选择方向只能影响添加单元格N的可能性，如果它是一个直接邻居，或者如果有一连串的单元格在M之后被添加并且连接单元格M和N。反过来说，如果我们不能添加单元格N，那么就没有必要追踪到单元格N-1，但我们可以追踪到单元格索引最大且已经被添加的N的邻居。 不幸的是，如果不谨慎应用，这种方法可能无法产生一个有效的树的路径。考虑以下情况，最初是从BAMG程序自动生成的950个单元的网格中提取的（这个程序通常生成的网格是相当不平衡的，通常有许多</p>
<ul>
<li>有时是10个或更多</li>
<li>一个顶点的邻居，并且在最初的算法中暴露了一些问题；还要注意的是，这个例子是在2D中，我们现在有上面描述的更好的算法，但同样的观察也适用于3D）。) <pre class="fragment">* 13----------14----15
* | \         |     |
* |  \    4   |  5  |
* |   \       |     |
* |    12-----10----11
* |     |     |     |
* |     |     |  7  |
* |     |     |     |
* |  3  |     8-----9
* |     |     |     |
* |     |     |  6  |
* |     |     |     |
* 4-----5-----6-----7
* |     |     |     |
* |  2  |  1  |  0  |
* |     |     |     |
* 0-----1-----2-----3
* </pre> 请注意，中间有一个洞。现在假设用户用顶点数字<code>2 3 6 7</code>来描述第一个单元格0，用<code>15 14 11 10</code>来描述单元格5，并假设单元格1、2、3、4的编号是可以在初始旋转中加入5。所有其他的单元格都以通常的方式进行编号，即从左下角开始，逆时针计数。鉴于对单元格的这种描述，算法将从零单元格开始，一个接一个地添加单元格，直到第六个。然后情况会是这样的。 <pre class="fragment">* 13-----&gt;---14--&lt;--15
* | \         |     |
* |  &gt;    4   v  5  v
* |   \       |     |
* |    12-&gt;--10--&lt;--11
* |     |     |     |
* ^     |     |  7  |
* |     |     |     |
* |  3  ^     8--&gt;--9
* |     |     |     |
* |     |     ^  6  ^
* |     |     |     |
* 4--&gt;--5--&gt;--6--&gt;--7
* |     |     |     |
* ^  2  ^  1  ^  0  ^
* |     |     |     |
* 0--&gt;--1--&gt;--2--&gt;--3
* </pre> 现在来看看第7个单元格，我们看到它的顶部和底部的两条相对的线有不同的方向；因此，我们将发现没有任何方向的第7个单元格可以在不违反三角形的一致性的情况下被添加。根据上述规则，我们回到索引最大的邻居，也就是单元格6，但由于它的底线是向右的，它的顶线也一定是向右的，所以我们无法找到单元格6的方向，从而使7符合三角形。然后，如果我们已经完成了单元格6的所有可能的方向，我们再追踪到6的最大索引的邻居，并且已经被添加了。然而，我们知道0号单元格的方向不可能是重要的，所以我们得出结论，没有任何可能的方法来确定给定单元格的所有线条的方向，使它们满足deal.II三角形的要求。我们知道这是不可能的，所以会导致抛出一个异常。 这个例子的底线是，当我们看了所有可能的单元格6的方向时，我们找不到一个可以添加单元格7的方向，然后决定追踪回单元格0，我们甚至没有尝试转动单元格5，之后添加单元格7就很简单了。因此，必须修改上述算法：如果我们未能在任何方向上添加一个单元格，我们只允许追踪回已经添加的那个邻居，其单元格索引最大。如果我们进一步追踪，因为我们已经用尽了所有可能的方向，但可以添加细胞（即我们追踪，因为另一个细胞，更远的地方不能添加，不管我们现在考虑的细胞的方向），那么我们不允许追踪到它的一个邻居，但必须只追踪一个细胞指数。 第二种修剪树的方法是，通常我们不能添加一个新的单元，因为它的一个已经被添加的邻居的方向是错误的。因此，如果我们可以尝试旋转其中一个邻居（当然要确保旋转该邻居不违反三角形的一致性），以允许现在的单元被添加。 第一种方法可以解释为在方向树上一次回溯不止一步，而转动一个邻居则意味着跳到树上一个完全不同的地方。对于这两种方法，人们可以找到论据，认为它们永远不会错过有效的路径，反正只跳过无效的路径。 这两种方法已经被证明是非常有效的。我们已经能够读取非常大的网格（几万个单元）而不需要回溯很多。特别是，我们发现找到单元格排序的时间与单元格的数量呈线性关系，而且重新排序的时间通常比从文件中读取数据所需的时间小得多（例如一个数量级），同时也比使用 <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation()</a> 函数从这些数据中实际生成三角图所需的时间小。</li>
</ul>
<h3>Statement of problems</h3>
<p>Triangulations in deal.II have a special structure, in that there are not only cells, but also faces, and in 3d also edges, that are objects of their own right. Faces and edges have unique orientations, and they have a specified orientation also with respect to the cells that are adjacent. Thus, a line that separates two cells in two space dimensions does not only have a direction, but it must also have a well-defined orientation with respect to the other lines bounding the two quadrilaterals adjacent to the first line. Likewise definitions hold for three dimensional cells and the objects (lines, quads) that separate them.</p>
<p>For example, in two dimensions, a quad consists of four lines which have a direction, which is by definition as follows: </p><pre class="fragment">*   2--&gt;--3
*   |     |
*   ^     ^
*   |     |
*   0--&gt;--1
* </pre><p> Now, two adjacent cells must have a vertex numbering such that the direction of the common side is the same. For example, the following two quads </p><pre class="fragment">*   3---4---5
*   |   |   |
*   0---1---2
* </pre><p> may be characterised by the vertex numbers <code>(0 1 3 4)</code> and <code>(1 2 4 5)</code>, since the middle line would get the direction <code>1-&gt;4</code> when viewed from both cells. The numbering <code>(0 1 3 4)</code> and <code>(5 4 2 1)</code> would not be allowed, since the left quad would give the common line the direction <code>1-&gt;4</code>, while the right one would want to use <code>4-&gt;1</code>, leading to an ambiguity.</p>
<p>As a sidenote, we remark that if one adopts the idea that having directions of faces is useful, then the orientation of the four faces of a cell as shown above is almost necessary. In particular, it is not possible to orient them such that they represent a (counter-)clockwise sense, since then we couldn't already find a valid orientation of the following patch of three cells: </p><pre class="fragment">*       o
*     /   \
*   o       o
*   | \   / |
*   |   o   |
*   |   |   |
*   o---o---o
* </pre><p> (The reader is asked to try to find a conforming choice of line directions; it will soon be obvious that there can't exists such a thing, even if we allow that there might be cells with clockwise and counterclockwise orientation of the lines at the same time.)</p>
<p>One might argue that the definition of unique directions for faces and edges, and the definition of directions relative to the cells they bound, is a misfeature of deal.II. In fact, it makes reading in grids created by mesh generators rather difficult, as they usually don't follow these conventions when generating their output. On the other hand, there are good reasons to introduce such conventions, as they can make programming much simpler in many cases, leading to an increase in speed of some computations as one can avoid expensive checks in many places because the orientation of faces is known by assumption that it is guaranteed by the triangulation.</p>
<p>The purpose of this class is now to find an ordering for a given set of cells such that the generated triangulation satisfies all the requirements stated above. To this end, we will first show some examples why this is a difficult problem, and then develop algorithms that finds such a reordering. Note that the algorithm operates on a set of <a class="el" href="structCellData.html">CellData</a> objects that are used to describe a mesh to the triangulation class. These objects are, for example, generated by the <a class="el" href="classGridIn.html">GridIn</a> class, when reading in grids from input files.</p>
<p>As a last question for this first section: is it guaranteed that such orientations of faces always exist for a given subdivision of a domain into cells? The linear complexity algorithm described below for 2d also proves that the answer is yes for 2d. For 3d, the answer is no (which also underlines that using such orientations might be an &ndash; unfortunately uncurable &ndash; misfeature of deal.II). A simple counter-example in 3d illustrates this: take a string of 3d cells and bend it together to a torus. Since opposing lines in a cell need to have the same direction, there is a simple ordering for them, for example all lines radially outward, tangentially clockwise, and axially upward. However, if before joining the two ends of the string of cells, the string is twisted by 180 degrees, then no such orientation is possible any more, as can easily be checked. In effect, some meshes could not be used in deal.II. In order to overcome this problem, the <code>face_rotation</code>, <code>face_flip</code> and <code>line_orientation</code> flags have been introduced. With these, it is possible to treat all purely hexahedral meshes. However, in order to reduce the effect of possible bugs, it should still be tried to reorder a grid. Only if this procedure fails, the original connectivity information should be used.</p>
<h3>Examples of problems</h3>
<p>As noted, reordering the vertex lists of cells such that the resulting grid is not a trivial problem. In particular, it is often not sufficient to only look at the neighborhood of a cell that cannot be added to a set of other cells without violating the requirements stated above. We will show two examples where this is obvious.</p>
<p>The first such example is the following, which we will call the ``four cells at the end'' because of the four cells that close of the right end of a row of three vertical cells each (in the following picture we only show one such column of three cells at the left, but we will indicate what happens if we prolong this list): </p><pre class="fragment">*   9---10-----11
*   |   |    / |
*   6---7---8  |
*   |   |   |  |
*   3---4---5  |
*   |   |    \ |
*   0---1------2
* </pre><p> Assume that you had numbered the vertices in the cells at the left boundary in a way, that the following line directions are induced: </p><pre class="fragment">*   9-&gt;-10-----11
*   ^   ^    / |
*   6-&gt;-7---8  |
*   ^   ^   |  |
*   3-&gt;-4---5  |
*   ^   ^    \ |
*   0-&gt;-1------2
* </pre><p> (This could for example be done by using the indices <code>(0 1 3 4)</code>, <code>(3 4 6 7)</code>, <code>(6 7 9 10)</code> for the three cells). Now, you will not find a way of giving indices for the right cells, without introducing either ambiguity for one line or other, or without violating that within each cells, there must be one vertex from which both lines are directed away and the opposite one to which both adjacent lines point to.</p>
<p>The solution in this case is to renumber one of the three left cells, e.g. by reverting the sense of the line between vertices 7 and 10 by numbering the top left cell by <code>(9 6 10 7)</code>: </p><pre class="fragment">*   9-&gt;-10-----11
*   v   v    / |
*   6-&gt;-7---8  |
*   ^   ^   |  |
*   3-&gt;-4---5  |
*   ^   ^    \ |
*   0-&gt;-1------2
* </pre><p>The point here is the following: assume we wanted to prolong the grid to the left like this: </p><pre class="fragment">*   o---o---o---o---o------o
*   |   |   |   |   |    / |
*   o---o---o---o---o---o  |
*   |   |   |   |   |   |  |
*   o---o---o---o---o---o  |
*   |   |   |   |   |    \ |
*   o---o---o---o---o------o
* </pre><p> Then we run into the same problem as above if we order the cells at the left uniformly, thus forcing us to revert the ordering of one cell (the one which we could order as <code>(9 6 7 10)</code> above). However, since opposite lines have to have the same direction, this in turn would force us to rotate the cell left of it, and then the one left to that, and so on until we reach the left end of the grid. This is therefore an example we have to track back right until the first column of three cells to find a consistent ordering, if we had initially ordered them uniformly.</p>
<p>As a second example, consider the following simple grid, where the order in which the cells are numbered is important: </p><pre class="fragment">*   3-----2-----o-----o ... o-----7-----6
*   |     |     |     |     |     |     |
*   |  0  |  N  | N-1 | ... |  2  |  1  |
*   |     |     |     |     |     |     |
*   0-----1-----o-----o ... o-----4-----5
* </pre><p> We have here only indicated the numbers of the vertices that are relevant. Assume that the user had given the cells 0 and 1 by the vertex indices <code>0 1 3 2</code> and <code>6 7 5 4</code>. Then, if we follow this orientation, the grid after creating the lines for these two cells would look like this: </p><pre class="fragment">*   3--&gt;--2-----o-----o ... o-----7--&lt;--6
*   |     |     |     |     |     |     |
*   ^  0  ^  N  | N-1 | ... |  2  v  1  v
*   |     |     |     |     |     |     |
*   0--&gt;--1-----o-----o ... o-----4--&lt;--5
* </pre><p> Now, since opposite lines must point in the same direction, we can only add the cells 2 through N-1 to cells 1 such that all vertical lines point down. Then, however, we cannot add cell N in any direction, as it would have two opposite lines that do not point in the same direction. We would have to rotate either cell 0 or 1 in order to be able to add all the other cells such that the requirements of deal.II triangulations are met.</p>
<p>These two examples demonstrate that if we have added a certain number of cells in some orientation of faces and can't add the next one without introducing faces that had already been added in another direction, then it might not be sufficient to only rotate cells in the neighborhood of the cell that we failed to add. It might be necessary to go back a long way and rotate cells that have been entered long ago.</p>
<h3>Solution</h3>
<p>From the examples above, it is obvious that if we encounter a cell that cannot be added to the cells which have already been entered, we can not usually point to a cell that is the culprit and that must be entered in a different orientation. Furthermore, even if we knew which cell, there might be large number of cells that would then cease to fit into the grid and which we would have to find a different orientation as well (in the second example above, if we rotated cell 1, then we would have to rotate the cells 1 through N-1 as well).</p>
<p>A brute force approach to this problem is the following: if cell N can't be added, then try to rotate cell N-1. If we can't rotate cell N-1 any more, then try to rotate cell N-2 and try to add cell N with all orientations of cell N-1. And so on. Algorithmically, we can visualize this by a tree structure, where node N has as many children as there are possible orientations of node N+1 (in two space dimensions, there are four orientations in which each cell can be constructed from its four vertices; for example, if the vertex indices are <code>(0 1 3 2)</code>, then the four possibilities would be <code>(0 1 3 2)</code>, <code>(1 3 2 0)</code>, <code>(3 2 0 1)</code>, and <code>(2 0 1 3)</code>). When adding one cell after the other, we traverse this tree in a depth-first (pre-order) fashion. When we encounter that one path from the root (cell 0) to a leaf (the last cell) is not allowed (i.e. that the orientations of the cells which are encoded in the path through the tree does not lead to a valid triangulation), we have to track back and try another path through the tree.</p>
<p>In practice, of course, we do not follow each path to a final node and then find out whether a path leads to a valid triangulation, but rather use an inductive argument: if for all previously added cells the triangulation is a valid one, then we can find out whether a path through the tree can yield a valid triangulation by checking whether entering the present cell would introduce any faces that have a nonunique direction; if that is so, then we can stop following all paths below this point and track back immediately.</p>
<p>Nevertheless, it is already obvious that the tree has \(4^N\) leaves in two space dimensions, since each of the \(N\) cells can be added in four orientations. Most of these nodes can be discarded rapidly, since firstly the orientation of the first cell is irrelevant, and secondly if we add one cell that has a neighbor that has already been added, then there are already only two possible orientations left, so the total number of checks we have to make until we find a valid way is significantly smaller than \(4^N\). However, the algorithm is still exponential in time and linear in memory (we only have to store the information for the present path in form of a stack of orientations of cells that have already been added).</p>
<p>In fact, the two examples above show that the exponential estimate is not a pessimistic one: we indeed have to track back to one of the very first cells there to find a way to add all cells in a consistent fashion.</p>
<p>This discouraging situation is greatly improved by the fact that we have an alternative algorithm for 2d that is always linear in runtime (discovered and implemented by Michael Anderson of TICAM, University of Texas, in 2003), and that for 3d we can find an algorithm that in practice is usually only roughly linear in time and memory. We will describe these algorithms in the following. A full description and theoretical analysis is given in <b>[AABB17]</b> .</p>
<h3>The 2d linear complexity algorithm</h3>
<p>The algorithm uses the fact that opposite faces of a cell need to have the same orientation. So you start with one arbitrary line, choose an orientation. Then the orientation of the opposite face is already fixed. Then go to the two cells across the two faces we have fixed: for them, one face is fixed, so we can also fix the opposite face. Go on with doing so. Eventually, we have done this for a string of cells. Then take one of the non-fixed faces of a cell which has already two fixed faces and do all this again.</p>
<p>In more detail, the algorithm is best illustrated using an example. We consider the mesh below: </p><pre class="fragment">*   9------10-------11
*   |      |        /|
*   |      |       / |
*   |      |      /  |
*   6------7-----8   |
*   |      |     |   |
*   |      |     |   |
*   |      |     |   |
*   3------4-----5   |
*   |      |      \  |
*   |      |       \ |
*   |      |        \|
*   0------1---------2
* </pre><p> First a cell is chosen ( (0,1,3,4) in this case). A single side of the cell is oriented arbitrarily (3-&gt;4). This choice of orientation is then propagated through the mesh, across sides and elements. (0-&gt;1), (6-&gt;7) and (9-&gt;10). The involves edge-hopping and face hopping, giving a path through the mesh shown in dots. </p><pre class="fragment">*   9--&gt;--10-------11
*   |  .  |        /|
*   |  .  |       / |
*   |  .  |      /  |
*   6--&gt;--7-----8   |
*   |  .  |     |   |
*   |  .  |     |   |
*   |  .  |     |   |
*   3--&gt;--4-----5   |
*   |  .  |      \  |
*   |  X  |       \ |
*   |  .  |        \|
*   0--&gt;--1---------2
* </pre><p> This is then repeated for the other sides of the chosen element, orienting more sides of the mesh. </p><pre class="fragment">*   9--&gt;--10-------11
*   |     |        /|
*   v.....v.......V |
*   |     |      /. |
*   6--&gt;--7-----8 . |
*   |     |     | . |
*   |     |     | . |
*   |     |     | . |
*   3--&gt;--4-----5 . |
*   |     |      \. |
*   ^..X..^.......^ |
*   |     |        \|
*   0--&gt;--1---------2
* </pre><p> Once an element has been completely oriented it need not be considered further. These elements are filled with o's in the diagrams. We then move to the next element. </p><pre class="fragment">*   9--&gt;--10-&gt;-----11
*   | ooo |  .     /|
*   v ooo v  .    V |
*   | ooo |  .   /  |
*   6--&gt;--7--&gt;--8   |
*   |     |  .  |   |
*   |     |  .  |   |
*   |     |  .  |   |
*   3--&gt;--4--&gt;--5   |
*   | ooo |  .   \  |
*   ^ ooo ^  X    ^ |
*   | ooo |  .     \|
*   0--&gt;--1--&gt;------2
* </pre><p> Repeating this gives </p><pre class="fragment">*   9--&gt;--10-&gt;-----11
*   | ooo | oooooo /|
*   v ooo v ooooo V |
*   | ooo | oooo /  |
*   6--&gt;--7--&gt;--8   |
*   |     |     |   |
*   ^.....^..X..^...^
*   |     |     |   |
*   3--&gt;--4--&gt;--5   |
*   | ooo | oooo \  |
*   ^ ooo ^ ooooo ^ |
*   | ooo | oooooo \|
*   0--&gt;--1--&gt;------2
* </pre><p> and the final oriented mesh is </p><pre class="fragment">*   9--&gt;--10-&gt;-----11
*   |     |        /|
*   v     v       V |
*   |     |      /  |
*   6--&gt;--7--&gt;--8   |
*   |     |     |   |
*   ^     ^     ^   ^
*   |     |     |   |
*   3--&gt;--4--&gt;--5   |
*   |     |      \  |
*   ^     ^       ^ |
*   |     |        \|
*   0--&gt;--1--&gt;-------2
* </pre><p> It is obvious that this algorithm has linear run-time, since it only ever touches each face exactly once.</p>
<p>The algorithm just described in the two-dimensional case is implemented for both 2d and (in generalized form) for 3d in this class. The 3d case uses sheets instead of strings of cells to work on. If a grid is orientable, then the algorithm is able to do its work in linear time; if it is not orientable, then it aborts in linear time as well.</p>
<p>Both algorithms are described in the paper "On orienting edges of
  unstructured two- and three-dimensional meshes", R. Agelek, M. Anderson, W. Bangerth, W. L. Barth, ACM Transactions on Mathematical Software, vol. 44, article 5, 2017. A preprint is available as <a href="http://arxiv.org/abs/1512.02137">arxiv 1512.02137</a>.</p>
<h3>For the curious</h3>
<p>Prior to the implementation of the algorithms described above (originally implemented by Michael Anderson in 2002, and re-implemented by Wolfgang Bangerth in 2016 based on the work in <b>[AABB17]</b>), we used a branch-and-cut algorithm initially implemented in 2000 by Wolfgang Bangerth. Although it is no longer used, here is how it works, and why it doesn't always work for large meshes since its run-time can be exponential in bad cases.</p>
<p>The first observation is that although there are counterexamples, problems are usually local. For example, in the second example mentioned above, if we had numbered the cells in a way that neighboring cells have similar cell numbers, then the amount of backtracking needed is greatly reduced. Therefore, in the implementation of the algorithm, the first step is to renumber the cells in a Cuthill-McKee fashion: start with the cell with the least number of neighbors and assign to it the cell number zero. Then find all neighbors of this cell and assign to them consecutive further numbers. Then find their neighbors that have not yet been numbered and assign to them numbers, and so on. Graphically, this represents finding zones of cells consecutively further away from the initial cells and number them in this front-marching way. This already greatly improves locality of problems and consequently reduced the necessary amount of backtracking.</p>
<p>The second point is that we can use some methods to prune the tree, which usually lead to a valid orientation of all cells very quickly.</p>
<p>The first such method is based on the observation that if we fail to insert one cell with number N, then this may not be due to cell N-1 unless N-1 is a direct neighbor of N. The reason is obvious: the chosen orientation of cell M could only affect the possibilities to add cell N if either it were a direct neighbor or if there were a sequence of cells that were added after M and that connected cells M and N. Clearly, for M=N-1, the latter cannot be the case. Conversely, if we fail to add cell N, then it is not necessary to track back to cell N-1, but we can track back to the neighbor of N with the largest cell index and which has already been added.</p>
<p>Unfortunately, this method can fail to yield a valid path through the tree if not applied with care. Consider the following situation, initially extracted from a mesh of 950 cells generated automatically by the program BAMG (this program usually generates meshes that are quite badly balanced, often have many &ndash; sometimes 10 or more &ndash; neighbors of one vertex, and exposed several problems in the initial algorithm; note also that the example is in 2d where we now have the much better algorithm described above, but the same observations also apply to 3d): </p><pre class="fragment">* 13----------14----15
* | \         |     |
* |  \    4   |  5  |
* |   \       |     |
* |    12-----10----11
* |     |     |     |
* |     |     |  7  |
* |     |     |     |
* |  3  |     8-----9
* |     |     |     |
* |     |     |  6  |
* |     |     |     |
* 4-----5-----6-----7
* |     |     |     |
* |  2  |  1  |  0  |
* |     |     |     |
* 0-----1-----2-----3
* </pre><p> Note that there is a hole in the middle. Assume now that the user described the first cell 0 by the vertex numbers <code>2 3 6 7</code>, and cell 5 by <code>15 14 11 10</code>, and assume that cells 1, 2, 3, and 4 are numbered such that 5 can be added in initial rotation. All other cells are numbered in the usual way, i.e. starting at the bottom left and counting counterclockwise. Given this description of cells, the algorithm will start with cell zero and add one cell after the other, up until the sixth one. Then the situation will be the following: </p><pre class="fragment">* 13-----&gt;---14--&lt;--15
* | \         |     |
* |  &gt;    4   v  5  v
* |   \       |     |
* |    12-&gt;--10--&lt;--11
* |     |     |     |
* ^     |     |  7  |
* |     |     |     |
* |  3  ^     8--&gt;--9
* |     |     |     |
* |     |     ^  6  ^
* |     |     |     |
* 4--&gt;--5--&gt;--6--&gt;--7
* |     |     |     |
* ^  2  ^  1  ^  0  ^
* |     |     |     |
* 0--&gt;--1--&gt;--2--&gt;--3
* </pre><p> Coming now to cell 7, we see that the two opposite lines at its top and bottom have different directions; we will therefore find no orientation of cell 7 in which it can be added without violation of the consistency of the triangulation. According to the rule stated above, we track back to the neighbor with greatest index, which is cell 6, but since its bottom line is to the right, its top line must be to the right as well, so we won't be able to find an orientation of cell 6 such that 7 will fit into the triangulation. Then, if we have finished all possible orientations of cell 6, we track back to the neighbor of 6 with the largest index and which has been added already. This would be cell 0. However, we know that the orientation of cell 0 can't be important, so we conclude that there is no possible way to orient all the lines of the given cells such that they satisfy the requirements of deal.II triangulations. We know that this can't be, so it results in an exception be thrown.</p>
<p>The bottom line of this example is that when we looked at all possible orientations of cell 6, we couldn't find one such that cell 7 could be added, and then decided to track back to cell 0. We did not even attempt to turn cell 5, after which it would be simple to add cell 7. Thus, the algorithm described above has to be modified: we are only allowed to track back to that neighbor that has already been added, with the largest cell index, if we fail to add a cell in any orientation. If we track back further because we have exhausted all possible orientations but could add the cell (i.e. we track back since another cell, further down the road couldn't be added, irrespective of the orientation of the cell which we are presently considering), then we are not allowed to track back to one of its neighbors, but have to track back only one cell index.</p>
<p>The second method to prune the tree is that usually we cannot add a new cell since the orientation of one of its neighbors that have already been added is wrong. Thus, if we may try to rotate one of the neighbors (of course making sure that rotating that neighbor does not violate the consistency of the triangulation) in order to allow the present cell to be added.</p>
<p>While the first method could be explained in terms of backtracking in the tree of orientations more than one step at once, turning a neighbor means jumping to a totally different place in the tree. For both methods, one can find arguments that they will never miss a path that is valid and only skip paths that are invalid anyway.</p>
<p>These two methods have proven extremely efficient. We have been able to read very large grids (several ten thousands of cells) without the need to track back much. In particular, the time to find an ordering of the cells was found to be mostly linear in the number of cells, and the time to reorder them is usually much smaller (for example by one order of magnitude) than the time needed to read the data from a file, and also to actually generate the triangulation from this data using the <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation()</a> function.</p>
<h3>Statement of problems</h3>
<p>Triangulations in deal.II have a special structure, in that there are not only cells, but also faces, and in 3d also edges, that are objects of their own right. Faces and edges have unique orientations, and they have a specified orientation also with respect to the cells that are adjacent. Thus, a line that separates two cells in two space dimensions does not only have a direction, but it must also have a well-defined orientation with respect to the other lines bounding the two quadrilaterals adjacent to the first line. Likewise definitions hold for three dimensional cells and the objects (lines, quads) that separate them. For example, in two dimensions, a quad consists of four lines which have a direction, which is by definition as follows:</p>
<pre class="fragment">* 2--&gt;--3
* |     |
* ^     ^
* |     |
* 0--&gt;--1
* </pre><p> Now, two adjacent cells must have a vertex numbering such that the direction of the common side is the same. For example, the following two quads</p>
<pre class="fragment">* 3---4---5
* |   |   |
* 0---1---2
* </pre><p> may be characterised by the vertex numbers <code>(0 1 3 4)</code> and <code>(1 2 4 5)</code>, since the middle line would get the direction <code>1-&gt;4</code> when viewed from both cells. The numbering <code>(0 1 3 4)</code> and <code>(5 4 2 1)</code> would not be allowed, since the left quad would give the common line the direction <code>1-&gt;4</code>, while the right one would want to use <code>4-&gt;1</code>, leading to an ambiguity. As a sidenote, we remark that if one adopts the idea that having directions of faces is useful, then the orientation of the four faces of a cell as shown above is almost necessary. In particular, it is not possible to orient them such that they represent a (counter-)clockwise sense, since then we couldn't already find a valid orientation of the following patch of three cells:</p>
<pre class="fragment">*     o
*   /   \
* o       o
* | \   / |
* |   o   |
* |   |   |
* o---o---o
* </pre><p> (The reader is asked to try to find a conforming choice of line directions; it will soon be obvious that there can't exists such a thing, even if we allow that there might be cells with clockwise and counterclockwise orientation of the lines at the same time.) One might argue that the definition of unique directions for faces and edges, and the definition of directions relative to the cells they bound, is a misfeature of deal.II. In fact, it makes reading in grids created by mesh generators rather difficult, as they usually don't follow these conventions when generating their output. On the other hand, there are good reasons to introduce such conventions, as they can make programming much simpler in many cases, leading to an increase in speed of some computations as one can avoid expensive checks in many places because the orientation of faces is known by assumption that it is guaranteed by the triangulation. The purpose of this class is now to find an ordering for a given set of cells such that the generated triangulation satisfies all the requirements stated above. To this end, we will first show some examples why this is a difficult problem, and then develop algorithms that finds such a reordering. Note that the algorithm operates on a set of <a class="el" href="structCellData.html">CellData</a> objects that are used to describe a mesh to the triangulation class. These objects are, for example, generated by the <a class="el" href="classGridIn.html">GridIn</a> class, when reading in grids from input files. As a last question for this first section: is it guaranteed that such orientations of faces always exist for a given subdivision of a domain into cells? The linear complexity algorithm described below for 2d also proves that the answer is yes for 2d. For 3d, the answer is no (which also underlines that using such orientations might be an</p>
<ul>
<li>unfortunately uncurable</li>
<li>misfeature of deal.II). A simple counter-example in 3d illustrates this: take a string of 3d cells and bend it together to a torus. Since opposing lines in a cell need to have the same direction, there is a simple ordering for them, for example all lines radially outward, tangentially clockwise, and axially upward. However, if before joining the two ends of the string of cells, the string is twisted by 180 degrees, then no such orientation is possible any more, as can easily be checked. In effect, some meshes could not be used in deal.II. In order to overcome this problem, the <code>face_rotation</code> , <code>face_flip</code> and <code>line_orientation</code> flags have been introduced. With these, it is possible to treat all purely hexahedral meshes. However, in order to reduce the effect of possible bugs, it should still be tried to reorder a grid. Only if this procedure fails, the original connectivity information should be used.</li>
</ul>
<h3>Examples of problems</h3>
<p>As noted, reordering the vertex lists of cells such that the resulting grid is not a trivial problem. In particular, it is often not sufficient to only look at the neighborhood of a cell that cannot be added to a set of other cells without violating the requirements stated above. We will show two examples where this is obvious. The first such example is the following, which we will call the ``four cells at the end'' because of the four cells that close of the right end of a row of three vertical cells each (in the following picture we only show one such column of three cells at the left, but we will indicate what happens if we prolong this list):</p>
<pre class="fragment">* 9---10-----11
* |   |    / |
* 6---7---8  |
* |   |   |  |
* 3---4---5  |
* |   |    \ |
* 0---1------2
* </pre><p> Assume that you had numbered the vertices in the cells at the left boundary in a way, that the following line directions are induced:</p>
<pre class="fragment">* 9-&gt;-10-----11
* ^   ^    / |
* 6-&gt;-7---8  |
* ^   ^   |  |
* 3-&gt;-4---5  |
* ^   ^    \ |
* 0-&gt;-1------2
* </pre><p> (This could for example be done by using the indices <code>(0 1 3 4)</code>, <code>(3 4 6 7)</code>, <code>(6 7 9 10)</code> for the three cells). Now, you will not find a way of giving indices for the right cells, without introducing either ambiguity for one line or other, or without violating that within each cells, there must be one vertex from which both lines are directed away and the opposite one to which both adjacent lines point to. The solution in this case is to renumber one of the three left cells, e.g. by reverting the sense of the line between vertices 7 and 10 by numbering the top left cell by <code>(9 6 10 7)</code>:</p>
<pre class="fragment">* 9-&gt;-10-----11
* v   v    / |
* 6-&gt;-7---8  |
* ^   ^   |  |
* 3-&gt;-4---5  |
* ^   ^    \ |
* 0-&gt;-1------2
* </pre><p>The point here is the following: assume we wanted to prolong the grid to the left like this:</p>
<pre class="fragment">* o---o---o---o---o------o
* |   |   |   |   |    / |
* o---o---o---o---o---o  |
* |   |   |   |   |   |  |
* o---o---o---o---o---o  |
* |   |   |   |   |    \ |
* o---o---o---o---o------o
* </pre><p> Then we run into the same problem as above if we order the cells at the left uniformly, thus forcing us to revert the ordering of one cell (the one which we could order as <code>(9 6 7 10)</code> above). However, since opposite lines have to have the same direction, this in turn would force us to rotate the cell left of it, and then the one left to that, and so on until we reach the left end of the grid. This is therefore an example we have to track back right until the first column of three cells to find a consistent ordering, if we had initially ordered them uniformly. As a second example, consider the following simple grid, where the order in which the cells are numbered is important:</p>
<pre class="fragment">* 3-----2-----o-----o ... o-----7-----6
* |     |     |     |     |     |     |
* |  0  |  N  | N-1 | ... |  2  |  1  |
* |     |     |     |     |     |     |
* 0-----1-----o-----o ... o-----4-----5
* </pre><p> We have here only indicated the numbers of the vertices that are relevant. Assume that the user had given the cells 0 and 1 by the vertex indices <code>0 1 3 2</code> and <code>6 7 5 4</code>. Then, if we follow this orientation, the grid after creating the lines for these two cells would look like this:</p>
<pre class="fragment">* 3--&gt;--2-----o-----o ... o-----7--&lt;--6
* |     |     |     |     |     |     |
* ^  0  ^  N  | N-1 | ... |  2  v  1  v
* |     |     |     |     |     |     |
* 0--&gt;--1-----o-----o ... o-----4--&lt;--5
* </pre><p> Now, since opposite lines must point in the same direction, we can only add the cells 2 through N-1 to cells 1 such that all vertical lines point down. Then, however, we cannot add cell N in any direction, as it would have two opposite lines that do not point in the same direction. We would have to rotate either cell 0 or 1 in order to be able to add all the other cells such that the requirements of deal.II triangulations are met. These two examples demonstrate that if we have added a certain number of cells in some orientation of faces and can't add the next one without introducing faces that had already been added in another direction, then it might not be sufficient to only rotate cells in the neighborhood of the cell that we failed to add. It might be necessary to go back a long way and rotate cells that have been entered long ago.</p>
<h3>Solution</h3>
<p>From the examples above, it is obvious that if we encounter a cell that cannot be added to the cells which have already been entered, we can not usually point to a cell that is the culprit and that must be entered in a different orientation. Furthermore, even if we knew which cell, there might be large number of cells that would then cease to fit into the grid and which we would have to find a different orientation as well (in the second example above, if we rotated cell 1, then we would have to rotate the cells 1 through N-1 as well). A brute force approach to this problem is the following: if cell N can't be added, then try to rotate cell N-1. If we can't rotate cell N-1 any more, then try to rotate cell N-2 and try to add cell N with all orientations of cell N-1. And so on. Algorithmically, we can visualize this by a tree structure, where node N has as many children as there are possible orientations of node N+1 (in two space dimensions, there are four orientations in which each cell can be constructed from its four vertices; for example, if the vertex indices are <code>(0 1 3 2)</code>, then the four possibilities would be <code>(0 1 3 2)</code>, <code>(1 3 2 0)</code>, <code>(3 2 0 1)</code>, and <code>(2 0 1 3)</code>). When adding one cell after the other, we traverse this tree in a depth-first (pre-order) fashion. When we encounter that one path from the root (cell 0) to a leaf (the last cell) is not allowed (i.e. that the orientations of the cells which are encoded in the path through the tree does not lead to a valid triangulation), we have to track back and try another path through the tree. In practice, of course, we do not follow each path to a final node and then find out whether a path leads to a valid triangulation, but rather use an inductive argument: if for all previously added cells the triangulation is a valid one, then we can find out whether a path through the tree can yield a valid triangulation by checking whether entering the present cell would introduce any faces that have a nonunique direction; if that is so, then we can stop following all paths below this point and track back immediately. Nevertheless, it is already obvious that the tree has \(4^N\) leaves in two space dimensions, since each of the \(N\) cells can be added in four orientations. Most of these nodes can be discarded rapidly, since firstly the orientation of the first cell is irrelevant, and secondly if we add one cell that has a neighbor that has already been added, then there are already only two possible orientations left, so the total number of checks we have to make until we find a valid way is significantly smaller than \(4^N\) . However, the algorithm is still exponential in time and linear in memory (we only have to store the information for the present path in form of a stack of orientations of cells that have already been added). In fact, the two examples above show that the exponential estimate is not a pessimistic one: we indeed have to track back to one of the very first cells there to find a way to add all cells in a consistent fashion. This discouraging situation is greatly improved by the fact that we have an alternative algorithm for 2d that is always linear in runtime (discovered and implemented by Michael Anderson of TICAM, University of Texas, in 2003), and that for 3d we can find an algorithm that in practice is usually only roughly linear in time and memory. We will describe these algorithms in the following. A full description and theoretical analysis is given in <b>[AABB17]</b> .</p>
<h3>The 2d linear complexity algorithm</h3>
<p>The algorithm uses the fact that opposite faces of a cell need to have the same orientation. So you start with one arbitrary line, choose an orientation. Then the orientation of the opposite face is already fixed. Then go to the two cells across the two faces we have fixed: for them, one face is fixed, so we can also fix the opposite face. Go on with doing so. Eventually, we have done this for a string of cells. Then take one of the non-fixed faces of a cell which has already two fixed faces and do all this again. In more detail, the algorithm is best illustrated using an example. We consider the mesh below:</p>
<pre class="fragment">* 9------10-------11
* |      |        /|
* |      |       / |
* |      |      /  |
* 6------7-----8   |
* |      |     |   |
* |      |     |   |
* |      |     |   |
* 3------4-----5   |
* |      |      \  |
* |      |       \ |
* |      |        \|
* 0------1---------2
* </pre><p> First a cell is chosen ( (0,1,3,4) in this case). A single side of the cell is oriented arbitrarily (3-&gt;4). This choice of orientation is then propagated through the mesh, across sides and elements. (0-&gt;1), (6-&gt;7) and (9-&gt;10). The involves edge-hopping and face hopping, giving a path through the mesh shown in dots.</p>
<pre class="fragment">* 9--&gt;--10-------11
* |  .  |        /|
* |  .  |       / |
* |  .  |      /  |
* 6--&gt;--7-----8   |
* |  .  |     |   |
* |  .  |     |   |
* |  .  |     |   |
* 3--&gt;--4-----5   |
* |  .  |      \  |
* |  X  |       \ |
* |  .  |        \|
* 0--&gt;--1---------2
* </pre><p> This is then repeated for the other sides of the chosen element, orienting more sides of the mesh.</p>
<pre class="fragment">* 9--&gt;--10-------11
* |     |        /|
* v.....v.......V |
* |     |      /. |
* 6--&gt;--7-----8 . |
* |     |     | . |
* |     |     | . |
* |     |     | . |
* 3--&gt;--4-----5 . |
* |     |      \. |
* ^..X..^.......^ |
* |     |        \|
* 0--&gt;--1---------2
* </pre><p> Once an element has been completely oriented it need not be considered further. These elements are filled with o's in the diagrams. We then move to the next element.</p>
<pre class="fragment">* 9--&gt;--10-&gt;-----11
* | ooo |  .     /|
* v ooo v  .    V |
* | ooo |  .   /  |
* 6--&gt;--7--&gt;--8   |
* |     |  .  |   |
* |     |  .  |   |
* |     |  .  |   |
* 3--&gt;--4--&gt;--5   |
* | ooo |  .   \  |
* ^ ooo ^  X    ^ |
* | ooo |  .     \|
* 0--&gt;--1--&gt;------2
* </pre><p> Repeating this gives</p>
<pre class="fragment">* 9--&gt;--10-&gt;-----11
* | ooo | oooooo /|
* v ooo v ooooo V |
* | ooo | oooo /  |
* 6--&gt;--7--&gt;--8   |
* |     |     |   |
* ^.....^..X..^...^
* |     |     |   |
* 3--&gt;--4--&gt;--5   |
* | ooo | oooo \  |
* ^ ooo ^ ooooo ^ |
* | ooo | oooooo \|
* 0--&gt;--1--&gt;------2
* </pre><p> and the final oriented mesh is</p>
<pre class="fragment">* 9--&gt;--10-&gt;-----11
* |     |        /|
* v     v       V |
* |     |      /  |
* 6--&gt;--7--&gt;--8   |
* |     |     |   |
* ^     ^     ^   ^
* |     |     |   |
* 3--&gt;--4--&gt;--5   |
* |     |      \  |
* ^     ^       ^ |
* |     |        \|
* 0--&gt;--1--&gt;-------2
* </pre><p> It is obvious that this algorithm has linear run-time, since it only ever touches each face exactly once. The algorithm just described in the two-dimensional case is implemented for both 2d and (in generalized form) for 3d in this class. The 3d case uses sheets instead of strings of cells to work on. If a grid is orientable, then the algorithm is able to do its work in linear time; if it is not orientable, then it aborts in linear time as well. Both algorithms are described in the paper "On orienting edges of
  unstructured two- and three-dimensional meshes", R. Agelek, M. Anderson, W. Bangerth, W. L. Barth, ACM Transactions on Mathematical Software, vol. 44, article 5, 2017. A preprint is available as <a href="http://arxiv.org/abs/1512.02137">arxiv 1512.02137</a>.</p>
<h3>For the curious</h3>
<p>Prior to the implementation of the algorithms described above (originally implemented by Michael Anderson in 2002, and re-implemented by Wolfgang Bangerth in 2016 based on the work in <b>[AABB17]</b> ), we used a branch-and-cut algorithm initially implemented in 2000 by Wolfgang Bangerth. Although it is no longer used, here is how it works, and why it doesn't always work for large meshes since its run-time can be exponential in bad cases. The first observation is that although there are counterexamples, problems are usually local. For example, in the second example mentioned above, if we had numbered the cells in a way that neighboring cells have similar cell numbers, then the amount of backtracking needed is greatly reduced. Therefore, in the implementation of the algorithm, the first step is to renumber the cells in a Cuthill-McKee fashion: start with the cell with the least number of neighbors and assign to it the cell number zero. Then find all neighbors of this cell and assign to them consecutive further numbers. Then find their neighbors that have not yet been numbered and assign to them numbers, and so on. Graphically, this represents finding zones of cells consecutively further away from the initial cells and number them in this front-marching way. This already greatly improves locality of problems and consequently reduced the necessary amount of backtracking. The second point is that we can use some methods to prune the tree, which usually lead to a valid orientation of all cells very quickly. The first such method is based on the observation that if we fail to insert one cell with number N, then this may not be due to cell N-1 unless N-1 is a direct neighbor of N. The reason is obvious: the chosen orientation of cell M could only affect the possibilities to add cell N if either it were a direct neighbor or if there were a sequence of cells that were added after M and that connected cells M and N. Clearly, for M=N-1, the latter cannot be the case. Conversely, if we fail to add cell N, then it is not necessary to track back to cell N-1, but we can track back to the neighbor of N with the largest cell index and which has already been added. Unfortunately, this method can fail to yield a valid path through the tree if not applied with care. Consider the following situation, initially extracted from a mesh of 950 cells generated automatically by the program BAMG (this program usually generates meshes that are quite badly balanced, often have many</p>
<ul>
<li>sometimes 10 or more</li>
<li>neighbors of one vertex, and exposed several problems in the initial algorithm; note also that the example is in 2d where we now have the much better algorithm described above, but the same observations also apply to 3d):</li>
</ul>
<pre class="fragment">* 13----------14----15
* | \         |     |
* |  \    4   |  5  |
* |   \       |     |
* |    12-----10----11
* |     |     |     |
* |     |     |  7  |
* |     |     |     |
* |  3  |     8-----9
* |     |     |     |
* |     |     |  6  |
* |     |     |     |
* 4-----5-----6-----7
* |     |     |     |
* |  2  |  1  |  0  |
* |     |     |     |
* 0-----1-----2-----3
* </pre><p> Note that there is a hole in the middle. Assume now that the user described the first cell 0 by the vertex numbers <code>2 3 6 7</code>, and cell 5 by <code>15 14 11 10</code>, and assume that cells 1, 2, 3, and 4 are numbered such that 5 can be added in initial rotation. All other cells are numbered in the usual way, i.e. starting at the bottom left and counting counterclockwise. Given this description of cells, the algorithm will start with cell zero and add one cell after the other, up until the sixth one. Then the situation will be the following:</p>
<pre class="fragment">* 13-----&gt;---14--&lt;--15
* | \         |     |
* |  &gt;    4   v  5  v
* |   \       |     |
* |    12-&gt;--10--&lt;--11
* |     |     |     |
* ^     |     |  7  |
* |     |     |     |
* |  3  ^     8--&gt;--9
* |     |     |     |
* |     |     ^  6  ^
* |     |     |     |
* 4--&gt;--5--&gt;--6--&gt;--7
* |     |     |     |
* ^  2  ^  1  ^  0  ^
* |     |     |     |
* 0--&gt;--1--&gt;--2--&gt;--3
* </pre><p> Coming now to cell 7, we see that the two opposite lines at its top and bottom have different directions; we will therefore find no orientation of cell 7 in which it can be added without violation of the consistency of the triangulation. According to the rule stated above, we track back to the neighbor with greatest index, which is cell 6, but since its bottom line is to the right, its top line must be to the right as well, so we won't be able to find an orientation of cell 6 such that 7 will fit into the triangulation. Then, if we have finished all possible orientations of cell 6, we track back to the neighbor of 6 with the largest index and which has been added already. This would be cell 0. However, we know that the orientation of cell 0 can't be important, so we conclude that there is no possible way to orient all the lines of the given cells such that they satisfy the requirements of deal.II triangulations. We know that this can't be, so it results in an exception be thrown. The bottom line of this example is that when we looked at all possible orientations of cell 6, we couldn't find one such that cell 7 could be added, and then decided to track back to cell 0. We did not even attempt to turn cell 5, after which it would be simple to add cell 7. Thus, the algorithm described above has to be modified: we are only allowed to track back to that neighbor that has already been added, with the largest cell index, if we fail to add a cell in any orientation. If we track back further because we have exhausted all possible orientations but could add the cell (i.e. we track back since another cell, further down the road couldn't be added, irrespective of the orientation of the cell which we are presently considering), then we are not allowed to track back to one of its neighbors, but have to track back only one cell index. The second method to prune the tree is that usually we cannot add a new cell since the orientation of one of its neighbors that have already been added is wrong. Thus, if we may try to rotate one of the neighbors (of course making sure that rotating that neighbor does not violate the consistency of the triangulation) in order to allow the present cell to be added. While the first method could be explained in terms of backtracking in the tree of orientations more than one step at once, turning a neighbor means jumping to a totally different place in the tree. For both methods, one can find arguments that they will never miss a path that is valid and only skip paths that are invalid anyway. These two methods have proven extremely efficient. We have been able to read very large grids (several ten thousands of cells) without the need to track back much. In particular, the time to find an ordering of the cells was found to be mostly linear in the number of cells, and the time to reorder them is usually much smaller (for example by one order of magnitude) than the time needed to read the data from a file, and also to actually generate the triangulation from this data using the <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation()</a> function. </p>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
