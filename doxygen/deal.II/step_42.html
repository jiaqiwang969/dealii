<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_42.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-42 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-42 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_41.html">step-41</a>, <a class="el" href="step_40.html">step-40</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Introduction">Introduction</a>
        <li><a href="#Classicalformulation">Classical formulation</a>
        <li><a href="#Reformulationasavariationalinequality">Reformulation as a variational inequality</a>
        <li><a href="#ANewtonmethodfortheplasticnonlinearity">A Newton method for the plastic nonlinearity</a>
        <li><a href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set methods to solve the saddle point problem</a>
        <li><a href="#Overallalgorithm">Overall algorithm</a>
        <li><a href="#Adaptivemeshrefinement">Adaptive mesh refinement</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeConstitutiveLawcodeclasstemplate">The <code>ConstitutiveLaw</code> class template</a>
      <ul>
        <li><a href="#ConstitutiveLawget_stress_strain_tensor">ConstitutiveLaw::get_stress_strain_tensor</a>
        <li><a href="#ConstitutiveLawget_linearized_stress_strain_tensors">ConstitutiveLaw::get_linearized_stress_strain_tensors</a>
        <li><a href="#ThecodeSphereObstaclecodeclass">The <code>SphereObstacle</code> class</a>
        <li><a href="#ThecodeBitmapFilecodeandcodeChineseObstaclecodeclasses">The <code>BitmapFile</code> and <code>ChineseObstacle</code> classes</a>
      </ul>
        <li><a href="#ThecodePlasticityContactProblemcodeclasstemplate">The <code>PlasticityContactProblem</code> class template</a>
        <li><a href="#ImplementationofthecodePlasticityContactProblemcodeclass">Implementation of the <code>PlasticityContactProblem</code> class</a>
      <ul>
        <li><a href="#PlasticityContactProblemdeclare_parameters">PlasticityContactProblem::declare_parameters</a>
        <li><a href="#ThecodePlasticityContactProblemcodeconstructor">The <code>PlasticityContactProblem</code> constructor</a>
        <li><a href="#PlasticityContactProblemmake_grid">PlasticityContactProblem::make_grid</a>
        <li><a href="#PlasticityContactProblemsetup_system">PlasticityContactProblem::setup_system</a>
        <li><a href="#PlasticityContactProblemcompute_dirichlet_constraints">PlasticityContactProblem::compute_dirichlet_constraints</a>
        <li><a href="#PlasticityContactProblemassemble_mass_matrix_diagonal">PlasticityContactProblem::assemble_mass_matrix_diagonal</a>
        <li><a href="#PlasticityContactProblemupdate_solution_and_constraints">PlasticityContactProblem::update_solution_and_constraints</a>
        <li><a href="#PlasticityContactProblemassemble_newton_system">PlasticityContactProblem::assemble_newton_system</a>
        <li><a href="#PlasticityContactProblemcompute_nonlinear_residual">PlasticityContactProblem::compute_nonlinear_residual</a>
        <li><a href="#PlasticityContactProblemsolve_newton_system">PlasticityContactProblem::solve_newton_system</a>
        <li><a href="#PlasticityContactProblemsolve_newton">PlasticityContactProblem::solve_newton</a>
        <li><a href="#PlasticityContactProblemrefine_grid">PlasticityContactProblem::refine_grid</a>
        <li><a href="#PlasticityContactProblemmove_mesh">PlasticityContactProblem::move_mesh</a>
        <li><a href="#PlasticityContactProblemoutput_results">PlasticityContactProblem::output_results</a>
        <li><a href="#PlasticityContactProblemoutput_contact_force">PlasticityContactProblem::output_contact_force</a>
        <li><a href="#PlasticityContactProblemrun">PlasticityContactProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by JÃ¶rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&amp;M University, with significant contributions by Timo Heister and Wolfgang Bangerth. <br />
 <br />
 The code described here provides the basis for the numerical experiments shown in the following paper: <br />
 J. Frohne, T. Heister, W. Bangerth: <b>Efficient numerical methods for the large-scale, parallel solution of elastoplastic contact problems</b>. Accepted for publication in International Journal for Numerical Methods in Engineering, 2015. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h3>Introduction</h3>
<p>This example is an extension of <a class="el" href="step_41.html">step-41</a>, considering a 3d contact problem with an elasto-plastic material behavior with isotropic hardening in three dimensions. In other words, it considers how a three-dimensional body deforms if one pushes into it a rigid obstacle (the contact problem) where deformation is governed by an elasto-plastic material law (a material that can only accommodate a certain maximal stress) that hardens as deformation accumulates. To show what we intend to do before going into too many details, let us just show a picture of what the solution will look like (the deformable body is a cube - only half of which is actually shown -, the obstacle corresponds to a Chinese character that is discussed below):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionLi2.png"/>
</div>
<p>This problem description implies that we have to take care of an additional nonlinearity compared to <a class="el" href="step_41.html">step-41</a>: the material behavior. Since we consider a three dimensional problem here, we also have to account for the fact that the contact area is at the boundary of the deformable body now, rather than in the interior. Finally, compared to <a class="el" href="step_41.html">step-41</a>, we also have to deal with hanging nodes in both the handling of the linear system as well as of the inequality constraints as we would like to use an adaptive mesh; in the latter case, we will have to deal with prioritizing whether the constraints from the hanging nodes or from the inequalities are more important.</p>
<p>Since you can very easily reach a few million degrees of freedom in three dimensions, even with adaptive mesh refinement, we decided to use Trilinos and p4est to run our code in parallel, building on the framework of <a class="el" href="step_40.html">step-40</a> for the parallelization. Additional pointers for parallelization can be found in <a class="el" href="step_32.html">step-32</a>.</p>
<p><a class="anchor" id="Classicalformulation"></a></p><h3>Classical formulation</h3>
<p>The classical formulation of the problem possesses the following form: </p><p class="formulaDsp">
\begin{align*} \varepsilon(\mathbf u) &amp;= A\sigma + \varepsilon^p &amp; &amp;\quad\text{in } \Omega,\\ -\textrm{div}\ \sigma &amp;= \mathbf f &amp; &amp;\quad\text{in } \Omega,\\ \varepsilon^p:(\tau - \sigma) &amp;\geq 0\quad\forall\tau\text{ with }\mathcal{F}(\tau)\leq 0 &amp; &amp;\quad\text{in } \Omega,\\ \mathbf u &amp;= 0 &amp; &amp;\quad\text{on }\Gamma_D,\\ \sigma \mathbf n - [\mathbf n \cdot(\sigma \mathbf n)]\mathbf n &amp;= 0, \quad \mathbf n \cdot (\sigma \mathbf n) \leq 0 &amp; &amp;\quad\text{on }\Gamma_C,\\ (\mathbf n \cdot (\sigma \mathbf n))(\mathbf n \cdot \mathbf u - g) &amp;= 0,\quad \mathbf n \cdot \mathbf u - g \leq 0 &amp; &amp;\quad\text{on } \Gamma_C. \end{align*}
</p>
<p> Here, the first of these equations defines the relationship between strain \(\varepsilon(\mathbf u)=\frac{1}{2}\left(\nabla \mathbf u + \nabla \mathbf u^T\right)\) and stress \(\sigma\) via the fourth-order compliance tensor \(A\); \(\varepsilon^p\) provides the plastic component of the strain to ensure that the stress does not exceed the yield stress. We will only consider isotropic materials for which \(A\) can be expressed in terms of the Lam&eacute; moduli \(\lambda\) and \(\mu\) or alternatively in terms of the bulk modulus \(\kappa\) and \(\mu\). The second equation is the force balance; we will here not consider any body forces and henceforth assume that \(\mathbf f=0\). The complementarity condition in the third line implies that \(\varepsilon^p=0\) if \(\mathcal{F}(\sigma)&lt; 0\) but that \(\varepsilon^p\) may be a nonzero tensor if and only if \(\mathcal{F}(\sigma) = 0\), and in particular that in this case \(\varepsilon^p\) must point in the direction \(\partial \mathcal{F}(\sigma)/\partial \sigma\). The inequality \(\mathcal{F}(\sigma)\le 0\) is a statement of the fact that plastic materials can only support a finite amount of stress; in other words, they react with plastic deformations \(\varepsilon^p\) if external forces would result in a stress \(\sigma\) for which \(\mathcal{F}(\sigma)&gt; 0\) would result. A typical form for this <em>yield function</em> is \(\mathcal{F}(\sigma)=|\sigma^D|-\sigma_{\text{yield}}\) where \(\tau^D = \tau - \dfrac{1}{3}tr(\tau)I\) is the deviatoric part of a tensor and \(|\cdot|\) denotes the Frobenius norm.</p>
<p>Further equations describe a fixed, zero displacement on \(\Gamma_D\) and that on the surface \(\Gamma_C=\partial\Omega\backslash\Gamma_D\) where contact may appear, the normal force \(\sigma_n=\mathbf n \cdot (\sigma(\mathbf u) \mathbf n)\) exerted by the obstacle is inward (no "pull" by the obstacle on our body) and with zero tangential component \(\mathbf \sigma_t= \sigma \mathbf n - \mathbf \sigma_n \mathbf n = \sigma \mathbf n - [\mathbf n \cdot(\sigma \mathbf n)]\mathbf n\). The last condition is again a complementarity condition that implies that on \(\Gamma_C\), the normal force can only be nonzero if the body is in contact with the obstacle; the second part describes the impenetrability of the obstacle and the body. The last two equations are commonly referred to as the Signorini contact conditions.</p>
<p>Most materials - especially metals - have the property that they show some hardening as a result of deformation. In other words, \(\sigma_{\text{yield}}\) increases with deformation. In practice, it is not the elastic deformation that results in hardening, but the plastic component. There are different constitutive laws to describe those material behaviors. The simplest one is called linear isotropic hardening described by the flow function \(\mathcal{F}(\sigma,\varepsilon^p) = \vert\sigma^D\vert - (\sigma_0 + \gamma^{\text{iso}}|\varepsilon^p|)\).</p>
<p><a class="anchor" id="Reformulationasavariationalinequality"></a></p><h3>Reformulation as a variational inequality</h3>
<p>It is generally rather awkward to deal with inequalities. Here, we have to deal with two: plasticity and the contact problem. As described in more detail in the paper mentioned at the top of this page, one can at least reformulate the plasticity in a way that makes it look like a nonlinearity that we can then treat with Newton's method. This is slightly tricky mathematically since the nonlinearity is not just some smooth function but instead has kinks where the stress reaches the yield stress; however, it can be shown for such <em>semismooth</em> functions that Newton's method still converges.</p>
<p>Without going into details, we will also get rid of the stress as an independent variable and instead work exclusively with the displacements \(\mathbf u\). Ultimately, the goal of this reformulation is that we will want to end up with a symmetric, positive definite problem - such as a linearized elasticity problem with spatially variable coefficients resulting from the plastic behavior - that needs to be solved in each Newton step. We want this because there are efficient and scalable methods for the solution of such linear systems, such as CG preconditioned with an algebraic multigrid. This is opposed to the saddle point problem akin to the mixed Laplace (see <a class="el" href="step_20.html">step-20</a>) we would get were we to continue with the mixed formulation containing both displacements and stresses, and for which <a class="el" href="step_20.html">step-20</a> already gives a hint at how difficult it is to construct good solvers and preconditioners.</p>
<p>With this said, let us simply state the problem we obtain after reformulation (again, details can be found in the paper): Find a displacement \(\mathbf u \in V^+\) so that </p><p class="formulaDsp">
\begin{align*} \left(P_{\Pi}(C\varepsilon(\mathbf u)),\varepsilon(\varphi) - \varepsilon(\mathbf u)\right) \geq 0,\quad \forall \varphi\in V^+. \end{align*}
</p>
<p> where the projector \(P_\Pi\) is defined as </p><p class="formulaDsp">
\begin{align*} P_{\Pi}(\tau) \dealcoloneq \begin{cases} \tau, &amp; \text{if }\vert\tau^D\vert \leq \sigma_0,\\ \left[ \dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}} + \left(1-\dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\right)\dfrac{\sigma_0}{\vert\tau^D\vert} \right]\tau^D + \dfrac{1}{3}\text{trace}(\tau) I, &amp; \text{if }\vert\tau^D\vert &gt; \sigma_0, \end{cases} \end{align*}
</p>
<p> and the space \(V^+\) is the space of all displacements that satisfy the contact condition: </p><p class="formulaDsp">
\begin{align*} V &amp;= \left\{ \mathbf u\in \left[H^1(\Omega)\right]^{d}: \mathbf u = 0 \text{ on } \Gamma_D\right\}, \\ V^+ &amp;= \left\{ \mathbf u\in V: \mathbf n \cdot \mathbf u\leq g \text{ on } \Gamma_C \right\}. \end{align*}
</p>
<p>In the actual code, we will use the abbreviation \(\gamma=\dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\).</p>
<p>Given this formulation, we will apply two techniques:</p><ul>
<li>Run a Newton method to iterate out the nonlinearity in the projector.</li>
<li>Run an active set method for the contact condition, in much the same way as we did in <a class="el" href="step_41.html">step-41</a>.</li>
</ul>
<p>A strict approach would keep the active set fixed while we iterate the Newton method to convergence (or maybe the other way around: find the final active set before moving on to the next Newton iteration). In practice, it turns out that it is sufficient to do only a single Newton step per active set iteration, and so we will iterate over them concurrently. We will also, every once in a while, refine the mesh.</p>
<p><a class="anchor" id="ANewtonmethodfortheplasticnonlinearity"></a></p><h3>A Newton method for the plastic nonlinearity</h3>
<p>As mentioned, we will treat the nonlinearity of the operator \(P_\Pi\) by applying a Newton method, despite the fact that the operator is not differentiable in the strict sense. However, it satisfies the conditions of <em>slant</em> differentiability and this turns out to be enough for Newton's method to work. The resulting method then goes by the name <em>semi-smooth Newton method</em>, which sounds impressive but is, in reality, just a Newton method applied to a semi-smooth function with an appropriately chosen "derivative".</p>
<p>In the current case, we will run our iteration by solving in each iteration \(i\) the following equation (still an inequality, but linearized): </p><p class="formulaDsp">
\begin{align*} \label{eq:linearization} \left(I_{\Pi}\varepsilon(\tilde {\mathbf u}^{i}), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right) \geq \left(\left(I_{\Pi}\varepsilon({\mathbf u}^{i-1}), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right) - \left(P_{\Pi}(C\varepsilon({\mathbf u}^{i-1})), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right)\right), \quad \forall \varphi\in V^+, \end{align*}
</p>
<p> where the rank-4 tensor \(I_\Pi=I_\Pi(\varepsilon^D(\mathbf u^{i-1}))\) given by </p><p class="formulaDsp">
\begin{align} I_\Pi = \begin{cases} C_{\mu} + C_{\kappa}, &amp; \hspace{-8em} \text{if } \vert C\varepsilon^D(\mathbf u^{i-1}) \vert \leq \sigma_0, \\ \frac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}} C_{\mu} + \frac{\left(1-\frac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\right)\sigma_0}{\vert C\varepsilon^D(\mathbf u^{i-1}) \vert}\left(C_{\mu} - 2\mu\dfrac{C\varepsilon^D(\mathbf u^{i-1})\otimes C\varepsilon^D(\mathbf u^{i-1})}{\vert C\varepsilon^D(\mathbf u^{i-1})\vert^2}\right) + C_{\kappa}, &amp; \text{ else.} \end{cases} \end{align}
</p>
<p> This tensor is the (formal) linearization of \(P_\Pi(C\cdot)\) around \(\varepsilon^D(\mathbf u^{i-1})\). For the linear isotropic material we consider here, the bulk and shear components of the projector are given by </p><p class="formulaDsp">
\begin{gather*} C_{\kappa} = \kappa I\otimes I, \qquad\qquad\qquad\qquad C_{\mu} = 2\mu\left(\mathbb{I} - \dfrac{1}{3} I\otimes I\right), \end{gather*}
</p>
<p> where \(I\) and \(\mathbb{I}\) are the identity tensors of rank 2 and 4, respectively.</p>
<p>Note that this problem corresponds to a linear elastic contact problem where \(I_\Pi\) plays the role of the elasticity tensor \(C=A^{-1}\). Indeed, if the material is not plastic at a point, then \(I_\Pi=C\). However, at places where the material is plastic, \(I_\Pi\) is a spatially varying function. In any case, the system we have to solve for the Newton iterate \(\tilde {\mathbf u}^{i}\) gets us closer to the goal of rewriting our problem in a way that allows us to use well-known solvers and preconditioners for elliptic systems.</p>
<p>As a final note about the Newton method let us mention that as is common with Newton methods we need to globalize it by controlling the step length. In other words, while the system above solves for \(\tilde {\mathbf u}^{i}\), the final iterate will rather be </p><p class="formulaDsp">
\begin{align*} {\mathbf u}^{i} = {\mathbf u}^{i-1} + \alpha_i (\tilde {\mathbf u}^{i} - {\mathbf u}^{i-1}) \end{align*}
</p>
<p> where the difference in parentheses on the right takes the role of the traditional Newton direction, \(\delta {\mathbf u}^{i}\). We will determine \(\alpha^i\) using a standard line search.</p>
<p><a class="anchor" id="ActiveSetmethodstosolvethesaddlepointproblem"></a></p><h3>Active Set methods to solve the saddle point problem</h3>
<p>This linearized problem to be solved in each Newton step is essentially like in <a class="el" href="step_41.html">step-41</a>. The only difference consists in the fact that the contact area is at the boundary instead of in the domain. But this has no further consequence so that we refer to the documentation of <a class="el" href="step_41.html">step-41</a> with the only hint that \(\mathcal{S}\) contains all the vertices at the contact boundary \(\Gamma_C\) this time. As there, what we need to do is keep a subset of degrees of freedom fixed, leading to additional constraints that one can write as a saddle point problem. However, as discussed in the paper, by writing these constraints in an appropriate way that removes the coupling between degrees of freedom, we end up with a set of nodes that essentially just have Dirichlet values attached to them.</p>
<p><a class="anchor" id="Overallalgorithm"></a></p><h3>Overall algorithm</h3>
<p>The algorithm outlined above combines the damped semismooth Newton-method, which we use for the nonlinear constitutive law, with the semismooth Newton method for the contact. It works as follows: </p><ol>
<li>
<p class="startli">Initialize the active and inactive sets \(\mathcal{A}_i\) and \(\mathcal{F}_i\) such that \(\mathcal{S} = \mathcal{A}_i \cup \mathcal{F}_i\) and \(\mathcal{A}_i \cap \mathcal{F}_i = \emptyset\) and set \(i = 1\). Here, \(\mathcal{S}\) is the set of all degrees of freedom located at the surface of the domain where contact may happen. The start value \(\hat U^0 \dealcoloneq P_{\mathcal{A}_k}(0)\) fulfills our obstacle condition, i.e., we project an initial zero displacement onto the set of feasible displacements.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Assemble the Newton matrix \(A_{pq} \dealcoloneq a&#39;( U^{i-1};\varphi_p,\varphi_q)\) and the right-hand-side \(F(\hat U^{i-1})\). These correspond to the linearized Newton step, ignoring for the moment the contact inequality.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Find the primal-dual pair \((\tilde U^i,\Lambda^i)\) that satisfies </p><p class="formulaDsp">
\begin{align*} A\tilde U^i + B\Lambda^i &amp; = F, &amp;\\ \left[B^T\tilde U^i\right]_p &amp; = G_p &amp; \forall p\in\mathcal{A}_i,\\ \Lambda^i_p &amp; = 0 &amp; \forall p\in\mathcal{F}_i. \end{align*}
</p>
<p> As in <a class="el" href="step_41.html">step-41</a>, we can obtain the solution to this problem by eliminating those degrees of freedom in \({\cal A}_i\) from the first equation and obtain a linear system \(\hat {\hat A}(U^{i-1}) \tilde U^i = \hat {\hat H}(U^{i-1})\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Damp the Newton iteration for \(i&gt;2\) by applying a line search and calculating a linear combination of \(U^{i-1}\) and \(\tilde U^i\). This requires finding an \(\alpha^i_l \dealcoloneq 2^{-l},(l=0,\ldots,10)\) so that </p><p class="formulaDsp">
\begin{gather*}U^i \dealcoloneq \alpha^i_l\bar U^i + (1-\alpha^i_l)U^{i-1}\end{gather*}
</p>
<p> satisfies </p><p class="formulaDsp">
\begin{gather*} \vert {\hat R}\left({\mathbf u}^{i}\right) \vert &lt; \vert {\hat R}\left({\mathbf u}^{i-1}\right) \vert. \end{gather*}
</p>
<p> with \({\hat R}\left({\mathbf u}\right)=\left(P_{Pi}(C\varepsilon(u)),\varepsilon(\varphi^{i}_p\right)\) with the exceptions of (i) elements \(p\in\mathcal{A}_i\) where we set \({\hat R}\left({\mathbf u}\right)=0\), and (ii) elements that correspond to hanging nodes, which we eliminate in the usual manner.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Define the new active and inactive sets by </p><p class="formulaDsp">
\begin{gather*}\mathcal{A}_{i+1} \dealcoloneq \lbrace p\in\mathcal{S}:\Lambda^i_p + c\left(\left[B^TU^i\right]_p - G_p\right) &gt; 0\rbrace,\end{gather*}
</p>
 <p class="formulaDsp">
\begin{gather*}\mathcal{F}_{i+1} \dealcoloneq \lbrace p\in\mathcal{S}:\Lambda^i_p + c\left(\left[B^TU^i\right]_p - G_p\right) \leq 0\rbrace.\end{gather*}
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Project \(U^i\) so that it satisfies the contact inequality, </p><p class="formulaDsp">
\begin{gather*}\hat U^i \dealcoloneq P_{\mathcal{A}_{i+1}}(U^i).\end{gather*}
</p>
<p> Here, \(P_{\mathcal{A}}(U)\) is the projection of the active components in \(\mathcal{A}\) to the gap </p><p class="formulaDsp">
\begin{gather*}P_{\mathcal{A}}(U)_p \dealcoloneq \begin{cases} U_p, &amp; \textrm{if}\quad p\notin\mathcal{A}\\ g_{h,p}, &amp; \textrm{if}\quad p\in\mathcal{A}, \end{cases}\end{gather*}
</p>
<p> where \(g_{h,p}\) is the <em>gap</em> denoting the distance of the obstacle from the undisplaced configuration of the body.</p>
<p class="endli"></p>
</li>
<li>
If \(\mathcal{A}_{i+1} = \mathcal{A}_k\) and \(\left\| {\hat R}\left({\mathbf u}^{i}\right) \right\|_{\ell_2} &lt; \delta\) then stop, else set \(i=i+1\) and go to step (1). This step ensures that we only stop iterations if both the correct active set has been found and the plasticity has been iterated to sufficient accuracy. </li>
</ol>
<p>In step 3 of this algorithm, the matrix \(B\in\mathbb{R}^{n\times m}\), \(n&gt;m\) describes the coupling of the bases for the displacements and Lagrange multiplier (contact forces) and it is not quadratic in our situation since \(\Lambda^k\) is only defined on \(\Gamma_C\), i.e., the surface where contact may happen. As shown in the paper, we can choose \(B\) to be a matrix that has only one entry per row, (see also H&uuml;eber, Wohlmuth: A primal-dual active set strategy for non-linear multibody contact problems, Comput. Methods Appl. Mech. Engrg. 194, 2005, pp. 3147-3166). The vector \(G\) is defined by a suitable approximation \(g_h\) of the gap \(g\) </p><p class="formulaDsp">
\begin{gather*}G_p = \begin{cases} g_{h,p}, &amp; \text{if}\quad p\in\mathcal{S}\\ 0, &amp; \text{if}\quad p\notin\mathcal{S}. \end{cases}\end{gather*}
</p>
<p><a class="anchor" id="Adaptivemeshrefinement"></a></p><h3>Adaptive mesh refinement</h3>
<p>Since we run our program in 3d, the computations the program performs are expensive. Consequently using adaptive mesh refinement is an important step towards staying within acceptable run-times. To make our lives easier we simply choose the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> that is already implemented in deal.II. We hand the solution vector to it which contains the displacement \(u\). As we will see in the results it yields a quite reasonable adaptive mesh for the contact zone as well as for plasticity.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>This tutorial is essentially a mixture of <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_41.html">step-41</a> but instead of PETSc we let the Trilinos library deal with parallelizing the linear algebra (like in <a class="el" href="step_32.html">step-32</a>). Since we are trying to solve a similar problem like in <a class="el" href="step_41.html">step-41</a> we will use the same methods but now in parallel.</p>
<p>A difficulty is handling of the constraints from the Dirichlet conditions, hanging nodes and the inequality condition that arises from the contact. For this purpose we create three objects of type <a class="el" href="classAffineConstraints.html">AffineConstraints</a> that describe the various constraints and that we will combine as appropriate in each iteration.</p>
<p>Compared to <a class="el" href="step_41.html">step-41</a>, the programs has a few new classes:</p>
<ul>
<li>
<p class="startli"><code>ConstitutiveLaw</code> describes the plastic behavior of the material</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>SphereObstacle</code> describes a sphere that serves as the obstacle that is pushed into the deformable, elastoplastic body. Whether this or the next class is used to describe the obstacle is determined from the input parameter file.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>ChineseObstacle</code> (and a helper class) is a class that allows us to read in an obstacle from a file. In the example we will show in the results section, this file will be <code>'obstacle_file.dat'</code> and will correspond to data that shows the Chinese, Japanese or Korean symbol for force or power (see <a href="http://www.orientaloutpost.com/">http://www.orientaloutpost.com/</a> : "This word can be used for motivation - it can also mean power/motion/propulsion/force. It can be anything internal or external that keeps you going. This is the safest way to express motivation in Chinese. If your audience is Japanese, please see the other entry for motivation. This is a word in Japanese and Korean, but it means "motive
  power" or "kinetic energy" (without the motivation meaning that you are probably looking for)"). In essence, we will pretend that we have a stamp (i.e., a mask that corresponds to a flat bottomed obstacle with no pieces of intermediate height) that we press into the body. The symbol in question looks as follows (see also the picture at the top of this section on how the end result looks like):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.character.png" width="25%"/>
</div>
 </li>
</ul>
<p>Other than that, let us comment only on the following aspects: </p><ul>
<li>
<p class="startli">The program allows you to select from two different coarse meshes through the parameter file. These are either a cube \([0,1]^3\) or a half sphere with the open side facing the positive \(z\) direction.</p>
<p class="endli"></p>
</li>
<li>
In either case, we will assume the convention that the part of the boundary that may be in contact with the obstacle has boundary indicator one. For both kinds of meshes, we assume that this is a free surface, i.e., the body is either in contact there or there is no force acting on it. For the half sphere, the curved part has boundary indicator zero and we impose zero displacement there. For the box, we impose zero displacement along the bottom but allow vertical displacement along the sides (though no horizontal displacement). </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The set of include files is not much of a surprise any more at this time:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__field__function_8h.html">deal.II/numerics/fe_field_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Finally, we include two system headers that let us create a directory for output files. The first header provides the <code>mkdir</code> function and the second lets us determine what happened if <code>mkdir</code> fails.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cerrno&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step42</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeConstitutiveLawcodeclasstemplate"></a> </p><h3>The <code>ConstitutiveLaw</code> class template</h3>
<p>This class provides an interface for a constitutive law, i.e., for the relationship between strain \(\varepsilon(\mathbf u)\) and stress \(\sigma\). In this example we are using an elastoplastic material behavior with linear, isotropic hardening. Such materials are characterized by Young's modulus \(E\), Poisson's ratio \(\nu\), the initial yield stress \(\sigma_0\) and the isotropic hardening parameter \(\gamma\). For \(\gamma = 0\) we obtain perfect elastoplastic behavior.</p>
<p>As explained in the paper that describes this program, the first Newton steps are solved with a completely elastic material model to avoid having to deal with both nonlinearities (plasticity and contact) at once. To this end, this class has a function <code>set_sigma_0()</code> that we use later on to simply set \(\sigma_0\) to a very large value &ndash; essentially guaranteeing that the actual stress will not exceed it, and thereby producing an elastic material. When we are ready to use a plastic model, we set \(\sigma_0\) back to its proper value, using the same function. As a result of this approach, we need to leave <code>sigma_0</code> as the only non-const member variable of this class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ConstitutiveLaw</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConstitutiveLaw(<span class="keyword">const</span> <span class="keywordtype">double</span> E,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> nu,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> sigma_0,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> gamma);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_sigma_0(<span class="keywordtype">double</span> sigma_zero);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> get_stress_strain_tensor(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> get_linearized_stress_strain_tensors(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">  <span class="keywordtype">double</span>       sigma_0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_kappa;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_mu;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the ConstitutiveLaw class sets the required material parameter for our deformable body. Material parameters for elastic isotropic media can be defined in a variety of ways, such as the pair \(E, \nu\) (elastic modulus and Poisson's number), using the Lam&eacute; parameters \(\lambda,mu\) or several other commonly used conventions. Here, the constructor takes a description of material parameters in the form of \(E,\nu\), but since this turns out to these are not the coefficients that appear in the equations of the plastic projector, we immediately convert them into the more suitable set \(\kappa,\mu\) of bulk and shear moduli. In addition, the constructor takes \(\sigma_0\) (the yield stress absent any plastic strain) and \(\gamma\) (the hardening parameter) as arguments. In this constructor, we also compute the two principal components of the stress-strain relation and its linearization.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ConstitutiveLaw&lt;dim&gt;::ConstitutiveLaw(<span class="keywordtype">double</span> E,</div><div class="line">                                      <span class="keywordtype">double</span> nu,</div><div class="line">                                      <span class="keywordtype">double</span> sigma_0,</div><div class="line">                                      <span class="keywordtype">double</span> gamma)</div><div class="line">  : kappa(E / (3 * (1 - 2 * nu)))</div><div class="line">  , mu(E / (2 * (1 + nu)))</div><div class="line">  , sigma_0(sigma_0)</div><div class="line">  , gamma(gamma)</div><div class="line">  , stress_strain_tensor_kappa(kappa *</div><div class="line">                               <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                             <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()))</div><div class="line">  , stress_strain_tensor_mu(</div><div class="line">      2 * mu *</div><div class="line">      (<a class="code" href="symmetric__tensor_8h.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor</a>&lt;dim&gt;() - <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                              <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()) /</div><div class="line">                                  3.0))</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::set_sigma_0(<span class="keywordtype">double</span> sigma_zero)</div><div class="line">{</div><div class="line">  sigma_0 = sigma_zero;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutiveLawget_stress_strain_tensor"></a> </p><h4>ConstitutiveLaw::get_stress_strain_tensor</h4>
<p>This is the principal component of the constitutive law. It computes the fourth order symmetric tensor that relates the strain to the stress according to the projection given above, when evaluated at a particular strain point. We need this function to calculate the nonlinear residual in <code>PlasticityContactProblem::residual_nl_system()</code> where we multiply this tensor with the strain given in a quadrature point. The computations follow the formulas laid out in the introduction. In comparing the formulas there with the implementation below, recall that \(C_\mu : \varepsilon = \tau_D\) and that \(C_\kappa : \varepsilon = \kappa \text{trace}(\varepsilon) I = \frac 13 \text{trace}(\tau) I\).</p>
<p>The function returns whether the quadrature point is plastic to allow for some statistics downstream on how many of the quadrature points are plastic and how many are elastic.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> ConstitutiveLaw&lt;dim&gt;::get_stress_strain_tensor(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor =</div><div class="line">    (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor =</div><div class="line">    <a class="code" href="classSymmetricTensor.html#a6e7fd34dd28fc3f6420068887a939753">deviator</a>(stress_tensor);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">  stress_strain_tensor = stress_strain_tensor_mu;</div><div class="line">  <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">    }</div><div class="line"></div><div class="line">  stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (deviator_stress_tensor_norm &gt; sigma_0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutiveLawget_linearized_stress_strain_tensors"></a> </p><h4>ConstitutiveLaw::get_linearized_stress_strain_tensors</h4>
<p>This function returns the linearized stress strain tensor, linearized around the solution \(u^{i-1}\) of the previous Newton step \(i-1\). The parameter <code>strain_tensor</code> (commonly denoted \(\varepsilon(u^{i-1})\)) must be passed as an argument, and serves as the linearization point. The function returns the derivative of the nonlinear constitutive law in the variable stress_strain_tensor, as well as the stress-strain tensor of the linearized problem in stress_strain_tensor_linearized. See PlasticityContactProblem::assemble_nl_system where this function is used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::get_linearized_stress_strain_tensors(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor =</div><div class="line">    (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">  stress_strain_tensor            = stress_strain_tensor_mu;</div><div class="line">  stress_strain_tensor_linearized = stress_strain_tensor_mu;</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = <a class="code" href="classSymmetricTensor.html#a6e7fd34dd28fc3f6420068887a939753">deviator</a>(stress_tensor);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">      stress_strain_tensor_linearized *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">      deviator_stress_tensor /= deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor_linearized -=</div><div class="line">        (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta * 2 * mu *</div><div class="line">        <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(deviator_stress_tensor, deviator_stress_tensor);</div><div class="line">    }</div><div class="line"></div><div class="line">  stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line">  stress_strain_tensor_linearized += stress_strain_tensor_kappa;</div><div class="line">}</div></div><!-- fragment --><h3>Equation data: boundary forces, boundary values, obstacles</h3>
<p>The following should be relatively standard. We need classes for the boundary forcing term (which we here choose to be zero) and boundary values on those part of the boundary that are not part of the contact surface (also chosen to be zero here).</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryForce();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoundaryForce&lt;dim&gt;::BoundaryForce()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryForce&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryForce&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryForce&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoundaryValues&lt;dim&gt;::BoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.;</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="ThecodeSphereObstaclecodeclass"></a> </p><h4>The <code>SphereObstacle</code> class</h4>
<p>The following class is the first of two obstacles that can be selected from the input file. It describes a sphere centered at position \(x=y=0.5, z=z_{\text{surface}}+0.59\) and radius \(r=0.6\), where \(z_{\text{surface}}\) is the vertical position of the (flat) surface of the deformable body. The function's <code>value</code> returns the location of the obstacle for a given \(x,y\) value if the point actually lies below the sphere, or a large positive value that can't possibly interfere with the deformation if it lies outside the "shadow" of the sphere.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SphereObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SphereObstacle&lt;dim&gt;::SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface)</div><div class="line">  : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  , z_surface(z_surface)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SphereObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> p(0);</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 1)</div><div class="line">    <span class="keywordflow">return</span> p(1);</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> ((p(0) - 0.5) * (p(0) - 0.5) + (p(1) - 0.5) * (p(1) - 0.5) &lt; 0.36)</div><div class="line">        <span class="keywordflow">return</span> (-std::sqrt(0.36 - (p(0) - 0.5) * (p(0) - 0.5) -</div><div class="line">                           (p(1) - 0.5) * (p(1) - 0.5)) +</div><div class="line">                z_surface + 0.59);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 1000;</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div></div><!-- fragment --><p>preceding Assert</p>
<div class="fragment"><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SphereObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SphereObstacle&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeBitmapFilecodeandcodeChineseObstaclecodeclasses"></a> </p><h4>The <code>BitmapFile</code> and <code>ChineseObstacle</code> classes</h4>
<p>The following two classes describe the obstacle outlined in the introduction, i.e., the Chinese character. The first of the two, <code>BitmapFile</code> is responsible for reading in data from a picture file stored in pbm ascii format. This data will be bilinearly interpolated and thereby provides a function that describes the obstacle. (The code below shows how one can construct a function by interpolating between given data points. One could use the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a>, introduced after this tutorial program was written, which does exactly what we want here, but it is instructive to see how to do it by hand.)</p>
<p>The data which we read from the file will be stored in a double std::vector named obstacle_data. This vector composes the base to calculate a piecewise bilinear function as a polynomial interpolation. The data we will read from a file consists of zeros (white) and ones (black).</p>
<p>The <code>hx,hy</code> variables denote the spacing between pixels in \(x\) and \(y\) directions. <code>nx,ny</code> are the numbers of pixels in each of these directions. <code>get_value()</code> returns the value of the image at a given location, interpolated from the adjacent pixel values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BitmapFile</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BitmapFile(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;double&gt; obstacle_data;</div><div class="line">  <span class="keywordtype">double</span>              hx, hy;</div><div class="line">  <span class="keywordtype">int</span>                 nx, ny;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of this class reads in the data that describes the obstacle from the given file name.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BitmapFile&lt;dim&gt;::BitmapFile(<span class="keyword">const</span> std::string &amp;name)</div><div class="line">  : obstacle_data(0)</div><div class="line">  , hx(0)</div><div class="line">  , hy(0)</div><div class="line">  , nx(0)</div><div class="line">  , ny(0)</div><div class="line">{</div><div class="line">  std::ifstream f(name);</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(f,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Can&#39;t read from file &lt;&quot;</span>) + name +</div><div class="line">                         <span class="stringliteral">&quot;&gt;!&quot;</span>));</div><div class="line"></div><div class="line">  std::string temp;</div><div class="line">  f &gt;&gt; temp &gt;&gt; nx &gt;&gt; ny;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(nx &gt; 0 &amp;&amp; ny &gt; 0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid file format.&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nx * ny; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> val;</div><div class="line">      f &gt;&gt; val;</div><div class="line">      obstacle_data.push_back(val);</div><div class="line">    }</div><div class="line"></div><div class="line">  hx = 1.0 / (nx - 1);</div><div class="line">  hy = 1.0 / (ny - 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Read obstacle from file &lt;&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Resolution of the scanned obstacle picture: &quot;</span> &lt;&lt; nx</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; ny &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The following two functions return the value of a given pixel with coordinates \(i,j\), which we identify with the values of a function defined at positions <code>i*hx, j*hy</code>, and at arbitrary coordinates \(x,y\) where we do a bilinear interpolation between point values returned by the first of the two functions. In the second function, for each \(x,y\), we first compute the (integer) location of the nearest pixel coordinate to the bottom left of \(x,y\), and then compute the coordinates \(\xi,\eta\) within this pixel. We truncate both kinds of variables from both below and above to avoid problems when evaluating the function outside of its defined range as may happen due to roundoff errors.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  assert(i &gt;= 0 &amp;&amp; i &lt; nx);</div><div class="line">  assert(j &gt;= 0 &amp;&amp; j &lt; ny);</div><div class="line">  <span class="keywordflow">return</span> obstacle_data[nx * (ny - 1 - j) + i];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> ix = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(x / hx), 0), nx - 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> iy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(y / hy), 0), ny - 2);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> xi  = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((x - ix * hx) / hx, 1.), 0.);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> eta = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((y - iy * hy) / hy, 1.), 0.);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +</div><div class="line">          xi * (1 - eta) * get_pixel_value(ix + 1, iy) +</div><div class="line">          (1 - xi) * eta * get_pixel_value(ix, iy + 1) +</div><div class="line">          xi * eta * get_pixel_value(ix + 1, iy + 1));</div><div class="line">}</div></div><!-- fragment --><p>Finally, this is the class that actually uses the class above. It has a BitmapFile object as a member that describes the height of the obstacle. As mentioned above, the BitmapFile class will provide us with a mask, i.e., values that are either zero or one (and, if you ask for locations between pixels, values that are interpolated between zero and one). This class translates this to heights that are either 0.001 below the surface of the deformable body (if the BitmapFile class reports a one at this location) or 0.999 above the obstacle (if the BitmapFile class reports a zero). The following function should then be self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ChineseObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename, <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> BitmapFile&lt;dim&gt; input_obstacle;</div><div class="line">  <span class="keywordtype">double</span>                z_surface;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ChineseObstacle&lt;dim&gt;::ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">double</span>       z_surface)</div><div class="line">  : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  , input_obstacle(filename)</div><div class="line">  , z_surface(z_surface)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ChineseObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> p(0);</div><div class="line">  <span class="keywordflow">if</span> (component == 1)</div><div class="line">    <span class="keywordflow">return</span> p(1);</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt;= 1.0 &amp;&amp; p(1) &gt;= 0.0 &amp;&amp; p(1) &lt;= 1.0)</div><div class="line">        <span class="keywordflow">return</span> z_surface + 0.999 - input_obstacle.get_value(p(0), p(1));</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div></div><!-- fragment --><p>preceding Assert</p>
<div class="fragment"><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ChineseObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                          <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = ChineseObstacle&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --><p><a class="anchor" id="ThecodePlasticityContactProblemcodeclasstemplate"></a> </p><h3>The <code>PlasticityContactProblem</code> class template</h3>
<p>This is the main class of this program and supplies all functions and variables needed to describe the nonlinear contact problem. It is close to <a class="el" href="step_41.html">step-41</a> but with some additional features like handling hanging nodes, a Newton method, using Trilinos and p4est for parallel distributed computing. To deal with hanging nodes makes life a bit more complicated since we need another <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object now. We create a Newton method for the active set method for the contact situation and to handle the nonlinear operator for the constitutive law.</p>
<p>The general layout of this class is very much like for most other tutorial programs. To make our life a bit easier, this class reads a set of input parameters from an input file. These parameters, using the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, are declared in the <code>declare_parameters</code> function (which is static so that it can be called before we even create an object of the current type), and a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that has been used to read an input file will then be passed to the constructor of this class.</p>
<p>The remaining member functions are by and large as we have seen in several of the other tutorial programs, though with additions for the current nonlinear system. We will comment on their purpose as we get to them further below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PlasticityContactProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PlasticityContactProblem(<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> compute_dirichlet_constraints();</div><div class="line">  <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">       assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">  <span class="keywordtype">void</span> assemble_newton_system(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">  <span class="keywordtype">void</span> compute_nonlinear_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">  <span class="keywordtype">void</span> solve_newton_system();</div><div class="line">  <span class="keywordtype">void</span> solve_newton();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> move_mesh(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_contact_force() <span class="keyword">const</span>;</div></div><!-- fragment --><p>As far as member variables are concerned, we start with ones that we use to indicate the MPI universe this program runs on, a stream we use to let exactly one processor produce output to the console (see <a class="el" href="step_17.html">step-17</a>) and a variable that is used to time the various sections of the program:</p>
<div class="fragment"><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a>           mpi_communicator;</div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer;</div></div><!-- fragment --><p>The next group describes the mesh and the finite element space. In particular, for this parallel program, the finite element space has associated with it variables that indicate which degrees of freedom live on the current processor (the index sets, see also <a class="el" href="step_40.html">step-40</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> documentation module) as well as a variety of constraints: those imposed by hanging nodes, by Dirichlet boundary conditions, and by the active set of contact nodes. Of the three <a class="el" href="classAffineConstraints.html">AffineConstraints</a> variables defined here, the first only contains hanging node constraints, the second also those associated with Dirichlet boundary conditions, and the third these plus the contact constraints.</p>
<p>The variable <code>active_set</code> consists of those degrees of freedom constrained by the contact, and we use <code>fraction_of_plastic_q_points_per_cell</code> to keep track of the fraction of quadrature points on each cell where the stress equals the yield stress. The latter is only used to create graphical output showing the plastic zone, but not for any further computation; the variable is a member variable of this class since the information is computed as a by-product of computing the residual, but is used only much later. (Note that the vector is a vector of length equal to the number of active cells on the <em>local mesh</em>; it is never used to exchange information between processors and can therefore be a regular deal.II vector.)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                        n_initial_global_refinements;</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_hanging_nodes;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_dirichlet_and_hanging_nodes;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> all_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>      active_set;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> fraction_of_plastic_q_points_per_cell;</div></div><!-- fragment --><p>The next block of variables corresponds to the solution and the linear systems we need to form. In particular, this includes the Newton matrix and right hand side; the vector that corresponds to the residual (i.e., the Newton right hand side) but from which we have not eliminated the various constraints and that is used to determine which degrees of freedom need to be constrained in the next iteration; and a vector that corresponds to the diagonal of the \(B\) matrix briefly mentioned in the introduction and discussed in the accompanying paper.</p>
<div class="fragment"><div class="line">TrilinosWrappers::SparseMatrix newton_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs_uncondensed;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector;</div></div><!-- fragment --><p>The next block contains the variables that describe the material response:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         e_modulus, nu, <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>, sigma_0;</div><div class="line">ConstitutiveLaw&lt;dim&gt; constitutive_law;</div></div><!-- fragment --><p>And then there is an assortment of other variables that are used to identify the mesh we are asked to build as selected by the parameter file, the obstacle that is being pushed into the deformable body, the mesh refinement strategy, whether to transfer the solution from one mesh to the next, and how many mesh refinement cycles to perform. As possible, we mark these kinds of variables as <code>const</code> to help the reader identify which ones may or may not be modified later on (the output directory being an exception &ndash; it is never modified outside the constructor but it is awkward to initialize in the member-initializer-list following the colon in the constructor since there we have only one shot at setting it; the same is true for the mesh refinement criterion):</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string                          base_mesh;</div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;const Function&lt;dim&gt;&gt; obstacle;</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>RefinementStrategy</div><div class="line">  {</div><div class="line">    <span class="keyword">enum</span> value</div><div class="line">    {</div><div class="line">      refine_global,</div><div class="line">      refine_percentage,</div><div class="line">      refine_fix_dofs</div><div class="line">    };</div><div class="line">  };</div><div class="line">  <span class="keyword">typename</span> RefinementStrategy::value refinement_strategy;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span>         transfer_solution;</div><div class="line">  std::string        output_dir;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_cycles;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       current_refinement_cycle;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodePlasticityContactProblemcodeclass"></a> </p><h3>Implementation of the <code>PlasticityContactProblem</code> class</h3>
<p><a class="anchor" id="PlasticityContactProblemdeclare_parameters"></a> </p><h4>PlasticityContactProblem::declare_parameters</h4>
<p>Let us start with the declaration of run-time parameters that can be selected in the input file. These values will be read back in the constructor of this class to initialize the member variables of this class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;polynomial degree&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">    <span class="stringliteral">&quot;Polynomial degree of the FE_Q finite element space, typically 1 or 2.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of initial refinements&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Number of initial global mesh refinement steps before &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;the first computation.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;refinement strategy&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;percentage&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;global|percentage&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;Mesh refinement strategy:\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot; global: one global refinement\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot; percentage: a fixed percentage of cells gets refined using the Kelly estimator.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of cycles&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Number of adaptive mesh refinement cycles to run.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;obstacle&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;sphere&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;sphere|read from file&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;The name of the obstacle to use. This may either be &#39;sphere&#39; if we should &quot;</span></div><div class="line">    <span class="stringliteral">&quot;use a spherical obstacle, or &#39;read from file&#39; in which case the obstacle &quot;</span></div><div class="line">    <span class="stringliteral">&quot;will be read from a file named &#39;obstacle.pbm&#39; that is supposed to be in &quot;</span></div><div class="line">    <span class="stringliteral">&quot;ASCII PBM format.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;output directory&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">    <span class="stringliteral">&quot;Directory for output files (graphical output and benchmark &quot;</span></div><div class="line">    <span class="stringliteral">&quot;statistics). If empty, use the current directory.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;transfer solution&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">    <span class="stringliteral">&quot;Whether the solution should be used as a starting guess &quot;</span></div><div class="line">    <span class="stringliteral">&quot;for the next finer mesh. If false, then the iteration starts at &quot;</span></div><div class="line">    <span class="stringliteral">&quot;zero on every mesh.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;base mesh&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;box&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;box|half sphere&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Select the shape of the domain: &#39;box&#39; or &#39;half sphere&#39;&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodePlasticityContactProblemcodeconstructor"></a> </p><h4>The <code>PlasticityContactProblem</code> constructor</h4>
<p>Given the declarations of member variables as well as the declarations of run-time parameters that are read from the input file, there is nothing surprising in this constructor. In the body we initialize the mesh refinement strategy and the output directory, creating such a directory if necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PlasticityContactProblem&lt;dim&gt;::PlasticityContactProblem(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">          (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">  , computing_timer(MPI_COMM_WORLD,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line"></div><div class="line">  , n_initial_global_refinements(</div><div class="line">      prm.get_integer(<span class="stringliteral">&quot;number of initial refinements&quot;</span>))</div><div class="line">  , triangulation(mpi_communicator)</div><div class="line">  , fe_degree(prm.get_integer(<span class="stringliteral">&quot;polynomial degree&quot;</span>))</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree + 1)), dim)</div><div class="line">  , dof_handler(triangulation)</div><div class="line"></div><div class="line">  , e_modulus(200000)</div><div class="line">  , nu(0.3)</div><div class="line">  , gamma(0.01)</div><div class="line">  , sigma_0(400.0)</div><div class="line">  , constitutive_law(e_modulus, nu, sigma_0, gamma)</div><div class="line"></div><div class="line">  , base_mesh(prm.get(<span class="stringliteral">&quot;base mesh&quot;</span>))</div><div class="line">  , obstacle(prm.get(<span class="stringliteral">&quot;obstacle&quot;</span>) == <span class="stringliteral">&quot;read from file&quot;</span> ?</div><div class="line">               static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                 new EquationData::ChineseObstacle&lt;dim&gt;(</div><div class="line">                   <span class="stringliteral">&quot;obstacle.pbm&quot;</span>,</div><div class="line">                   (base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5))) :</div><div class="line">               static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                 new EquationData::SphereObstacle&lt;dim&gt;(</div><div class="line">                   base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5)))</div><div class="line"></div><div class="line">  , transfer_solution(prm.get_bool(<span class="stringliteral">&quot;transfer solution&quot;</span>))</div><div class="line">  , n_refinement_cycles(prm.get_integer(<span class="stringliteral">&quot;number of cycles&quot;</span>))</div><div class="line">  , current_refinement_cycle(0)</div><div class="line"></div><div class="line">{</div><div class="line">  std::string strat = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;refinement strategy&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">    refinement_strategy = RefinementStrategy::refine_global;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;percentage&quot;</span>)</div><div class="line">    refinement_strategy = RefinementStrategy::refine_percentage;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  output_dir = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;output directory&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (output_dir != <span class="stringliteral">&quot;&quot;</span> &amp;&amp; *(output_dir.rbegin()) != <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">    output_dir += <span class="stringliteral">&quot;/&quot;</span>;</div></div><!-- fragment --><p>If necessary, create a new directory for the output.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> ierr = mkdir(output_dir.c_str(), 0777);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(ierr == 0 || errno == EEXIST, <a class="code" href="group__Exceptions.html#gac29b5f3efd2b164642b8e0c49ad3ad27">ExcIO</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Using output directory &#39;&quot;</span> &lt;&lt; output_dir &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    FE degree &quot;</span> &lt;&lt; fe_degree &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    transfer solution &quot;</span> &lt;&lt; (transfer_solution ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>)</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemmake_grid"></a> </p><h4>PlasticityContactProblem::make_grid</h4>
<p>The next block deals with constructing the starting mesh. We will use the following helper function and the first block of the <code>make_grid()</code> to construct a mesh that corresponds to a half sphere. deal.II has a function that creates such a mesh, but it is in the wrong location and facing the wrong direction, so we need to shift and rotate it a bit before using it.</p>
<p>For later reference, as described in the documentation of <a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball()</a>, the flat surface of the halfsphere has boundary indicator zero, while the remainder has boundary indicator one.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> rotate_half_sphere(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;in)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> {in(2), in(1), -in(0)};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;half sphere&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0, 0, 0);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>     radius = 0.8;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(triangulation, center, radius);</div></div><!-- fragment --><p>Since we will attach a different manifold below, we immediately clear the default manifold description:</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;rotate_half_sphere, triangulation);</div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5), triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5));</div><div class="line">  <a class="code" href="namespaceGridTools.html#aa92034313ef924778e01beb3e24002dd">GridTools::copy_boundary_to_manifold_id</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, manifold_description);</div><div class="line">}</div></div><!-- fragment --><p>Alternatively, create a hypercube mesh. After creating it, assign boundary indicators as follows: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">&gt;     _______</div><div class="line">&gt;    /  1    /|</div><div class="line">&gt;   /______ / |</div><div class="line">&gt;  |       | 8|</div><div class="line">&gt;  |   8   | /</div><div class="line">&gt;  |_______|/</div><div class="line">&gt;      6</div></div><!-- fragment --> </div><p> In other words, the boundary indicators of the sides of the cube are 8. The boundary indicator of the bottom is 6 and the top has indicator 1. We set these by looping over all cells of all faces and looking at coordinate values of the cell center, and will make use of these indicators later when evaluating which boundary will carry Dirichlet boundary conditions or will be subject to potential contact. (In the current case, the mesh contains only a single cell, and all of its faces are on the boundary, so both the loop over all cells and the query whether a face is on the boundary are, strictly speaking, unnecessary; we retain them simply out of habit: this kind of code can be found in many programs in essentially this form.)</p>
<div class="fragment"><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1(0, 0, 0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p2(1.0, 1.0, 1.0);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation, p1, p2);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p2[2]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(1);</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p1[0]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p2[0]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p1[1]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p2[1]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(8);</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p1[2]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(6);</div><div class="line">            }</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsetup_system"></a> </p><h4>PlasticityContactProblem::setup_system</h4>
<p>The next piece in the puzzle is to set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, resize vectors and take care of various other status variables such as index sets and constraint matrices.</p>
<p>In the following, each group of operations is put into a brace-enclosed block that is being timed by the variable declared at the top of the block (the constructor of the <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable starts the timed section, the destructor that is called at the end of the block stops it again).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="comment">// setup dofs and get index sets for locally owned and relevant dofs </span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: distribute DoFs&quot;</span>);</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">    locally_relevant_dofs.<a class="code" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a>();</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler,</div><div class="line">                                            locally_relevant_dofs);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// setup hanging nodes and Dirichlet constraints </span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: constraints&quot;</span>);</div><div class="line">    constraints_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            constraints_hanging_nodes);</div><div class="line">    constraints_hanging_nodes.close();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    compute_dirichlet_constraints();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// initialization of vectors and the active set </span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: vectors&quot;</span>);</div><div class="line">    solution.reinit(locally_relevant_dofs, mpi_communicator);</div><div class="line">    newton_rhs.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    fraction_of_plastic_q_points_per_cell.reinit(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    active_set.clear();</div><div class="line">    active_set.set_size(dof_handler.n_dofs());</div><div class="line">  }</div></div><!-- fragment --><p>Finally, we set up sparsity patterns and matrices. We temporarily (ab)use the system matrix to also build the (diagonal) matrix that we use in eliminating degrees of freedom that are in contact with the obstacle, but we then immediately set the Newton matrix back to zero.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>                t(computing_timer, <span class="stringliteral">&quot;Setup: matrix&quot;</span>);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(locally_owned_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                    sp,</div><div class="line">                                    constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                    <span class="keyword">false</span>,</div><div class="line">                                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                      mpi_communicator));</div><div class="line">    sp.compress();</div><div class="line">    newton_matrix.reinit(sp);</div><div class="line"></div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix = newton_matrix;</div><div class="line"></div><div class="line">    assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start = (newton_rhs.local_range().first),</div><div class="line">                       end   = (newton_rhs.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = start; j &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++j)</div><div class="line">      diag_mass_matrix_vector(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">    diag_mass_matrix_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    mass_matrix = 0;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_dirichlet_constraints"></a> </p><h4>PlasticityContactProblem::compute_dirichlet_constraints</h4>
<p>This function, broken out of the preceding one, computes the constraints associated with Dirichlet-type boundary conditions and puts them into the <code>constraints_dirichlet_and_hanging_nodes</code> variable by merging with the constraints that come from hanging nodes.</p>
<p>As laid out in the introduction, we need to distinguish between two cases:</p><ul>
<li>If the domain is a box, we set the displacement to zero at the bottom, and allow vertical movement in z-direction along the sides. As shown in the <code>make_grid()</code> function, the former corresponds to boundary indicator 6, the latter to 8.</li>
<li>If the domain is a half sphere, then we impose zero displacement along the curved part of the boundary, associated with boundary indicator zero.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_dirichlet_constraints()</div><div class="line">{</div><div class="line">  constraints_dirichlet_and_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">  constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">    {</div></div><!-- fragment --><p>interpolate all components of the solution</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">  dof_handler,</div><div class="line">  6,</div><div class="line">  EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">  constraints_dirichlet_and_hanging_nodes,</div><div class="line">  <a class="code" href="classComponentMask.html">ComponentMask</a>());</div></div><!-- fragment --><p>interpolate x- and y-components of the solution (this is a bit mask, so apply operator| )</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        8,</div><div class="line">        EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">        constraints_dirichlet_and_hanging_nodes,</div><div class="line">        (fe.component_mask(x_displacement) |</div><div class="line">         fe.component_mask(y_displacement)));</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      dof_handler,</div><div class="line">      0,</div><div class="line">      EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">      constraints_dirichlet_and_hanging_nodes,</div><div class="line">      <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">  constraints_dirichlet_and_hanging_nodes.close();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemassemble_mass_matrix_diagonal"></a> </p><h4>PlasticityContactProblem::assemble_mass_matrix_diagonal</h4>
<p>The next helper function computes the (diagonal) mass matrix that is used to determine the active set of the active set method we use in the contact algorithm. This matrix is of mass matrix type, but unlike the standard mass matrix, we can make it diagonal (even in the case of higher order elements) by using a quadrature formula that has its quadrature points at exactly the same locations as the interpolation points for the finite element are located. We achieve this by using a <a class="el" href="classQGaussLobatto.html">QGaussLobatto</a> quadrature formula here, along with initializing the finite element with a set of interpolation points derived from the same quadrature formula. The remainder of the function is relatively straightforward: we put the resulting matrix into the given argument; because we know the matrix is diagonal, it is sufficient to have a loop over only \(i\) and not over \(j\). Strictly speaking, we could even avoid multiplying the shape function's values at quadrature point <code>q_point</code> by itself because we know the shape value to be a vector with exactly one one which when dotted with itself yields one. Since this function is not time critical we add this term for clarity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">  TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">{</div><div class="line">  <a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">          {</div><div class="line">            fe_values_face.reinit(cell, face);</div><div class="line">            cell_matrix = 0;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                 ++q_point)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">                  (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                   fe_values_face[displacement].value(i, q_point) *</div><div class="line">                   fe_values_face.JxW(q_point));</div><div class="line"></div><div class="line">            cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a>(local_dof_indices[i],</div><div class="line">                              local_dof_indices[i],</div><div class="line">                              cell_matrix(i, i));</div><div class="line">          }</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemupdate_solution_and_constraints"></a> </p><h4>PlasticityContactProblem::update_solution_and_constraints</h4>
<p>The following function is the first function we call in each Newton iteration in the <code>solve_newton()</code> function. What it does is to project the solution onto the feasible set and update the active set for the degrees of freedom that touch or penetrate the obstacle.</p>
<p>In order to function, we first need to do some bookkeeping: We need to write into the solution vector (which we can only do with fully distributed vectors without ghost elements) and we need to read the Lagrange multiplier and the elements of the diagonal mass matrix from their respective vectors (which we can only do with vectors that do have ghost elements), so we create the respective vectors. We then also initialize the constraints object that will contain constraints from contact and all other sources, as well as an object that contains an index set of all locally owned degrees of freedom that are part of the contact:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">{</div><div class="line">  std::vector&lt;bool&gt; dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">  distributed_solution = solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                       mpi_communicator);</div><div class="line">  lambda = newton_rhs_uncondensed;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector_relevant(</div><div class="line">    locally_relevant_dofs, mpi_communicator);</div><div class="line">  diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;</div><div class="line"></div><div class="line"></div><div class="line">  all_constraints.reinit(locally_relevant_dofs);</div><div class="line">  active_set.clear();</div></div><!-- fragment --><p>The second part is a loop over all cells in which we look at each point where a degree of freedom is defined whether the active set condition is true and we need to add this degree of freedom to the active set of contact nodes. As we always do, if we want to evaluate functions at individual points, we do this with an <a class="el" href="classFEValues.html">FEValues</a> object (or, here, an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object since we need to check contact at the surface) with an appropriately chosen quadrature object. We create this face quadrature object by choosing the "support points" of the shape functions defined on the faces of cells (for more on support points, see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>). As a consequence, we have as many quadrature points as there are shape functions per face and looping over quadrature points is equivalent to looping over shape functions defined on a face. With this, the code looks as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim - 1&gt; face_quadrature(fe.get_unit_face_support_points());</div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>   fe_values_face(fe,</div><div class="line">                                 face_quadrature,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_face   = fe.n_dofs_per_face();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature.size();</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; dof_indices(dofs_per_face);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (!cell-&gt;is_artificial())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">        {</div><div class="line">          fe_values_face.reinit(cell, face);</div><div class="line">          face-&gt;get_dof_indices(dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">               ++q_point)</div><div class="line">            {</div></div><!-- fragment --><p>At each quadrature point (i.e., at each support point of a degree of freedom located on the contact boundary), we then ask whether it is part of the z-displacement degrees of freedom and if we haven't encountered this degree of freedom yet (which can happen for those on the edges between faces), we need to evaluate the gap between the deformed object and the obstacle. If the active set condition is true, then we add a constraint to the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object that the next Newton update needs to satisfy, set the solution vector's corresponding element to the correct value, and add the index to the <a class="el" href="classIndexSet.html">IndexSet</a> object that stores which degree of freedom is part of the contact:</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component =</div><div class="line">        fe.face_system_to_component_index(q_point).first;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_z = dof_indices[q_point];</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((component == 2) &amp;&amp; (dof_touched[index_z] == <span class="keyword">false</span>))</div><div class="line">        {</div><div class="line">          dof_touched[index_z] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> this_support_point =</div><div class="line">            fe_values_face.quadrature_point(q_point);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value =</div><div class="line">            obstacle-&gt;value(this_support_point, 2);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> solution_here = solution(index_z);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> undeformed_gap =</div><div class="line">            obstacle_value - this_support_point(2);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> c = 100.0 * e_modulus;</div><div class="line">          <span class="keywordflow">if</span> ((lambda(index_z) /</div><div class="line">                   diag_mass_matrix_vector_relevant(index_z) +</div><div class="line">                 c * (solution_here - undeformed_gap) &gt;</div><div class="line">               0) &amp;&amp;</div><div class="line">              !constraints_hanging_nodes.is_constrained(index_z))</div><div class="line">            {</div><div class="line">              all_constraints.add_line(index_z);</div><div class="line">              all_constraints.set_inhomogeneity(index_z,</div><div class="line">                                                undeformed_gap);</div><div class="line">              distributed_solution(index_z) = undeformed_gap;</div><div class="line"></div><div class="line">              active_set.add_index(index_z);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>At the end of this function, we exchange data between processors updating those ghost elements in the <code>solution</code> variable that have been written by other processors. We then merge the Dirichlet constraints and those from hanging nodes into the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object that already contains the active set. We finish the function by outputting the total number of actively constrained degrees of freedom for which we sum over the number of actively constrained degrees of freedom owned by each of the processors. This number of locally owned constrained degrees of freedom is of course the number of elements of the intersection of the active set and the set of locally owned degrees of freedom, which we can get by using <code>operator&amp;</code> on two IndexSets:</p>
<div class="fragment"><div class="line">  distributed_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  solution = distributed_solution;</div><div class="line"></div><div class="line">  all_constraints.close();</div><div class="line">  all_constraints.merge(constraints_dirichlet_and_hanging_nodes);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;         Size of active set: &quot;</span></div><div class="line">        &lt;&lt; <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set &amp; locally_owned_dofs).n_elements(),</div><div class="line">                               mpi_communicator)</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemassemble_newton_system"></a> </p><h4>PlasticityContactProblem::assemble_newton_system</h4>
<p>Given the complexity of the problem, it may come as a bit of a surprise that assembling the linear system we have to solve in each Newton iteration is actually fairly straightforward. The following function builds the Newton right hand side and Newton matrix. It looks fairly innocent because the heavy lifting happens in the call to <code>ConstitutiveLaw::get_linearized_stress_strain_tensors()</code> and in particular in <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, using the constraints we have previously computed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_newton_system(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assembling&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensor(n_q_points);</div><div class="line">        fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">          linearization_point, strain_tensor);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">            constitutive_law.get_linearized_stress_strain_tensors(</div><div class="line">              strain_tensor[q_point],</div><div class="line">              stress_strain_tensor_linearized,</div><div class="line">              stress_strain_tensor);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div></div><!-- fragment --><p>Having computed the stress-strain tensor and its linearization, we can now put together the parts of the matrix and right hand side. In both, we need the linearized stress-strain tensor times the symmetric gradient of \(\varphi_i\), i.e. the term \(I_\Pi\varepsilon(\varphi_i)\), so we introduce an abbreviation of this term. Recall that the matrix corresponds to the bilinear form \(A_{ij}=(I_\Pi\varepsilon(\varphi_i),\varepsilon(\varphi_j))\) in the notation of the accompanying publication, whereas the right hand side is \(F_i=([I_\Pi-P_\Pi C]\varepsilon(\varphi_i),\varepsilon(\mathbf u))\) where \(u\) is the current linearization points (typically the last solution). This might suggest that the right hand side will be zero if the material is completely elastic (where \(I_\Pi=P_\Pi\)) but this ignores the fact that the right hand side will also contain contributions from non-homogeneous constraints due to the contact.</p>
<p>The code block that follows this adds contributions that are due to boundary forces, should there be any.</p>
<div class="fragment"><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_phi_i =</div><div class="line">                  stress_strain_tensor_linearized *</div><div class="line">                  fe_values[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (stress_phi_i *</div><div class="line">                     fe_values[displacement].symmetric_gradient(j, q_point) *</div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  ((stress_phi_i -</div><div class="line">                    stress_strain_tensor *</div><div class="line">                      fe_values[displacement].symmetric_gradient(i,</div><div class="line">                                                                 q_point)) *</div><div class="line">                   strain_tensor[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              boundary_force.vector_value_list(</div><div class="line">                fe_values_face.get_quadrature_points(),</div><div class="line">                boundary_force_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) +=</div><div class="line">                      (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                       rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        all_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                   cell_rhs,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   newton_matrix,</div><div class="line">                                                   newton_rhs,</div><div class="line">                                                   <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line"></div><div class="line">  newton_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_nonlinear_residual"></a> </p><h4>PlasticityContactProblem::compute_nonlinear_residual</h4>
<p>The following function computes the nonlinear residual of the equation given the current solution (or any other linearization point). This is needed in the linear search algorithm where we need to try various linear combinations of previous and current (trial) solution to compute the (real, globalized) solution of the current Newton step.</p>
<p>That said, in a slight abuse of the name of the function, it actually does significantly more. For example, it also computes the vector that corresponds to the Newton residual but without eliminating constrained degrees of freedom. We need this vector to compute contact forces and, ultimately, to compute the next active set. Likewise, by keeping track of how many quadrature points we encounter on each cell that show plastic yielding, we also compute the <code>fraction_of_plastic_q_points_per_cell</code> vector that we can later output to visualize the plastic zone. In both of these cases, the results are not necessary as part of the line search, and so we may be wasting a small amount of time computing them. At the same time, this information appears as a natural by-product of what we need to do here anyway, and we want to collect it once at the end of each Newton step, so we may as well do it here.</p>
<p>The actual implementation of this function should be rather obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_nonlinear_residual(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  newton_rhs             = 0;</div><div class="line">  newton_rhs_uncondensed = 0;</div><div class="line"></div><div class="line">  fraction_of_plastic_q_points_per_cell = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensors(n_q_points);</div><div class="line">        fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">          linearization_point, strain_tensors);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span>              q_point_is_plastic =</div><div class="line">              constitutive_law.get_stress_strain_tensor(</div><div class="line">                strain_tensors[q_point], stress_strain_tensor);</div><div class="line">            <span class="keywordflow">if</span> (q_point_is_plastic)</div><div class="line">              ++fraction_of_plastic_q_points_per_cell(</div><div class="line">                cell-&gt;active_cell_index());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                cell_rhs(i) -=</div><div class="line">                  (strain_tensors[q_point] * stress_strain_tensor *</div><div class="line">                   fe_values[displacement].symmetric_gradient(i, q_point) *</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                rhs_values = 0;</div><div class="line">                cell_rhs(i) += (fe_values[displacement].value(i, q_point) *</div><div class="line">                                rhs_values * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              boundary_force.vector_value_list(</div><div class="line">                fe_values_face.get_quadrature_points(),</div><div class="line">                boundary_force_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) +=</div><div class="line">                      (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                       rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(</div><div class="line">          cell_rhs, local_dof_indices, newton_rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line"></div><div class="line">  fraction_of_plastic_q_points_per_cell /= quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  newton_rhs_uncondensed.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsolve_newton_system"></a> </p><h4>PlasticityContactProblem::solve_newton_system</h4>
<p>The last piece before we can discuss the actual Newton iteration on a single mesh is the solver for the linear systems. There are a couple of complications that slightly obscure the code, but mostly it is just setup then solve. Among the complications are:</p>
<ul>
<li>For the hanging nodes we have to apply the <a class="el" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">AffineConstraints::set_zero</a> function to newton_rhs. This is necessary if a hanging node with solution value \(x_0\) has one neighbor with value \(x_1\) which is in contact with the obstacle and one neighbor \(x_2\) which is not in contact. Because the update for the former will be prescribed, the hanging node constraint will have an inhomogeneity and will look like \(x_0 = x_1/2 + \text{gap}/2\). So the corresponding entries in the right-hand-side are non-zero with a meaningless value. These values we have to set to zero.</li>
<li>Like in <a class="el" href="step_40.html">step-40</a>, we need to shuffle between vectors that do and do not have ghost elements when solving or using the solution.</li>
</ul>
<p>The rest of the function is similar to <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_41.html">step-41</a> except that we use a BiCGStab solver instead of CG. This is due to the fact that for very small hardening parameters \(\gamma\), the linear system becomes almost semidefinite though still symmetric. BiCGStab appears to have an easier time with such linear systems.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">  distributed_solution = solution;</div><div class="line"></div><div class="line">  constraints_hanging_nodes.set_zero(distributed_solution);</div><div class="line">  constraints_hanging_nodes.set_zero(newton_rhs);</div><div class="line"></div><div class="line">  TrilinosWrappers::PreconditionAMG preconditioner;</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: setup preconditioner&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(dof_handler,</div><div class="line">                                     <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                     constant_modes);</div><div class="line"></div><div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a>              = <span class="keyword">true</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a4a403dc7faf67ee0fcb6436d7b741687">n_cycles</a>              = 1;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a56500e96ab5ae9b84dd874b38283453b">w_cycle</a>               = <span class="keyword">false</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#ab9fc3e207a7c534094d514685e645c92">output_details</a>        = <span class="keyword">false</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a>       = 2;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 1e-2;</div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(newton_matrix, additional_data);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: iterate&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> relative_accuracy = 1e-8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance =</div><div class="line">      relative_accuracy *</div><div class="line">      newton_matrix.residual(tmp, distributed_solution, newton_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(newton_matrix.m(), solver_tolerance);</div><div class="line">    <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line">    solver.solve(newton_matrix,</div><div class="line">                 distributed_solution,</div><div class="line">                 newton_rhs,</div><div class="line">                 preconditioner);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;         Error: &quot;</span> &lt;&lt; solver_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; Bicgstab iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  all_constraints.distribute(distributed_solution);</div><div class="line"></div><div class="line">  solution = distributed_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsolve_newton"></a> </p><h4>PlasticityContactProblem::solve_newton</h4>
<p>This is, finally, the function that implements the damped Newton method on the current mesh. There are two nested loops: the outer loop for the Newton iteration and the inner loop for the line search which will be used only if necessary. To obtain a good and reasonable starting value we solve an elastic problem in the very first Newton step on each mesh (or only on the first mesh if we transfer solutions between meshes). We do so by setting the yield stress to an unreasonably large value in these iterations and then setting it back to the correct value in subsequent iterations.</p>
<p>Other than this, the top part of this function should be reasonably obvious. We initialize the variable <code>previous_residual_norm</code> to the most negative value representable with double precision numbers so that the comparison whether the current residual is less than that of the previous step will always fail in the first step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton()</div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_solution(locally_owned_dofs,</div><div class="line">                                             mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> residual(locally_owned_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp_vector(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_tmp_vector(</div><div class="line">    locally_relevant_dofs, mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> residual_norm;</div><div class="line">  <span class="keywordtype">double</span> previous_residual_norm = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> correct_sigma = sigma_0;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> old_active_set(active_set);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= 100; ++newton_step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (newton_step == 1 &amp;&amp;</div><div class="line">          ((transfer_solution &amp;&amp; current_refinement_cycle == 0) ||</div><div class="line">           !transfer_solution))</div><div class="line">        constitutive_law.set_sigma_0(1e+10);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == 2 || current_refinement_cycle &gt; 0 ||</div><div class="line">               !transfer_solution)</div><div class="line">        constitutive_law.set_sigma_0(correct_sigma);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Newton iteration &quot;</span> &lt;&lt; newton_step &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;update active set&quot;</span>);</div><div class="line">        update_solution_and_constraints();</div><div class="line">      }</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Assembling system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">      newton_matrix = 0;</div><div class="line">      newton_rhs    = 0;</div><div class="line">      assemble_newton_system(solution);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Solving system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">      solve_newton_system();</div></div><!-- fragment --><p>It gets a bit more hairy after we have computed the trial solution \(\tilde{\mathbf u}\) of the current Newton step. We handle a highly nonlinear problem so we have to damp Newton's method using a line search. To understand how we do this, recall that in our formulation, we compute a trial solution in each Newton step and not the update between old and new solution. Since the solution set is a convex set, we will use a line search that tries linear combinations of the previous and the trial solution to guarantee that the damped solution is in our solution set again. At most we apply 5 damping steps.</p>
<p>There are exceptions to when we use a line search. First, if this is the first Newton step on any mesh, then we don't have any point to compare the residual to, so we always accept a full step. Likewise, if this is the second Newton step on the first mesh (or the second on any mesh if we don't transfer solutions from mesh to mesh), then we have computed the first of these steps using just an elastic model (see how we set the yield stress sigma to an unreasonably large value above). In this case, the first Newton solution was a purely elastic one, the second one a plastic one, and any linear combination would not necessarily be expected to lie in the feasible set &ndash; so we just accept the solution we just got.</p>
<p>In either of these two cases, we bypass the line search and just update residual and other vectors as necessary.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((newton_step == 1) ||</div><div class="line">    (transfer_solution &amp;&amp; newton_step == 2 &amp;&amp;</div><div class="line">     current_refinement_cycle == 0) ||</div><div class="line">    (!transfer_solution &amp;&amp; newton_step == 2))</div><div class="line">  {</div><div class="line">    compute_nonlinear_residual(solution);</div><div class="line">    old_solution = solution;</div><div class="line"></div><div class="line">    residual                     = newton_rhs;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                       end_res   = (residual.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">      <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">        residual(n) = 0;</div><div class="line"></div><div class="line">    residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;      Accepting Newton solution with residual: &quot;</span></div><div class="line">          &lt;&lt; residual_norm &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)</div><div class="line">      {</div><div class="line">        distributed_solution = solution;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.5, static_cast&lt;double&gt;(i));</div><div class="line">        tmp_vector         = old_solution;</div><div class="line">        tmp_vector.sadd(1 - alpha, alpha, distributed_solution);</div><div class="line"></div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Residual and lambda&quot;</span>);</div><div class="line"></div><div class="line">        locally_relevant_tmp_vector = tmp_vector;</div><div class="line">        compute_nonlinear_residual(locally_relevant_tmp_vector);</div><div class="line">        residual = newton_rhs;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                           end_res   = (residual.local_range().second);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">          <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">            residual(n) = 0;</div><div class="line"></div><div class="line">        residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">        residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">        pcout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;      Residual of the non-contact part of the system: &quot;</span></div><div class="line">          &lt;&lt; residual_norm &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;         with a damping parameter alpha = &quot;</span> &lt;&lt; alpha</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (residual_norm &lt; previous_residual_norm)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    solution     = tmp_vector;</div><div class="line">    old_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line">previous_residual_norm = residual_norm;</div></div><!-- fragment --><p>The final step is to check for convergence. If the active set has not changed across all processors and the residual is less than a threshold of \(10^{-10}\), then we terminate the iteration on the current mesh:</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set == old_active_set) ? 0 : 1,</div><div class="line">                              mpi_communicator) == 0)</div><div class="line">        {</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;      Active set did not change!&quot;</span> &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">if</span> (residual_norm &lt; 1e-10)</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">      old_active_set = active_set;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemrefine_grid"></a> </p><h4>PlasticityContactProblem::refine_grid</h4>
<p>If you've made it this far into the deal.II tutorial, the following function refining the mesh should not pose any challenges to you any more. It refines the mesh, either globally or using the Kelly error estimator, and if so asked also transfers the solution from the previous to the next mesh. In the latter case, we also need to compute the active set and other quantities again, for which we need the information computed by <code>compute_nonlinear_residual()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (refinement_strategy == RefinementStrategy::refine_global)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">             triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">           cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">           ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 2),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number</a>(</div><div class="line">        triangulation, estimated_error_per_cell, 0.3, 0.03);</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">    solution_transfer(dof_handler);</div><div class="line">  <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  setup_system();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                         mpi_communicator);</div><div class="line">      solution_transfer.interpolate(distributed_solution);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">      constraints_hanging_nodes.distribute(distributed_solution);</div><div class="line"></div><div class="line">      solution = distributed_solution;</div><div class="line">      compute_nonlinear_residual(solution);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemmove_mesh"></a> </p><h4>PlasticityContactProblem::move_mesh</h4>
<p>The remaining three functions before we get to <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> have to do with generating output. The following one is an attempt at showing the deformed body in its deformed configuration. To this end, this function takes a displacement vector field and moves every vertex of the (local part) of the mesh by the previously computed displacement. We will call this function with the current displacement field before we generate graphical output, and we will call it again after generating graphical output with the negative displacement field to undo the changes to the mesh so made.</p>
<p>The function itself is pretty straightforward. All we have to do is keep track which vertices we have already touched, as we encounter the same vertices multiple times as we loop over cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::move_mesh(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">          {</div><div class="line">            vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              vertex_displacement[d] =</div><div class="line">                displacement(cell-&gt;vertex_dof_index(v, d));</div><div class="line"></div><div class="line">            cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">          }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemoutput_results"></a> </p><h4>PlasticityContactProblem::output_results</h4>
<p>Next is the function we use to actually generate graphical output. The function is a bit tedious, but not actually particularly complicated. It moves the mesh at the top (and moves it back at the end), then computes the contact forces along the contact surface. We can do so (as shown in the accompanying paper) by taking the untreated residual vector and identifying which degrees of freedom correspond to those with contact by asking whether they have an inhomogeneous constraints associated with them. As always, we need to be mindful that we can only write into completely distributed vectors (i.e., vectors without ghost elements) but that when we want to generate output, we need vectors that do indeed have ghost entries for all locally relevant degrees of freedom.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Graphical output&quot;</span>);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;      Writing graphical output... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  move_mesh(solution);</div></div><!-- fragment --><p>Calculation of the contact forces</p>
<div class="fragment"><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                 mpi_communicator);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                   end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">  <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">    distributed_lambda(n) =</div><div class="line">      newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                     mpi_communicator);</div><div class="line">lambda = distributed_lambda;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_active_set_vector(</div><div class="line">  locally_owned_dofs, mpi_communicator);</div><div class="line">distributed_active_set_vector = 0.;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">  distributed_active_set_vector[index] = 1.;</div><div class="line">distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(locally_relevant_dofs,</div><div class="line">                                                mpi_communicator);</div><div class="line">active_set_vector = distributed_active_set_vector;</div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  data_component_interpretation(</div><div class="line">    dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;displacement&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;contact_force&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;active_set&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">  subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fraction_of_plastic_q_points_per_cell,</div><div class="line">                         <span class="stringliteral">&quot;fraction_of_plastic_q_points&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div></div><!-- fragment --><p>In the remainder of the function, we generate one VTU file on every processor, indexed by the subdomain id of this processor. On the first processor, we then also create a <code>.pvtu</code> file that indexes <em>all</em> of the VTU files so that the entire set of output files can be read at once. These <code>.pvtu</code> are used by Paraview to describe an entire parallel computation's output files. We then do the same again for the competitor of Paraview, the VisIt visualization program, by creating a matching <code>.visit</code> file.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string pvtu_filename = data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    output_dir, <span class="stringliteral">&quot;solution&quot;</span>, current_refinement_cycle, mpi_communicator, 2);</div><div class="line">  pcout &lt;&lt; pvtu_filename &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(solution);</div><div class="line">  tmp *= -1;</div><div class="line">  move_mesh(tmp);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemoutput_contact_force"></a> </p><h4>PlasticityContactProblem::output_contact_force</h4>
<p>This last auxiliary function computes the contact force by calculating an integral over the contact pressure in z-direction over the contact area. For this purpose we set the contact pressure lambda to 0 for all inactive dofs (whether a degree of freedom is part of the contact is determined just as we did in the previous function). For all active dofs, lambda contains the quotient of the nonlinear residual (newton_rhs_uncondensed) and corresponding diagonal entry of the mass matrix (diag_mass_matrix_vector). Because it is not unlikely that hanging nodes show up in the contact area it is important to apply constraints_hanging_nodes.distribute to the distributed_lambda vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_contact_force()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                   mpi_communicator);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                     end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">    <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">      distributed_lambda(n) =</div><div class="line">        newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      distributed_lambda(n) = 0;</div><div class="line">  distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                       mpi_communicator);</div><div class="line">  lambda = distributed_lambda;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> contact_force = 0.0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">          {</div><div class="line">            fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">            std::vector&lt;Tensor&lt;1, dim&gt;&gt; lambda_values(n_face_q_points);</div><div class="line">            fe_values_face[displacement].get_function_values(lambda,</div><div class="line">                                                             lambda_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                 ++q_point)</div><div class="line">              contact_force +=</div><div class="line">                lambda_values[q_point][2] * fe_values_face.JxW(q_point);</div><div class="line">          }</div><div class="line">  contact_force = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(contact_force, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Contact force = &quot;</span> &lt;&lt; contact_force &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemrun"></a> </p><h4>PlasticityContactProblem::run</h4>
<p>As in all other tutorial programs, the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function contains the overall logic. There is not very much to it here: in essence, it performs the loops over all mesh refinement cycles, and within each, hands things over to the Newton solver in <code>solve_newton()</code> on the current mesh and calls the function that creates graphical output for the so-computed solution. It then outputs some statistics concerning both run times and memory consumption that has been collected over the course of computations on this mesh.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PlasticityContactProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    computing_timer.reset();</div><div class="line">    <span class="keywordflow">for</span> (; current_refinement_cycle &lt; n_refinement_cycles;</div><div class="line">         ++current_refinement_cycle)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup&quot;</span>);</div><div class="line"></div><div class="line">          pcout &lt;&lt; std::endl;</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; current_refinement_cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (current_refinement_cycle == 0)</div><div class="line">            {</div><div class="line">              make_grid();</div><div class="line">              setup_system();</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: refine mesh&quot;</span>);</div><div class="line">              refine_grid();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        solve_newton();</div><div class="line"></div><div class="line">        output_results(current_refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line"></div><div class="line">        <a class="code" href="structUtilities_1_1System_1_1MemoryStats.html">Utilities::System::MemoryStats</a> stats;</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#a25db0fc07c298b5bef3d6f738283bd6d">Utilities::System::get_memory_stats</a>(stats);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Peak virtual memory used, resident in kB: &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a9cb487ac1831b7e5836be93859c1c2af">VmSize</a></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a39901417b9e6ebfa36d05bfb8a282aa2">VmRSS</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">          output_contact_force();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step42</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>There really isn't much to the <code>main()</code> function. It looks like they always do:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>Step42;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      PlasticityContactProblem&lt;3&gt;::declare_parameters(prm);</div><div class="line">      <span class="keywordflow">if</span> (argc != 2)</div><div class="line">        {</div><div class="line">          std::cerr &lt;&lt; <span class="stringliteral">&quot;*** Call this program as &lt;./step-42 input.prm&gt;&quot;</span></div><div class="line">                    &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(argv[1]);</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line">      {</div><div class="line">        PlasticityContactProblem&lt;3&gt; problem(prm);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The directory that contains this program also contains a number of input parameter files that can be used to create various different simulations. For example, running the program with the <code>p1_adaptive.prm</code> parameter file (using a ball as obstacle and the box as domain) on 16 cores produces output like this: </p><div class="fragment"><div class="line">    Using output directory <span class="stringliteral">&#39;p1adaptive/&#39;</span></div><div class="line">    FE degree 1</div><div class="line">    transfer solution <span class="keyword">false</span></div><div class="line"></div><div class="line">Cycle 0:</div><div class="line">   Number of active cells: 512</div><div class="line">   Number of degrees of freedom: 2187</div><div class="line"></div><div class="line">  Newton iteration 1</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 1</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 173.076 -&gt; 1.64265e-06 in 7 Bicgstab iterations.</div><div class="line">      Accepting Newton solution with residual: 1.64265e-06</div><div class="line"></div><div class="line">   Newton iteration 2</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 1</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 57.3622 -&gt; 3.23721e-07 in 8 Bicgstab iterations.</div><div class="line">      Accepting Newton solution with residual: 24.9028</div><div class="line">      Active <span class="keyword">set</span> did not change!</div><div class="line"></div><div class="line">   Newton iteration 3</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 1</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 24.9028 -&gt; 9.94326e-08 in 7 Bicgstab iterations.</div><div class="line">      Residual of the non-contact part of the system: 1.63333</div><div class="line">         with a damping parameter alpha = 1</div><div class="line">      Active <span class="keyword">set</span> did not change!</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">  Newton iteration 6</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 1</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 1.43188e-07 -&gt; 3.56218e-16 in 8 Bicgstab iterations.</div><div class="line">      Residual of the non-contact part of the system: 4.298e-14</div><div class="line">         with a damping parameter alpha = 1</div><div class="line">      Active <span class="keyword">set</span> did not change!</div><div class="line">      Writing graphical output... p1_adaptive/solution-00.pvtu</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.13s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assembling                      |         6 |     0.463s |        41% |</div><div class="line">| Graphical output                |         1 |    0.0257s |       2.3% |</div><div class="line">| Residual and lambda             |         4 |    0.0754s |       6.7% |</div><div class="line">| Setup                           |         1 |     0.227s |        20% |</div><div class="line">| Setup: constraints              |         1 |    0.0347s |       3.1% |</div><div class="line">| Setup: distribute DoFs          |         1 |    0.0441s |       3.9% |</div><div class="line">| Setup: <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>                   |         1 |    0.0119s |       1.1% |</div><div class="line">| Setup: vectors                  |         1 |   0.00155s |      0.14% |</div><div class="line">| Solve                           |         6 |     0.246s |        22% |</div><div class="line">| Solve: iterate                  |         6 |    0.0631s |       5.6% |</div><div class="line">| Solve: setup preconditioner     |         6 |     0.167s |        15% |</div><div class="line">| update active <span class="keyword">set</span>               |         6 |    0.0401s |       3.6% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line">Peak <span class="keyword">virtual</span> memory used, resident in kB: 541884 77464</div><div class="line">Contact force = 37.3058</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Cycle 3:</div><div class="line">   Number of active cells: 14652</div><div class="line">   Number of degrees of freedom: 52497</div><div class="line"></div><div class="line">   Newton iteration 1</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 145</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 296.309 -&gt; 2.72484e-06 in 10 Bicgstab iterations.</div><div class="line">      Accepting Newton solution with residual: 2.72484e-06</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">   Newton iteration 10</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 145</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 2.71541e-07 -&gt; 1.5428e-15 in 27 Bicgstab iterations.</div><div class="line">      Residual of the non-contact part of the system: 1.89261e-13</div><div class="line">         with a damping parameter alpha = 1</div><div class="line">      Active <span class="keyword">set</span> did not change!</div><div class="line">      Writing graphical output... p1_adaptive/solution-03.pvtu</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      38.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assembling                      |        10 |      22.5s |        58% |</div><div class="line">| Graphical output                |         1 |     0.327s |      0.85% |</div><div class="line">| Residual and lambda             |         9 |      3.75s |       9.8% |</div><div class="line">| Setup                           |         1 |      4.83s |        13% |</div><div class="line">| Setup: constraints              |         1 |     0.578s |       1.5% |</div><div class="line">| Setup: distribute DoFs          |         1 |      0.71s |       1.8% |</div><div class="line">| Setup: <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>                   |         1 |     0.111s |      0.29% |</div><div class="line">| Setup: <a class="code" href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">refine</a> mesh              |         1 |      4.83s |        13% |</div><div class="line">| Setup: vectors                  |         1 |   0.00548s |     0.014% |</div><div class="line">| Solve                           |        10 |      5.49s |        14% |</div><div class="line">| Solve: iterate                  |        10 |       3.5s |       9.1% |</div><div class="line">| Solve: setup preconditioner     |        10 |      1.84s |       4.8% |</div><div class="line">| update active <span class="keyword">set</span>               |        10 |     0.662s |       1.7% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line">Peak <span class="keyword">virtual</span> memory used, resident in kB: 566052 105788</div><div class="line">Contact force = 56.794</div><div class="line"></div><div class="line">...</div></div><!-- fragment --><p>The tables at the end of each cycle show information about computing time (these numbers are of course specific to the machine on which this output was produced) and the number of calls of different parts of the program like assembly or calculating the residual, for the most recent mesh refinement cycle. Some of the numbers above can be improved by transferring the solution from one mesh to the next, an option we have not exercised here. Of course, you can also make the program run faster, especially on the later refinement cycles, by just using more processors: the accompanying paper shows good scaling to at least 1000 cores.</p>
<p>In a typical run, you can observe that for every refinement step, the active set - the contact points - are iterated out at first. After that the Newton method has only to resolve the plasticity. For the finer meshes, quadratic convergence can be observed for the last 4 or 5 Newton iterations.</p>
<p>We will not discuss here in all detail what happens with each of the input files. Rather, let us just show pictures of the solution (the left half of the domain is omitted if cells have zero quadrature points at which the plastic inequality is active):</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionColorbar.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionBall2.png" width="70%"/>
</div>
  </td><td valign="top">&#160;  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionLi2.png" width="70%"/>
</div>
   </td></tr>
</table>
<p>The picture shows the adaptive refinement and as well how much a cell is plastified during the contact with the ball. Remember that we consider the norm of the deviator part of the stress in each quadrature point to see if there is elastic or plastic behavior. The blue color means that this cell contains only elastic quadrature points in contrast to the red cells in which all quadrature points are plastified. In the middle of the top surface - where the mesh is finest - a very close look shows the dimple caused by the obstacle. This is the result of the <code>move_mesh()</code> function. However, because the indentation of the obstacles we consider here is so small, it is hard to discern this effect; one could play with displacing vertices of the mesh by a multiple of the computed displacement.</p>
<p>Further discussion of results that can be obtained using this program is provided in the publication mentioned at the very top of this page.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h1>Possibilities for extensions</h1>
<p>There are, as always, multiple possibilities for extending this program. From an algorithmic perspective, this program goes about as far as one can at the time of writing, using the best available algorithms for the contact inequality, the plastic nonlinearity, and the linear solvers. However, there are things one would like to do with this program as far as more realistic situations are concerned: </p><ul>
<li>
<p class="startli">Extend the program from a static to a quasi-static situation, perhaps by choosing a backward-Euler-scheme for the time discretization. Some theoretical results can be found in the PhD thesis by JÃ¶rg Frohne, <em>FEM-Simulation der Umformtechnik metallischer Oberfl&auml;chen im Mikrokosmos</em>, University of Siegen, Germany, 2011.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">It would also be an interesting advance to consider a contact problem with friction. In almost every mechanical process friction has a big influence. To model this situation, we have to take into account tangential stresses at the contact surface. Friction also adds another inequality to our problem since body and obstacle will typically stick together as long as the tangential stress does not exceed a certain limit, beyond which the two bodies slide past each other.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">If we already simulate a frictional contact, the next step to consider is heat generation over the contact zone. The heat that is caused by friction between two bodies raises the temperature in the deformable body and entails an change of some material parameters.</p>
<p class="endli"></p>
</li>
<li>
It might be of interest to implement more accurate, problem-adapted error estimators for contact as well as for the plasticity. </li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2012 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Joerg Frohne, Texas A&amp;M University and</span></div><div class="line"><span class="comment"> *                        University of Siegen, 2012, 2013</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2012, 2013</span></div><div class="line"><span class="comment"> *          Timo Heister, Texas A&amp;M University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__field__function_8h.html">deal.II/numerics/fe_field_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cerrno&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step42</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ConstitutiveLaw</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ConstitutiveLaw(<span class="keyword">const</span> <span class="keywordtype">double</span> E,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> nu,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> sigma_0,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> gamma);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_sigma_0(<span class="keywordtype">double</span> sigma_zero);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> get_stress_strain_tensor(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> get_linearized_stress_strain_tensors(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">    <span class="keywordtype">double</span>       sigma_0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_kappa;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_mu;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ConstitutiveLaw&lt;dim&gt;::ConstitutiveLaw(<span class="keywordtype">double</span> E,</div><div class="line">                                        <span class="keywordtype">double</span> nu,</div><div class="line">                                        <span class="keywordtype">double</span> sigma_0,</div><div class="line">                                        <span class="keywordtype">double</span> gamma)</div><div class="line">    : kappa(E / (3 * (1 - 2 * nu)))</div><div class="line">    , mu(E / (2 * (1 + nu)))</div><div class="line">    , sigma_0(sigma_0)</div><div class="line">    , gamma(gamma)</div><div class="line">    , stress_strain_tensor_kappa(kappa *</div><div class="line">                                 <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                               <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()))</div><div class="line">    , stress_strain_tensor_mu(</div><div class="line">        2 * mu *</div><div class="line">        (<a class="code" href="symmetric__tensor_8h.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor</a>&lt;dim&gt;() - <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                                <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()) /</div><div class="line">                                    3.0))</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::set_sigma_0(<span class="keywordtype">double</span> sigma_zero)</div><div class="line">  {</div><div class="line">    sigma_0 = sigma_zero;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> ConstitutiveLaw&lt;dim&gt;::get_stress_strain_tensor(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">    stress_tensor =</div><div class="line">      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor =</div><div class="line">      <a class="code" href="symmetric__tensor_8h.html#a022faa691137ee8c1f65dacc47d94a04">deviator</a>(stress_tensor);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">    stress_strain_tensor = stress_strain_tensor_mu;</div><div class="line">    <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">      }</div><div class="line"></div><div class="line">    stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (deviator_stress_tensor_norm &gt; sigma_0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::get_linearized_stress_strain_tensors(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">    stress_tensor =</div><div class="line">      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">    stress_strain_tensor            = stress_strain_tensor_mu;</div><div class="line">    stress_strain_tensor_linearized = stress_strain_tensor_mu;</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = <a class="code" href="symmetric__tensor_8h.html#a022faa691137ee8c1f65dacc47d94a04">deviator</a>(stress_tensor);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">        stress_strain_tensor_linearized *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">        deviator_stress_tensor /= deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor_linearized -=</div><div class="line">          (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta * 2 * mu *</div><div class="line">          <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(deviator_stress_tensor, deviator_stress_tensor);</div><div class="line">      }</div><div class="line"></div><div class="line">    stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line">    stress_strain_tensor_linearized += stress_strain_tensor_kappa;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>EquationData</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BoundaryForce();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BoundaryForce&lt;dim&gt;::BoundaryForce()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BoundaryForce&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> BoundaryForce&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                          Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryForce&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BoundaryValues();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BoundaryValues&lt;dim&gt;::BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>SphereObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    SphereObstacle&lt;dim&gt;::SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">      , z_surface(z_surface)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> SphereObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (component == 0)</div><div class="line">        <span class="keywordflow">return</span> p(0);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 1)</div><div class="line">        <span class="keywordflow">return</span> p(1);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((p(0) - 0.5) * (p(0) - 0.5) + (p(1) - 0.5) * (p(1) - 0.5) &lt; 0.36)</div><div class="line">            <span class="keywordflow">return</span> (-std::sqrt(0.36 - (p(0) - 0.5) * (p(0) - 0.5) -</div><div class="line">                               (p(1) - 0.5) * (p(1) - 0.5)) +</div><div class="line">                    z_surface + 0.59);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">return</span> 1000;</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> SphereObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                           Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SphereObstacle&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BitmapFile</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BitmapFile(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      std::vector&lt;double&gt; obstacle_data;</div><div class="line">      <span class="keywordtype">double</span>              hx, hy;</div><div class="line">      <span class="keywordtype">int</span>                 nx, ny;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BitmapFile&lt;dim&gt;::BitmapFile(<span class="keyword">const</span> std::string &amp;name)</div><div class="line">      : obstacle_data(0)</div><div class="line">      , hx(0)</div><div class="line">      , hy(0)</div><div class="line">      , nx(0)</div><div class="line">      , ny(0)</div><div class="line">    {</div><div class="line">      std::ifstream f(name);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(f,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Can&#39;t read from file &lt;&quot;</span>) + name +</div><div class="line">                             <span class="stringliteral">&quot;&gt;!&quot;</span>));</div><div class="line"></div><div class="line">      std::string temp;</div><div class="line">      f &gt;&gt; temp &gt;&gt; nx &gt;&gt; ny;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(nx &gt; 0 &amp;&amp; ny &gt; 0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid file format.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nx * ny; ++k)</div><div class="line">        {</div><div class="line">          <span class="keywordtype">double</span> val;</div><div class="line">          f &gt;&gt; val;</div><div class="line">          obstacle_data.push_back(val);</div><div class="line">        }</div><div class="line"></div><div class="line">      hx = 1.0 / (nx - 1);</div><div class="line">      hy = 1.0 / (ny - 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Read obstacle from file &lt;&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;Resolution of the scanned obstacle picture: &quot;</span> &lt;&lt; nx</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; ny &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      assert(i &gt;= 0 &amp;&amp; i &lt; nx);</div><div class="line">      assert(j &gt;= 0 &amp;&amp; j &lt; ny);</div><div class="line">      <span class="keywordflow">return</span> obstacle_data[nx * (ny - 1 - j) + i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> ix = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(x / hx), 0), nx - 2);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> iy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(y / hy), 0), ny - 2);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> xi  = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((x - ix * hx) / hx, 1.), 0.);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> eta = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((y - iy * hy) / hy, 1.), 0.);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +</div><div class="line">              xi * (1 - eta) * get_pixel_value(ix + 1, iy) +</div><div class="line">              (1 - xi) * eta * get_pixel_value(ix, iy + 1) +</div><div class="line">              xi * eta * get_pixel_value(ix + 1, iy + 1));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ChineseObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename, <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> BitmapFile&lt;dim&gt; input_obstacle;</div><div class="line">      <span class="keywordtype">double</span>                z_surface;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ChineseObstacle&lt;dim&gt;::ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span>       z_surface)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">      , input_obstacle(filename)</div><div class="line">      , z_surface(z_surface)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> ChineseObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (component == 0)</div><div class="line">        <span class="keywordflow">return</span> p(0);</div><div class="line">      <span class="keywordflow">if</span> (component == 1)</div><div class="line">        <span class="keywordflow">return</span> p(1);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt;= 1.0 &amp;&amp; p(1) &gt;= 0.0 &amp;&amp; p(1) &lt;= 1.0)</div><div class="line">            <span class="keywordflow">return</span> z_surface + 0.999 - input_obstacle.get_value(p(0), p(1));</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ChineseObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                            Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = ChineseObstacle&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace EquationData</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PlasticityContactProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PlasticityContactProblem(<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> compute_dirichlet_constraints();</div><div class="line">    <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">    <span class="keywordtype">void</span> assemble_newton_system(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">    <span class="keywordtype">void</span> compute_nonlinear_residual(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">    <span class="keywordtype">void</span> solve_newton_system();</div><div class="line">    <span class="keywordtype">void</span> solve_newton();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> move_mesh(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_contact_force() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classMPI__Comm.html">MPI_Comm</a>           mpi_communicator;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                        n_initial_global_refinements;</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_hanging_nodes;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_dirichlet_and_hanging_nodes;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> all_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>      active_set;</div><div class="line">    Vector&lt;float&gt; fraction_of_plastic_q_points_per_cell;</div><div class="line"></div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix newton_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs_uncondensed;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>         e_modulus, nu, <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>, sigma_0;</div><div class="line">    ConstitutiveLaw&lt;dim&gt; constitutive_law;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string                          base_mesh;</div><div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;const Function&lt;dim&gt;&gt; obstacle;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>RefinementStrategy</div><div class="line">    {</div><div class="line">      <span class="keyword">enum</span> value</div><div class="line">      {</div><div class="line">        refine_global,</div><div class="line">        refine_percentage,</div><div class="line">        refine_fix_dofs</div><div class="line">      };</div><div class="line">    };</div><div class="line">    <span class="keyword">typename</span> RefinementStrategy::value refinement_strategy;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>         transfer_solution;</div><div class="line">    std::string        output_dir;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_cycles;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       current_refinement_cycle;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">      <span class="stringliteral">&quot;Polynomial degree of the FE_Q finite element space, typically 1 or 2.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of initial refinements&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Number of initial global mesh refinement steps before &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;the first computation.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;refinement strategy&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;percentage&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;global|percentage&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;Mesh refinement strategy:\n&quot;</span></div><div class="line">      <span class="stringliteral">&quot; global: one global refinement\n&quot;</span></div><div class="line">      <span class="stringliteral">&quot; percentage: a fixed percentage of cells gets refined using the Kelly estimator.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of cycles&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Number of adaptive mesh refinement cycles to run.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;obstacle&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;sphere&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;sphere|read from file&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;The name of the obstacle to use. This may either be &#39;sphere&#39; if we should &quot;</span></div><div class="line">      <span class="stringliteral">&quot;use a spherical obstacle, or &#39;read from file&#39; in which case the obstacle &quot;</span></div><div class="line">      <span class="stringliteral">&quot;will be read from a file named &#39;obstacle.pbm&#39; that is supposed to be in &quot;</span></div><div class="line">      <span class="stringliteral">&quot;ASCII PBM format.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;output directory&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">      <span class="stringliteral">&quot;Directory for output files (graphical output and benchmark &quot;</span></div><div class="line">      <span class="stringliteral">&quot;statistics). If empty, use the current directory.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;transfer solution&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">      <span class="stringliteral">&quot;Whether the solution should be used as a starting guess &quot;</span></div><div class="line">      <span class="stringliteral">&quot;for the next finer mesh. If false, then the iteration starts at &quot;</span></div><div class="line">      <span class="stringliteral">&quot;zero on every mesh.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;base mesh&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;box&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;box|half sphere&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Select the shape of the domain: &#39;box&#39; or &#39;half sphere&#39;&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PlasticityContactProblem&lt;dim&gt;::PlasticityContactProblem(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">            (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">    , computing_timer(MPI_COMM_WORLD,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line"></div><div class="line">    , n_initial_global_refinements(</div><div class="line">        prm.get_integer(<span class="stringliteral">&quot;number of initial refinements&quot;</span>))</div><div class="line">    , triangulation(mpi_communicator)</div><div class="line">    , fe_degree(prm.get_integer(<span class="stringliteral">&quot;polynomial degree&quot;</span>))</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree + 1)), dim)</div><div class="line">    , dof_handler(triangulation)</div><div class="line"></div><div class="line">    , e_modulus(200000)</div><div class="line">    , nu(0.3)</div><div class="line">    , gamma(0.01)</div><div class="line">    , sigma_0(400.0)</div><div class="line">    , constitutive_law(e_modulus, nu, sigma_0, gamma)</div><div class="line"></div><div class="line">    , base_mesh(prm.get(<span class="stringliteral">&quot;base mesh&quot;</span>))</div><div class="line">    , obstacle(prm.get(<span class="stringliteral">&quot;obstacle&quot;</span>) == <span class="stringliteral">&quot;read from file&quot;</span> ?</div><div class="line">                 static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                   new EquationData::ChineseObstacle&lt;dim&gt;(</div><div class="line">                     <span class="stringliteral">&quot;obstacle.pbm&quot;</span>,</div><div class="line">                     (base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5))) :</div><div class="line">                 static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                   new EquationData::SphereObstacle&lt;dim&gt;(</div><div class="line">                     base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5)))</div><div class="line"></div><div class="line">    , transfer_solution(prm.get_bool(<span class="stringliteral">&quot;transfer solution&quot;</span>))</div><div class="line">    , n_refinement_cycles(prm.get_integer(<span class="stringliteral">&quot;number of cycles&quot;</span>))</div><div class="line">    , current_refinement_cycle(0)</div><div class="line"></div><div class="line">  {</div><div class="line">    std::string strat = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;refinement strategy&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">      refinement_strategy = RefinementStrategy::refine_global;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;percentage&quot;</span>)</div><div class="line">      refinement_strategy = RefinementStrategy::refine_percentage;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    output_dir = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;output directory&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (output_dir != <span class="stringliteral">&quot;&quot;</span> &amp;&amp; *(output_dir.rbegin()) != <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">      output_dir += <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> ierr = mkdir(output_dir.c_str(), 0777);</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(ierr == 0 || errno == EEXIST, <a class="code" href="group__Exceptions.html#gac29b5f3efd2b164642b8e0c49ad3ad27">ExcIO</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    Using output directory &#39;&quot;</span> &lt;&lt; output_dir &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    FE degree &quot;</span> &lt;&lt; fe_degree &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    transfer solution &quot;</span> &lt;&lt; (transfer_solution ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>)</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> rotate_half_sphere(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;in)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> {in(2), in(1), -in(0)};</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;half sphere&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0, 0, 0);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>     radius = 0.8;</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(triangulation, center, radius);</div><div class="line">        triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;rotate_half_sphere, triangulation);</div><div class="line">        <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5), triangulation);</div><div class="line"></div><div class="line">        <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5));</div><div class="line">        <a class="code" href="namespaceGridTools.html#aa92034313ef924778e01beb3e24002dd">GridTools::copy_boundary_to_manifold_id</a>(triangulation);</div><div class="line">        triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, manifold_description);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1(0, 0, 0);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p2(1.0, 1.0, 1.0);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation, p1, p2);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p2[2]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(1);</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p1[0]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p2[0]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p1[1]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p2[1]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(8);</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p1[2]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(6);</div><div class="line">              }</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="comment">/* setup dofs and get index sets for locally owned and relevant dofs */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: distribute DoFs&quot;</span>);</div><div class="line">      dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">      locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">      locally_relevant_dofs.<a class="code" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a>();</div><div class="line">      <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler,</div><div class="line">                                              locally_relevant_dofs);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* setup hanging nodes and Dirichlet constraints */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: constraints&quot;</span>);</div><div class="line">      constraints_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              constraints_hanging_nodes);</div><div class="line">      constraints_hanging_nodes.close();</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      compute_dirichlet_constraints();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* initialization of vectors and the active set */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: vectors&quot;</span>);</div><div class="line">      solution.reinit(locally_relevant_dofs, mpi_communicator);</div><div class="line">      newton_rhs.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      fraction_of_plastic_q_points_per_cell.reinit(</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">      active_set.clear();</div><div class="line">      active_set.set_size(dof_handler.n_dofs());</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>                t(computing_timer, <span class="stringliteral">&quot;Setup: matrix&quot;</span>);</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                      sp,</div><div class="line">                                      constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                      <span class="keyword">false</span>,</div><div class="line">                                      <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                        mpi_communicator));</div><div class="line">      sp.compress();</div><div class="line">      newton_matrix.reinit(sp);</div><div class="line"></div><div class="line"></div><div class="line">      TrilinosWrappers::SparseMatrix &amp;mass_matrix = newton_matrix;</div><div class="line"></div><div class="line">      assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start = (newton_rhs.local_range().first),</div><div class="line">                         end   = (newton_rhs.local_range().second);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = start; j &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++j)</div><div class="line">        diag_mass_matrix_vector(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">      diag_mass_matrix_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">      mass_matrix = 0;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_dirichlet_constraints()</div><div class="line">  {</div><div class="line">    constraints_dirichlet_and_hanging_nodes.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(locally_relevant_dofs);</div><div class="line">    constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          dof_handler,</div><div class="line">          6,</div><div class="line">          EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">          constraints_dirichlet_and_hanging_nodes,</div><div class="line">          <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          dof_handler,</div><div class="line">          8,</div><div class="line">          EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">          constraints_dirichlet_and_hanging_nodes,</div><div class="line">          (fe.component_mask(x_displacement) |</div><div class="line">           fe.component_mask(y_displacement)));</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        0,</div><div class="line">        EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">        constraints_dirichlet_and_hanging_nodes,</div><div class="line">        <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">    constraints_dirichlet_and_hanging_nodes.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line">              cell_matrix = 0;</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">                    (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                     fe_values_face[displacement].value(i, q_point) *</div><div class="line">                     fe_values_face.JxW(q_point));</div><div class="line"></div><div class="line">              cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a>(local_dof_indices[i],</div><div class="line">                                local_dof_indices[i],</div><div class="line">                                cell_matrix(i, i));</div><div class="line">            }</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">  {</div><div class="line">    std::vector&lt;bool&gt; dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line">    distributed_solution = solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = newton_rhs_uncondensed;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector_relevant(</div><div class="line">      locally_relevant_dofs, mpi_communicator);</div><div class="line">    diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;</div><div class="line"></div><div class="line"></div><div class="line">    all_constraints.reinit(locally_relevant_dofs);</div><div class="line">    active_set.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim - 1&gt; face_quadrature(fe.get_unit_face_support_points());</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>   fe_values_face(fe,</div><div class="line">                                     face_quadrature,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_face   = fe.n_dofs_per_face();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature.size();</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; dof_indices(dofs_per_face);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (!cell-&gt;is_artificial())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line">              face-&gt;get_dof_indices(dof_indices);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component =</div><div class="line">                    fe.face_system_to_component_index(q_point).first;</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_z = dof_indices[q_point];</div><div class="line"></div><div class="line">                  <span class="keywordflow">if</span> ((component == 2) &amp;&amp; (dof_touched[index_z] == <span class="keyword">false</span>))</div><div class="line">                    {</div><div class="line">                      dof_touched[index_z] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> this_support_point =</div><div class="line">                        fe_values_face.quadrature_point(q_point);</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value =</div><div class="line">                        obstacle-&gt;value(this_support_point, 2);</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> solution_here = solution(index_z);</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> undeformed_gap =</div><div class="line">                        obstacle_value - this_support_point(2);</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> c = 100.0 * e_modulus;</div><div class="line">                      <span class="keywordflow">if</span> ((lambda(index_z) /</div><div class="line">                               diag_mass_matrix_vector_relevant(index_z) +</div><div class="line">                             c * (solution_here - undeformed_gap) &gt;</div><div class="line">                           0) &amp;&amp;</div><div class="line">                          !constraints_hanging_nodes.is_constrained(index_z))</div><div class="line">                        {</div><div class="line">                          all_constraints.add_line(index_z);</div><div class="line">                          all_constraints.set_inhomogeneity(index_z,</div><div class="line">                                                            undeformed_gap);</div><div class="line">                          distributed_solution(index_z) = undeformed_gap;</div><div class="line"></div><div class="line">                          active_set.add_index(index_z);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">    distributed_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    solution = distributed_solution;</div><div class="line"></div><div class="line">    all_constraints.close();</div><div class="line">    all_constraints.merge(constraints_dirichlet_and_hanging_nodes);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;         Size of active set: &quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set &amp; locally_owned_dofs).n_elements(),</div><div class="line">                                 mpi_communicator)</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_newton_system(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assembling&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim));</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          cell_matrix = 0;</div><div class="line">          cell_rhs    = 0;</div><div class="line"></div><div class="line">          std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensor(n_q_points);</div><div class="line">          fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">            linearization_point, strain_tensor);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            {</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">              constitutive_law.get_linearized_stress_strain_tensors(</div><div class="line">                strain_tensor[q_point],</div><div class="line">                stress_strain_tensor_linearized,</div><div class="line">                stress_strain_tensor);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_phi_i =</div><div class="line">                    stress_strain_tensor_linearized *</div><div class="line">                    fe_values[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (stress_phi_i *</div><div class="line">                       fe_values[displacement].symmetric_gradient(j, q_point) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  cell_rhs(i) +=</div><div class="line">                    ((stress_phi_i -</div><div class="line">                      stress_strain_tensor *</div><div class="line">                        fe_values[displacement].symmetric_gradient(i,</div><div class="line">                                                                   q_point)) *</div><div class="line">                     strain_tensor[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">              {</div><div class="line">                fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">                boundary_force.vector_value_list(</div><div class="line">                  fe_values_face.get_quadrature_points(),</div><div class="line">                  boundary_force_values);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                     ++q_point)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                    rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                         rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          all_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                     cell_rhs,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     newton_matrix,</div><div class="line">                                                     newton_rhs,</div><div class="line">                                                     <span class="keyword">true</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">    newton_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_nonlinear_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim));</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    newton_rhs             = 0;</div><div class="line">    newton_rhs_uncondensed = 0;</div><div class="line"></div><div class="line">    fraction_of_plastic_q_points_per_cell = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensors(n_q_points);</div><div class="line">          fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">            linearization_point, strain_tensors);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            {</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">bool</span>              q_point_is_plastic =</div><div class="line">                constitutive_law.get_stress_strain_tensor(</div><div class="line">                  strain_tensors[q_point], stress_strain_tensor);</div><div class="line">              <span class="keywordflow">if</span> (q_point_is_plastic)</div><div class="line">                ++fraction_of_plastic_q_points_per_cell(</div><div class="line">                  cell-&gt;active_cell_index());</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  cell_rhs(i) -=</div><div class="line">                    (strain_tensors[q_point] * stress_strain_tensor *</div><div class="line">                     fe_values[displacement].symmetric_gradient(i, q_point) *</div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values = 0;</div><div class="line">                  cell_rhs(i) += (fe_values[displacement].value(i, q_point) *</div><div class="line">                                  rhs_values * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">              {</div><div class="line">                fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">                boundary_force.vector_value_list(</div><div class="line">                  fe_values_face.get_quadrature_points(),</div><div class="line">                  boundary_force_values);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                     ++q_point)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                    rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                         rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(</div><div class="line">            cell_rhs, local_dof_indices, newton_rhs);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    fraction_of_plastic_q_points_per_cell /= quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    newton_rhs_uncondensed.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line">    distributed_solution = solution;</div><div class="line"></div><div class="line">    constraints_hanging_nodes.set_zero(distributed_solution);</div><div class="line">    constraints_hanging_nodes.set_zero(newton_rhs);</div><div class="line"></div><div class="line">    TrilinosWrappers::PreconditionAMG preconditioner;</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: setup preconditioner&quot;</span>);</div><div class="line"></div><div class="line">      std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(dof_handler,</div><div class="line">                                       <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                       constant_modes);</div><div class="line"></div><div class="line">      <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a>              = <span class="keyword">true</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a4a403dc7faf67ee0fcb6436d7b741687">n_cycles</a>              = 1;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a56500e96ab5ae9b84dd874b38283453b">w_cycle</a>               = <span class="keyword">false</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#ab9fc3e207a7c534094d514685e645c92">output_details</a>        = <span class="keyword">false</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a>       = 2;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 1e-2;</div><div class="line"></div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(newton_matrix, additional_data);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: iterate&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> relative_accuracy = 1e-8;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance =</div><div class="line">        relative_accuracy *</div><div class="line">        newton_matrix.residual(tmp, distributed_solution, newton_rhs);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(newton_matrix.m(), solver_tolerance);</div><div class="line">      <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line">      solver.solve(newton_matrix,</div><div class="line">                   distributed_solution,</div><div class="line">                   newton_rhs,</div><div class="line">                   preconditioner);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;         Error: &quot;</span> &lt;&lt; solver_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; Bicgstab iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    all_constraints.distribute(distributed_solution);</div><div class="line"></div><div class="line">    solution = distributed_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_solution(locally_owned_dofs,</div><div class="line">                                               mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> residual(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp_vector(locally_owned_dofs,</div><div class="line">                                             mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_tmp_vector(</div><div class="line">      locally_relevant_dofs, mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> residual_norm;</div><div class="line">    <span class="keywordtype">double</span> previous_residual_norm = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> correct_sigma = sigma_0;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> old_active_set(active_set);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= 100; ++newton_step)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (newton_step == 1 &amp;&amp;</div><div class="line">            ((transfer_solution &amp;&amp; current_refinement_cycle == 0) ||</div><div class="line">             !transfer_solution))</div><div class="line">          constitutive_law.set_sigma_0(1e+10);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == 2 || current_refinement_cycle &gt; 0 ||</div><div class="line">                 !transfer_solution)</div><div class="line">          constitutive_law.set_sigma_0(correct_sigma);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Newton iteration &quot;</span> &lt;&lt; newton_step &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;update active set&quot;</span>);</div><div class="line">          update_solution_and_constraints();</div><div class="line">        }</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Assembling system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">        newton_matrix = 0;</div><div class="line">        newton_rhs    = 0;</div><div class="line">        assemble_newton_system(solution);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Solving system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve_newton_system();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((newton_step == 1) ||</div><div class="line">            (transfer_solution &amp;&amp; newton_step == 2 &amp;&amp;</div><div class="line">             current_refinement_cycle == 0) ||</div><div class="line">            (!transfer_solution &amp;&amp; newton_step == 2))</div><div class="line">          {</div><div class="line">            compute_nonlinear_residual(solution);</div><div class="line">            old_solution = solution;</div><div class="line"></div><div class="line">            residual                     = newton_rhs;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                               end_res   = (residual.local_range().second);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">              <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">                residual(n) = 0;</div><div class="line"></div><div class="line">            residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">            residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;      Accepting Newton solution with residual: &quot;</span></div><div class="line">                  &lt;&lt; residual_norm &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)</div><div class="line">              {</div><div class="line">                distributed_solution = solution;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.5, static_cast&lt;double&gt;(i));</div><div class="line">                tmp_vector         = old_solution;</div><div class="line">                tmp_vector.sadd(1 - alpha, alpha, distributed_solution);</div><div class="line"></div><div class="line">                <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Residual and lambda&quot;</span>);</div><div class="line"></div><div class="line">                locally_relevant_tmp_vector = tmp_vector;</div><div class="line">                compute_nonlinear_residual(locally_relevant_tmp_vector);</div><div class="line">                residual = newton_rhs;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                                   end_res   = (residual.local_range().second);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">                  <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">                    residual(n) = 0;</div><div class="line"></div><div class="line">                residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">                residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">                pcout</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;      Residual of the non-contact part of the system: &quot;</span></div><div class="line">                  &lt;&lt; residual_norm &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;         with a damping parameter alpha = &quot;</span> &lt;&lt; alpha</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (residual_norm &lt; previous_residual_norm)</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            solution     = tmp_vector;</div><div class="line">            old_solution = solution;</div><div class="line">          }</div><div class="line"></div><div class="line">        previous_residual_norm = residual_norm;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set == old_active_set) ? 0 : 1,</div><div class="line">                                mpi_communicator) == 0)</div><div class="line">          {</div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;      Active set did not change!&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (residual_norm &lt; 1e-10)</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        old_active_set = active_set;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (refinement_strategy == RefinementStrategy::refine_global)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">               triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">             cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">             ++cell)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">        <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">          dof_handler,</div><div class="line">          <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 2),</div><div class="line">          std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">          solution,</div><div class="line">          estimated_error_per_cell);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number</a>(</div><div class="line">          triangulation, estimated_error_per_cell, 0.3, 0.03);</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">      solution_transfer(dof_handler);</div><div class="line">    <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">      solution_transfer.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                           mpi_communicator);</div><div class="line">        solution_transfer.interpolate(distributed_solution);</div><div class="line"></div><div class="line">        constraints_hanging_nodes.distribute(distributed_solution);</div><div class="line"></div><div class="line">        solution = distributed_solution;</div><div class="line">        compute_nonlinear_residual(solution);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::move_mesh(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">            {</div><div class="line">              vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                vertex_displacement[d] =</div><div class="line">                  displacement(cell-&gt;vertex_dof_index(v, d));</div><div class="line"></div><div class="line">              cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">            }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Graphical output&quot;</span>);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;      Writing graphical output... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    move_mesh(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                       end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">      <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">        distributed_lambda(n) =</div><div class="line">          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = distributed_lambda;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_active_set_vector(</div><div class="line">      locally_owned_dofs, mpi_communicator);</div><div class="line">    distributed_active_set_vector = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">      distributed_active_set_vector[index] = 1.;</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(locally_relevant_dofs,</div><div class="line">                                                    mpi_communicator);</div><div class="line">    active_set_vector = distributed_active_set_vector;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;displacement&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;contact_force&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;active_set&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fraction_of_plastic_q_points_per_cell,</div><div class="line">                             <span class="stringliteral">&quot;fraction_of_plastic_q_points&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string pvtu_filename = data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      output_dir, <span class="stringliteral">&quot;solution&quot;</span>, current_refinement_cycle, mpi_communicator, 2);</div><div class="line">    pcout &lt;&lt; pvtu_filename &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(solution);</div><div class="line">    tmp *= -1;</div><div class="line">    move_mesh(tmp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_contact_force()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                       end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">      <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">        distributed_lambda(n) =</div><div class="line">          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        distributed_lambda(n) = 0;</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = distributed_lambda;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> contact_force = 0.0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              std::vector&lt;Tensor&lt;1, dim&gt;&gt; lambda_values(n_face_q_points);</div><div class="line">              fe_values_face[displacement].get_function_values(lambda,</div><div class="line">                                                               lambda_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                contact_force +=</div><div class="line">                  lambda_values[q_point][2] * fe_values_face.JxW(q_point);</div><div class="line">            }</div><div class="line">    contact_force = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(contact_force, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Contact force = &quot;</span> &lt;&lt; contact_force &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PlasticityContactProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    computing_timer.reset();</div><div class="line">    <span class="keywordflow">for</span> (; current_refinement_cycle &lt; n_refinement_cycles;</div><div class="line">         ++current_refinement_cycle)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup&quot;</span>);</div><div class="line"></div><div class="line">          pcout &lt;&lt; std::endl;</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; current_refinement_cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (current_refinement_cycle == 0)</div><div class="line">            {</div><div class="line">              make_grid();</div><div class="line">              setup_system();</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: refine mesh&quot;</span>);</div><div class="line">              refine_grid();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        solve_newton();</div><div class="line"></div><div class="line">        output_results(current_refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line"></div><div class="line">        <a class="code" href="structUtilities_1_1System_1_1MemoryStats.html">Utilities::System::MemoryStats</a> stats;</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#a25db0fc07c298b5bef3d6f738283bd6d">Utilities::System::get_memory_stats</a>(stats);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Peak virtual memory used, resident in kB: &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a9cb487ac1831b7e5836be93859c1c2af">VmSize</a></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a39901417b9e6ebfa36d05bfb8a282aa2">VmRSS</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">          output_contact_force();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step42</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>Step42;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      PlasticityContactProblem&lt;3&gt;::declare_parameters(prm);</div><div class="line">      <span class="keywordflow">if</span> (argc != 2)</div><div class="line">        {</div><div class="line">          std::cerr &lt;&lt; <span class="stringliteral">&quot;*** Call this program as &lt;./step-42 input.prm&gt;&quot;</span></div><div class="line">                    &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(argv[1]);</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line">      {</div><div class="line">        PlasticityContactProblem&lt;3&gt; problem(prm);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_41.html">step-41</a> , <a class="el" href="step_40.html">step-40</a> . <table
 class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Introduction">Introduction</a><a
 href="#Introduction">Introduction</a>
 <li><a href="#Classicalformulation">Classical formulation</a><a
 href="#Classicalformulation">Classical formulation</a>
 <li><a href="#Reformulationasavariationalinequality">Reformulation as a
 variational inequality</a><a
 href="#Reformulationasavariationalinequality">Reformulation as a
 variational inequality</a>
 <li><a href="#ANewtonmethodfortheplasticnonlinearity">A Newton method for
 the plastic nonlinearity</a><a
 href="#ANewtonmethodfortheplasticnonlinearity">A Newton method for the
 plastic nonlinearity</a>
 <li><a href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set
 methods to solve the saddle point problem</a><a
 href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set methods to
 solve the saddle point problem</a>
 <li><a href="#Overallalgorithm">Overall algorithm</a><a
 href="#Overallalgorithm">Overall algorithm</a>
 <li><a href="#Adaptivemeshrefinement">Adaptive mesh refinement</a><a
 href="#Adaptivemeshrefinement">Adaptive mesh refinement</a>
 <li><a href="#Implementation">Implementation</a><a
 href="#Implementation">Implementation</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#ThecodeConstitutiveLawcodeclasstemplate">The
 <code>ConstitutiveLaw</code> class template</a><a
 href="#ThecodeConstitutiveLawcodeclasstemplate">The
 <code>ConstitutiveLaw</code> class template</a>
 <ul>
 <li><a
 href="#ConstitutiveLawget_stress_strain_tensor">ConstitutiveLaw::get_stress_strain_tensor</a><a
 href="#ConstitutiveLawget_stress_strain_tensor">ConstitutiveLaw::get_stress_strain_tensor</a>
 <li><a
 href="#ConstitutiveLawget_linearized_stress_strain_tensors">ConstitutiveLaw::get_linearized_stress_strain_tensors</a><a
 href="#ConstitutiveLawget_linearized_stress_strain_tensors">ConstitutiveLaw::get_linearized_stress_strain_tensors</a>
 <li><a href="#ThecodeSphereObstaclecodeclass">The
 <code>SphereObstacle</code> class</a><a
 href="#ThecodeSphereObstaclecodeclass">The <code>SphereObstacle</code>
 class</a>
 <li><a href="#ThecodeBitmapFilecodeandcodeChineseObstaclecodeclasses">The
 <code>BitmapFile</code> and <code>ChineseObstacle</code> classes</a><a
 href="#ThecodeBitmapFilecodeandcodeChineseObstaclecodeclasses">The
 <code>BitmapFile</code> and <code>ChineseObstacle</code> classes</a>
 </ul>
 <li><a href="#ThecodePlasticityContactProblemcodeclasstemplate">The
 <code>PlasticityContactProblem</code> class template</a><a
 href="#ThecodePlasticityContactProblemcodeclasstemplate">The
 <code>PlasticityContactProblem</code> class template</a>
 <li><a
 href="#ImplementationofthecodePlasticityContactProblemcodeclass">Implementation
 of the <code>PlasticityContactProblem</code> class</a><a
 href="#ImplementationofthecodePlasticityContactProblemcodeclass">Implementation
 of the <code>PlasticityContactProblem</code> class</a>
 <ul>
 <li><a
 href="#PlasticityContactProblemdeclare_parameters">PlasticityContactProblem::declare_parameters</a><a
 href="#PlasticityContactProblemdeclare_parameters">PlasticityContactProblem::declare_parameters</a>
 <li><a href="#ThecodePlasticityContactProblemcodeconstructor">The
 <code>PlasticityContactProblem</code> constructor</a><a
 href="#ThecodePlasticityContactProblemcodeconstructor">The
 <code>PlasticityContactProblem</code> constructor</a>
 <li><a
 href="#PlasticityContactProblemmake_grid">PlasticityContactProblem::make_grid</a><a
 href="#PlasticityContactProblemmake_grid">PlasticityContactProblem::make_grid</a>
 <li><a
 href="#PlasticityContactProblemsetup_system">PlasticityContactProblem::setup_system</a><a
 href="#PlasticityContactProblemsetup_system">PlasticityContactProblem::setup_system</a>
 <li><a
 href="#PlasticityContactProblemcompute_dirichlet_constraints">PlasticityContactProblem::compute_dirichlet_constraints</a><a
 href="#PlasticityContactProblemcompute_dirichlet_constraints">PlasticityContactProblem::compute_dirichlet_constraints</a>
 <li><a
 href="#PlasticityContactProblemassemble_mass_matrix_diagonal">PlasticityContactProblem::assemble_mass_matrix_diagonal</a><a
 href="#PlasticityContactProblemassemble_mass_matrix_diagonal">PlasticityContactProblem::assemble_mass_matrix_diagonal</a>
 <li><a
 href="#PlasticityContactProblemupdate_solution_and_constraints">PlasticityContactProblem::update_solution_and_constraints</a><a
 href="#PlasticityContactProblemupdate_solution_and_constraints">PlasticityContactProblem::update_solution_and_constraints</a>
 <li><a
 href="#PlasticityContactProblemassemble_newton_system">PlasticityContactProblem::assemble_newton_system</a><a
 href="#PlasticityContactProblemassemble_newton_system">PlasticityContactProblem::assemble_newton_system</a>
 <li><a
 href="#PlasticityContactProblemcompute_nonlinear_residual">PlasticityContactProblem::compute_nonlinear_residual</a><a
 href="#PlasticityContactProblemcompute_nonlinear_residual">PlasticityContactProblem::compute_nonlinear_residual</a>
 <li><a
 href="#PlasticityContactProblemsolve_newton_system">PlasticityContactProblem::solve_newton_system</a><a
 href="#PlasticityContactProblemsolve_newton_system">PlasticityContactProblem::solve_newton_system</a>
 <li><a
 href="#PlasticityContactProblemsolve_newton">PlasticityContactProblem::solve_newton</a><a
 href="#PlasticityContactProblemsolve_newton">PlasticityContactProblem::solve_newton</a>
 <li><a
 href="#PlasticityContactProblemrefine_grid">PlasticityContactProblem::refine_grid</a><a
 href="#PlasticityContactProblemrefine_grid">PlasticityContactProblem::refine_grid</a>
 <li><a
 href="#PlasticityContactProblemmove_mesh">PlasticityContactProblem::move_mesh</a><a
 href="#PlasticityContactProblemmove_mesh">PlasticityContactProblem::move_mesh</a>
 <li><a
 href="#PlasticityContactProblemoutput_results">PlasticityContactProblem::output_results</a><a
 href="#PlasticityContactProblemoutput_results">PlasticityContactProblem::output_results</a>
 <li><a
 href="#PlasticityContactProblemoutput_contact_force">PlasticityContactProblem::output_contact_force</a><a
 href="#PlasticityContactProblemoutput_contact_force">PlasticityContactProblem::output_contact_force</a>
 <li><a
 href="#PlasticityContactProblemrun">PlasticityContactProblem::run</a><a
 href="#PlasticityContactProblemrun">PlasticityContactProblem::run</a>
 </ul>
 <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a
 href="#Thecodemaincodefunction">The <code>main</code> function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by JÃ¶rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&amp;M University, with significant contributions by Timo Heister and Wolfgang Bangerth. <br />
 <br />
 The code described here provides the basis for the numerical experiments shown in the following paper: <br />
 J. Frohne, T. Heister, W. Bangerth: <b>Efficient numerical methods for the large-scale, parallel solution of elastoplastic contact problems</b><b>Efficient numerical methods for the large-scale, parallel solution of elastoplastic contact problems</b>. Accepted for publication in International Journal for Numerical Methods in Engineering, 2015. </em></p>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h3>Introduction</h3>
<p>This example is an extension of <a class="el" href="step_41.html">step-41</a> , considering a 3d contact problem with anelasto-plastic material behavior with isotropic hardening in three dimensions.In other words, it considers how a three-dimensional body deforms if one pushesinto it a rigid obstacle (the contact problem) where deformation is governedby an elasto-plastic material law (a material that can only accommodate a certainmaximal stress) that hardens as deformation accumulates. To show what we intend todo before going into too many details, let us just show a picture of what thesolution will look like (the deformable body is a cube</p>
<ul>
<li>only half ofwhich is actually shown</li>
<li>the obstacle correspondsto a Chinese character that is discussed below): <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionLi2.png"/>
</div>
</li>
</ul>
<p>This problem description implies that we have to take care of an additionalnonlinearity compared to <a class="el" href="step_41.html">step-41</a> : thematerial behavior. Since we consider a three dimensional problem here, we alsohave to account for the fact that the contact area is at the boundary ofthe deformable body now, rather than in the interior. Finally, compared to <a class="el" href="step_41.html">step-41</a> , we also have to deal with hanging nodes in both the handling of the linearsystem as well as of the inequality constraints as we would like to use anadaptive mesh; in the latter case, we willhave to deal with prioritizing whether the constraints from the hanging nodesor from the inequalities are more important. Since you can very easily reach a few million degrees of freedom in threedimensions, even with adaptive mesh refinement, we decided to use Trilinos andp4est to run our code in parallel, building on the framework of <a class="el" href="step_40.html">step-40</a> forthe parallelization. Additional pointers for parallelization can be found in <a class="el" href="step_32.html">step-32</a> .</p>
<p><a class="anchor" id="Classicalformulation"></a></p><h3>Classical formulation</h3>
<p>The classical formulation of the problem possesses the following form: </p><p class="formulaDsp">
\begin{align*} \varepsilon(\mathbf u) &amp;= A\sigma + \varepsilon^p &amp; &amp;\quad\text{in } \Omega,\\ -\textrm{div}\ \sigma &amp;= \mathbf f &amp; &amp;\quad\text{in } \Omega,\\ \varepsilon^p:(\tau - \sigma) &amp;\geq 0\quad\forall\tau\text{ with }\mathcal{F}(\tau)\leq 0 &amp; &amp;\quad\text{in } \Omega,\\ \mathbf u &amp;= 0 &amp; &amp;\quad\text{on }\Gamma_D,\\ \sigma \mathbf n - [\mathbf n \cdot(\sigma \mathbf n)]\mathbf n &amp;= 0, \quad \mathbf n \cdot (\sigma \mathbf n) \leq 0 &amp; &amp;\quad\text{on }\Gamma_C,\\ (\mathbf n \cdot (\sigma \mathbf n))(\mathbf n \cdot \mathbf u - g) &amp;= 0,\quad \mathbf n \cdot \mathbf u - g \leq 0 &amp; &amp;\quad\text{on } \Gamma_C. \end{align*}
</p>
<p> Here, the first of these equations defines therelationship between strain \(\varepsilon(\mathbf u)=\frac{1}{2}\left(\nabla \mathbf u + \nabla \mathbf u^T\right)\) and stress \(\sigma\) viathe fourth-order compliance tensor \(A\) ; \(\varepsilon^p\) provides the plasticcomponent of the strain to ensure that the stress does not exceed the yieldstress. We will only consider isotropicmaterials for which \(A\) can be expressed in terms of the Lam&eacute; moduli \(\lambda\) and \(\mu\) or alternatively in terms of the bulk modulus \(\kappa\) and \(\mu\) .The second equation is the force balance; we will herenot consider any body forces and henceforth assume that \(\mathbf f=0\) . Thecomplementarity condition in the third line implies that \(\varepsilon^p=0\) if \(\mathcal{F}(\sigma)&lt; 0\) but that \(\varepsilon^p\) may be a nonzero tensor if andonly if \(\mathcal{F}(\sigma) = 0\) , and in particular that in this case \(\varepsilon^p\) must point in the direction \(\partial \mathcal{F}(\sigma)/\partial \sigma\) . The inequality \(\mathcal{F}(\sigma)\le 0\) isa statement of the fact that plastic materials can only support a finite amountof stress; in other words, they react with plastic deformations \(\varepsilon^p\) if external forces would result in a stress \(\sigma\) for which \(\mathcal{F}(\sigma)&gt; 0\) would result. A typical form for this <em>yield function</em> is \(\mathcal{F}(\sigma)=|\sigma^D|-\sigma_{\text{yield}}\) where \(\tau^D = \tau - \dfrac{1}{3}tr(\tau)I\) is the deviatoric part of a tensorand \(|\cdot|\) denotes the Frobenius norm. Further equations describe afixed, zero displacement on \(\Gamma_D\) andthat on the surface \(\Gamma_C=\partial\Omega\backslash\Gamma_D\) where contact may appear, the normalforce \(\sigma_n=\mathbf n \cdot (\sigma(\mathbf u) \mathbf n)\) exerted by the obstacle is inward (no "pull" by the obstacle on ourbody) and with zero tangential component \(\mathbf \sigma_t= \sigma \mathbf n - \mathbf \sigma_n \mathbf n = \sigma \mathbf n - [\mathbf n \cdot(\sigma \mathbf n)]\mathbf n\) .The last condition is again a complementarity condition thatimplies that on \(\Gamma_C\) , the normalforce can only be nonzero if the body is in contact with the obstacle; thesecond part describes the impenetrability of the obstacle and the body.The last two equations are commonly referred to as the Signorini contactconditions. Most materials</p>
<ul>
<li>especially metals</li>
<li>have the property that they show some hardening as a result ofdeformation. In other words, \(\sigma_{\text{yield}}\) increases with deformation.In practice, it is not the elastic deformation that results in hardening,but the plastic component.There are different constitutive laws to describe those material behaviors. Thesimplest one is called linear isotropic hardening described by the flow function \(\mathcal{F}(\sigma,\varepsilon^p) = \vert\sigma^D\vert - (\sigma_0 + \gamma^{\text{iso}}|\varepsilon^p|)\) .</li>
</ul>
<p><a class="anchor" id="Reformulationasavariationalinequality"></a></p><h3>Reformulation as a variational inequality</h3>
<p>It is generally rather awkward to deal with inequalities. Here, we have to deal withtwo: plasticity and the contact problem.As described in more detail in the paper mentioned at the top of this page, onecan at least reformulate the plasticity in a way that makes it look like anonlinearity that we can then treat with Newton's method. This is slightlytricky mathematically since the nonlinearity is not just some smoothfunction but instead has kinks where the stress reaches the yield stress;however, it can be shown for such <em>semismooth</em> functions that Newton'smethod still converges. Without going into details, we will also get rid of the stress as an independentvariable and instead work exclusively with the displacements \(\mathbf u\) . Ultimately,the goal of this reformulation is that we will want to end up with a symmetric,positive definite problem</p>
<ul>
<li>such as a linearized elasticity problem with spatiallyvariable coefficients resulting from the plastic behavior</li>
<li>that needs to be solvedin each Newton step. We want this because there are efficient and scalable methodsfor the solution of such linear systems, such as CG preconditioned with analgebraic multigrid. This is opposed to the saddle point problem akin to the mixedLaplace (see <a class="el" href="step_20.html">step-20</a> ) we would get were we to continue with the mixed formulationcontaining both displacements and stresses, and for which <a class="el" href="step_20.html">step-20</a> already gives ahint at how difficult it is to construct good solvers and preconditioners. With this said, let us simply state the problem we obtain after reformulation(again, details can be found in the paper): Find a displacement \(\mathbf u \in V^+\) so that <p class="formulaDsp">
\begin{align*} \left(P_{\Pi}(C\varepsilon(\mathbf u)),\varepsilon(\varphi) - \varepsilon(\mathbf u)\right) \geq 0,\quad \forall \varphi\in V^+. \end{align*}
</p>
 where the projector \(P_\Pi\) is defined as <p class="formulaDsp">
\begin{align*} P_{\Pi}(\tau) \dealcoloneq \begin{cases} \tau, &amp; \text{if }\vert\tau^D\vert \leq \sigma_0,\\ \left[ \dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}} + \left(1-\dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\right)\dfrac{\sigma_0}{\vert\tau^D\vert} \right]\tau^D + \dfrac{1}{3}\text{trace}(\tau) I, &amp; \text{if }\vert\tau^D\vert &gt; \sigma_0, \end{cases} \end{align*}
</p>
 and the space \(V^+\) is the space of all displacements that satisfy the contactcondition: <p class="formulaDsp">
\begin{align*} V &amp;= \left\{ \mathbf u\in \left[H^1(\Omega)\right]^{d}: \mathbf u = 0 \text{ on } \Gamma_D\right\}, \\ V^+ &amp;= \left\{ \mathbf u\in V: \mathbf n \cdot \mathbf u\leq g \text{ on } \Gamma_C \right\}. \end{align*}
</p>
</li>
</ul>
<p>In the actual code, we will use the abbreviation \(\gamma=\dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\) . Given this formulation, we will apply two techniques:</p>
<ul>
<li>Run a Newton method to iterate out the nonlinearity in the projector.</li>
<li>Run an active set method for the contact condition, in much the same way as we did in <a class="el" href="step_41.html">step-41</a> . A strict approach would keep the active set fixed while we iteratethe Newton method to convergence (or maybe the other way around: find thefinal active set before moving on to the next Newton iteration).In practice, it turns out that it is sufficient to do only a singleNewton step per active set iteration, and so we will iterate over themconcurrently. We will also, every once in a while, refine the mesh.</li>
</ul>
<p><a class="anchor" id="ANewtonmethodfortheplasticnonlinearity"></a></p><h3>A Newton method for the plastic nonlinearity</h3>
<p>As mentioned, we will treat the nonlinearity of the operator \(P_\Pi\) byapplying a Newton method, despite the fact that the operator is not differentiablein the strict sense. However, it satisfies the conditions of <em>slant</em>differentiability and this turns out to be enough for Newton's method to work.The resulting method then goes by the name <em>semi-smooth Newton method</em>,which sounds impressive but is, in reality, just a Newton method applied toa semi-smooth function with an appropriately chosen "derivative". In the current case, we will run our iteration by solving in each iteration \(i\) the following equation (still an inequality, but linearized): </p><p class="formulaDsp">
\begin{align*} \label{eq:linearization} \left(I_{\Pi}\varepsilon(\tilde {\mathbf u}^{i}), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right) \geq \left(\left(I_{\Pi}\varepsilon({\mathbf u}^{i-1}), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right) - \left(P_{\Pi}(C\varepsilon({\mathbf u}^{i-1})), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right)\right), \quad \forall \varphi\in V^+, \end{align*}
</p>
<p> where the rank-4 tensor \(I_\Pi=I_\Pi(\varepsilon^D(\mathbf u^{i-1}))\) given by </p><p class="formulaDsp">
\begin{align} I_\Pi = \begin{cases} C_{\mu} + C_{\kappa}, &amp; \hspace{-8em} \text{if } \vert C\varepsilon^D(\mathbf u^{i-1}) \vert \leq \sigma_0, \\ \frac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}} C_{\mu} + \frac{\left(1-\frac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\right)\sigma_0}{\vert C\varepsilon^D(\mathbf u^{i-1}) \vert}\left(C_{\mu} - 2\mu\dfrac{C\varepsilon^D(\mathbf u^{i-1})\otimes C\varepsilon^D(\mathbf u^{i-1})}{\vert C\varepsilon^D(\mathbf u^{i-1})\vert^2}\right) + C_{\kappa}, &amp; \text{ else.} \end{cases} \end{align}
</p>
<p> This tensor is the (formal) linearization of \(P_\Pi(C\cdot)\) around \(\varepsilon^D(\mathbf u^{i-1})\) .For the linear isotropic material we consider here,the bulk and shear components of the projector are given by </p><p class="formulaDsp">
\begin{gather*} C_{\kappa} = \kappa I\otimes I, \qquad\qquad\qquad\qquad C_{\mu} = 2\mu\left(\mathbb{I} - \dfrac{1}{3} I\otimes I\right), \end{gather*}
</p>
<p> where \(I\) and \(\mathbb{I}\) are the identity tensors of rank 2 and 4, respectively. Note that this problem corresponds to a linear elastic contact problemwhere \(I_\Pi\) plays the role of the elasticity tensor \(C=A^{-1}\) . Indeed,if the material is not plastic at a point, then \(I_\Pi=C\) . However, atplaces where the material is plastic, \(I_\Pi\) is a spatially varyingfunction. In any case, the system we have to solve for the Newton iterate \(\tilde {\mathbf u}^{i}\) gets us closer to the goal of rewriting our problem ina way that allows us to use well-known solvers and preconditioners forelliptic systems. As a final note about the Newton method let us mention that as is common withNewton methods we need to globalize it by controlling the step length. Inother words, while the system above solves for \(\tilde {\mathbf u}^{i}\) , the finaliterate will rather be </p><p class="formulaDsp">
\begin{align*} {\mathbf u}^{i} = {\mathbf u}^{i-1} + \alpha_i (\tilde {\mathbf u}^{i} - {\mathbf u}^{i-1}) \end{align*}
</p>
<p> where the difference in parentheses on the right takes the role of thetraditional Newton direction, \(\delta {\mathbf u}^{i}\) . We will determine \(\alpha^i\) using a standard line search.</p>
<p><a class="anchor" id="ActiveSetmethodstosolvethesaddlepointproblem"></a></p><h3>Active Set methods to solve the saddle point problem</h3>
<p>This linearized problem to be solved in each Newton step is essentially likein <a class="el" href="step_41.html">step-41</a> . The only difference consists in the fact that the contact areais at the boundary instead of in the domain. But this has no further consequenceso that we refer to the documentation of <a class="el" href="step_41.html">step-41</a> with the only hint that \(\mathcal{S}\) contains all the vertices at the contact boundary \(\Gamma_C\) thistime. As there, what we need to do is keep a subset of degrees of freedom fixed,leading to additional constraints that one can write as a saddle point problem.However, as discussed in the paper, by writing these constraints in anappropriate way that removes the coupling between degrees of freedom,we end up with a set of nodes that essentially just have Dirichlet valuesattached to them.</p>
<p><a class="anchor" id="Overallalgorithm"></a></p><h3>Overall algorithm</h3>
<p>The algorithm outlined above combines the damped semismooth Newton-method,which we use for the nonlinear constitutive law, with the semismooth Newtonmethod for the contact. It works as follows: </p><ol>
<li>
Initialize the active and inactive sets \(\mathcal{A}_i\) and \(\mathcal{F}_i\) such that \(\mathcal{S} = \mathcal{A}_i \cup \mathcal{F}_i\) and \(\mathcal{A}_i \cap \mathcal{F}_i = \emptyset\) and set \(i = 1\) . Here, \(\mathcal{S}\) is the set of all degrees of freedom located at the surface of the domain where contact may happen. The start value \(\hat U^0 \dealcoloneq P_{\mathcal{A}_k}(0)\) fulfills our obstacle condition, i.e., we project an initial zero displacement onto the set of feasible displacements. </li>
<li>
Assemble the Newton matrix \(A_{pq} \dealcoloneq a&#39;( U^{i-1};\varphi_p,\varphi_q)\) and the right-hand-side \(F(\hat U^{i-1})\) . These correspond to the linearized Newton step, ignoring for the moment the contact inequality. </li>
<li>
<p class="startli">Find the primal-dual pair \((\tilde U^i,\Lambda^i)\) that satisfies</p>
<p class="formulaDsp">
\begin{align*} A\tilde U^i + B\Lambda^i &amp; = F, &amp;\\ \left[B^T\tilde U^i\right]_p &amp; = G_p &amp; \forall p\in\mathcal{A}_i,\\ \Lambda^i_p &amp; = 0 &amp; \forall p\in\mathcal{F}_i. \end{align*}
</p>
<p> As in <a class="el" href="step_41.html">step-41</a> , we can obtain the solution to this problem by eliminating those degrees of freedom in \({\cal A}_i\) from the first equation and obtain a linear system \(\hat {\hat A}(U^{i-1}) \tilde U^i = \hat {\hat H}(U^{i-1})\) .</p>
<p class="endli"></p>
</li>
<li>
Damp the Newton iteration for \(i&gt;2\) by applying a line search and calculating a linear combination of \(U^{i-1}\) and \(\tilde U^i\) . This requires finding an \(\alpha^i_l \dealcoloneq 2^{-l},(l=0,\ldots,10)\) so that <p class="formulaDsp">
\begin{gather*}U^i \dealcoloneq \alpha^i_l\bar U^i + (1-\alpha^i_l)U^{i-1}\end{gather*}
</p>
 satisfies <p class="formulaDsp">
\begin{gather*} \vert {\hat R}\left({\mathbf u}^{i}\right) \vert &lt; \vert {\hat R}\left({\mathbf u}^{i-1}\right) \vert. \end{gather*}
</p>
 with \({\hat R}\left({\mathbf u}\right)=\left(P_{Pi}(C\varepsilon(u)),\varepsilon(\varphi^{i}_p\right)\) with the exceptions of (i) elements \(p\in\mathcal{A}_i\) where we set \({\hat R}\left({\mathbf u}\right)=0\) , and (ii) elements that correspond to hanging nodes, which we eliminate in the usual manner. </li>
<li>
<p class="startli">Define the new active and inactive sets by </p><p class="formulaDsp">
\begin{gather*}\mathcal{A}_{i+1} \dealcoloneq \lbrace p\in\mathcal{S}:\Lambda^i_p + c\left(\left[B^TU^i\right]_p - G_p\right) &gt; 0\rbrace,\end{gather*}
</p>
 <p class="formulaDsp">
\begin{gather*}\mathcal{F}_{i+1} \dealcoloneq \lbrace p\in\mathcal{S}:\Lambda^i_p + c\left(\left[B^TU^i\right]_p - G_p\right) \leq 0\rbrace.\end{gather*}
</p>
<p class="endli"></p>
</li>
<li>
Project \(U^i\) so that it satisfies the contact inequality, <p class="formulaDsp">
\begin{gather*}\hat U^i \dealcoloneq P_{\mathcal{A}_{i+1}}(U^i).\end{gather*}
</p>
 Here, \(P_{\mathcal{A}}(U)\) is the projection of the active components in \(\mathcal{A}\) to the gap <p class="formulaDsp">
\begin{gather*}P_{\mathcal{A}}(U)_p \dealcoloneq \begin{cases} U_p, &amp; \textrm{if}\quad p\notin\mathcal{A}\\ g_{h,p}, &amp; \textrm{if}\quad p\in\mathcal{A}, \end{cases}\end{gather*}
</p>
 where \(g_{h,p}\) is the <em>gap</em> denoting the distance of the obstacle from the undisplaced configuration of the body. </li>
<li>
If \(\mathcal{A}_{i+1} = \mathcal{A}_k\) and \(\left\| {\hat R}\left({\mathbf u}^{i}\right) \right\|_{\ell_2} &lt; \delta\) then stop, else set \(i=i+1\) and go to step (1). This step ensures that we only stop iterations if both the correct active set has been found and the plasticity has been iterated to sufficient accuracy. </li>
</ol>
<p>In step 3 of this algorithm,the matrix \(B\in\mathbb{R}^{n\times m}\) , \(n&gt;m\) describes the coupling of thebases for the displacements and Lagrange multiplier (contact forces)and it is not quadratic in our situation since \(\Lambda^k\) is only defined on \(\Gamma_C\) , i.e., the surface where contact may happen. As shown in the paper,we can choose \(B\) to be a matrix that has only one entry per row,(see also H&uuml;eber, Wohlmuth: A primal-dual activeset strategy for non-linear multibody contact problems, Comput. Methods Appl. Mech. Engrg.194, 2005, pp. 3147-3166).The vector \(G\) is defined by a suitable approximation \(g_h\) of the gap \(g\) </p><p class="formulaDsp">
\begin{gather*}G_p = \begin{cases} g_{h,p}, &amp; \text{if}\quad p\in\mathcal{S}\\ 0, &amp; \text{if}\quad p\notin\mathcal{S}. \end{cases}\end{gather*}
</p>
<p><a class="anchor" id="Adaptivemeshrefinement"></a></p><h3>Adaptive mesh refinement</h3>
<p>Since we run our program in 3d, the computations the program performs areexpensive. Consequently using adaptive mesh refinement is an important step towardsstaying within acceptable run-times. To make our lives easier we simply choose theKellyErrorEstimator that is already implemented in deal.II. We hand thesolution vector to it which contains the displacement \(u\) . As we will see in theresults it yields a quite reasonable adaptive mesh for the contact zone as wellas for plasticity.</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>This tutorial is essentially a mixture of <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_41.html">step-41</a> but instead ofPETSc we let the Trilinos library deal with parallelizing the linear algebra(like in <a class="el" href="step_32.html">step-32</a> ). Since we are trying to solve a similar problem like in <a class="el" href="step_41.html">step-41</a> we will use the same methods but now in parallel. A difficulty is handling of the constraints fromthe Dirichlet conditions, hanging nodes and the inequality condition thatarises from the contact. For this purpose we create three objects of typeAffineConstraints that describe the various constraints and that we willcombine as appropriate in each iteration. Compared to <a class="el" href="step_41.html">step-41</a> , the programs has a few new classes: </p><ul>
<li>
<code>ConstitutiveLaw</code> describes the plastic behavior of the material </li>
<li>
<code>SphereObstacle</code> describes a sphere that serves as the obstacle that is pushed into the deformable, elastoplastic body. Whether this or the next class is used to describe the obstacle is determined from the input parameter file. </li>
<li>
<p class="startli"><code>ChineseObstacle</code> (and a helper class) is a class that allows us to read in an obstacle from a file. In the example we will show in the results section, this file will be <code>'obstacle_file.dat'</code> and will correspond to data that shows the Chinese, Japanese or Korean symbol for force or power (see <a href="http://www.orientaloutpost.com/">http://www.orientaloutpost.com/</a> : "This word can be used for motivation</p>
<ul>
<li>it can also mean power/motion/propulsion/force. It can be anything internal or external that keeps you going. This is the safest way to express motivation in Chinese. If your audience is Japanese, please see the other entry for motivation. This is a word in Japanese and Korean, but it means "motive  power" or "kinetic energy" (without the motivation meaning that you are probably looking for)"). In essence, we will pretend that we have a stamp  (i.e., a mask that corresponds to a flat bottomed obstacle with no pieces  of intermediate height) that we press into the body. The symbol in question  looks as follows (see also the picture at  the top of this section on how the end result looks like):
 &lt;img src="<a href="https://www.dealii.org/images/steps/developer/step-42.character.png">https://www.dealii.org/images/steps/developer/step-42.character.png</a>" alt="" width="25%"&gt; </li>
</ul>
</li>
</ul>
<p>Other than that, let us comment only on the following aspects: </p><ul>
<li>
The program allows you to select from two different coarse meshes through the parameter file. These are either a cube \([0,1]^3\) or a half sphere with the open side facing the positive \(z\) direction. </li>
<li>
In either case, we will assume the convention that the part of the boundary that may be in contact with the obstacle has boundary indicator one. For both kinds of meshes, we assume that this is a free surface, i.e., the body is either in contact there or there is no force acting on it. For the half sphere, the curved part has boundary indicator zero and we impose zero displacement there. For the box, we impose zero displacement along the bottom but allow vertical displacement along the sides (though no horizontal displacement). </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The set of include files is not much of a surprise any more at this time:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__field__function_8h.html">deal.II/numerics/fe_field_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Finally, we include two system headers that let us create a directory for output files. The first header provides the <code>mkdir</code> function and the second lets us determine what happened if <code>mkdir</code> fails.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cerrno&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step42</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeConstitutiveLawcodeclasstemplate"></a> </p><h3>The <code>ConstitutiveLaw</code> class template</h3>
<p>This class provides an interface for a constitutive law, i.e., for the relationship between strain \(\varepsilon(\mathbf u)\) and stress \(\sigma\) . In this example we are using an elastoplastic material behavior with linear, isotropic hardening. Such materials are characterized by Young's modulus \(E\) , Poisson's ratio \(\nu\) , the initial yield stress \(\sigma_0\) and the isotropic hardening parameter \(\gamma\) . For \(\gamma = 0\) we obtain perfect elastoplastic behavior. As explained in the paper that describes this program, the first Newton steps are solved with a completely elastic material model to avoid having to deal with both nonlinearities (plasticity and contact) at once. To this end, this class has a function <code>set_sigma_0()</code> that we use later on to simply set \(\sigma_0\) to a very large value</p>
<ul>
<li>essentially guaranteeing that the actual stress will not exceed it, and thereby producing an elastic material. When we are ready to use a plastic model, we set \(\sigma_0\) back to its proper value, using the same function. As a result of this approach, we need to leave <code>sigma_0</code> as the only non-const member variable of this class.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ConstitutiveLaw</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConstitutiveLaw(<span class="keyword">const</span> <span class="keywordtype">double</span> E,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> nu,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> sigma_0,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> gamma);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_sigma_0(<span class="keywordtype">double</span> sigma_zero);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> get_stress_strain_tensor(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> get_linearized_stress_strain_tensors(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">  <span class="keywordtype">double</span>       sigma_0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_kappa;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_mu;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the ConstitutiveLaw class sets the required material parameter for our deformable body. Material parameters for elastic isotropic media can be defined in a variety of ways, such as the pair \(E, \nu\) (elastic modulus and Poisson's number), using the Lam&eacute; parameters \(\lambda,mu\) or several other commonly used conventions. Here, the constructor takes a description of material parameters in the form of \(E,\nu\) , but since this turns out to these are not the coefficients that appear in the equations of the plastic projector, we immediately convert them into the more suitable set \(\kappa,\mu\) of bulk and shear moduli. In addition, the constructor takes \(\sigma_0\) (the yield stress absent any plastic strain) and \(\gamma\) (the hardening parameter) as arguments. In this constructor, we also compute the two principal components of the stress-strain relation and its linearization.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ConstitutiveLaw&lt;dim&gt;::ConstitutiveLaw(<span class="keywordtype">double</span> E,</div><div class="line">                                      <span class="keywordtype">double</span> nu,</div><div class="line">                                      <span class="keywordtype">double</span> sigma_0,</div><div class="line">                                      <span class="keywordtype">double</span> gamma)</div><div class="line">  : kappa(E / (3 (1</div><div class="line"></div><div class="line">- 2 nu)))</div><div class="line">  , mu(E / (2 (1 + nu)))</div><div class="line">  , sigma_0(sigma_0)</div><div class="line">  , gamma(gamma)</div><div class="line">  , stress_strain_tensor_kappa(kappa</div><div class="line">                               <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                             <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()))</div><div class="line">  , stress_strain_tensor_mu(</div><div class="line">      2 mu</div><div class="line">      (<a class="code" href="symmetric__tensor_8h.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor</a>&lt;dim&gt;()</div><div class="line"></div><div class="line">- <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                              <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()) /</div><div class="line">                                  3.0))</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::set_sigma_0(<span class="keywordtype">double</span> sigma_zero)</div><div class="line">{</div><div class="line">  sigma_0 = sigma_zero;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutiveLawget_stress_strain_tensor"></a> </p><h4>ConstitutiveLaw::get_stress_strain_tensor</h4>
<p>This is the principal component of the constitutive law. It computes the fourth order symmetric tensor that relates the strain to the stress according to the projection given above, when evaluated at a particular strain point. We need this function to calculate the nonlinear residual in <code>PlasticityContactProblem::residual_nl_system()</code> where we multiply this tensor with the strain given in a quadrature point. The computations follow the formulas laid out in the introduction. In comparing the formulas there with the implementation below, recall that \(C_\mu : \varepsilon = \tau_D\) and that \(C_\kappa : \varepsilon = \kappa \text{trace}(\varepsilon) I = \frac 13 \text{trace}(\tau) I\) . The function returns whether the quadrature point is plastic to allow for some statistics downstream on how many of the quadrature points are plastic and how many are elastic.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> ConstitutiveLaw&lt;dim&gt;::get_stress_strain_tensor(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor =</div><div class="line">    (stress_strain_tensor_kappa + stress_strain_tensor_mu) strain_tensor;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor =</div><div class="line">    <a class="code" href="classSymmetricTensor.html#a6e7fd34dd28fc3f6420068887a939753">deviator</a>(stress_tensor);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">  stress_strain_tensor = stress_strain_tensor_mu;</div><div class="line">  <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor= (gamma + (1</div><div class="line"></div><div class="line">- <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) beta);</div><div class="line">    }</div><div class="line"></div><div class="line">  stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (deviator_stress_tensor_norm &gt; sigma_0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutiveLawget_linearized_stress_strain_tensors"></a> </p><h4>ConstitutiveLaw::get_linearized_stress_strain_tensors</h4>
<p>This function returns the linearized stress strain tensor, linearized around the solution \(u^{i-1}\) of the previous Newton step \(i-1\) . The parameter <code>strain_tensor</code> (commonly denoted \(\varepsilon(u^{i-1})\) ) must be passed as an argument, and serves as the linearization point. The function returns the derivative of the nonlinear constitutive law in the variable stress_strain_tensor, as well as the stress-strain tensor of the linearized problem in stress_strain_tensor_linearized. See PlasticityContactProblem::assemble_nl_system where this function is used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::get_linearized_stress_strain_tensors(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor =</div><div class="line">    (stress_strain_tensor_kappa + stress_strain_tensor_mu) strain_tensor;</div><div class="line"></div><div class="line">  stress_strain_tensor            = stress_strain_tensor_mu;</div><div class="line">  stress_strain_tensor_linearized = stress_strain_tensor_mu;</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = <a class="code" href="classSymmetricTensor.html#a6e7fd34dd28fc3f6420068887a939753">deviator</a>(stress_tensor);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor= (gamma + (1</div><div class="line"></div><div class="line">- <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) beta);</div><div class="line">      stress_strain_tensor_linearized= (gamma + (1</div><div class="line"></div><div class="line">- <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) beta);</div><div class="line">      deviator_stress_tensor /= deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor_linearized</div><div class="line"></div><div class="line">-=</div><div class="line">        (1</div><div class="line"></div><div class="line">- <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) beta 2 mu</div><div class="line">        <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(deviator_stress_tensor, deviator_stress_tensor);</div><div class="line">    }</div><div class="line"></div><div class="line">  stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line">  stress_strain_tensor_linearized += stress_strain_tensor_kappa;</div><div class="line">}</div></div><!-- fragment --><h3>Equation data: boundary forces, boundary values, obstacles</h3>
<p>The following should be relatively standard. We need classes for the boundary forcing term (which we here choose to be zero) and boundary values on those part of the boundary that are not part of the contact surface (also chosen to be zero here).</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryForce();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoundaryForce&lt;dim&gt;::BoundaryForce()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryForce&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryForce&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryForce&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoundaryValues&lt;dim&gt;::BoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.;</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="ThecodeSphereObstaclecodeclass"></a> </p><h4>The <code>SphereObstacle</code> class</h4>
<p>The following class is the first of two obstacles that can be selected from the input file. It describes a sphere centered at position \(x=y=0.5, z=z_{\text{surface}}+0.59\) and radius \(r=0.6\) , where \(z_{\text{surface}}\) is the vertical position of the (flat) surface of the deformable body. The function's <code>value</code> returns the location of the obstacle for a given \(x,y\) value if the point actually lies below the sphere, or a large positive value that can't possibly interfere with the deformation if it lies outside the "shadow" of the sphere.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SphereObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SphereObstacle&lt;dim&gt;::SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface)</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">    , z_surface(z_surface)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> SphereObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (component == 0)</div><div class="line">      <span class="keywordflow">return</span> p(0);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 1)</div><div class="line">      <span class="keywordflow">return</span> p(1);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> ((p(0)</div><div class="line"></div><div class="line">- 0.5) (p(0)</div><div class="line"></div><div class="line">- 0.5) + (p(1)</div><div class="line"></div><div class="line">- 0.5) (p(1)</div><div class="line"></div><div class="line">- 0.5) &lt; 0.36)</div><div class="line">          <span class="keywordflow">return</span> (-std::sqrt(0.36</div><div class="line"></div><div class="line">- (p(0)</div><div class="line"></div><div class="line">- 0.5) (p(0)</div><div class="line"></div><div class="line">- 0.5)</div><div class="line"></div><div class="line">-</div><div class="line">                             (p(1)</div><div class="line"></div><div class="line">- 0.5) (p(1)</div><div class="line"></div><div class="line">- 0.5)) +</div><div class="line">                  z_surface + 0.59);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">return</span> 1000;</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div></div><!-- fragment --><p>preceding Assert</p>
<div class="fragment"><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SphereObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SphereObstacle&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeBitmapFilecodeandcodeChineseObstaclecodeclasses"></a> </p><h4>The <code>BitmapFile</code> and <code>ChineseObstacle</code> classes</h4>
<p>The following two classes describe the obstacle outlined in the introduction, i.e., the Chinese character. The first of the two, <code>BitmapFile</code> is responsible for reading in data from a picture file stored in pbm ascii format. This data will be bilinearly interpolated and thereby provides a function that describes the obstacle. (The code below shows how one can construct a function by interpolating between given data points. One could use the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a>, introduced after this tutorial program was written, which does exactly what we want here, but it is instructive to see how to do it by hand.) The data which we read from the file will be stored in a double std::vector named obstacle_data. This vector composes the base to calculate a piecewise bilinear function as a polynomial interpolation. The data we will read from a file consists of zeros (white) and ones (black). The <code>hx,hy</code> variables denote the spacing between pixels in \(x\) and \(y\) directions. <code>nx,ny</code> are the numbers of pixels in each of these directions. <code>get_value()</code> returns the value of the image at a given location, interpolated from the adjacent pixel values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BitmapFile</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BitmapFile(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;double&gt; obstacle_data;</div><div class="line">  <span class="keywordtype">double</span>              hx, hy;</div><div class="line">  <span class="keywordtype">int</span>                 nx, ny;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of this class reads in the data that describes the obstacle from the given file name.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BitmapFile&lt;dim&gt;::BitmapFile(<span class="keyword">const</span> std::string &amp;name)</div><div class="line">    : obstacle_data(0)</div><div class="line">    , hx(0)</div><div class="line">    , hy(0)</div><div class="line">    , nx(0)</div><div class="line">    , ny(0)</div><div class="line">  {</div><div class="line">    std::ifstream f(name);</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(f,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Can&#39;t read from file &lt;&quot;</span>) + name +</div><div class="line">                           <span class="stringliteral">&quot;&gt;!&quot;</span>));</div><div class="line"></div><div class="line">    std::string temp;</div><div class="line">    f &gt;&gt; temp &gt;&gt; nx &gt;&gt; ny;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(nx &gt; 0 &amp;&amp; ny &gt; 0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid file format.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nx ny; ++k)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> val;</div><div class="line">        f &gt;&gt; val;</div><div class="line">        obstacle_data.push_back(val);</div><div class="line">      }</div><div class="line"></div><div class="line">    hx = 1.0 / (nx</div><div class="line"></div><div class="line">- 1);</div><div class="line">    hy = 1.0 / (ny</div><div class="line"></div><div class="line">- 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Read obstacle from file &lt;&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Resolution of the scanned obstacle picture: &quot;</span> &lt;&lt; nx</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; ny &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>The following two functions return the value of a given pixel with coordinates \(i,j\) , which we identify with the values of a function defined at positions <code>i*hx, j*hy</code> , and at arbitrary coordinates \(x,y\) where we do a bilinear interpolation between point values returned by the first of the two functions. In the second function, for each \(x,y\) , we first compute the (integer) location of the nearest pixel coordinate to the bottom left of \(x,y\) , and then compute the coordinates \(\xi,\eta\) within this pixel. We truncate both kinds of variables from both below and above to avoid problems when evaluating the function outside of its defined range as may happen due to roundoff errors.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    assert(i &gt;= 0 &amp;&amp; i &lt; nx);</div><div class="line">    assert(j &gt;= 0 &amp;&amp; j &lt; ny);</div><div class="line">    <span class="keywordflow">return</span> obstacle_data[nx (ny</div><div class="line"></div><div class="line">- 1</div><div class="line"></div><div class="line">- j) + i];</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> ix = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(x / hx), 0), nx</div><div class="line"></div><div class="line">- 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> iy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(y / hy), 0), ny</div><div class="line"></div><div class="line">- 2);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> xi  = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((x</div><div class="line"></div><div class="line">- ix hx) / hx, 1.), 0.);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> eta = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((y</div><div class="line"></div><div class="line">- iy hy) / hy, 1.), 0.);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> ((1</div><div class="line"></div><div class="line">- xi) (1</div><div class="line"></div><div class="line">- eta) get_pixel_value(ix, iy) +</div><div class="line">            xi (1</div><div class="line"></div><div class="line">- eta) get_pixel_value(ix + 1, iy) +</div><div class="line">            (1</div><div class="line"></div><div class="line">- xi) eta get_pixel_value(ix, iy + 1) +</div><div class="line">            xi eta get_pixel_value(ix + 1, iy + 1));</div><div class="line">  }</div></div><!-- fragment --><p>Finally, this is the class that actually uses the class above. It has a BitmapFile object as a member that describes the height of the obstacle. As mentioned above, the BitmapFile class will provide us with a mask, i.e., values that are either zero or one (and, if you ask for locations between pixels, values that are interpolated between zero and one). This class translates this to heights that are either 0.001 below the surface of the deformable body (if the BitmapFile class reports a one at this location) or 0.999 above the obstacle (if the BitmapFile class reports a zero). The following function should then be self-explanatory.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ChineseObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename, <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> BitmapFile&lt;dim&gt; input_obstacle;</div><div class="line">    <span class="keywordtype">double</span>                z_surface;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ChineseObstacle&lt;dim&gt;::ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">double</span>       z_surface)</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">    , input_obstacle(filename)</div><div class="line">    , z_surface(z_surface)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> ChineseObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (component == 0)</div><div class="line">      <span class="keywordflow">return</span> p(0);</div><div class="line">    <span class="keywordflow">if</span> (component == 1)</div><div class="line">      <span class="keywordflow">return</span> p(1);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt;= 1.0 &amp;&amp; p(1) &gt;= 0.0 &amp;&amp; p(1) &lt;= 1.0)</div><div class="line">          <span class="keywordflow">return</span> z_surface + 0.999</div><div class="line"></div><div class="line">- input_obstacle.get_value(p(0), p(1));</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">    <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div></div><!-- fragment --><p>preceding Assert</p>
<div class="fragment"><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ChineseObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                          <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = ChineseObstacle&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --><p><a class="anchor" id="ThecodePlasticityContactProblemcodeclasstemplate"></a> </p><h3>The <code>PlasticityContactProblem</code> class template</h3>
<p>This is the main class of this program and supplies all functions and variables needed to describe the nonlinear contact problem. It is close to <a class="el" href="step_41.html">step-41</a> but with some additional features like handling hanging nodes, a Newton method, using Trilinos and p4est for parallel distributed computing. To deal with hanging nodes makes life a bit more complicated since we need another <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object now. We create a Newton method for the active set method for the contact situation and to handle the nonlinear operator for the constitutive law. The general layout of this class is very much like for most other tutorial programs. To make our life a bit easier, this class reads a set of input parameters from an input file. These parameters, using the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, are declared in the <code>declare_parameters</code> function (which is static so that it can be called before we even create an object of the current type), and a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that has been used to read an input file will then be passed to the constructor of this class. The remaining member functions are by and large as we have seen in several of the other tutorial programs, though with additions for the current nonlinear system. We will comment on their purpose as we get to them further below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PlasticityContactProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PlasticityContactProblem(<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> compute_dirichlet_constraints();</div><div class="line">  <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">       assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">  <span class="keywordtype">void</span> assemble_newton_system(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">  <span class="keywordtype">void</span> compute_nonlinear_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">  <span class="keywordtype">void</span> solve_newton_system();</div><div class="line">  <span class="keywordtype">void</span> solve_newton();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> move_mesh(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_contact_force() <span class="keyword">const</span>;</div></div><!-- fragment --><p>As far as member variables are concerned, we start with ones that we use to indicate the MPI universe this program runs on, a stream we use to let exactly one processor produce output to the console (see <a class="el" href="step_17.html">step-17</a> ) and a variable that is used to time the various sections of the program:</p>
<div class="fragment"><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a>           mpi_communicator;</div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer;</div></div><!-- fragment --><p>The next group describes the mesh and the finite element space. In particular, for this parallel program, the finite element space has associated with it variables that indicate which degrees of freedom live on the current processor (the index sets, see also <a class="el" href="step_40.html">step-40</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> documentation module) as well as a variety of constraints: those imposed by hanging nodes, by Dirichlet boundary conditions, and by the active set of contact nodes. Of the three <a class="el" href="classAffineConstraints.html">AffineConstraints</a> variables defined here, the first only contains hanging node constraints, the second also those associated with Dirichlet boundary conditions, and the third these plus the contact constraints. The variable <code>active_set</code> consists of those degrees of freedom constrained by the contact, and we use <code>fraction_of_plastic_q_points_per_cell</code> to keep track of the fraction of quadrature points on each cell where the stress equals the yield stress. The latter is only used to create graphical output showing the plastic zone, but not for any further computation; the variable is a member variable of this class since the information is computed as a by-product of computing the residual, but is used only much later. (Note that the vector is a vector of length equal to the number of active cells on the <em>local mesh</em>; it is never used to exchange information between processors and can therefore be a regular deal.II vector.)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                        n_initial_global_refinements;</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_hanging_nodes;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_dirichlet_and_hanging_nodes;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> all_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>      active_set;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> fraction_of_plastic_q_points_per_cell;</div></div><!-- fragment --><p>The next block of variables corresponds to the solution and the linear systems we need to form. In particular, this includes the Newton matrix and right hand side; the vector that corresponds to the residual (i.e., the Newton right hand side) but from which we have not eliminated the various constraints and that is used to determine which degrees of freedom need to be constrained in the next iteration; and a vector that corresponds to the diagonal of the \(B\) matrix briefly mentioned in the introduction and discussed in the accompanying paper.</p>
<div class="fragment"><div class="line">TrilinosWrappers::SparseMatrix newton_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs_uncondensed;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector;</div></div><!-- fragment --><p>The next block contains the variables that describe the material response:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         e_modulus, nu, <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>, sigma_0;</div><div class="line">ConstitutiveLaw&lt;dim&gt; constitutive_law;</div></div><!-- fragment --><p>And then there is an assortment of other variables that are used to identify the mesh we are asked to build as selected by the parameter file, the obstacle that is being pushed into the deformable body, the mesh refinement strategy, whether to transfer the solution from one mesh to the next, and how many mesh refinement cycles to perform. As possible, we mark these kinds of variables as <code>const</code> to help the reader identify which ones may or may not be modified later on (the output directory being an exception</p>
<ul>
<li>it is never modified outside the constructor but it is awkward to initialize in the member-initializer-list following the colon in the constructor since there we have only one shot at setting it; the same is true for the mesh refinement criterion):</li>
</ul>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string                          base_mesh;</div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;const Function&lt;dim&gt;&gt; obstacle;</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>RefinementStrategy</div><div class="line">  {</div><div class="line">    <span class="keyword">enum</span> value</div><div class="line">    {</div><div class="line">      refine_global,</div><div class="line">      refine_percentage,</div><div class="line">      refine_fix_dofs</div><div class="line">    };</div><div class="line">  };</div><div class="line">  <span class="keyword">typename</span> RefinementStrategy::value refinement_strategy;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span>         transfer_solution;</div><div class="line">  std::string        output_dir;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_cycles;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       current_refinement_cycle;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodePlasticityContactProblemcodeclass"></a> </p><h3>Implementation of the <code>PlasticityContactProblem</code> class</h3>
<p><a class="anchor" id="PlasticityContactProblemdeclare_parameters"></a> </p><h4>PlasticityContactProblem::declare_parameters</h4>
<p>Let us start with the declaration of run-time parameters that can be selected in the input file. These values will be read back in the constructor of this class to initialize the member variables of this class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;polynomial degree&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">    <span class="stringliteral">&quot;Polynomial degree of the FE_Q finite element space, typically 1 or 2.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of initial refinements&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Number of initial global mesh refinement steps before &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;the first computation.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;refinement strategy&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;percentage&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;global|percentage&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;Mesh refinement strategy:\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot; global: one global refinement\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot; percentage: a fixed percentage of cells gets refined using the Kelly estimator.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of cycles&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Number of adaptive mesh refinement cycles to run.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;obstacle&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;sphere&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;sphere|read from file&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;The name of the obstacle to use. This may either be &#39;sphere&#39; if we should &quot;</span></div><div class="line">    <span class="stringliteral">&quot;use a spherical obstacle, or &#39;read from file&#39; in which case the obstacle &quot;</span></div><div class="line">    <span class="stringliteral">&quot;will be read from a file named &#39;obstacle.pbm&#39; that is supposed to be in &quot;</span></div><div class="line">    <span class="stringliteral">&quot;ASCII PBM format.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;output directory&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">    <span class="stringliteral">&quot;Directory for output files (graphical output and benchmark &quot;</span></div><div class="line">    <span class="stringliteral">&quot;statistics). If empty, use the current directory.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;transfer solution&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">    <span class="stringliteral">&quot;Whether the solution should be used as a starting guess &quot;</span></div><div class="line">    <span class="stringliteral">&quot;for the next finer mesh. If false, then the iteration starts at &quot;</span></div><div class="line">    <span class="stringliteral">&quot;zero on every mesh.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;base mesh&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;box&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;box|half sphere&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Select the shape of the domain: &#39;box&#39; or &#39;half sphere&#39;&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodePlasticityContactProblemcodeconstructor"></a> </p><h4>The <code>PlasticityContactProblem</code> constructor</h4>
<p>Given the declarations of member variables as well as the declarations of run-time parameters that are read from the input file, there is nothing surprising in this constructor. In the body we initialize the mesh refinement strategy and the output directory, creating such a directory if necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PlasticityContactProblem&lt;dim&gt;::PlasticityContactProblem(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">          (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">  , computing_timer(MPI_COMM_WORLD,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line"></div><div class="line">  , n_initial_global_refinements(</div><div class="line">      prm.get_integer(<span class="stringliteral">&quot;number of initial refinements&quot;</span>))</div><div class="line">  , triangulation(mpi_communicator)</div><div class="line">  , fe_degree(prm.get_integer(<span class="stringliteral">&quot;polynomial degree&quot;</span>))</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree + 1)), dim)</div><div class="line">  , dof_handler(triangulation)</div><div class="line"></div><div class="line">  , e_modulus(200000)</div><div class="line">  , nu(0.3)</div><div class="line">  , gamma(0.01)</div><div class="line">  , sigma_0(400.0)</div><div class="line">  , constitutive_law(e_modulus, nu, sigma_0, gamma)</div><div class="line"></div><div class="line">  , base_mesh(prm.get(<span class="stringliteral">&quot;base mesh&quot;</span>))</div><div class="line">  , obstacle(prm.get(<span class="stringliteral">&quot;obstacle&quot;</span>) == <span class="stringliteral">&quot;read from file&quot;</span> ?</div><div class="line">               static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;&gt;(</div><div class="line">                 new EquationData::ChineseObstacle&lt;dim&gt;(</div><div class="line">                   <span class="stringliteral">&quot;obstacle.pbm&quot;</span>,</div><div class="line">                   (base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5))) :</div><div class="line">               static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;&gt;(</div><div class="line">                 new EquationData::SphereObstacle&lt;dim&gt;(</div><div class="line">                   base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5)))</div><div class="line"></div><div class="line">  , transfer_solution(prm.get_bool(<span class="stringliteral">&quot;transfer solution&quot;</span>))</div><div class="line">  , n_refinement_cycles(prm.get_integer(<span class="stringliteral">&quot;number of cycles&quot;</span>))</div><div class="line">  , current_refinement_cycle(0)</div><div class="line"></div><div class="line">{</div><div class="line">  std::string strat = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;refinement strategy&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">    refinement_strategy = RefinementStrategy::refine_global;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;percentage&quot;</span>)</div><div class="line">    refinement_strategy = RefinementStrategy::refine_percentage;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  output_dir = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;output directory&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (output_dir != <span class="stringliteral">&quot;&quot;</span> &amp;&amp;(output_dir.rbegin()) != <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">    output_dir += <span class="stringliteral">&quot;/&quot;</span>;</div></div><!-- fragment --><p>If necessary, create a new directory for the output.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> ierr = mkdir(output_dir.c_str(), 0777);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(ierr == 0 || errno == EEXIST, <a class="code" href="group__Exceptions.html#gac29b5f3efd2b164642b8e0c49ad3ad27">ExcIO</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Using output directory &#39;&quot;</span> &lt;&lt; output_dir &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    FE degree &quot;</span> &lt;&lt; fe_degree &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    transfer solution &quot;</span> &lt;&lt; (transfer_solution ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>)</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemmake_grid"></a> </p><h4>PlasticityContactProblem::make_grid</h4>
<p>The next block deals with constructing the starting mesh. We will use the following helper function and the first block of the <code>make_grid()</code> to construct a mesh that corresponds to a half sphere. deal.II has a function that creates such a mesh, but it is in the wrong location and facing the wrong direction, so we need to shift and rotate it a bit before using it. For later reference, as described in the documentation of <a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball()</a>, the flat surface of the halfsphere has boundary indicator zero, while the remainder has boundary indicator one.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> rotate_half_sphere(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;in)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> {in(2), in(1),</div><div class="line"></div><div class="line">-in(0)};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;half sphere&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0, 0, 0);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>     radius = 0.8;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(triangulation, center, radius);</div></div><!-- fragment --><p>Since we will attach a different manifold below, we immediately clear the default manifold description:</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;rotate_half_sphere, triangulation);</div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5), triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5));</div><div class="line">  <a class="code" href="namespaceGridTools.html#aa92034313ef924778e01beb3e24002dd">GridTools::copy_boundary_to_manifold_id</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, manifold_description);</div><div class="line">}</div></div><!-- fragment --><p>Alternatively, create a hypercube mesh. After creating it, assign boundary indicators as follows: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line">&gt;     _______</div><div class="line">&gt;    /  1    /|</div><div class="line">&gt;   /______ / |</div><div class="line">&gt;  |       | 8|</div><div class="line">&gt;  |   8   | /</div><div class="line">&gt;  |_______|/</div><div class="line">&gt;      6</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> In other words, the boundary indicators of the sides of the cube are 8. The boundary indicator of the bottom is 6 and the top has indicator</p><ol type="1">
<li>We set these by looping over all cells of all faces and looking at coordinate values of the cell center, and will make use of these indicators later when evaluating which boundary will carry Dirichlet boundary conditions or will be subject to potential contact. (In the current case, the mesh contains only a single cell, and all of its faces are on the boundary, so both the loop over all cells and the query whether a face is on the boundary are, strictly speaking, unnecessary; we retain them simply out of habit: this kind of code can be found in many programs in essentially this form.)</li>
</ol>
<div class="fragment"><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1(0, 0, 0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p2(1.0, 1.0, 1.0);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation, p1, p2);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2]</div><div class="line"></div><div class="line">- p2[2]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(1);</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0]</div><div class="line"></div><div class="line">- p1[0]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0]</div><div class="line"></div><div class="line">- p2[0]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1]</div><div class="line"></div><div class="line">- p1[1]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1]</div><div class="line"></div><div class="line">- p2[1]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(8);</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2]</div><div class="line"></div><div class="line">- p1[2]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(6);</div><div class="line">            }</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsetup_system"></a> </p><h4>PlasticityContactProblem::setup_system</h4>
<p>The next piece in the puzzle is to set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, resize vectors and take care of various other status variables such as index sets and constraint matrices. In the following, each group of operations is put into a brace-enclosed block that is being timed by the variable declared at the top of the block (the constructor of the <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable starts the timed section, the destructor that is called at the end of the block stops it again).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="comment">// setup dofs and get index sets for locally owned and relevant dofs</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: distribute DoFs&quot;</span>);</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">    locally_relevant_dofs.<a class="code" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a>();</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler,</div><div class="line">                                            locally_relevant_dofs);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// setup hanging nodes and Dirichlet constraints</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: constraints&quot;</span>);</div><div class="line">    constraints_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            constraints_hanging_nodes);</div><div class="line">    constraints_hanging_nodes.close();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    compute_dirichlet_constraints();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// initialization of vectors and the active set</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: vectors&quot;</span>);</div><div class="line">    solution.reinit(locally_relevant_dofs, mpi_communicator);</div><div class="line">    newton_rhs.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    fraction_of_plastic_q_points_per_cell.reinit(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    active_set.clear();</div><div class="line">    active_set.set_size(dof_handler.n_dofs());</div><div class="line">  }</div></div><!-- fragment --><p>Finally, we set up sparsity patterns and matrices. We temporarily (ab)use the system matrix to also build the (diagonal) matrix that we use in eliminating degrees of freedom that are in contact with the obstacle, but we then immediately set the Newton matrix back to zero.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>                t(computing_timer, <span class="stringliteral">&quot;Setup: matrix&quot;</span>);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(locally_owned_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                    sp,</div><div class="line">                                    constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                    <span class="keyword">false</span>,</div><div class="line">                                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                      mpi_communicator));</div><div class="line">    sp.compress();</div><div class="line">    newton_matrix.reinit(sp);</div><div class="line"></div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix = newton_matrix;</div><div class="line"></div><div class="line">    assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start = (newton_rhs.local_range().first),</div><div class="line">                       end   = (newton_rhs.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = start; j &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++j)</div><div class="line">      diag_mass_matrix_vector(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">    diag_mass_matrix_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    mass_matrix = 0;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_dirichlet_constraints"></a> </p><h4>PlasticityContactProblem::compute_dirichlet_constraints</h4>
<p>This function, broken out of the preceding one, computes the constraints associated with Dirichlet-type boundary conditions and puts them into the <code>constraints_dirichlet_and_hanging_nodes</code> variable by merging with the constraints that come from hanging nodes. As laid out in the introduction, we need to distinguish between two cases:</p>
<ul>
<li>If the domain is a box, we set the displacement to zero at the bottom, and allow vertical movement in z-direction along the sides. As shown in the <code>make_grid()</code> function, the former corresponds to boundary indicator 6, the latter to 8.</li>
<li>If the domain is a half sphere, then we impose zero displacement along the curved part of the boundary, associated with boundary indicator zero.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_dirichlet_constraints()</div><div class="line">{</div><div class="line">  constraints_dirichlet_and_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">  constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">    {</div></div><!-- fragment --><p>interpolate all components of the solution</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">  dof_handler,</div><div class="line">  6,</div><div class="line">  EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">  constraints_dirichlet_and_hanging_nodes,</div><div class="line">  <a class="code" href="classComponentMask.html">ComponentMask</a>());</div></div><!-- fragment --><p>interpolate x- and y-components of the solution (this is a bit mask, so apply operator| )</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        8,</div><div class="line">        EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">        constraints_dirichlet_and_hanging_nodes,</div><div class="line">        (fe.component_mask(x_displacement) |</div><div class="line">         fe.component_mask(y_displacement)));</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      dof_handler,</div><div class="line">      0,</div><div class="line">      EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">      constraints_dirichlet_and_hanging_nodes,</div><div class="line">      <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">  constraints_dirichlet_and_hanging_nodes.close();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemassemble_mass_matrix_diagonal"></a> </p><h4>PlasticityContactProblem::assemble_mass_matrix_diagonal</h4>
<p>The next helper function computes the (diagonal) mass matrix that is used to determine the active set of the active set method we use in the contact algorithm. This matrix is of mass matrix type, but unlike the standard mass matrix, we can make it diagonal (even in the case of higher order elements) by using a quadrature formula that has its quadrature points at exactly the same locations as the interpolation points for the finite element are located. We achieve this by using a <a class="el" href="classQGaussLobatto.html">QGaussLobatto</a> quadrature formula here, along with initializing the finite element with a set of interpolation points derived from the same quadrature formula. The remainder of the function is relatively straightforward: we put the resulting matrix into the given argument; because we know the matrix is diagonal, it is sufficient to have a loop over only \(i\) and not over \(j\) . Strictly speaking, we could even avoid multiplying the shape function's values at quadrature point <code>q_point</code> by itself because we know the shape value to be a vector with exactly one one which when dotted with itself yields one. Since this function is not time critical we add this term for clarity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">  TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">{</div><div class="line">  <a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">          {</div><div class="line">            fe_values_face.reinit(cell, face);</div><div class="line">            cell_matrix = 0;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                 ++q_point)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">                  (fe_values_face[displacement].value(i, q_point)</div><div class="line">                   fe_values_face[displacement].value(i, q_point)</div><div class="line">                   fe_values_face.JxW(q_point));</div><div class="line"></div><div class="line">            cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a>(local_dof_indices[i],</div><div class="line">                              local_dof_indices[i],</div><div class="line">                              cell_matrix(i, i));</div><div class="line">          }</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemupdate_solution_and_constraints"></a> </p><h4>PlasticityContactProblem::update_solution_and_constraints</h4>
<p>The following function is the first function we call in each Newton iteration in the <code>solve_newton()</code> function. What it does is to project the solution onto the feasible set and update the active set for the degrees of freedom that touch or penetrate the obstacle. In order to function, we first need to do some bookkeeping: We need to write into the solution vector (which we can only do with fully distributed vectors without ghost elements) and we need to read the Lagrange multiplier and the elements of the diagonal mass matrix from their respective vectors (which we can only do with vectors that do have ghost elements), so we create the respective vectors. We then also initialize the constraints object that will contain constraints from contact and all other sources, as well as an object that contains an index set of all locally owned degrees of freedom that are part of the contact:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">{</div><div class="line">  std::vector&lt;bool&gt; dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">  distributed_solution = solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                       mpi_communicator);</div><div class="line">  lambda = newton_rhs_uncondensed;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector_relevant(</div><div class="line">    locally_relevant_dofs, mpi_communicator);</div><div class="line">  diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;</div><div class="line"></div><div class="line"></div><div class="line">  all_constraints.reinit(locally_relevant_dofs);</div><div class="line">  active_set.clear();</div></div><!-- fragment --><div class="fragment"><div class="line">  <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_quadrature(fe.get_unit_face_support_points());</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>   fe_values_face(fe,</div><div class="line">                                   face_quadrature,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_face   = fe.n_dofs_per_face();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature.size();</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; dof_indices(dofs_per_face);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (!cell-&gt;is_artificial())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">          {</div><div class="line">            fe_values_face.reinit(cell, face);</div><div class="line">            face-&gt;get_dof_indices(dof_indices);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                 ++q_point)</div><div class="line">              {</div></div><!-- fragment --><p>At each quadrature point (i.e., at each support point of a degree of freedom located on the contact boundary), we then ask whether it is part of the z-displacement degrees of freedom and if we haven't encountered this degree of freedom yet (which can happen for those on the edges between faces), we need to evaluate the gap between the deformed object and the obstacle. If the active set condition is true, then we add a constraint to the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object that the next Newton update needs to satisfy, set the solution vector's corresponding element to the correct value, and add the index to the <a class="el" href="classIndexSet.html">IndexSet</a> object that stores which degree of freedom is part of the contact:</p>
<div class="fragment"><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component =</div><div class="line">                  fe.face_system_to_component_index(q_point).first;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_z = dof_indices[q_point];</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> ((component == 2) &amp;&amp; (dof_touched[index_z] == <span class="keyword">false</span>))</div><div class="line">                  {</div><div class="line">                    dof_touched[index_z] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> this_support_point =</div><div class="line">                      fe_values_face.quadrature_point(q_point);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value =</div><div class="line">                      obstacle-&gt;value(this_support_point, 2);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> solution_here = solution(index_z);</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> undeformed_gap =</div><div class="line">                      obstacle_value</div><div class="line"></div><div class="line">- this_support_point(2);</div><div class="line"></div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> c = 100.0 e_modulus;</div><div class="line">                    <span class="keywordflow">if</span> ((lambda(index_z) /</div><div class="line">                             diag_mass_matrix_vector_relevant(index_z) +</div><div class="line">                           c (solution_here</div><div class="line"></div><div class="line">- undeformed_gap) &gt;</div><div class="line">                         0) &amp;&amp;</div><div class="line">                        !constraints_hanging_nodes.is_constrained(index_z))</div><div class="line">                      {</div><div class="line">                        all_constraints.add_line(index_z);</div><div class="line">                        all_constraints.set_inhomogeneity(index_z,</div><div class="line">                                                          undeformed_gap);</div><div class="line">                        distributed_solution(index_z) = undeformed_gap;</div><div class="line"></div><div class="line">                        active_set.add_index(index_z);</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div></div><!-- fragment --><p>At the end of this function, we exchange data between processors updating those ghost elements in the <code>solution</code> variable that have been written by other processors. We then merge the Dirichlet constraints and those from hanging nodes into the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object that already contains the active set. We finish the function by outputting the total number of actively constrained degrees of freedom for which we sum over the number of actively constrained degrees of freedom owned by each of the processors. This number of locally owned constrained degrees of freedom is of course the number of elements of the intersection of the active set and the set of locally owned degrees of freedom, which we can get by using <code>operator&amp;</code> on two IndexSets:</p>
<div class="fragment"><div class="line">  distributed_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  solution = distributed_solution;</div><div class="line"></div><div class="line">  all_constraints.close();</div><div class="line">  all_constraints.merge(constraints_dirichlet_and_hanging_nodes);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;         Size of active set: &quot;</span></div><div class="line">        &lt;&lt; <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set &amp; locally_owned_dofs).n_elements(),</div><div class="line">                               mpi_communicator)</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemassemble_newton_system"></a> </p><h4>PlasticityContactProblem::assemble_newton_system</h4>
<p>Given the complexity of the problem, it may come as a bit of a surprise that assembling the linear system we have to solve in each Newton iteration is actually fairly straightforward. The following function builds the Newton right hand side and Newton matrix. It looks fairly innocent because the heavy lifting happens in the call to <code>ConstitutiveLaw::get_linearized_stress_strain_tensors()</code> and in particular in <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, using the constraints we have previously computed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_newton_system(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assembling&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensor(n_q_points);</div><div class="line">        fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">          linearization_point, strain_tensor);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">            constitutive_law.get_linearized_stress_strain_tensors(</div><div class="line">              strain_tensor[q_point],</div><div class="line">              stress_strain_tensor_linearized,</div><div class="line">              stress_strain_tensor);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div></div><!-- fragment --><p>Having computed the stress-strain tensor and its linearization, we can now put together the parts of the matrix and right hand side. In both, we need the linearized stress-strain tensor times the symmetric gradient of \(\varphi_i\) , i.e. the term \(I_\Pi\varepsilon(\varphi_i)\) , so we introduce an abbreviation of this term. Recall that the matrix corresponds to the bilinear form \(A_{ij}=(I_\Pi\varepsilon(\varphi_i),\varepsilon(\varphi_j))\) in the notation of the accompanying publication, whereas the right hand side is \(F_i=([I_\Pi-P_\Pi C]\varepsilon(\varphi_i),\varepsilon(\mathbf u))\) where \(u\) is the current linearization points (typically the last solution). This might suggest that the right hand side will be zero if the material is completely elastic (where \(I_\Pi=P_\Pi\) ) but this ignores the fact that the right hand side will also contain contributions from non-homogeneous constraints due to the contact. The code block that follows this adds contributions that are due to boundary forces, should there be any.</p>
<div class="fragment"><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_phi_i =</div><div class="line">                  stress_strain_tensor_linearized</div><div class="line">                  fe_values[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (stress_phi_i</div><div class="line">                     fe_values[displacement].symmetric_gradient(j, q_point)</div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  ((stress_phi_i</div><div class="line"></div><div class="line">-</div><div class="line">                    stress_strain_tensor</div><div class="line">                      fe_values[displacement].symmetric_gradient(i,</div><div class="line">                                                                 q_point))</div><div class="line">                   strain_tensor[q_point] fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              boundary_force.vector_value_list(</div><div class="line">                fe_values_face.get_quadrature_points(),</div><div class="line">                boundary_force_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) +=</div><div class="line">                      (fe_values_face[displacement].value(i, q_point)</div><div class="line">                       rhs_values fe_values_face.JxW(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        all_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                   cell_rhs,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   newton_matrix,</div><div class="line">                                                   newton_rhs,</div><div class="line">                                                   <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line"></div><div class="line">  newton_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_nonlinear_residual"></a> </p><h4>PlasticityContactProblem::compute_nonlinear_residual</h4>
<p>The following function computes the nonlinear residual of the equation given the current solution (or any other linearization point). This is needed in the linear search algorithm where we need to try various linear combinations of previous and current (trial) solution to compute the (real, globalized) solution of the current Newton step. That said, in a slight abuse of the name of the function, it actually does significantly more. For example, it also computes the vector that corresponds to the Newton residual but without eliminating constrained degrees of freedom. We need this vector to compute contact forces and, ultimately, to compute the next active set. Likewise, by keeping track of how many quadrature points we encounter on each cell that show plastic yielding, we also compute the <code>fraction_of_plastic_q_points_per_cell</code> vector that we can later output to visualize the plastic zone. In both of these cases, the results are not necessary as part of the line search, and so we may be wasting a small amount of time computing them. At the same time, this information appears as a natural by-product of what we need to do here anyway, and we want to collect it once at the end of each Newton step, so we may as well do it here. The actual implementation of this function should be rather obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_nonlinear_residual(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  newton_rhs             = 0;</div><div class="line">  newton_rhs_uncondensed = 0;</div><div class="line"></div><div class="line">  fraction_of_plastic_q_points_per_cell = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensors(n_q_points);</div><div class="line">        fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">          linearization_point, strain_tensors);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span>              q_point_is_plastic =</div><div class="line">              constitutive_law.get_stress_strain_tensor(</div><div class="line">                strain_tensors[q_point], stress_strain_tensor);</div><div class="line">            <span class="keywordflow">if</span> (q_point_is_plastic)</div><div class="line">              ++fraction_of_plastic_q_points_per_cell(</div><div class="line">                cell-&gt;active_cell_index());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                cell_rhs(i)</div><div class="line"></div><div class="line">-=</div><div class="line">                  (strain_tensors[q_point] stress_strain_tensor</div><div class="line">                   fe_values[displacement].symmetric_gradient(i, q_point)</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                rhs_values = 0;</div><div class="line">                cell_rhs(i) += (fe_values[displacement].value(i, q_point)</div><div class="line">                                rhs_values fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              boundary_force.vector_value_list(</div><div class="line">                fe_values_face.get_quadrature_points(),</div><div class="line">                boundary_force_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) +=</div><div class="line">                      (fe_values_face[displacement].value(i, q_point)</div><div class="line">                       rhs_values fe_values_face.JxW(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(</div><div class="line">          cell_rhs, local_dof_indices, newton_rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line"></div><div class="line">  fraction_of_plastic_q_points_per_cell /= quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  newton_rhs_uncondensed.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsolve_newton_system"></a> </p><h4>PlasticityContactProblem::solve_newton_system</h4>
<p>The last piece before we can discuss the actual Newton iteration on a single mesh is the solver for the linear systems. There are a couple of complications that slightly obscure the code, but mostly it is just setup then solve. Among the complications are:</p>
<ul>
<li>For the hanging nodes we have to apply the <a class="el" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">AffineConstraints::set_zero</a> function to newton_rhs. This is necessary if a hanging node with solution value \(x_0\) has one neighbor with value \(x_1\) which is in contact with the obstacle and one neighbor \(x_2\) which is not in contact. Because the update for the former will be prescribed, the hanging node constraint will have an inhomogeneity and will look like \(x_0 = x_1/2 + \text{gap}/2\) . So the corresponding entries in the right-hand-side are non-zero with a meaningless value. These values we have to set to zero.</li>
<li>Like in <a class="el" href="step_40.html">step-40</a> , we need to shuffle between vectors that do and do not have ghost elements when solving or using the solution. The rest of the function is similar to <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_41.html">step-41</a> except that we use a BiCGStab solver instead of CG. This is due to the fact that for very small hardening parameters \(\gamma\) , the linear system becomes almost semidefinite though still symmetric. BiCGStab appears to have an easier time with such linear systems.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">  distributed_solution = solution;</div><div class="line"></div><div class="line">  constraints_hanging_nodes.set_zero(distributed_solution);</div><div class="line">  constraints_hanging_nodes.set_zero(newton_rhs);</div><div class="line"></div><div class="line">  TrilinosWrappers::PreconditionAMG preconditioner;</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: setup preconditioner&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(dof_handler,</div><div class="line">                                     <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                     constant_modes);</div><div class="line"></div><div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a>              = <span class="keyword">true</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a4a403dc7faf67ee0fcb6436d7b741687">n_cycles</a>              = 1;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a56500e96ab5ae9b84dd874b38283453b">w_cycle</a>               = <span class="keyword">false</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#ab9fc3e207a7c534094d514685e645c92">output_details</a>        = <span class="keyword">false</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a>       = 2;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 1e-2;</div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(newton_matrix, additional_data);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: iterate&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> relative_accuracy = 1e-8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance =</div><div class="line">      relative_accuracy</div><div class="line">      newton_matrix.residual(tmp, distributed_solution, newton_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(newton_matrix.m(), solver_tolerance);</div><div class="line">    <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line">    solver.solve(newton_matrix,</div><div class="line">                 distributed_solution,</div><div class="line">                 newton_rhs,</div><div class="line">                 preconditioner);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;         Error: &quot;</span> &lt;&lt; solver_control.initial_value() &lt;&lt; <span class="stringliteral">&quot;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">-&gt; &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; Bicgstab iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  all_constraints.distribute(distributed_solution);</div><div class="line"></div><div class="line">  solution = distributed_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsolve_newton"></a> </p><h4>PlasticityContactProblem::solve_newton</h4>
<p>This is, finally, the function that implements the damped Newton method on the current mesh. There are two nested loops: the outer loop for the Newton iteration and the inner loop for the line search which will be used only if necessary. To obtain a good and reasonable starting value we solve an elastic problem in the very first Newton step on each mesh (or only on the first mesh if we transfer solutions between meshes). We do so by setting the yield stress to an unreasonably large value in these iterations and then setting it back to the correct value in subsequent iterations. Other than this, the top part of this function should be reasonably obvious. We initialize the variable <code>previous_residual_norm</code> to the most negative value representable with double precision numbers so that the comparison whether the current residual is less than that of the previous step will always fail in the first step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton()</div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_solution(locally_owned_dofs,</div><div class="line">                                             mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> residual(locally_owned_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp_vector(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_tmp_vector(</div><div class="line">    locally_relevant_dofs, mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> residual_norm;</div><div class="line">  <span class="keywordtype">double</span> previous_residual_norm =</div><div class="line"></div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> correct_sigma = sigma_0;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> old_active_set(active_set);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= 100; ++newton_step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (newton_step == 1 &amp;&amp;</div><div class="line">          ((transfer_solution &amp;&amp; current_refinement_cycle == 0) ||</div><div class="line">           !transfer_solution))</div><div class="line">        constitutive_law.set_sigma_0(1e+10);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == 2 || current_refinement_cycle &gt; 0 ||</div><div class="line">               !transfer_solution)</div><div class="line">        constitutive_law.set_sigma_0(correct_sigma);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Newton iteration &quot;</span> &lt;&lt; newton_step &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;update active set&quot;</span>);</div><div class="line">        update_solution_and_constraints();</div><div class="line">      }</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Assembling system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">      newton_matrix = 0;</div><div class="line">      newton_rhs    = 0;</div><div class="line">      assemble_newton_system(solution);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Solving system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">      solve_newton_system();</div></div><!-- fragment --><p>It gets a bit more hairy after we have computed the trial solution \(\tilde{\mathbf u}\) of the current Newton step. We handle a highly nonlinear problem so we have to damp Newton's method using a line search. To understand how we do this, recall that in our formulation, we compute a trial solution in each Newton step and not the update between old and new solution. Since the solution set is a convex set, we will use a line search that tries linear combinations of the previous and the trial solution to guarantee that the damped solution is in our solution set again. At most we apply 5 damping steps. There are exceptions to when we use a line search. First, if this is the first Newton step on any mesh, then we don't have any point to compare the residual to, so we always accept a full step. Likewise, if this is the second Newton step on the first mesh (or the second on any mesh if we don't transfer solutions from mesh to mesh), then we have computed the first of these steps using just an elastic model (see how we set the yield stress sigma to an unreasonably large value above). In this case, the first Newton solution was a purely elastic one, the second one a plastic one, and any linear combination would not necessarily be expected to lie in the feasible set</p>
<ul>
<li>so we just accept the solution we just got. In either of these two cases, we bypass the line search and just update residual and other vectors as necessary.</li>
</ul>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> ((newton_step == 1) ||</div><div class="line">          (transfer_solution &amp;&amp; newton_step == 2 &amp;&amp;</div><div class="line">           current_refinement_cycle == 0) ||</div><div class="line">          (!transfer_solution &amp;&amp; newton_step == 2))</div><div class="line">        {</div><div class="line">          compute_nonlinear_residual(solution);</div><div class="line">          old_solution = solution;</div><div class="line"></div><div class="line">          residual                     = newton_rhs;</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                             end_res   = (residual.local_range().second);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">            <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">              residual(n) = 0;</div><div class="line"></div><div class="line">          residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">          residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;      Accepting Newton solution with residual: &quot;</span></div><div class="line">                &lt;&lt; residual_norm &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)</div><div class="line">            {</div><div class="line">              distributed_solution = solution;</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.5, static_cast&lt;double&gt;(i));</div><div class="line">              tmp_vector         = old_solution;</div><div class="line">              tmp_vector.sadd(1</div><div class="line"></div><div class="line">- alpha, alpha, distributed_solution);</div><div class="line"></div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Residual and lambda&quot;</span>);</div><div class="line"></div><div class="line">              locally_relevant_tmp_vector = tmp_vector;</div><div class="line">              compute_nonlinear_residual(locally_relevant_tmp_vector);</div><div class="line">              residual = newton_rhs;</div><div class="line"></div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                                 end_res   = (residual.local_range().second);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">                <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">                  residual(n) = 0;</div><div class="line"></div><div class="line">              residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">              residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">              pcout</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;      Residual of the non-contact part of the system: &quot;</span></div><div class="line">                &lt;&lt; residual_norm &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;         with a damping parameter alpha = &quot;</span> &lt;&lt; alpha</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (residual_norm &lt; previous_residual_norm)</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          solution     = tmp_vector;</div><div class="line">          old_solution = solution;</div><div class="line">        }</div><div class="line"></div><div class="line">      previous_residual_norm = residual_norm;</div></div><!-- fragment --><p>The final step is to check for convergence. If the active set has not changed across all processors and the residual is less than a threshold of \(10^{-10}\) , then we terminate the iteration on the current mesh:</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set == old_active_set) ? 0 : 1,</div><div class="line">                              mpi_communicator) == 0)</div><div class="line">        {</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;      Active set did not change!&quot;</span> &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">if</span> (residual_norm &lt; 1e-10)</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">      old_active_set = active_set;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemrefine_grid"></a> </p><h4>PlasticityContactProblem::refine_grid</h4>
<p>If you've made it this far into the deal.II tutorial, the following function refining the mesh should not pose any challenges to you any more. It refines the mesh, either globally or using the Kelly error estimator, and if so asked also transfers the solution from the previous to the next mesh. In the latter case, we also need to compute the active set and other quantities again, for which we need the information computed by <code>compute_nonlinear_residual()</code> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (refinement_strategy == RefinementStrategy::refine_global)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">             triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">           cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">           ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt;(fe.degree + 2),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">        solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number</a>(</div><div class="line">        triangulation, estimated_error_per_cell, 0.3, 0.03);</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">    solution_transfer(dof_handler);</div><div class="line">  <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  setup_system();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                         mpi_communicator);</div><div class="line">      solution_transfer.interpolate(distributed_solution);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">      constraints_hanging_nodes.distribute(distributed_solution);</div><div class="line"></div><div class="line">      solution = distributed_solution;</div><div class="line">      compute_nonlinear_residual(solution);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemmove_mesh"></a> </p><h4>PlasticityContactProblem::move_mesh</h4>
<p>The remaining three functions before we get to <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> have to do with generating output. The following one is an attempt at showing the deformed body in its deformed configuration. To this end, this function takes a displacement vector field and moves every vertex of the (local part) of the mesh by the previously computed displacement. We will call this function with the current displacement field before we generate graphical output, and we will call it again after generating graphical output with the negative displacement field to undo the changes to the mesh so made. The function itself is pretty straightforward. All we have to do is keep track which vertices we have already touched, as we encounter the same vertices multiple times as we loop over cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::move_mesh(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">          {</div><div class="line">            vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              vertex_displacement[d] =</div><div class="line">                displacement(cell-&gt;vertex_dof_index(v, d));</div><div class="line"></div><div class="line">            cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">          }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemoutput_results"></a> </p><h4>PlasticityContactProblem::output_results</h4>
<p>Next is the function we use to actually generate graphical output. The function is a bit tedious, but not actually particularly complicated. It moves the mesh at the top (and moves it back at the end), then computes the contact forces along the contact surface. We can do so (as shown in the accompanying paper) by taking the untreated residual vector and identifying which degrees of freedom correspond to those with contact by asking whether they have an inhomogeneous constraints associated with them. As always, we need to be mindful that we can only write into completely distributed vectors (i.e., vectors without ghost elements) but that when we want to generate output, we need vectors that do indeed have ghost entries for all locally relevant degrees of freedom.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Graphical output&quot;</span>);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;      Writing graphical output... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  move_mesh(solution);</div></div><!-- fragment --><p>Calculation of the contact forces</p>
<div class="fragment"><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                 mpi_communicator);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                   end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">  <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">    distributed_lambda(n) =</div><div class="line">      newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                     mpi_communicator);</div><div class="line">lambda = distributed_lambda;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_active_set_vector(</div><div class="line">  locally_owned_dofs, mpi_communicator);</div><div class="line">distributed_active_set_vector = 0.;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">  distributed_active_set_vector[index] = 1.;</div><div class="line">distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(locally_relevant_dofs,</div><div class="line">                                                mpi_communicator);</div><div class="line">active_set_vector = distributed_active_set_vector;</div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  data_component_interpretation(</div><div class="line">    dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;displacement&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;contact_force&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;active_set&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">  subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fraction_of_plastic_q_points_per_cell,</div><div class="line">                         <span class="stringliteral">&quot;fraction_of_plastic_q_points&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div></div><!-- fragment --><p>In the remainder of the function, we generate one VTU file on every processor, indexed by the subdomain id of this processor. On the first processor, we then also create a <code>.pvtu</code> file that indexes <em>all</em> of the VTU files so that the entire set of output files can be read at once. These <code>.pvtu</code> are used by Paraview to describe an entire parallel computation's output files. We then do the same again for the competitor of Paraview, the VisIt visualization program, by creating a matching <code>.visit</code> file.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string pvtu_filename = data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    output_dir, <span class="stringliteral">&quot;solution&quot;</span>, current_refinement_cycle, mpi_communicator, 2);</div><div class="line">  pcout &lt;&lt; pvtu_filename &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(solution);</div><div class="line">  tmp=</div><div class="line"></div><div class="line">-1;</div><div class="line">  move_mesh(tmp);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemoutput_contact_force"></a> </p><h4>PlasticityContactProblem::output_contact_force</h4>
<p>This last auxiliary function computes the contact force by calculating an integral over the contact pressure in z-direction over the contact area. For this purpose we set the contact pressure lambda to 0 for all inactive dofs (whether a degree of freedom is part of the contact is determined just as we did in the previous function). For all active dofs, lambda contains the quotient of the nonlinear residual (newton_rhs_uncondensed) and corresponding diagonal entry of the mass matrix (diag_mass_matrix_vector). Because it is not unlikely that hanging nodes show up in the contact area it is important to apply constraints_hanging_nodes.distribute to the distributed_lambda vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_contact_force()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                   mpi_communicator);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                     end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">    <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">      distributed_lambda(n) =</div><div class="line">        newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      distributed_lambda(n) = 0;</div><div class="line">  distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                       mpi_communicator);</div><div class="line">  lambda = distributed_lambda;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> contact_force = 0.0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt;   face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">          {</div><div class="line">            fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">            std::vector&lt;Tensor&lt;1, dim&gt;&gt; lambda_values(n_face_q_points);</div><div class="line">            fe_values_face[displacement].get_function_values(lambda,</div><div class="line">                                                             lambda_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                 ++q_point)</div><div class="line">              contact_force +=</div><div class="line">                lambda_values[q_point][2] fe_values_face.JxW(q_point);</div><div class="line">          }</div><div class="line">  contact_force = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(contact_force, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Contact force = &quot;</span> &lt;&lt; contact_force &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemrun"></a> </p><h4>PlasticityContactProblem::run</h4>
<p>As in all other tutorial programs, the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function contains the overall logic. There is not very much to it here: in essence, it performs the loops over all mesh refinement cycles, and within each, hands things over to the Newton solver in <code>solve_newton()</code> on the current mesh and calls the function that creates graphical output for the so-computed solution. It then outputs some statistics concerning both run times and memory consumption that has been collected over the course of computations on this mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PlasticityContactProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  computing_timer.reset();</div><div class="line">  <span class="keywordflow">for</span> (; current_refinement_cycle &lt; n_refinement_cycles;</div><div class="line">       ++current_refinement_cycle)</div><div class="line">    {</div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup&quot;</span>);</div><div class="line"></div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; current_refinement_cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (current_refinement_cycle == 0)</div><div class="line">          {</div><div class="line">            make_grid();</div><div class="line">            setup_system();</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: refine mesh&quot;</span>);</div><div class="line">            refine_grid();</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">      solve_newton();</div><div class="line"></div><div class="line">      output_results(current_refinement_cycle);</div><div class="line"></div><div class="line">      computing_timer.print_summary();</div><div class="line">      computing_timer.reset();</div><div class="line"></div><div class="line">      <a class="code" href="structUtilities_1_1System_1_1MemoryStats.html">Utilities::System::MemoryStats</a> stats;</div><div class="line">      <a class="code" href="namespaceUtilities_1_1System.html#a25db0fc07c298b5bef3d6f738283bd6d">Utilities::System::get_memory_stats</a>(stats);</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Peak virtual memory used, resident in kB: &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a9cb487ac1831b7e5836be93859c1c2af">VmSize</a></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a39901417b9e6ebfa36d05bfb8a282aa2">VmRSS</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">        output_contact_force();</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step42</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>There really isn't much to the <code>main()</code> function. It looks like they always do:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"><span class="keyword">using namespace </span>Step42;</div><div class="line"></div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">    PlasticityContactProblem&lt;3&gt;::declare_parameters(prm);</div><div class="line">    <span class="keywordflow">if</span> (argc != 2)</div><div class="line">      {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;*** Call this program as &lt;./step-42 input.prm&gt;&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">      }</div><div class="line"></div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(argv[1]);</div><div class="line">    <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">      argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line">    {</div><div class="line">      PlasticityContactProblem&lt;3&gt; problem(prm);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The directory that contains this program also contains a number of inputparameter files that can be used to create various differentsimulations. For example, running the program with the <code>p1_adaptive.prm</code> parameter file (using a ball as obstacle and thebox as domain) on 16 cores produces output like this: </p><div class="fragment"><div class="line"> Using output directory <span class="stringliteral">&#39;p1adaptive/&#39;</span></div><div class="line"> FE degree 1</div><div class="line"> transfer solution <span class="keyword">false</span></div><div class="line"></div><div class="line">Cycle 0:</div><div class="line">Number of active cells: 512</div><div class="line">Number of degrees of freedom: 2187</div><div class="line"></div><div class="line">Newton iteration 1</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 1</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 173.076</div><div class="line"></div><div class="line">-&gt; 1.64265e-06 in 7 Bicgstab iterations.</div><div class="line">   Accepting Newton solution with residual: 1.64265e-06</div><div class="line"></div><div class="line">Newton iteration 2</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 1</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 57.3622</div><div class="line"></div><div class="line">-&gt; 3.23721e-07 in 8 Bicgstab iterations.</div><div class="line">   Accepting Newton solution with residual: 24.9028</div><div class="line">   Active <span class="keyword">set</span> did not change!</div><div class="line"></div><div class="line">Newton iteration 3</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 1</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 24.9028</div><div class="line"></div><div class="line">-&gt; 9.94326e-08 in 7 Bicgstab iterations.</div><div class="line">   Residual of the non-contact part of the system: 1.63333</div><div class="line">      with a damping parameter alpha = 1</div><div class="line">   Active <span class="keyword">set</span> did not change!</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Newton iteration 6</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 1</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 1.43188e-07</div><div class="line"></div><div class="line">-&gt; 3.56218e-16 in 8 Bicgstab iterations.</div><div class="line">   Residual of the non-contact part of the system: 4.298e-14</div><div class="line">      with a damping parameter alpha = 1</div><div class="line">   Active <span class="keyword">set</span> did not change!</div><div class="line">   Writing graphical output... p1_adaptive/solution-00.pvtu</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.13s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assembling                      |         6 |     0.463s |        41% |</div><div class="line">| Graphical output                |         1 |    0.0257s |       2.3% |</div><div class="line">| Residual and lambda             |         4 |    0.0754s |       6.7% |</div><div class="line">| Setup                           |         1 |     0.227s |        20% |</div><div class="line">| Setup: constraints              |         1 |    0.0347s |       3.1% |</div><div class="line">| Setup: distribute DoFs          |         1 |    0.0441s |       3.9% |</div><div class="line">| Setup: <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>                   |         1 |    0.0119s |       1.1% |</div><div class="line">| Setup: vectors                  |         1 |   0.00155s |      0.14% |</div><div class="line">| Solve                           |         6 |     0.246s |        22% |</div><div class="line">| Solve: iterate                  |         6 |    0.0631s |       5.6% |</div><div class="line">| Solve: setup preconditioner     |         6 |     0.167s |        15% |</div><div class="line">| update active <span class="keyword">set</span>               |         6 |    0.0401s |       3.6% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line">Peak <span class="keyword">virtual</span> memory used, resident in kB: 541884 77464</div><div class="line">Contact force = 37.3058</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Cycle 3:</div><div class="line">Number of active cells: 14652</div><div class="line">Number of degrees of freedom: 52497</div><div class="line"></div><div class="line">Newton iteration 1</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 145</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 296.309</div><div class="line"></div><div class="line">-&gt; 2.72484e-06 in 10 Bicgstab iterations.</div><div class="line">   Accepting Newton solution with residual: 2.72484e-06</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Newton iteration 10</div><div class="line">   Updating active <span class="keyword">set</span>...</div><div class="line">      Size of active <span class="keyword">set</span>: 145</div><div class="line">   Assembling system...</div><div class="line">   Solving system...</div><div class="line">      Error: 2.71541e-07</div><div class="line"></div><div class="line">-&gt; 1.5428e-15 in 27 Bicgstab iterations.</div><div class="line">   Residual of the non-contact part of the system: 1.89261e-13</div><div class="line">      with a damping parameter alpha = 1</div><div class="line">   Active <span class="keyword">set</span> did not change!</div><div class="line">   Writing graphical output... p1_adaptive/solution-03.pvtu</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      38.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assembling                      |        10 |      22.5s |        58% |</div><div class="line">| Graphical output                |         1 |     0.327s |      0.85% |</div><div class="line">| Residual and lambda             |         9 |      3.75s |       9.8% |</div><div class="line">| Setup                           |         1 |      4.83s |        13% |</div><div class="line">| Setup: constraints              |         1 |     0.578s |       1.5% |</div><div class="line">| Setup: distribute DoFs          |         1 |      0.71s |       1.8% |</div><div class="line">| Setup: <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>                   |         1 |     0.111s |      0.29% |</div><div class="line">| Setup: <a class="code" href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">refine</a> mesh              |         1 |      4.83s |        13% |</div><div class="line">| Setup: vectors                  |         1 |   0.00548s |     0.014% |</div><div class="line">| Solve                           |        10 |      5.49s |        14% |</div><div class="line">| Solve: iterate                  |        10 |       3.5s |       9.1% |</div><div class="line">| Solve: setup preconditioner     |        10 |      1.84s |       4.8% |</div><div class="line">| update active <span class="keyword">set</span>               |        10 |     0.662s |       1.7% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line">Peak <span class="keyword">virtual</span> memory used, resident in kB: 566052 105788</div><div class="line">Contact force = 56.794</div><div class="line"></div><div class="line">...</div></div><!-- fragment --><p>The tables at the end of each cycle show information about computing time(these numbers are of course specific to the machine on which this outputwas produced)and the number of calls of different parts of the program like assembly orcalculating the residual, for the most recent mesh refinement cycle. Some ofthe numbers above can be improved by transferring the solution from one mesh tothe next, an option we have not exercised here. Of course, you can also makethe program run faster, especially on the later refinement cycles, by justusing more processors: the accompanying paper shows good scaling to at least1000 cores. In a typical run, you can observe that for every refinement step, the activeset</p>
<ul>
<li>the contact points</li>
<li>are iterated out at first. After that the Newtonmethod has only to resolve the plasticity. For the finer meshes,quadratic convergence can be observed for the last 4 or 5 Newton iterations. We will not discuss here in all detail what happens with each of the inputfiles. Rather, let us just show pictures of the solution (the left half of thedomain is omitted if cells have zero quadrature points at which the plasticinequality is active): <table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionColorbar.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionBall2.png" width="70%"/>
</div>
  </td><td valign="top">&#160;  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionLi2.png" width="70%"/>
</div>
   </td></tr>
</table>
The picture shows the adaptive refinement and as well how much a cell isplastified during the contact with the ball. Remember that we consider thenorm of the deviator part of the stress in each quadrature point tosee if there is elastic or plastic behavior.The bluecolor means that this cell contains only elastic quadrature points incontrast to the red cells in which all quadrature points are plastified.In the middle of the top surface</li>
<li>here the mesh is finest</li>
<li>a very close look shows the dimple caused by theobstacle. This is the result of the <code>move_mesh()</code> function. However, because the indentation of the obstacles we consider hereis so small, it is hard to discern this effect; one could play with displacingvertices of the mesh by a multiple of the computed displacement. Further discussion of results that can be obtained using this program isprovided in the publication mentioned at the very top of this page.</li>
</ul>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h1>Possibilities for extensions</h1>
<p>There are, as always, multiple possibilities for extending this program. Froman algorithmic perspective, this program goes about as far as one can at thetime of writing, using the best available algorithms for the contactinequality, the plastic nonlinearity, and the linear solvers. However, thereare things one would like to do with this program as far as more realisticsituations are concerned: </p><ul>
<li>
Extend the program from a static to a quasi-static situation, perhaps bychoosing a backward-Euler-scheme for the time discretization. Some theoreticalresults can be found in the PhD thesis by JÃ¶rg Frohne, <em>FEM-Simulation der Umformtechnik metallischer Oberfl&auml;chen im Mikrokosmos</em>, Universityof Siegen, Germany, 2011. </li>
<li>
It would also be an interesting advance to consider a contact problemwith friction. In almost every mechanical process friction has a biginfluence. To model this situation, we have to take into account tangentialstresses at the contact surface. Friction also adds another inequality toour problem since body and obstacle will typically stick together as long asthe tangential stress does not exceed a certain limit, beyond which the twobodies slide past each other. </li>
<li>
If we already simulate a frictional contact, the next step to consideris heat generation over the contact zone. The heat that iscaused by friction between two bodies raises the temperature in thedeformable body and entails an change of some material parameters. </li>
<li>
It might be of interest to implement more accurate, problem-adapted errorestimators for contact as well as for the plasticity. </li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2012 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Joerg Frohne, Texas A&amp;M University and</span></div><div class="line"><span class="comment"> *                        University of Siegen, 2012, 2013</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2012, 2013</span></div><div class="line"><span class="comment"> *          Timo Heister, Texas A&amp;M University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__field__function_8h.html">deal.II/numerics/fe_field_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cerrno&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step42</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ConstitutiveLaw</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ConstitutiveLaw(<span class="keyword">const</span> <span class="keywordtype">double</span> E,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> nu,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> sigma_0,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> gamma);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_sigma_0(<span class="keywordtype">double</span> sigma_zero);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> get_stress_strain_tensor(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> get_linearized_stress_strain_tensors(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">    <span class="keywordtype">double</span>       sigma_0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_kappa;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_mu;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ConstitutiveLaw&lt;dim&gt;::ConstitutiveLaw(<span class="keywordtype">double</span> E,</div><div class="line">                                        <span class="keywordtype">double</span> nu,</div><div class="line">                                        <span class="keywordtype">double</span> sigma_0,</div><div class="line">                                        <span class="keywordtype">double</span> gamma)</div><div class="line">    : kappa(E / (3 * (1 - 2 * nu)))</div><div class="line">    , mu(E / (2 * (1 + nu)))</div><div class="line">    , sigma_0(sigma_0)</div><div class="line">    , gamma(gamma)</div><div class="line">    , stress_strain_tensor_kappa(kappa *</div><div class="line">                                 <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                               <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()))</div><div class="line">    , stress_strain_tensor_mu(</div><div class="line">        2 * mu *</div><div class="line">        (<a class="code" href="symmetric__tensor_8h.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor</a>&lt;dim&gt;() - <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                                <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()) /</div><div class="line">                                    3.0))</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::set_sigma_0(<span class="keywordtype">double</span> sigma_zero)</div><div class="line">  {</div><div class="line">    sigma_0 = sigma_zero;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> ConstitutiveLaw&lt;dim&gt;::get_stress_strain_tensor(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">    stress_tensor =</div><div class="line">      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor =</div><div class="line">      <a class="code" href="symmetric__tensor_8h.html#a022faa691137ee8c1f65dacc47d94a04">deviator</a>(stress_tensor);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">    stress_strain_tensor = stress_strain_tensor_mu;</div><div class="line">    <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">      }</div><div class="line"></div><div class="line">    stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (deviator_stress_tensor_norm &gt; sigma_0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::get_linearized_stress_strain_tensors(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">    stress_tensor =</div><div class="line">      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">    stress_strain_tensor            = stress_strain_tensor_mu;</div><div class="line">    stress_strain_tensor_linearized = stress_strain_tensor_mu;</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = <a class="code" href="symmetric__tensor_8h.html#a022faa691137ee8c1f65dacc47d94a04">deviator</a>(stress_tensor);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">        stress_strain_tensor_linearized *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">        deviator_stress_tensor /= deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor_linearized -=</div><div class="line">          (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta * 2 * mu *</div><div class="line">          <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(deviator_stress_tensor, deviator_stress_tensor);</div><div class="line">      }</div><div class="line"></div><div class="line">    stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line">    stress_strain_tensor_linearized += stress_strain_tensor_kappa;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>EquationData</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BoundaryForce();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BoundaryForce&lt;dim&gt;::BoundaryForce()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BoundaryForce&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> BoundaryForce&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                          Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryForce&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BoundaryValues();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BoundaryValues&lt;dim&gt;::BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>SphereObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    SphereObstacle&lt;dim&gt;::SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">      , z_surface(z_surface)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> SphereObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (component == 0)</div><div class="line">        <span class="keywordflow">return</span> p(0);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 1)</div><div class="line">        <span class="keywordflow">return</span> p(1);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((p(0) - 0.5) * (p(0) - 0.5) + (p(1) - 0.5) * (p(1) - 0.5) &lt; 0.36)</div><div class="line">            <span class="keywordflow">return</span> (-std::sqrt(0.36 - (p(0) - 0.5) * (p(0) - 0.5) -</div><div class="line">                               (p(1) - 0.5) * (p(1) - 0.5)) +</div><div class="line">                    z_surface + 0.59);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">return</span> 1000;</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> SphereObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                           Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SphereObstacle&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BitmapFile</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BitmapFile(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      std::vector&lt;double&gt; obstacle_data;</div><div class="line">      <span class="keywordtype">double</span>              hx, hy;</div><div class="line">      <span class="keywordtype">int</span>                 nx, ny;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BitmapFile&lt;dim&gt;::BitmapFile(<span class="keyword">const</span> std::string &amp;name)</div><div class="line">      : obstacle_data(0)</div><div class="line">      , hx(0)</div><div class="line">      , hy(0)</div><div class="line">      , nx(0)</div><div class="line">      , ny(0)</div><div class="line">    {</div><div class="line">      std::ifstream f(name);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(f,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Can&#39;t read from file &lt;&quot;</span>) + name +</div><div class="line">                             <span class="stringliteral">&quot;&gt;!&quot;</span>));</div><div class="line"></div><div class="line">      std::string temp;</div><div class="line">      f &gt;&gt; temp &gt;&gt; nx &gt;&gt; ny;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(nx &gt; 0 &amp;&amp; ny &gt; 0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid file format.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nx * ny; ++k)</div><div class="line">        {</div><div class="line">          <span class="keywordtype">double</span> val;</div><div class="line">          f &gt;&gt; val;</div><div class="line">          obstacle_data.push_back(val);</div><div class="line">        }</div><div class="line"></div><div class="line">      hx = 1.0 / (nx - 1);</div><div class="line">      hy = 1.0 / (ny - 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Read obstacle from file &lt;&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;Resolution of the scanned obstacle picture: &quot;</span> &lt;&lt; nx</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; ny &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      assert(i &gt;= 0 &amp;&amp; i &lt; nx);</div><div class="line">      assert(j &gt;= 0 &amp;&amp; j &lt; ny);</div><div class="line">      <span class="keywordflow">return</span> obstacle_data[nx * (ny - 1 - j) + i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> ix = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(x / hx), 0), nx - 2);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> iy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(y / hy), 0), ny - 2);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> xi  = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((x - ix * hx) / hx, 1.), 0.);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> eta = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((y - iy * hy) / hy, 1.), 0.);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +</div><div class="line">              xi * (1 - eta) * get_pixel_value(ix + 1, iy) +</div><div class="line">              (1 - xi) * eta * get_pixel_value(ix, iy + 1) +</div><div class="line">              xi * eta * get_pixel_value(ix + 1, iy + 1));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ChineseObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename, <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> BitmapFile&lt;dim&gt; input_obstacle;</div><div class="line">      <span class="keywordtype">double</span>                z_surface;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ChineseObstacle&lt;dim&gt;::ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span>       z_surface)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">      , input_obstacle(filename)</div><div class="line">      , z_surface(z_surface)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> ChineseObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (component == 0)</div><div class="line">        <span class="keywordflow">return</span> p(0);</div><div class="line">      <span class="keywordflow">if</span> (component == 1)</div><div class="line">        <span class="keywordflow">return</span> p(1);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt;= 1.0 &amp;&amp; p(1) &gt;= 0.0 &amp;&amp; p(1) &lt;= 1.0)</div><div class="line">            <span class="keywordflow">return</span> z_surface + 0.999 - input_obstacle.get_value(p(0), p(1));</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ChineseObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                            Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = ChineseObstacle&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace EquationData</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PlasticityContactProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PlasticityContactProblem(<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> compute_dirichlet_constraints();</div><div class="line">    <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">    <span class="keywordtype">void</span> assemble_newton_system(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">    <span class="keywordtype">void</span> compute_nonlinear_residual(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">    <span class="keywordtype">void</span> solve_newton_system();</div><div class="line">    <span class="keywordtype">void</span> solve_newton();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> move_mesh(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_contact_force() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classMPI__Comm.html">MPI_Comm</a>           mpi_communicator;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                        n_initial_global_refinements;</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_hanging_nodes;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_dirichlet_and_hanging_nodes;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> all_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>      active_set;</div><div class="line">    Vector&lt;float&gt; fraction_of_plastic_q_points_per_cell;</div><div class="line"></div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix newton_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs_uncondensed;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>         e_modulus, nu, <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>, sigma_0;</div><div class="line">    ConstitutiveLaw&lt;dim&gt; constitutive_law;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string                          base_mesh;</div><div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;const Function&lt;dim&gt;&gt; obstacle;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>RefinementStrategy</div><div class="line">    {</div><div class="line">      <span class="keyword">enum</span> value</div><div class="line">      {</div><div class="line">        refine_global,</div><div class="line">        refine_percentage,</div><div class="line">        refine_fix_dofs</div><div class="line">      };</div><div class="line">    };</div><div class="line">    <span class="keyword">typename</span> RefinementStrategy::value refinement_strategy;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>         transfer_solution;</div><div class="line">    std::string        output_dir;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_cycles;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       current_refinement_cycle;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">      <span class="stringliteral">&quot;Polynomial degree of the FE_Q finite element space, typically 1 or 2.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of initial refinements&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Number of initial global mesh refinement steps before &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;the first computation.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;refinement strategy&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;percentage&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;global|percentage&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;Mesh refinement strategy:\n&quot;</span></div><div class="line">      <span class="stringliteral">&quot; global: one global refinement\n&quot;</span></div><div class="line">      <span class="stringliteral">&quot; percentage: a fixed percentage of cells gets refined using the Kelly estimator.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of cycles&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Number of adaptive mesh refinement cycles to run.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;obstacle&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;sphere&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;sphere|read from file&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;The name of the obstacle to use. This may either be &#39;sphere&#39; if we should &quot;</span></div><div class="line">      <span class="stringliteral">&quot;use a spherical obstacle, or &#39;read from file&#39; in which case the obstacle &quot;</span></div><div class="line">      <span class="stringliteral">&quot;will be read from a file named &#39;obstacle.pbm&#39; that is supposed to be in &quot;</span></div><div class="line">      <span class="stringliteral">&quot;ASCII PBM format.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;output directory&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">      <span class="stringliteral">&quot;Directory for output files (graphical output and benchmark &quot;</span></div><div class="line">      <span class="stringliteral">&quot;statistics). If empty, use the current directory.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;transfer solution&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">      <span class="stringliteral">&quot;Whether the solution should be used as a starting guess &quot;</span></div><div class="line">      <span class="stringliteral">&quot;for the next finer mesh. If false, then the iteration starts at &quot;</span></div><div class="line">      <span class="stringliteral">&quot;zero on every mesh.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;base mesh&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;box&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;box|half sphere&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Select the shape of the domain: &#39;box&#39; or &#39;half sphere&#39;&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PlasticityContactProblem&lt;dim&gt;::PlasticityContactProblem(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">            (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">    , computing_timer(MPI_COMM_WORLD,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line"></div><div class="line">    , n_initial_global_refinements(</div><div class="line">        prm.get_integer(<span class="stringliteral">&quot;number of initial refinements&quot;</span>))</div><div class="line">    , triangulation(mpi_communicator)</div><div class="line">    , fe_degree(prm.get_integer(<span class="stringliteral">&quot;polynomial degree&quot;</span>))</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree + 1)), dim)</div><div class="line">    , dof_handler(triangulation)</div><div class="line"></div><div class="line">    , e_modulus(200000)</div><div class="line">    , nu(0.3)</div><div class="line">    , gamma(0.01)</div><div class="line">    , sigma_0(400.0)</div><div class="line">    , constitutive_law(e_modulus, nu, sigma_0, gamma)</div><div class="line"></div><div class="line">    , base_mesh(prm.get(<span class="stringliteral">&quot;base mesh&quot;</span>))</div><div class="line">    , obstacle(prm.get(<span class="stringliteral">&quot;obstacle&quot;</span>) == <span class="stringliteral">&quot;read from file&quot;</span> ?</div><div class="line">                 static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                   new EquationData::ChineseObstacle&lt;dim&gt;(</div><div class="line">                     <span class="stringliteral">&quot;obstacle.pbm&quot;</span>,</div><div class="line">                     (base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5))) :</div><div class="line">                 static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                   new EquationData::SphereObstacle&lt;dim&gt;(</div><div class="line">                     base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5)))</div><div class="line"></div><div class="line">    , transfer_solution(prm.get_bool(<span class="stringliteral">&quot;transfer solution&quot;</span>))</div><div class="line">    , n_refinement_cycles(prm.get_integer(<span class="stringliteral">&quot;number of cycles&quot;</span>))</div><div class="line">    , current_refinement_cycle(0)</div><div class="line"></div><div class="line">  {</div><div class="line">    std::string strat = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;refinement strategy&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">      refinement_strategy = RefinementStrategy::refine_global;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;percentage&quot;</span>)</div><div class="line">      refinement_strategy = RefinementStrategy::refine_percentage;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    output_dir = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;output directory&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (output_dir != <span class="stringliteral">&quot;&quot;</span> &amp;&amp; *(output_dir.rbegin()) != <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">      output_dir += <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> ierr = mkdir(output_dir.c_str(), 0777);</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(ierr == 0 || errno == EEXIST, <a class="code" href="group__Exceptions.html#gac29b5f3efd2b164642b8e0c49ad3ad27">ExcIO</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    Using output directory &#39;&quot;</span> &lt;&lt; output_dir &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    FE degree &quot;</span> &lt;&lt; fe_degree &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    transfer solution &quot;</span> &lt;&lt; (transfer_solution ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>)</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> rotate_half_sphere(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;in)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> {in(2), in(1), -in(0)};</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;half sphere&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0, 0, 0);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>     radius = 0.8;</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(triangulation, center, radius);</div><div class="line">        triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;rotate_half_sphere, triangulation);</div><div class="line">        <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5), triangulation);</div><div class="line"></div><div class="line">        <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5));</div><div class="line">        <a class="code" href="namespaceGridTools.html#aa92034313ef924778e01beb3e24002dd">GridTools::copy_boundary_to_manifold_id</a>(triangulation);</div><div class="line">        triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, manifold_description);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1(0, 0, 0);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p2(1.0, 1.0, 1.0);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation, p1, p2);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p2[2]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(1);</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p1[0]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p2[0]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p1[1]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p2[1]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(8);</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p1[2]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(6);</div><div class="line">              }</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="comment">/* setup dofs and get index sets for locally owned and relevant dofs */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: distribute DoFs&quot;</span>);</div><div class="line">      dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">      locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">      locally_relevant_dofs.<a class="code" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a>();</div><div class="line">      <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler,</div><div class="line">                                              locally_relevant_dofs);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* setup hanging nodes and Dirichlet constraints */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: constraints&quot;</span>);</div><div class="line">      constraints_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              constraints_hanging_nodes);</div><div class="line">      constraints_hanging_nodes.close();</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      compute_dirichlet_constraints();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* initialization of vectors and the active set */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: vectors&quot;</span>);</div><div class="line">      solution.reinit(locally_relevant_dofs, mpi_communicator);</div><div class="line">      newton_rhs.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      fraction_of_plastic_q_points_per_cell.reinit(</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">      active_set.clear();</div><div class="line">      active_set.set_size(dof_handler.n_dofs());</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>                t(computing_timer, <span class="stringliteral">&quot;Setup: matrix&quot;</span>);</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                      sp,</div><div class="line">                                      constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                      <span class="keyword">false</span>,</div><div class="line">                                      <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                        mpi_communicator));</div><div class="line">      sp.compress();</div><div class="line">      newton_matrix.reinit(sp);</div><div class="line"></div><div class="line"></div><div class="line">      TrilinosWrappers::SparseMatrix &amp;mass_matrix = newton_matrix;</div><div class="line"></div><div class="line">      assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start = (newton_rhs.local_range().first),</div><div class="line">                         end   = (newton_rhs.local_range().second);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = start; j &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++j)</div><div class="line">        diag_mass_matrix_vector(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">      diag_mass_matrix_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">      mass_matrix = 0;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_dirichlet_constraints()</div><div class="line">  {</div><div class="line">    constraints_dirichlet_and_hanging_nodes.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(locally_relevant_dofs);</div><div class="line">    constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          dof_handler,</div><div class="line">          6,</div><div class="line">          EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">          constraints_dirichlet_and_hanging_nodes,</div><div class="line">          <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          dof_handler,</div><div class="line">          8,</div><div class="line">          EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">          constraints_dirichlet_and_hanging_nodes,</div><div class="line">          (fe.component_mask(x_displacement) |</div><div class="line">           fe.component_mask(y_displacement)));</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        0,</div><div class="line">        EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">        constraints_dirichlet_and_hanging_nodes,</div><div class="line">        <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">    constraints_dirichlet_and_hanging_nodes.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line">              cell_matrix = 0;</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">                    (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                     fe_values_face[displacement].value(i, q_point) *</div><div class="line">                     fe_values_face.JxW(q_point));</div><div class="line"></div><div class="line">              cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a>(local_dof_indices[i],</div><div class="line">                                local_dof_indices[i],</div><div class="line">                                cell_matrix(i, i));</div><div class="line">            }</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">  {</div><div class="line">    std::vector&lt;bool&gt; dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line">    distributed_solution = solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = newton_rhs_uncondensed;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector_relevant(</div><div class="line">      locally_relevant_dofs, mpi_communicator);</div><div class="line">    diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;</div><div class="line"></div><div class="line"></div><div class="line">    all_constraints.reinit(locally_relevant_dofs);</div><div class="line">    active_set.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim - 1&gt; face_quadrature(fe.get_unit_face_support_points());</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>   fe_values_face(fe,</div><div class="line">                                     face_quadrature,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_face   = fe.n_dofs_per_face();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature.size();</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; dof_indices(dofs_per_face);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (!cell-&gt;is_artificial())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line">              face-&gt;get_dof_indices(dof_indices);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component =</div><div class="line">                    fe.face_system_to_component_index(q_point).first;</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_z = dof_indices[q_point];</div><div class="line"></div><div class="line">                  <span class="keywordflow">if</span> ((component == 2) &amp;&amp; (dof_touched[index_z] == <span class="keyword">false</span>))</div><div class="line">                    {</div><div class="line">                      dof_touched[index_z] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> this_support_point =</div><div class="line">                        fe_values_face.quadrature_point(q_point);</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value =</div><div class="line">                        obstacle-&gt;value(this_support_point, 2);</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> solution_here = solution(index_z);</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> undeformed_gap =</div><div class="line">                        obstacle_value - this_support_point(2);</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> c = 100.0 * e_modulus;</div><div class="line">                      <span class="keywordflow">if</span> ((lambda(index_z) /</div><div class="line">                               diag_mass_matrix_vector_relevant(index_z) +</div><div class="line">                             c * (solution_here - undeformed_gap) &gt;</div><div class="line">                           0) &amp;&amp;</div><div class="line">                          !constraints_hanging_nodes.is_constrained(index_z))</div><div class="line">                        {</div><div class="line">                          all_constraints.add_line(index_z);</div><div class="line">                          all_constraints.set_inhomogeneity(index_z,</div><div class="line">                                                            undeformed_gap);</div><div class="line">                          distributed_solution(index_z) = undeformed_gap;</div><div class="line"></div><div class="line">                          active_set.add_index(index_z);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">    distributed_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    solution = distributed_solution;</div><div class="line"></div><div class="line">    all_constraints.close();</div><div class="line">    all_constraints.merge(constraints_dirichlet_and_hanging_nodes);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;         Size of active set: &quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set &amp; locally_owned_dofs).n_elements(),</div><div class="line">                                 mpi_communicator)</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_newton_system(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assembling&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim));</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          cell_matrix = 0;</div><div class="line">          cell_rhs    = 0;</div><div class="line"></div><div class="line">          std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensor(n_q_points);</div><div class="line">          fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">            linearization_point, strain_tensor);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            {</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">              constitutive_law.get_linearized_stress_strain_tensors(</div><div class="line">                strain_tensor[q_point],</div><div class="line">                stress_strain_tensor_linearized,</div><div class="line">                stress_strain_tensor);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_phi_i =</div><div class="line">                    stress_strain_tensor_linearized *</div><div class="line">                    fe_values[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (stress_phi_i *</div><div class="line">                       fe_values[displacement].symmetric_gradient(j, q_point) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  cell_rhs(i) +=</div><div class="line">                    ((stress_phi_i -</div><div class="line">                      stress_strain_tensor *</div><div class="line">                        fe_values[displacement].symmetric_gradient(i,</div><div class="line">                                                                   q_point)) *</div><div class="line">                     strain_tensor[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">              {</div><div class="line">                fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">                boundary_force.vector_value_list(</div><div class="line">                  fe_values_face.get_quadrature_points(),</div><div class="line">                  boundary_force_values);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                     ++q_point)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                    rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                         rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          all_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                     cell_rhs,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     newton_matrix,</div><div class="line">                                                     newton_rhs,</div><div class="line">                                                     <span class="keyword">true</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">    newton_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_nonlinear_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim));</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    newton_rhs             = 0;</div><div class="line">    newton_rhs_uncondensed = 0;</div><div class="line"></div><div class="line">    fraction_of_plastic_q_points_per_cell = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensors(n_q_points);</div><div class="line">          fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">            linearization_point, strain_tensors);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            {</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">bool</span>              q_point_is_plastic =</div><div class="line">                constitutive_law.get_stress_strain_tensor(</div><div class="line">                  strain_tensors[q_point], stress_strain_tensor);</div><div class="line">              <span class="keywordflow">if</span> (q_point_is_plastic)</div><div class="line">                ++fraction_of_plastic_q_points_per_cell(</div><div class="line">                  cell-&gt;active_cell_index());</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  cell_rhs(i) -=</div><div class="line">                    (strain_tensors[q_point] * stress_strain_tensor *</div><div class="line">                     fe_values[displacement].symmetric_gradient(i, q_point) *</div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values = 0;</div><div class="line">                  cell_rhs(i) += (fe_values[displacement].value(i, q_point) *</div><div class="line">                                  rhs_values * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">              {</div><div class="line">                fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">                boundary_force.vector_value_list(</div><div class="line">                  fe_values_face.get_quadrature_points(),</div><div class="line">                  boundary_force_values);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                     ++q_point)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                    rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                         rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(</div><div class="line">            cell_rhs, local_dof_indices, newton_rhs);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    fraction_of_plastic_q_points_per_cell /= quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    newton_rhs_uncondensed.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line">    distributed_solution = solution;</div><div class="line"></div><div class="line">    constraints_hanging_nodes.set_zero(distributed_solution);</div><div class="line">    constraints_hanging_nodes.set_zero(newton_rhs);</div><div class="line"></div><div class="line">    TrilinosWrappers::PreconditionAMG preconditioner;</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: setup preconditioner&quot;</span>);</div><div class="line"></div><div class="line">      std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(dof_handler,</div><div class="line">                                       <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                       constant_modes);</div><div class="line"></div><div class="line">      <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a>              = <span class="keyword">true</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a4a403dc7faf67ee0fcb6436d7b741687">n_cycles</a>              = 1;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a56500e96ab5ae9b84dd874b38283453b">w_cycle</a>               = <span class="keyword">false</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#ab9fc3e207a7c534094d514685e645c92">output_details</a>        = <span class="keyword">false</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a>       = 2;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 1e-2;</div><div class="line"></div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(newton_matrix, additional_data);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: iterate&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> relative_accuracy = 1e-8;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance =</div><div class="line">        relative_accuracy *</div><div class="line">        newton_matrix.residual(tmp, distributed_solution, newton_rhs);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(newton_matrix.m(), solver_tolerance);</div><div class="line">      <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line">      solver.solve(newton_matrix,</div><div class="line">                   distributed_solution,</div><div class="line">                   newton_rhs,</div><div class="line">                   preconditioner);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;         Error: &quot;</span> &lt;&lt; solver_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; Bicgstab iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    all_constraints.distribute(distributed_solution);</div><div class="line"></div><div class="line">    solution = distributed_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_solution(locally_owned_dofs,</div><div class="line">                                               mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> residual(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp_vector(locally_owned_dofs,</div><div class="line">                                             mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_tmp_vector(</div><div class="line">      locally_relevant_dofs, mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> residual_norm;</div><div class="line">    <span class="keywordtype">double</span> previous_residual_norm = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> correct_sigma = sigma_0;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> old_active_set(active_set);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= 100; ++newton_step)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (newton_step == 1 &amp;&amp;</div><div class="line">            ((transfer_solution &amp;&amp; current_refinement_cycle == 0) ||</div><div class="line">             !transfer_solution))</div><div class="line">          constitutive_law.set_sigma_0(1e+10);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == 2 || current_refinement_cycle &gt; 0 ||</div><div class="line">                 !transfer_solution)</div><div class="line">          constitutive_law.set_sigma_0(correct_sigma);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Newton iteration &quot;</span> &lt;&lt; newton_step &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;update active set&quot;</span>);</div><div class="line">          update_solution_and_constraints();</div><div class="line">        }</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Assembling system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">        newton_matrix = 0;</div><div class="line">        newton_rhs    = 0;</div><div class="line">        assemble_newton_system(solution);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Solving system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve_newton_system();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((newton_step == 1) ||</div><div class="line">            (transfer_solution &amp;&amp; newton_step == 2 &amp;&amp;</div><div class="line">             current_refinement_cycle == 0) ||</div><div class="line">            (!transfer_solution &amp;&amp; newton_step == 2))</div><div class="line">          {</div><div class="line">            compute_nonlinear_residual(solution);</div><div class="line">            old_solution = solution;</div><div class="line"></div><div class="line">            residual                     = newton_rhs;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                               end_res   = (residual.local_range().second);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">              <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">                residual(n) = 0;</div><div class="line"></div><div class="line">            residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">            residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;      Accepting Newton solution with residual: &quot;</span></div><div class="line">                  &lt;&lt; residual_norm &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)</div><div class="line">              {</div><div class="line">                distributed_solution = solution;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.5, static_cast&lt;double&gt;(i));</div><div class="line">                tmp_vector         = old_solution;</div><div class="line">                tmp_vector.sadd(1 - alpha, alpha, distributed_solution);</div><div class="line"></div><div class="line">                <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Residual and lambda&quot;</span>);</div><div class="line"></div><div class="line">                locally_relevant_tmp_vector = tmp_vector;</div><div class="line">                compute_nonlinear_residual(locally_relevant_tmp_vector);</div><div class="line">                residual = newton_rhs;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                                   end_res   = (residual.local_range().second);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">                  <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">                    residual(n) = 0;</div><div class="line"></div><div class="line">                residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">                residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">                pcout</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;      Residual of the non-contact part of the system: &quot;</span></div><div class="line">                  &lt;&lt; residual_norm &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;         with a damping parameter alpha = &quot;</span> &lt;&lt; alpha</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (residual_norm &lt; previous_residual_norm)</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            solution     = tmp_vector;</div><div class="line">            old_solution = solution;</div><div class="line">          }</div><div class="line"></div><div class="line">        previous_residual_norm = residual_norm;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set == old_active_set) ? 0 : 1,</div><div class="line">                                mpi_communicator) == 0)</div><div class="line">          {</div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;      Active set did not change!&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (residual_norm &lt; 1e-10)</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        old_active_set = active_set;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (refinement_strategy == RefinementStrategy::refine_global)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">               triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">             cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">             ++cell)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">        <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">          dof_handler,</div><div class="line">          <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 2),</div><div class="line">          std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">          solution,</div><div class="line">          estimated_error_per_cell);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number</a>(</div><div class="line">          triangulation, estimated_error_per_cell, 0.3, 0.03);</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">      solution_transfer(dof_handler);</div><div class="line">    <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">      solution_transfer.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                           mpi_communicator);</div><div class="line">        solution_transfer.interpolate(distributed_solution);</div><div class="line"></div><div class="line">        constraints_hanging_nodes.distribute(distributed_solution);</div><div class="line"></div><div class="line">        solution = distributed_solution;</div><div class="line">        compute_nonlinear_residual(solution);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::move_mesh(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">            {</div><div class="line">              vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                vertex_displacement[d] =</div><div class="line">                  displacement(cell-&gt;vertex_dof_index(v, d));</div><div class="line"></div><div class="line">              cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">            }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Graphical output&quot;</span>);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;      Writing graphical output... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    move_mesh(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                       end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">      <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">        distributed_lambda(n) =</div><div class="line">          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = distributed_lambda;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_active_set_vector(</div><div class="line">      locally_owned_dofs, mpi_communicator);</div><div class="line">    distributed_active_set_vector = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">      distributed_active_set_vector[index] = 1.;</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(locally_relevant_dofs,</div><div class="line">                                                    mpi_communicator);</div><div class="line">    active_set_vector = distributed_active_set_vector;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;displacement&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;contact_force&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;active_set&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fraction_of_plastic_q_points_per_cell,</div><div class="line">                             <span class="stringliteral">&quot;fraction_of_plastic_q_points&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string pvtu_filename = data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      output_dir, <span class="stringliteral">&quot;solution&quot;</span>, current_refinement_cycle, mpi_communicator, 2);</div><div class="line">    pcout &lt;&lt; pvtu_filename &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(solution);</div><div class="line">    tmp *= -1;</div><div class="line">    move_mesh(tmp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_contact_force()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                       end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">      <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">        distributed_lambda(n) =</div><div class="line">          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        distributed_lambda(n) = 0;</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = distributed_lambda;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> contact_force = 0.0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              std::vector&lt;Tensor&lt;1, dim&gt;&gt; lambda_values(n_face_q_points);</div><div class="line">              fe_values_face[displacement].get_function_values(lambda,</div><div class="line">                                                               lambda_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                contact_force +=</div><div class="line">                  lambda_values[q_point][2] * fe_values_face.JxW(q_point);</div><div class="line">            }</div><div class="line">    contact_force = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(contact_force, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Contact force = &quot;</span> &lt;&lt; contact_force &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PlasticityContactProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    computing_timer.reset();</div><div class="line">    <span class="keywordflow">for</span> (; current_refinement_cycle &lt; n_refinement_cycles;</div><div class="line">         ++current_refinement_cycle)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup&quot;</span>);</div><div class="line"></div><div class="line">          pcout &lt;&lt; std::endl;</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; current_refinement_cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (current_refinement_cycle == 0)</div><div class="line">            {</div><div class="line">              make_grid();</div><div class="line">              setup_system();</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: refine mesh&quot;</span>);</div><div class="line">              refine_grid();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        solve_newton();</div><div class="line"></div><div class="line">        output_results(current_refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line"></div><div class="line">        <a class="code" href="structUtilities_1_1System_1_1MemoryStats.html">Utilities::System::MemoryStats</a> stats;</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#a25db0fc07c298b5bef3d6f738283bd6d">Utilities::System::get_memory_stats</a>(stats);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Peak virtual memory used, resident in kB: &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a9cb487ac1831b7e5836be93859c1c2af">VmSize</a></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a39901417b9e6ebfa36d05bfb8a282aa2">VmRSS</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">          output_contact_force();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step42</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>Step42;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      PlasticityContactProblem&lt;3&gt;::declare_parameters(prm);</div><div class="line">      <span class="keywordflow">if</span> (argc != 2)</div><div class="line">        {</div><div class="line">          std::cerr &lt;&lt; <span class="stringliteral">&quot;*** Call this program as &lt;./step-42 input.prm&gt;&quot;</span></div><div class="line">                    &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(argv[1]);</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line">      {</div><div class="line">        PlasticityContactProblem&lt;3&gt; problem(prm);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_41.html">step-41</a>, <a class="el" href="step_40.html">step-40</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Introduction">Introduction</a>
        <li><a href="#Classicalformulation">Classical formulation</a>
        <li><a href="#Reformulationasavariationalinequality">Reformulation as a variational inequality</a>
        <li><a href="#ANewtonmethodfortheplasticnonlinearity">A Newton method for the plastic nonlinearity</a>
        <li><a href="#ActiveSetmethodstosolvethesaddlepointproblem">Active Set methods to solve the saddle point problem</a>
        <li><a href="#Overallalgorithm">Overall algorithm</a>
        <li><a href="#Adaptivemeshrefinement">Adaptive mesh refinement</a>
        <li><a href="#Implementation">Implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeConstitutiveLawcodeclasstemplate">The <code>ConstitutiveLaw</code> class template</a>
      <ul>
        <li><a href="#ConstitutiveLawget_stress_strain_tensor">ConstitutiveLaw::get_stress_strain_tensor</a>
        <li><a href="#ConstitutiveLawget_linearized_stress_strain_tensors">ConstitutiveLaw::get_linearized_stress_strain_tensors</a>
        <li><a href="#ThecodeSphereObstaclecodeclass">The <code>SphereObstacle</code> class</a>
        <li><a href="#ThecodeBitmapFilecodeandcodeChineseObstaclecodeclasses">The <code>BitmapFile</code> and <code>ChineseObstacle</code> classes</a>
      </ul>
        <li><a href="#ThecodePlasticityContactProblemcodeclasstemplate">The <code>PlasticityContactProblem</code> class template</a>
        <li><a href="#ImplementationofthecodePlasticityContactProblemcodeclass">Implementation of the <code>PlasticityContactProblem</code> class</a>
      <ul>
        <li><a href="#PlasticityContactProblemdeclare_parameters">PlasticityContactProblem::declare_parameters</a>
        <li><a href="#ThecodePlasticityContactProblemcodeconstructor">The <code>PlasticityContactProblem</code> constructor</a>
        <li><a href="#PlasticityContactProblemmake_grid">PlasticityContactProblem::make_grid</a>
        <li><a href="#PlasticityContactProblemsetup_system">PlasticityContactProblem::setup_system</a>
        <li><a href="#PlasticityContactProblemcompute_dirichlet_constraints">PlasticityContactProblem::compute_dirichlet_constraints</a>
        <li><a href="#PlasticityContactProblemassemble_mass_matrix_diagonal">PlasticityContactProblem::assemble_mass_matrix_diagonal</a>
        <li><a href="#PlasticityContactProblemupdate_solution_and_constraints">PlasticityContactProblem::update_solution_and_constraints</a>
        <li><a href="#PlasticityContactProblemassemble_newton_system">PlasticityContactProblem::assemble_newton_system</a>
        <li><a href="#PlasticityContactProblemcompute_nonlinear_residual">PlasticityContactProblem::compute_nonlinear_residual</a>
        <li><a href="#PlasticityContactProblemsolve_newton_system">PlasticityContactProblem::solve_newton_system</a>
        <li><a href="#PlasticityContactProblemsolve_newton">PlasticityContactProblem::solve_newton</a>
        <li><a href="#PlasticityContactProblemrefine_grid">PlasticityContactProblem::refine_grid</a>
        <li><a href="#PlasticityContactProblemmove_mesh">PlasticityContactProblem::move_mesh</a>
        <li><a href="#PlasticityContactProblemoutput_results">PlasticityContactProblem::output_results</a>
        <li><a href="#PlasticityContactProblemoutput_contact_force">PlasticityContactProblem::output_contact_force</a>
        <li><a href="#PlasticityContactProblemrun">PlasticityContactProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-42/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by JÃ¶rg Frohne (University of Siegen, Germany) while on a long-term visit to Texas A&amp;M University, with significant contributions by Timo Heister and Wolfgang Bangerth. <br />
 <br />
 The code described here provides the basis for the numerical experiments shown in the following paper: <br />
 J. Frohne, T. Heister, W. Bangerth: <b>Efficient numerical methods for the large-scale, parallel solution of elastoplastic contact problems</b><b>Efficient numerical methods for the large-scale, parallel solution of elastoplastic contact problems</b>. Accepted for publication in International Journal for Numerical Methods in Engineering, 2015. </em> ã</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h3>Introduction</h3>
<p>è¿ä¸ªä¾å­æ¯ç¬¬41æ­¥çå»¶ä¼¸ï¼èèçæ¯ä¸ç»´æ¥è§¦é®é¢ï¼å·æåååæ§ç¡¬åçå¼¹å¡æ§ææè¡ä¸ºãæ¢å¥è¯è¯´ï¼å®èèçæ¯ï¼å¦ææä¸ä¸ªåæ§çéç¢ç©æ¨å°ä¸ä¸ªä¸ç»´ä½ä¸ï¼å®æ¯å¦ä½åå½¢çï¼æ¥è§¦é®é¢ï¼ï¼å¶ä¸­çåå½¢åå¼¹å¡æ§æææ³åï¼ä¸ç§åªè½å®¹çº³ä¸å®æå¤§åºåçææï¼çå¶çº¦ï¼éçåå½¢çç´¯ç§¯ï¼è¯¥ææä¼ç¡¬åãä¸ºäºè¯´ææä»¬æç®åä»ä¹ï¼å¨è®¨è®ºå¤ªå¤ç»èä¹åï¼è®©æä»¬åªå±ç¤ºä¸å¼ è§£å³æ¹æ¡çå¾çï¼å¯åå½¢ä½æ¯ä¸ä¸ªç«æ¹ä½&ndash;å®éä¸åªæ¾ç¤ºäºä¸å&ndash;ï¼éç¢ç©å¯¹åºäºä¸ä¸ªæ±å­ï¼å°å¨ä¸é¢è®¨è®ºï¼ã</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionLi2.png"/>
</div>
<p>è¿ä¸ªé®é¢çæè¿°æå³çï¼ä¸ç¬¬41æ­¥ç¸æ¯ï¼æä»¬å¿é¡»ç§é¡¾å°ä¸ä¸ªé¢å¤çéçº¿æ§å ç´ ï¼ææè¡ä¸ºãç±äºæä»¬å¨è¿éèèçæ¯ä¸ä¸ªä¸ç»´é®é¢ï¼æä»¬è¿å¿é¡»èèå°ä¸ä¸ªäºå®ï¼å³ç°å¨æ¥è§¦åºæ¯å¨å¯åå½¢ä½çè¾¹çï¼èä¸æ¯å¨åé¨ãæåï¼ä¸ç¬¬41æ­¥ç¸æ¯ï¼æä»¬è¿å¿é¡»å¨å¤ççº¿æ§ç³»ç»åä¸ç­å¼çº¦ææ¶å¤çæ¬ç©ºèç¹ï¼å ä¸ºæä»¬å¸æä½¿ç¨èªéåºç½æ ¼ï¼å¨åä¸ç§æåµä¸ï¼æä»¬å°ä¸å¾ä¸å¤çä¼åèèæ¬ç©ºèç¹ççº¦æè¿æ¯ä¸ç­å¼ççº¦ææ´éè¦ã</p>
<p>ç±äºå¨ä¸ç»´ç©ºé´ä¸­å¾å®¹æè¾¾å°å ç¾ä¸ä¸ªèªç±åº¦ï¼å³ä½¿ä½¿ç¨èªéåºç½æ ¼ç»åï¼æä»¬å³å®ä½¿ç¨Trilinosåp4estæ¥å¹¶è¡è¿è¡æä»¬çä»£ç ï¼å¨æ­¥éª¤40çæ¡æ¶ä¸è¿è¡å¹¶è¡åãå¹¶è¡åçå¶ä»æéå¯ä»¥å¨æ­¥éª¤32ä¸­æ¾å°ã</p>
<p><a class="anchor" id="Classicalformulation"></a></p><h3>Classical formulation</h3>
<p>è¯¥é®é¢çç»å¸è¡¨è¿°å·æä»¥ä¸å½¢å¼ã</p>
<p class="formulaDsp">
\begin{align*} \varepsilon(\mathbf u) &amp;= A\sigma + \varepsilon^p &amp; &amp;\quad\text{in } \Omega,\\ -\textrm{div}\ \sigma &amp;= \mathbf f &amp; &amp;\quad\text{in } \Omega,\\ \varepsilon^p:(\tau - \sigma) &amp;\geq 0\quad\forall\tau\text{ with }\mathcal{F}(\tau)\leq 0 &amp; &amp;\quad\text{in } \Omega,\\ \mathbf u &amp;= 0 &amp; &amp;\quad\text{on }\Gamma_D,\\ \sigma \mathbf n - [\mathbf n \cdot(\sigma \mathbf n)]\mathbf n &amp;= 0, \quad \mathbf n \cdot (\sigma \mathbf n) \leq 0 &amp; &amp;\quad\text{on }\Gamma_C,\\ (\mathbf n \cdot (\sigma \mathbf n))(\mathbf n \cdot \mathbf u - g) &amp;= 0,\quad \mathbf n \cdot \mathbf u - g \leq 0 &amp; &amp;\quad\text{on } \Gamma_C. \end{align*}
</p>
<p>è¿éï¼è¿äºæ¹ç¨çç¬¬ä¸ä¸ªå®ä¹äºåºå \(\varepsilon(\mathbf u)=\frac{1}{2}\left(\nabla \mathbf u + \nabla \mathbf u^T\right)\) ååºå \(\sigma\) ä¹é´çå³ç³»ï¼éè¿åé¶é¡ºåºæ§å¼ é \(A\) ï¼ \(\varepsilon^p\) æä¾äºåºåçå¡æ§æåï¼ç¡®ä¿åºåä¸è¶è¿å±æåºåãæä»¬å°åªèèåååæ§çææï¼å¯¹äºè¿äºææï¼ \(A\) å¯ä»¥ç¨Lam&eacute;æ¨¡é \(\lambda\) å \(\mu\) è¡¨ç¤ºï¼æèç¨ä½æ¨¡é \(\kappa\) å \(\mu\) è¡¨ç¤ºãç¬¬äºä¸ªæ¹ç¨æ¯åçå¹³è¡¡ï¼æä»¬å¨æ­¤ä¸èèä»»ä½ä½åï¼å¹¶åå® \(\mathbf f=0\) ãç¬¬ä¸è¡çäºè¡¥æ¡ä»¶æå³çï¼å¦æ \(\mathcal{F}(\sigma)&lt; 0\) ï¼å \(\varepsilon^p=0\) ï¼ä½å½ä¸ä»å½ \(\mathcal{F}(\sigma) = 0\) ï¼ \(\varepsilon^p\) å¯è½æ¯ä¸ä¸ªéé¶å¼ éï¼ç¹å«æ¯å¨è¿ç§æåµä¸ï¼ \(\varepsilon^p\) å¿é¡»æå \(\partial \mathcal{F}(\sigma)/\partial \sigma\) çæ¹åãä¸ç­å¼ \(\mathcal{F}(\sigma)\le 0\) æ¯å¡æ§ææåªè½æ¯ææéçåºåï¼æ¢å¥è¯è¯´ï¼å¦æå¤åä¼å¯¼è´ \(\sigma\) çåºåï¼é£ä¹å®ä»¬å°±ä¼äº§çå¡æ§åå½¢ \(\varepsilon^p\) çååºãè¿ç§<em>yield function</em>çå¸åå½¢å¼æ¯ \(\mathcal{F}(\sigma)=|\sigma^D|-\sigma_{\text{yield}}\) ï¼å¶ä¸­ \(\tau^D = \tau - \dfrac{1}{3}tr(\tau)I\) æ¯å¼ éçåç¦»é¨åï¼ \(|\cdot|\) è¡¨ç¤ºå¼ç½æ¬å°¼æ¯è§èã</p>
<p>è¿ä¸æ­¥çæ¹ç¨æè¿°äº \(\Gamma_D\) ä¸åºå®çé¶ä½ç§»ï¼å¨å¯è½åºç°æ¥è§¦çè¡¨é¢ \(\Gamma_C=\partial\Omega\backslash\Gamma_D\) ä¸ï¼éç¢ç©æ½å çæ³åå \(\sigma_n=\mathbf n \cdot (\sigma(\mathbf u) \mathbf n)\) æ¯ååçï¼éç¢ç©å¯¹æä»¬çèº«ä½æ²¡æ "æå"ï¼ï¼åååéä¸ºé¶ \(\mathbf \sigma_t= \sigma \mathbf n - \mathbf \sigma_n \mathbf n = \sigma \mathbf n - [\mathbf n \cdot(\sigma \mathbf n)]\mathbf n\) ãæåä¸ä¸ªæ¡ä»¶åæ¯ä¸ä¸ªäºè¡¥æ¡ä»¶ï¼æå³çå¨ \(\Gamma_C\) ä¸ï¼åªæå½èº«ä½ä¸éç¢ç©æ¥è§¦æ¶ï¼æ³ååæè½éé¶ï¼ç¬¬äºé¨åæè¿°äºéç¢ç©åèº«ä½çä¸å¯ç©¿éæ§ãæåä¸¤ä¸ªæ¹ç¨éå¸¸è¢«ç§°ä¸ºSignoriniæ¥è§¦æ¡ä»¶ã</p>
<p>å¤§å¤æ°ææ&ndash;å°¤å¶æ¯éå±&ndash;é½æè¿æ ·çç¹æ§ï¼å³å®ä»¬å¨åå½¢æ¶è¡¨ç°åºä¸å®çç¡¬åãæ¢å¥è¯è¯´ï¼ \(\sigma_{\text{yield}}\) éçåå½¢èå¢å ãå¨å®è·µä¸­ï¼å¯¼è´ç¡¬åçä¸æ¯å¼¹æ§åå½¢ï¼èæ¯å¡æ§æåãæä¸åçæææ³åæ¥æè¿°è¿äºææè¡ä¸ºãæç®åçç§°ä¸ºçº¿æ§åååæ§ç¡¬åï¼ç±æµå¨å½æ° \(\mathcal{F}(\sigma,\varepsilon^p) = \vert\sigma^D\vert - (\sigma_0 + \gamma^{\text{iso}}|\varepsilon^p|)\) æè¿°ã</p>
<p><a class="anchor" id="Reformulationasavariationalinequality"></a></p><h3>Reformulation as a variational inequality</h3>
<p>ä¸è¬æ¥è¯´ï¼å¤çä¸ç­å¼æ¯ç¸å½ç¬¨æçãå¨è¿éï¼æä»¬å¿é¡»å¤çä¸¤ä¸ªé®é¢ï¼å¡æ§åæ¥è§¦é®é¢ãæ­£å¦æ¬é¡µé¡¶é¨æå°çè®ºæä¸­è¯¦ç»æè¿°çé£æ ·ï¼æä»¬è³å°å¯ä»¥éæ°è¡¨è¿°å¡æ§ï¼ä½¿å¶çèµ·æ¥åä¸ä¸ªéçº¿æ§ï¼ç¶åæä»¬å¯ä»¥ç¨çé¡¿æ¹æ³å¤çãè¿å¨æ°å­¦ä¸ç¥æ¾æ£æï¼å ä¸ºéçº¿æ§ä¸åªæ¯ä¸äºå¹³æ»çå½æ°ï¼èæ¯å¨åºåè¾¾å°å±æåºåçå°æ¹æç»ç¹ï¼ç¶èï¼å¯¹äºè¿æ ·ç<em>semismooth</em>å½æ°ï¼å¯ä»¥è¯æçé¡¿æ¹æ³ä»ç¶æ¶æã</p>
<p>å¨ä¸æ¶åç»èçæåµä¸ï¼æä»¬ä¹å°æè±ä½ä¸ºç¬ç«åéçåºåï¼èå®å¨ç¨ä½ç§»æ¥å·¥ä½ \(\mathbf u\) ãæç»ï¼è¿ç§éæçç®æ æ¯ï¼æä»¬å¸ææç»å¾å°ä¸ä¸ªå¯¹ç§°çãæ­£å®çé®é¢&ndash;æ¯å¦ä¸ä¸ªçº¿æ§åçå¼¹æ§é®é¢ï¼å¶ç©ºé´åéç³»æ°ç±å¡æ§è¡ä¸ºäº§ç&ndash;éè¦å¨æ¯ä¸ªçé¡¿æ­¥éª¤ä¸­è§£å³ãæä»¬å¸æå¦æ­¤ï¼å ä¸ºæé«æåå¯æ©å±çæ¹æ³æ¥è§£å³è¿æ ·ççº¿æ§ç³»ç»ï¼å¦ç¨ä»£æ°å¤éç½æ ¼çCGé¢å¤çãè¿ä¸æä»¬ç»§ç»­ä½¿ç¨åå«ä½ç§»ååºåçæ··åå¬å¼æå¾å°çç±»ä¼¼äºæ··åææ®ææ¯çéç¹é®é¢ï¼è§ç¬¬20æ­¥ï¼æ¯ç¸åçï¼ç¬¬20æ­¥å·²ç»æç¤ºäºæå»ºè¯å¥½çæ±è§£å¨åé¢å¤çå¨æ¯å¤ä¹å°é¾ã</p>
<p>è¯´å°è¿éï¼è®©æä»¬ç®åéè¿°ä¸ä¸æä»¬å¨éæåå¾å°çé®é¢ï¼åæ ·ï¼ç»èå¯ä»¥å¨è®ºæä¸­æ¾å°ï¼ãæ¾å°ä¸ä¸ªä½ç§» \(\mathbf u \in V^+\) ï¼ä»¥ä¾¿</p>
<p class="formulaDsp">
\begin{align*} \left(P_{\Pi}(C\varepsilon(\mathbf u)),\varepsilon(\varphi) - \varepsilon(\mathbf u)\right) \geq 0,\quad \forall \varphi\in V^+. \end{align*}
</p>
<p>å¶ä¸­æå½±ä»ª \(P_\Pi\) è¢«å®ä¹ä¸º</p>
<p class="formulaDsp">
\begin{align*} P_{\Pi}(\tau) \dealcoloneq \begin{cases} \tau, &amp; \text{if }\vert\tau^D\vert \leq \sigma_0,\\ \left[ \dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}} + \left(1-\dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\right)\dfrac{\sigma_0}{\vert\tau^D\vert} \right]\tau^D + \dfrac{1}{3}\text{trace}(\tau) I, &amp; \text{if }\vert\tau^D\vert &gt; \sigma_0, \end{cases} \end{align*}
</p>
<p>åç©ºé´ \(V^+\) æ¯æ»¡è¶³æ¥è§¦æ¡ä»¶çææä½ç§»çç©ºé´ã</p>
<p class="formulaDsp">
\begin{align*} V &amp;= \left\{ \mathbf u\in \left[H^1(\Omega)\right]^{d}: \mathbf u = 0 \text{ on } \Gamma_D\right\}, \\ V^+ &amp;= \left\{ \mathbf u\in V: \mathbf n \cdot \mathbf u\leq g \text{ on } \Gamma_C \right\}. \end{align*}
</p>
<p>å¨å®éä»£ç ä¸­ï¼æä»¬å°ä½¿ç¨ç¼©å \(\gamma=\dfrac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\) ã</p>
<p>é´äºè¿ç§è¡¨è¿°ï¼æä»¬å°åºç¨ä¸¤ç§ææ¯ã</p>
<ul>
<li>è¿è¡çé¡¿æ¹æ³æ¥è¿­ä»£åºæå½±ä»ªçéçº¿æ§ã</li>
<li>ä¸ºæ¥è§¦æ¡ä»¶è¿è¡ä¸ä¸ªä¸»å¨è®¾ç½®æ¹æ³ï¼æ¹æ³ä¸æä»¬å¨æ­¥éª¤41ä¸­æåçåºæ¬ç¸åã</li>
</ul>
<p>ä¸ä¸ªä¸¥æ ¼çæ¹æ³æ¯å¨æä»¬è¿­ä»£çé¡¿æ¹æ³å°æ¶ææ¶ä¿ææ´»å¨éçåºå®ï¼æèä¹è®¸åè¿æ¥ï¼å¨è¿å¥ä¸ä¸ä¸ªçé¡¿è¿­ä»£ä¹åæ¾å°æç»çæ´»å¨éï¼ãå¨å®è·µä¸­ï¼äºå®è¯æï¼æ¯ä¸ªæ´»å¨éè¿­ä»£åªåä¸ä¸ªçé¡¿æ­¥éª¤å°±è¶³å¤äºï¼æä»¥æä»¬å°åæ¶è¿­ä»£å®ä»¬ãæä»¬è¿å°æ¯éä¸æ®µæ¶é´ç»åä¸ä¸ç½æ ¼ã</p>
<p><a class="anchor" id="ANewtonmethodfortheplasticnonlinearity"></a></p><h3>A Newton method for the plastic nonlinearity</h3>
<p>å¦åæè¿°ï¼æä»¬å°éè¿åºç¨çé¡¿æ¹æ³æ¥å¤çç®å­ \(P_\Pi\) çéçº¿æ§ï¼å°½ç®¡è¯¥ç®å­å¨ä¸¥æ ¼æä¹ä¸æ¯ä¸å¯å¾®çãç¶èï¼å®æ»¡è¶³äº<em>slant</em>çå¯å¾®æ¡ä»¶ï¼è¿å°±è¶³ä»¥ä½¿çé¡¿æ¹æ³åæ¥ä½ç¨ãç±æ­¤äº§ççæ¹æ³è¢«ç§°ä¸º<em>semi-smooth Newton method</em>ï¼å¬èµ·æ¥ä»¤äººå°è±¡æ·±å»ï¼ä½å®éä¸åªæ¯ä¸ä¸ªçé¡¿æ¹æ³åºç¨äºä¸ä¸ªå·æéå½éæ©ç "å¯¼æ° "çååæ»å½æ°ã</p>
<p>å¨ç®åçæåµä¸ï¼æä»¬å°éè¿å¨æ¯ä¸ªè¿­ä»£ \(i\) ä¸­æ±è§£ä»¥ä¸æ¹ç¨æ¥è¿è¡æä»¬çè¿­ä»£ï¼ä»ç¶æ¯ä¸ç­å¼ï¼ä½æ¯çº¿æ§åï¼ã</p>
<p class="formulaDsp">
\begin{align*} \label{eq:linearization} \left(I_{\Pi}\varepsilon(\tilde {\mathbf u}^{i}), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right) \geq \left(\left(I_{\Pi}\varepsilon({\mathbf u}^{i-1}), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right) - \left(P_{\Pi}(C\varepsilon({\mathbf u}^{i-1})), \varepsilon(\varphi) - \varepsilon(\tilde {\mathbf u}^{i})\right)\right), \quad \forall \varphi\in V^+, \end{align*}
</p>
<p>å¶ä¸­ï¼ç­çº§4å¼ é \(I_\Pi=I_\Pi(\varepsilon^D(\mathbf u^{i-1}))\) ç±ä»¥ä¸å¬å¼ç»åº</p>
<p class="formulaDsp">
\begin{align} I_\Pi = \begin{cases} C_{\mu} + C_{\kappa}, &amp; \hspace{-8em} \text{if } \vert C\varepsilon^D(\mathbf u^{i-1}) \vert \leq \sigma_0, \\ \frac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}} C_{\mu} + \frac{\left(1-\frac{\gamma^{\text{iso}}}{2\mu + \gamma^{\text{iso}}}\right)\sigma_0}{\vert C\varepsilon^D(\mathbf u^{i-1}) \vert}\left(C_{\mu} - 2\mu\dfrac{C\varepsilon^D(\mathbf u^{i-1})\otimes C\varepsilon^D(\mathbf u^{i-1})}{\vert C\varepsilon^D(\mathbf u^{i-1})\vert^2}\right) + C_{\kappa}, &amp; \text{ else.} \end{cases} \end{align}
</p>
<p>è¿ä¸ªå¼ éæ¯ \(P_\Pi(C\cdot)\) å´ç» \(\varepsilon^D(\mathbf u^{i-1})\) çï¼å½¢å¼ï¼çº¿æ§åãå¯¹äºæä»¬è¿éèèççº¿æ§åååæ§ææï¼æå½±ä»ªçä½ç§¯ååªååéç±ä»¥ä¸å¬å¼ç»åº</p>
<p class="formulaDsp">
\begin{gather*} C_{\kappa} = \kappa I\otimes I, \qquad\qquad\qquad\qquad C_{\mu} = 2\mu\left(\mathbb{I} - \dfrac{1}{3} I\otimes I\right), \end{gather*}
</p>
<p>å¶ä¸­ \(I\) å \(\mathbb{I}\) åå«æ¯ç­çº§ä¸º2å4çè®¤åå¼ éã</p>
<p>è¯·æ³¨æï¼è¿ä¸ªé®é¢å¯¹åºäºçº¿æ§å¼¹æ§æ¥è§¦é®é¢ï¼å¶ä¸­ \(I_\Pi\) æ®æ¼å¼¹æ§å¼ éçè§è² \(C=A^{-1}\) ãäºå®ä¸ï¼å¦æææå¨æä¸ç¹ä¸æ²¡æå¡æ§ï¼é£ä¹ \(I_\Pi=C\) ãç¶èï¼å¨ææå·æå¡æ§çå°æ¹ï¼ \(I_\Pi\) æ¯ä¸ä¸ªç©ºé´ååçå½æ°ãå¨ä»»ä½æåµä¸ï¼æä»¬å¿é¡»è§£å³çé¡¿è¿­ä»£çç³»ç» \(\tilde {\mathbf u}^{i}\) ä½¿æä»¬æ´æ¥è¿éåæä»¬é®é¢çç®æ ï¼ä½¿æä»¬è½å¤ä½¿ç¨ä¼æå¨ç¥çæ¤­åç³»ç»çæ±è§£å¨åé¢å¤çå¨ã</p>
<p>ä½ä¸ºå¯¹çé¡¿æ¹æ³çæåè¯´æï¼è®©æä»¬æä¸ä¸ï¼æ­£å¦çé¡¿æ¹æ³å¸¸è§çé£æ ·ï¼æä»¬éè¦éè¿æ§å¶æ­¥é¿æ¥ä½¿å¶å¨çåãæ¢å¥è¯è¯´ï¼è½ç¶ä¸é¢çç³»ç»æ±è§£çæ¯ \(\tilde {\mathbf u}^{i}\) ï¼ä½æåçè¿­ä»£ç»æå°æ¯</p>
<p class="formulaDsp">
\begin{align*} {\mathbf u}^{i} = {\mathbf u}^{i-1} + \alpha_i (\tilde {\mathbf u}^{i} - {\mathbf u}^{i-1}) \end{align*}
</p>
<p>å¶ä¸­å³è¾¹æ¬å·ä¸­çå·®å¼æ®æ¼äºä¼ ç»çé¡¿æ¹åçè§è²ï¼ \(\delta {\mathbf u}^{i}\) ãæä»¬å°ç¨æ åçç´çº¿æç´¢æ¥ç¡®å® \(\alpha^i\) ã</p>
<p><a class="anchor" id="ActiveSetmethodstosolvethesaddlepointproblem"></a></p><h3>Active Set methods to solve the saddle point problem</h3>
<p>è¿ä¸ªè¦å¨æ¯ä¸ªçé¡¿æ­¥éª¤ä¸­è§£å³ççº¿æ§åé®é¢åºæ¬ä¸ä¸æ­¥éª¤41ä¸æ ·ãå¯ä¸çåºå«å¨äºæ¥è§¦åºæ¯å¨è¾¹çèä¸æ¯å¨åä¸­ãä½è¿æ²¡æè¿ä¸æ­¥çåæï¼æä»¥æä»¬åèæ­¥éª¤41çæä»¶ï¼å¯ä¸çæç¤ºæ¯ \(\mathcal{S}\) è¿æ¬¡åå«äºæ¥è§¦è¾¹ççææé¡¶ç¹ \(\Gamma_C\) ãåé£éä¸æ ·ï¼æä»¬éè¦åçæ¯ä¿æä¸ä¸ªèªç±åº¦å­éçåºå®ï¼å¯¼è´é¢å¤ççº¦æï¼å¯ä»¥åæä¸ä¸ªéç¹é®é¢ãç¶èï¼æ­£å¦è®ºæä¸­æè®¨è®ºçï¼éè¿ä»¥éå½çæ¹å¼åè¿äºçº¦æï¼æ¶é¤èªç±åº¦ä¹é´çè¦åï¼æä»¬æç»ä¼å¾å°ä¸ç»èç¹ï¼è¿äºèç¹åºæ¬ä¸åªæ¯éå äºDirichletå¼ã</p>
<p><a class="anchor" id="Overallalgorithm"></a></p><h3>Overall algorithm</h3>
<p>ä¸è¿°ç®æ³ç»åäºé»å°¼ååæ»çé¡¿æ³ï¼æä»¬ç¨äºéçº¿æ§æææ³ï¼åååæ»çé¡¿æ³ç¨äºæ¥è§¦ãå®çå·¥ä½åçå¦ä¸ã</p><ol>
<li>
<p class="startli">åå§åæ´»å¨åéæ´»å¨é \(\mathcal{A}_i\) å \(\mathcal{F}_i\) ï¼ä½¿ \(\mathcal{S} = \mathcal{A}_i \cup \mathcal{F}_i\) å \(\mathcal{A}_i \cap \mathcal{F}_i = \emptyset\) åé \(i = 1\) ãè¿éï¼ \(\mathcal{S}\) æ¯ä½äºå¯è½åçæ¥è§¦çåçè¡¨é¢çææèªç±åº¦çéåã èµ·å§å¼ \(\hat U^0 \dealcoloneq P_{\mathcal{A}_k}(0)\) æ»¡è¶³æä»¬çéç¢æ¡ä»¶ï¼ä¹å°±æ¯è¯´ï¼æä»¬å°åå§é¶ä½ç§»æå°å°å¯è¡ä½ç§»éåä¸ã</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">ç»è£çé¡¿ç©éµ \(A_{pq} \dealcoloneq a&#39;( U^{i-1};\varphi_p,\varphi_q)\) åå³ä¾§ \(F(\hat U^{i-1})\) ã è¿äºå¯¹åºäºçº¿æ§åççé¡¿æ­¥éª¤ï¼ææ¶å¿½ç¥äºæ¥è§¦ä¸ç­å¼ã</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">æ¾å°æ»¡è¶³ </p><p class="formulaDsp">
\begin{align*} A\tilde U^i + B\Lambda^i &amp; = F, &amp;\\ \left[B^T\tilde U^i\right]_p &amp; = G_p &amp; \forall p\in\mathcal{A}_i,\\ \Lambda^i_p &amp; = 0 &amp; \forall p\in\mathcal{F}_i. \end{align*}
</p>
<p>çåå§-åæ°å¯¹ \((\tilde U^i,\Lambda^i)\) ã</p>
<p>å¦åæ­¥éª¤-41ï¼æä»¬å¯ä»¥éè¿æ¶é¤ç¬¬ä¸ä¸ªæ¹ç¨ä¸­ \({\cal A}_i\) çé£äºèªç±åº¦æ¥è·å¾è¿ä¸ªé®é¢çè§£å³æ¹æ¡ï¼å¹¶è·å¾ä¸ä¸ªçº¿æ§ç³»ç» \(\hat {\hat A}(U^{i-1}) \tilde U^i = \hat {\hat H}(U^{i-1})\) ã</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">éè¿åºç¨ç´çº¿æç´¢åè®¡ç® \(U^{i-1}\) å \(\tilde U^i\) ççº¿æ§ç»åæ¥åå¼± \(i&gt;2\) ççé¡¿è¿­ä»£ãè¿éè¦æ¾å°ä¸ä¸ª \(\alpha^i_l \dealcoloneq 2^{-l},(l=0,\ldots,10)\) ï¼ä»¥ä¾¿ </p><p class="formulaDsp">
\begin{gather*}U^i \dealcoloneq \alpha^i_l\bar U^i + (1-\alpha^i_l)U^{i-1}\end{gather*}
</p>
<p>ã</p>
<p>æ»¡è¶³ </p><p class="formulaDsp">
\begin{gather*} \vert {\hat R}\left({\mathbf u}^{i}\right) \vert &lt; \vert {\hat R}\left({\mathbf u}^{i-1}\right) \vert. \end{gather*}
</p>
<p>ä¸ \({\hat R}\left({\mathbf u}\right)=\left(P_{Pi}(C\varepsilon(u)),\varepsilon(\varphi^{i}_p\right)\) ï¼é¤äº(i)åç´  \(p\in\mathcal{A}_i\) ï¼æä»¬è®¾ç½® \({\hat R}\left({\mathbf u}\right)=0\) ï¼å(ii)å¯¹åºäºæ¬æèç¹çåç´ ï¼æä»¬ä»¥éå¸¸æ¹å¼æ¶é¤ã</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">éè¿ </p><p class="formulaDsp">
\begin{gather*}\mathcal{A}_{i+1} \dealcoloneq \lbrace p\in\mathcal{S}:\Lambda^i_p + c\left(\left[B^TU^i\right]_p - G_p\right) &gt; 0\rbrace,\end{gather*}
</p>
<p>å®ä¹æ°çæ´»å¨åéæ´»å¨éã</p>
<p class="formulaDsp">
\begin{gather*}\mathcal{F}_{i+1} \dealcoloneq \lbrace p\in\mathcal{S}:\Lambda^i_p + c\left(\left[B^TU^i\right]_p - G_p\right) \leq 0\rbrace.\end{gather*}
</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">é¡¹ç® \(U^i\) ï¼ä½¿å¶æ»¡è¶³æ¥è§¦ä¸ç­å¼ï¼ </p><p class="formulaDsp">
\begin{gather*}\hat U^i \dealcoloneq P_{\mathcal{A}_{i+1}}(U^i).\end{gather*}
</p>
<p> ã</p>
<p>è¿éï¼ \(P_{\mathcal{A}}(U)\) æ¯ \(\mathcal{A}\) ä¸­çæ´»æ§æåå¯¹é´é </p><p class="formulaDsp">
\begin{gather*}P_{\mathcal{A}}(U)_p \dealcoloneq \begin{cases} U_p, &amp; \textrm{if}\quad p\notin\mathcal{A}\\ g_{h,p}, &amp; \textrm{if}\quad p\in\mathcal{A}, \end{cases}\end{gather*}
</p>
<p>çæå½±ã</p>
<p>å¶ä¸­ \(g_{h,p}\) æ¯<em>gap</em>ï¼è¡¨ç¤ºéç¢ç©ä¸èº«ä½æªä½ç§»éç½®çè·ç¦»ã</p>
<p class="endli"></p>
</li>
<li>
å¦æ \(\mathcal{A}_{i+1} = \mathcal{A}_k\) å \(\left\| {\hat R}\left({\mathbf u}^{i}\right) \right\|_{\ell_2} &lt; \delta\) ååæ­¢ï¼å¦åè®¾ç½® \(i=i+1\) å¹¶è½¬å°æ­¥éª¤ï¼1ï¼ãè¿ä¸æ­¥ç¡®ä¿æä»¬åªæå¨æ¾å°æ­£ç¡®çæ´»å¨éåå¡æ§å·²ç»è¿­ä»£å°è¶³å¤çç²¾åº¦æ¶æåæ­¢è¿­ä»£ã </li>
</ol>
<p>å¨è¿ä¸ªç®æ³çç¬¬3æ­¥ä¸­ï¼ç©éµ \(B\in\mathbb{R}^{n\times m}\) , \(n&gt;m\) æè¿°äºä½ç§»åææ ¼ææ¥ä¹æ°ï¼æ¥è§¦åï¼çåºæ°çè¦åï¼å¨æä»¬çæåµä¸å®ä¸æ¯äºæ¬¡çï¼å ä¸º \(\Lambda^k\) åªå®ä¹å¨ \(\Gamma_C\) ï¼å³å¯è½åçæ¥è§¦çé¢ãå¦æä¸­æç¤ºï¼æä»¬å¯ä»¥éæ© \(B\) æ¯ä¸ä¸ªæ¯è¡åªæä¸ä¸ªæ¡ç®çç©éµï¼ï¼å¦è§H&uuml;eber, Wohlmuth:A primal-dual active set strategy for non-linear multibody contact problems, Comput.Method Appl. Mech.Engrg.194, 2005, pp.3147-3166ï¼ã)ç¢é \(G\) æ¯ç±é´é \(g_h\) çåéè¿ä¼¼å¼å®ä¹çã</p>
<p class="formulaDsp">
\begin{gather*}G_p = \begin{cases} g_{h,p}, &amp; \text{if}\quad p\in\mathcal{S}\\ 0, &amp; \text{if}\quad p\notin\mathcal{S}. \end{cases}\end{gather*}
</p>
<p><a class="anchor" id="Adaptivemeshrefinement"></a></p><h3>Adaptive mesh refinement</h3>
<p>ç±äºæä»¬çç¨åºæ¯å¨ä¸ç»´ç©ºé´ä¸­è¿è¡çï¼æä»¥ç¨åºæ§è¡çè®¡ç®å¾æè´µãå æ­¤ï¼ä½¿ç¨èªéåºç½æ ¼ç»åæ¯å¨å¯æ¥åçè¿è¡æ¶é´åçä¸ä¸ªéè¦æ­¥éª¤ãä¸ºäºä½¿æä»¬ççæ´»æ´è½»æ¾ï¼æä»¬ç®åå°éæ©å·²ç»å¨deal.IIä¸­å®ç°çKellyErrorEstimatorãæä»¬æåå«ä½ç§» \(u\) çè§£åéäº¤ç»å®ãæ­£å¦æä»¬å°å¨ç»æä¸­çå°çï¼å®äº§çäºä¸ä¸ªç¸å½åççæ¥è§¦åºåå¡æ§çèªéåºç½æ ¼ã</p>
<p><a class="anchor" id="Implementation"></a></p><h3>Implementation</h3>
<p>æ¬æç¨å®è´¨ä¸æ¯æ­¥éª¤40åæ­¥éª¤41çæ··åä½ï¼ä½æä»¬æ²¡æä½¿ç¨PETScï¼èæ¯è®©Trilinosåºæ¥å¤ççº¿æ§ä»£æ°çå¹¶è¡åé®é¢ï¼å°±åæ­¥éª¤32ä¸æ ·ï¼ãç±äºæä»¬è¯å¾è§£å³ä¸ä¸ªç±»ä¼¼äºæ­¥éª¤41çé®é¢ï¼æä»¬å°ä½¿ç¨åæ ·çæ¹æ³ï¼ä½ç°å¨æ¯å¹¶è¡çã</p>
<p>ä¸ä¸ªå°é¾æ¯å¤çæ¥èªDirichletæ¡ä»¶ççº¦æï¼æ¬æèç¹åç±æ¥è§¦äº§ççä¸å¹³ç­æ¡ä»¶ãä¸ºæ­¤ï¼æä»¬åå»ºäºä¸ä¸ªAffineConstraintsç±»åçå¯¹è±¡ï¼å®ä»¬æè¿°äºåç§çº¦ææ¡ä»¶ï¼æä»¬å°å¨æ¯æ¬¡è¿­ä»£ä¸­éå½å°ç»åå®ä»¬ã</p>
<p>ä¸ç¬¬41æ­¥ç¸æ¯ï¼è¯¥è®¡åæä¸äºæ°çè¯¾ç¨ã</p>
<ul>
<li>
<p class="startli"><code>ConstitutiveLaw</code> æè¿°ææçå¡æ§è¡ä¸ºã</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>SphereObstacle</code> æè¿°ä¸ä¸ªçä½ï¼ä½ä¸ºè¢«æ¨å¥å¯åå½¢å¼¹æ§ä½çéç¢ç©ã æ¯ç¨è¿ä¸ªè¿æ¯ä¸ä¸ä¸ªç±»æ¥æè¿°éç¢ç©ï¼ç±è¾å¥åæ°æä»¶å³å®ã</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>ChineseObstacle</code> ï¼åä¸ä¸ªè¾å©ç±»ï¼æ¯ä¸ä¸ªåè®¸æä»¬ä»ä¸ä¸ªæä»¶ä¸­è¯»å¥éç¢ç©çç±»ãå¨æä»¬å°å¨ç»æé¨åå±ç¤ºçä¾å­ä¸­ï¼è¿ä¸ªæä»¶å°æ¯ <code>'obstacle_file.dat'</code> ï¼å¹¶å¯¹åºäºæ¾ç¤ºåæåéçä¸­æãæ¥ææé©æç¬¦å·çæ°æ®ï¼è§http://www.orientaloutpost.com/ï¼"è¿ä¸ªè¯å¯ç¨äºæ¿å±--å®ä¹å¯ä»¥æåé/è¿å¨/æ¨è¿/åãå®å¯ä»¥æ¯ä»»ä½ä½¿ä½ ç»§ç»­åè¿çåé¨æå¤é¨äºç©ãè¿æ¯ç¨ä¸­æè¡¨è¾¾å¨æºçæå®å¨æ¹å¼ãå¦æä½ çå¬ä¼æ¯æ¥æ¬äººï¼è¯·çå¦ä¸ä¸ªå³äºå¨æºçæ¡ç®ãè¿æ¯æ¥è¯­åé©è¯­ä¸­çä¸ä¸ªè¯ï¼ä½å®çæææ¯ "å¨å "æ "å¨è½"ï¼æ²¡æä½ å¯è½æ­£å¨å¯»æ¾çå¨æºçææï¼"ï¼ãå®è´¨ä¸ï¼æä»¬å°åè£æä¸ä¸ªå°ç« ï¼å³å¯¹åºäºå¹³åºéç¢ç©çé¢å·ï¼æ²¡æä¸­é´é«åº¦çç¢çï¼ï¼æä»¬æå®åå¨èº«ä½éãæå³çç¬¦å·çèµ·æ¥å¦ä¸ï¼ä¹å¯åè§æ¬èé¡¶é¨çå¾çï¼äºè§£æç»ç»ææ¯ææ ·çï¼ã</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.character.png" width="25%"/>
</div>
 </li>
</ul>
<p>ã</p>
<p>é¤æ­¤ä»¥å¤ï¼è®©æä»¬åªå¯¹ä»¥ä¸æ¹é¢è¿è¡è¯è®ºã </p><ul>
<li>
<p class="startli">ç¨åºåè®¸ä½ éè¿åæ°æä»¶ä»ä¸¤ä¸ªä¸åçç²ç¥ç½æ ¼ä¸­è¿è¡éæ©ãè¿äºæ¯ç«æ¹ä½ \([0,1]^3\) æåçä½ï¼å¶å¼æ¾é¢æåæ­£ \(z\) æ¹åã</p>
<p class="endli"></p>
</li>
<li>
å¨è¿ä¸¤ç§æåµä¸ï¼æä»¬å°åè®¾å¯è½ä¸éç¢ç©æ¥è§¦çè¾¹çé¨åå·æè¾¹çææ ä¸çæ¯ä¾ãå¯¹äºè¿ä¸¤ç§ç½æ ¼ï¼æä»¬åå®è¿æ¯ä¸ä¸ªèªç±è¡¨é¢ï¼å³èº«ä½è¦ä¹å¨é£éæ¥è§¦ï¼è¦ä¹æ²¡æåä½ç¨å¨å®èº«ä¸ãå¯¹äºåçä½ï¼å¼¯æ²é¨åçè¾¹çææ ä¸ºé¶ï¼æä»¬å¨é£éæ½å é¶ä½ç§»ãå¯¹äºçå­ï¼æä»¬æ²¿åºé¨æ½å é¶ä½ç§»ï¼ä½åè®¸æ²¿è¾¹çåç´ä½ç§»ï¼å°½ç®¡æ²¡ææ°´å¹³ä½ç§»ï¼ã </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The set of include files is not much of a surprise any more at this time:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__field__function_8h.html">deal.II/numerics/fe_field_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Finally, we include two system headers that let us create a directory for output files. The first header provides the <code>mkdir</code> function and the second lets us determine what happened if <code>mkdir</code> fails.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cerrno&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step42</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeConstitutiveLawcodeclasstemplate"></a> </p><h3>The <code>ConstitutiveLaw</code> class template</h3>
<p>This class provides an interface for a constitutive law, i.e., for the relationship between strain \(\varepsilon(\mathbf u)\) and stress \(\sigma\). In this example we are using an elastoplastic material behavior with linear, isotropic hardening. Such materials are characterized by Young's modulus \(E\), Poisson's ratio \(\nu\), the initial yield stress \(\sigma_0\) and the isotropic hardening parameter \(\gamma\). For \(\gamma = 0\) we obtain perfect elastoplastic behavior.</p>
<p>As explained in the paper that describes this program, the first Newton steps are solved with a completely elastic material model to avoid having to deal with both nonlinearities (plasticity and contact) at once. To this end, this class has a function <code>set_sigma_0()</code> that we use later on to simply set \(\sigma_0\) to a very large value &ndash; essentially guaranteeing that the actual stress will not exceed it, and thereby producing an elastic material. When we are ready to use a plastic model, we set \(\sigma_0\) back to its proper value, using the same function. As a result of this approach, we need to leave <code>sigma_0</code> as the only non-const member variable of this class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ConstitutiveLaw</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ConstitutiveLaw(<span class="keyword">const</span> <span class="keywordtype">double</span> E,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> nu,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> sigma_0,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> gamma);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_sigma_0(<span class="keywordtype">double</span> sigma_zero);</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> get_stress_strain_tensor(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> get_linearized_stress_strain_tensors(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">  <span class="keywordtype">double</span>       sigma_0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_kappa;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_mu;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of the ConstitutiveLaw class sets the required material parameter for our deformable body. Material parameters for elastic isotropic media can be defined in a variety of ways, such as the pair \(E, \nu\) (elastic modulus and Poisson's number), using the Lam&eacute; parameters \(\lambda,mu\) or several other commonly used conventions. Here, the constructor takes a description of material parameters in the form of \(E,\nu\), but since this turns out to these are not the coefficients that appear in the equations of the plastic projector, we immediately convert them into the more suitable set \(\kappa,\mu\) of bulk and shear moduli. In addition, the constructor takes \(\sigma_0\) (the yield stress absent any plastic strain) and \(\gamma\) (the hardening parameter) as arguments. In this constructor, we also compute the two principal components of the stress-strain relation and its linearization.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ConstitutiveLaw&lt;dim&gt;::ConstitutiveLaw(<span class="keywordtype">double</span> E,</div><div class="line">                                      <span class="keywordtype">double</span> nu,</div><div class="line">                                      <span class="keywordtype">double</span> sigma_0,</div><div class="line">                                      <span class="keywordtype">double</span> gamma)</div><div class="line">  : kappa(E / (3 * (1 - 2 * nu)))</div><div class="line">  , mu(E / (2 * (1 + nu)))</div><div class="line">  , sigma_0(sigma_0)</div><div class="line">  , gamma(gamma)</div><div class="line">  , stress_strain_tensor_kappa(kappa *</div><div class="line">                               <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                             <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()))</div><div class="line">  , stress_strain_tensor_mu(</div><div class="line">      2 * mu *</div><div class="line">      (<a class="code" href="symmetric__tensor_8h.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor</a>&lt;dim&gt;() - <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                              <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()) /</div><div class="line">                                  3.0))</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::set_sigma_0(<span class="keywordtype">double</span> sigma_zero)</div><div class="line">{</div><div class="line">  sigma_0 = sigma_zero;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutiveLawget_stress_strain_tensor"></a> </p><h4>ConstitutiveLaw::get_stress_strain_tensor</h4>
<p>This is the principal component of the constitutive law. It computes the fourth order symmetric tensor that relates the strain to the stress according to the projection given above, when evaluated at a particular strain point. We need this function to calculate the nonlinear residual in <code>PlasticityContactProblem::residual_nl_system()</code> where we multiply this tensor with the strain given in a quadrature point. The computations follow the formulas laid out in the introduction. In comparing the formulas there with the implementation below, recall that \(C_\mu : \varepsilon = \tau_D\) and that \(C_\kappa : \varepsilon = \kappa \text{trace}(\varepsilon) I = \frac 13 \text{trace}(\tau) I\).</p>
<p>The function returns whether the quadrature point is plastic to allow for some statistics downstream on how many of the quadrature points are plastic and how many are elastic.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> ConstitutiveLaw&lt;dim&gt;::get_stress_strain_tensor(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor =</div><div class="line">    (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor =</div><div class="line">    <a class="code" href="classSymmetricTensor.html#a6e7fd34dd28fc3f6420068887a939753">deviator</a>(stress_tensor);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">  stress_strain_tensor = stress_strain_tensor_mu;</div><div class="line">  <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">    }</div><div class="line"></div><div class="line">  stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (deviator_stress_tensor_norm &gt; sigma_0);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ConstitutiveLawget_linearized_stress_strain_tensors"></a> </p><h4>ConstitutiveLaw::get_linearized_stress_strain_tensors</h4>
<p>This function returns the linearized stress strain tensor, linearized around the solution \(u^{i-1}\) of the previous Newton step \(i-1\). The parameter <code>strain_tensor</code> (commonly denoted \(\varepsilon(u^{i-1})\)) must be passed as an argument, and serves as the linearization point. The function returns the derivative of the nonlinear constitutive law in the variable stress_strain_tensor, as well as the stress-strain tensor of the linearized problem in stress_strain_tensor_linearized. See PlasticityContactProblem::assemble_nl_system where this function is used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::get_linearized_stress_strain_tensors(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">  stress_tensor =</div><div class="line">    (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">  stress_strain_tensor            = stress_strain_tensor_mu;</div><div class="line">  stress_strain_tensor_linearized = stress_strain_tensor_mu;</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = <a class="code" href="classSymmetricTensor.html#a6e7fd34dd28fc3f6420068887a939753">deviator</a>(stress_tensor);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">      stress_strain_tensor_linearized *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">      deviator_stress_tensor /= deviator_stress_tensor_norm;</div><div class="line">      stress_strain_tensor_linearized -=</div><div class="line">        (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta * 2 * mu *</div><div class="line">        <a class="code" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(deviator_stress_tensor, deviator_stress_tensor);</div><div class="line">    }</div><div class="line"></div><div class="line">  stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line">  stress_strain_tensor_linearized += stress_strain_tensor_kappa;</div><div class="line">}</div></div><!-- fragment --><h3>Equation data: boundary forces, boundary values, obstacles</h3>
<p>The following should be relatively standard. We need classes for the boundary forcing term (which we here choose to be zero) and boundary values on those part of the boundary that are not part of the contact surface (also chosen to be zero here).</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryForce();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoundaryForce&lt;dim&gt;::BoundaryForce()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryForce&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryForce&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                        <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryForce&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues();</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoundaryValues&lt;dim&gt;::BoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.;</div><div class="line">  }</div></div><!-- fragment --><p><a class="anchor" id="ThecodeSphereObstaclecodeclass"></a> </p><h4>The <code>SphereObstacle</code> class</h4>
<p>The following class is the first of two obstacles that can be selected from the input file. It describes a sphere centered at position \(x=y=0.5, z=z_{\text{surface}}+0.59\) and radius \(r=0.6\), where \(z_{\text{surface}}\) is the vertical position of the (flat) surface of the deformable body. The function's <code>value</code> returns the location of the obstacle for a given \(x,y\) value if the point actually lies below the sphere, or a large positive value that can't possibly interfere with the deformation if it lies outside the "shadow" of the sphere.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SphereObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SphereObstacle&lt;dim&gt;::SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface)</div><div class="line">  : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  , z_surface(z_surface)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SphereObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> p(0);</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 1)</div><div class="line">    <span class="keywordflow">return</span> p(1);</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> ((p(0) - 0.5) * (p(0) - 0.5) + (p(1) - 0.5) * (p(1) - 0.5) &lt; 0.36)</div><div class="line">        <span class="keywordflow">return</span> (-std::sqrt(0.36 - (p(0) - 0.5) * (p(0) - 0.5) -</div><div class="line">                           (p(1) - 0.5) * (p(1) - 0.5)) +</div><div class="line">                z_surface + 0.59);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 1000;</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div></div><!-- fragment --><p>preceding Assert</p>
<div class="fragment"><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SphereObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SphereObstacle&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeBitmapFilecodeandcodeChineseObstaclecodeclasses"></a> </p><h4>The <code>BitmapFile</code> and <code>ChineseObstacle</code> classes</h4>
<p>The following two classes describe the obstacle outlined in the introduction, i.e., the Chinese character. The first of the two, <code>BitmapFile</code> is responsible for reading in data from a picture file stored in pbm ascii format. This data will be bilinearly interpolated and thereby provides a function that describes the obstacle. (The code below shows how one can construct a function by interpolating between given data points. One could use the <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html">Functions::InterpolatedUniformGridData</a>, introduced after this tutorial program was written, which does exactly what we want here, but it is instructive to see how to do it by hand.)</p>
<p>The data which we read from the file will be stored in a double std::vector named obstacle_data. This vector composes the base to calculate a piecewise bilinear function as a polynomial interpolation. The data we will read from a file consists of zeros (white) and ones (black).</p>
<p>The <code>hx,hy</code> variables denote the spacing between pixels in \(x\) and \(y\) directions. <code>nx,ny</code> are the numbers of pixels in each of these directions. <code>get_value()</code> returns the value of the image at a given location, interpolated from the adjacent pixel values.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BitmapFile</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BitmapFile(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  std::vector&lt;double&gt; obstacle_data;</div><div class="line">  <span class="keywordtype">double</span>              hx, hy;</div><div class="line">  <span class="keywordtype">int</span>                 nx, ny;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of this class reads in the data that describes the obstacle from the given file name.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BitmapFile&lt;dim&gt;::BitmapFile(<span class="keyword">const</span> std::string &amp;name)</div><div class="line">  : obstacle_data(0)</div><div class="line">  , hx(0)</div><div class="line">  , hy(0)</div><div class="line">  , nx(0)</div><div class="line">  , ny(0)</div><div class="line">{</div><div class="line">  std::ifstream f(name);</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(f,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Can&#39;t read from file &lt;&quot;</span>) + name +</div><div class="line">                         <span class="stringliteral">&quot;&gt;!&quot;</span>));</div><div class="line"></div><div class="line">  std::string temp;</div><div class="line">  f &gt;&gt; temp &gt;&gt; nx &gt;&gt; ny;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(nx &gt; 0 &amp;&amp; ny &gt; 0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid file format.&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nx * ny; ++k)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> val;</div><div class="line">      f &gt;&gt; val;</div><div class="line">      obstacle_data.push_back(val);</div><div class="line">    }</div><div class="line"></div><div class="line">  hx = 1.0 / (nx - 1);</div><div class="line">  hy = 1.0 / (ny - 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Read obstacle from file &lt;&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Resolution of the scanned obstacle picture: &quot;</span> &lt;&lt; nx</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; ny &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The following two functions return the value of a given pixel with coordinates \(i,j\), which we identify with the values of a function defined at positions <code>i*hx, j*hy</code>, and at arbitrary coordinates \(x,y\) where we do a bilinear interpolation between point values returned by the first of the two functions. In the second function, for each \(x,y\), we first compute the (integer) location of the nearest pixel coordinate to the bottom left of \(x,y\), and then compute the coordinates \(\xi,\eta\) within this pixel. We truncate both kinds of variables from both below and above to avoid problems when evaluating the function outside of its defined range as may happen due to roundoff errors.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  assert(i &gt;= 0 &amp;&amp; i &lt; nx);</div><div class="line">  assert(j &gt;= 0 &amp;&amp; j &lt; ny);</div><div class="line">  <span class="keywordflow">return</span> obstacle_data[nx * (ny - 1 - j) + i];</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> ix = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(x / hx), 0), nx - 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> iy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(y / hy), 0), ny - 2);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> xi  = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((x - ix * hx) / hx, 1.), 0.);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> eta = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((y - iy * hy) / hy, 1.), 0.);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +</div><div class="line">          xi * (1 - eta) * get_pixel_value(ix + 1, iy) +</div><div class="line">          (1 - xi) * eta * get_pixel_value(ix, iy + 1) +</div><div class="line">          xi * eta * get_pixel_value(ix + 1, iy + 1));</div><div class="line">}</div></div><!-- fragment --><p>Finally, this is the class that actually uses the class above. It has a BitmapFile object as a member that describes the height of the obstacle. As mentioned above, the BitmapFile class will provide us with a mask, i.e., values that are either zero or one (and, if you ask for locations between pixels, values that are interpolated between zero and one). This class translates this to heights that are either 0.001 below the surface of the deformable body (if the BitmapFile class reports a one at this location) or 0.999 above the obstacle (if the BitmapFile class reports a zero). The following function should then be self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ChineseObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename, <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">vector_value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> BitmapFile&lt;dim&gt; input_obstacle;</div><div class="line">  <span class="keywordtype">double</span>                z_surface;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">ChineseObstacle&lt;dim&gt;::ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">double</span>       z_surface)</div><div class="line">  : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">  , input_obstacle(filename)</div><div class="line">  , z_surface(z_surface)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ChineseObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (component == 0)</div><div class="line">    <span class="keywordflow">return</span> p(0);</div><div class="line">  <span class="keywordflow">if</span> (component == 1)</div><div class="line">    <span class="keywordflow">return</span> p(1);</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt;= 1.0 &amp;&amp; p(1) &gt;= 0.0 &amp;&amp; p(1) &lt;= 1.0)</div><div class="line">        <span class="keywordflow">return</span> z_surface + 0.999 - input_obstacle.get_value(p(0), p(1));</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div></div><!-- fragment --><p>preceding Assert</p>
<div class="fragment"><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ChineseObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                          <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = ChineseObstacle&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --><p><a class="anchor" id="ThecodePlasticityContactProblemcodeclasstemplate"></a> </p><h3>The <code>PlasticityContactProblem</code> class template</h3>
<p>This is the main class of this program and supplies all functions and variables needed to describe the nonlinear contact problem. It is close to <a class="el" href="step_41.html">step-41</a> but with some additional features like handling hanging nodes, a Newton method, using Trilinos and p4est for parallel distributed computing. To deal with hanging nodes makes life a bit more complicated since we need another <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object now. We create a Newton method for the active set method for the contact situation and to handle the nonlinear operator for the constitutive law.</p>
<p>The general layout of this class is very much like for most other tutorial programs. To make our life a bit easier, this class reads a set of input parameters from an input file. These parameters, using the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class, are declared in the <code>declare_parameters</code> function (which is static so that it can be called before we even create an object of the current type), and a <a class="el" href="classParameterHandler.html">ParameterHandler</a> object that has been used to read an input file will then be passed to the constructor of this class.</p>
<p>The remaining member functions are by and large as we have seen in several of the other tutorial programs, though with additions for the current nonlinear system. We will comment on their purpose as we get to them further below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PlasticityContactProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PlasticityContactProblem(<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> compute_dirichlet_constraints();</div><div class="line">  <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">       assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">  <span class="keywordtype">void</span> assemble_newton_system(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">  <span class="keywordtype">void</span> compute_nonlinear_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">  <span class="keywordtype">void</span> solve_newton_system();</div><div class="line">  <span class="keywordtype">void</span> solve_newton();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> move_mesh(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement) <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_contact_force() <span class="keyword">const</span>;</div></div><!-- fragment --><p>As far as member variables are concerned, we start with ones that we use to indicate the MPI universe this program runs on, a stream we use to let exactly one processor produce output to the console (see <a class="el" href="step_17.html">step-17</a>) and a variable that is used to time the various sections of the program:</p>
<div class="fragment"><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a>           mpi_communicator;</div><div class="line"><a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer;</div></div><!-- fragment --><p>The next group describes the mesh and the finite element space. In particular, for this parallel program, the finite element space has associated with it variables that indicate which degrees of freedom live on the current processor (the index sets, see also <a class="el" href="step_40.html">step-40</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> documentation module) as well as a variety of constraints: those imposed by hanging nodes, by Dirichlet boundary conditions, and by the active set of contact nodes. Of the three <a class="el" href="classAffineConstraints.html">AffineConstraints</a> variables defined here, the first only contains hanging node constraints, the second also those associated with Dirichlet boundary conditions, and the third these plus the contact constraints.</p>
<p>The variable <code>active_set</code> consists of those degrees of freedom constrained by the contact, and we use <code>fraction_of_plastic_q_points_per_cell</code> to keep track of the fraction of quadrature points on each cell where the stress equals the yield stress. The latter is only used to create graphical output showing the plastic zone, but not for any further computation; the variable is a member variable of this class since the information is computed as a by-product of computing the residual, but is used only much later. (Note that the vector is a vector of length equal to the number of active cells on the <em>local mesh</em>; it is never used to exchange information between processors and can therefore be a regular deal.II vector.)</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                        n_initial_global_refinements;</div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_hanging_nodes;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_dirichlet_and_hanging_nodes;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> all_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a>      active_set;</div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> fraction_of_plastic_q_points_per_cell;</div></div><!-- fragment --><p>The next block of variables corresponds to the solution and the linear systems we need to form. In particular, this includes the Newton matrix and right hand side; the vector that corresponds to the residual (i.e., the Newton right hand side) but from which we have not eliminated the various constraints and that is used to determine which degrees of freedom need to be constrained in the next iteration; and a vector that corresponds to the diagonal of the \(B\) matrix briefly mentioned in the introduction and discussed in the accompanying paper.</p>
<div class="fragment"><div class="line">TrilinosWrappers::SparseMatrix newton_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs_uncondensed;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector;</div></div><!-- fragment --><p>The next block contains the variables that describe the material response:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>         e_modulus, nu, <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>, sigma_0;</div><div class="line">ConstitutiveLaw&lt;dim&gt; constitutive_law;</div></div><!-- fragment --><p>And then there is an assortment of other variables that are used to identify the mesh we are asked to build as selected by the parameter file, the obstacle that is being pushed into the deformable body, the mesh refinement strategy, whether to transfer the solution from one mesh to the next, and how many mesh refinement cycles to perform. As possible, we mark these kinds of variables as <code>const</code> to help the reader identify which ones may or may not be modified later on (the output directory being an exception &ndash; it is never modified outside the constructor but it is awkward to initialize in the member-initializer-list following the colon in the constructor since there we have only one shot at setting it; the same is true for the mesh refinement criterion):</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string                          base_mesh;</div><div class="line">  <span class="keyword">const</span> std::shared_ptr&lt;const Function&lt;dim&gt;&gt; obstacle;</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>RefinementStrategy</div><div class="line">  {</div><div class="line">    <span class="keyword">enum</span> value</div><div class="line">    {</div><div class="line">      refine_global,</div><div class="line">      refine_percentage,</div><div class="line">      refine_fix_dofs</div><div class="line">    };</div><div class="line">  };</div><div class="line">  <span class="keyword">typename</span> RefinementStrategy::value refinement_strategy;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span>         transfer_solution;</div><div class="line">  std::string        output_dir;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_cycles;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       current_refinement_cycle;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodePlasticityContactProblemcodeclass"></a> </p><h3>Implementation of the <code>PlasticityContactProblem</code> class</h3>
<p><a class="anchor" id="PlasticityContactProblemdeclare_parameters"></a> </p><h4>PlasticityContactProblem::declare_parameters</h4>
<p>Let us start with the declaration of run-time parameters that can be selected in the input file. These values will be read back in the constructor of this class to initialize the member variables of this class:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">{</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;polynomial degree&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">    <span class="stringliteral">&quot;Polynomial degree of the FE_Q finite element space, typically 1 or 2.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of initial refinements&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Number of initial global mesh refinement steps before &quot;</span></div><div class="line">                    <span class="stringliteral">&quot;the first computation.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;refinement strategy&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;percentage&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;global|percentage&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;Mesh refinement strategy:\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot; global: one global refinement\n&quot;</span></div><div class="line">    <span class="stringliteral">&quot; percentage: a fixed percentage of cells gets refined using the Kelly estimator.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of cycles&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                    <span class="stringliteral">&quot;Number of adaptive mesh refinement cycles to run.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;obstacle&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;sphere&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;sphere|read from file&quot;</span>),</div><div class="line">    <span class="stringliteral">&quot;The name of the obstacle to use. This may either be &#39;sphere&#39; if we should &quot;</span></div><div class="line">    <span class="stringliteral">&quot;use a spherical obstacle, or &#39;read from file&#39; in which case the obstacle &quot;</span></div><div class="line">    <span class="stringliteral">&quot;will be read from a file named &#39;obstacle.pbm&#39; that is supposed to be in &quot;</span></div><div class="line">    <span class="stringliteral">&quot;ASCII PBM format.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;output directory&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">    <span class="stringliteral">&quot;Directory for output files (graphical output and benchmark &quot;</span></div><div class="line">    <span class="stringliteral">&quot;statistics). If empty, use the current directory.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">    <span class="stringliteral">&quot;transfer solution&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">    <span class="stringliteral">&quot;Whether the solution should be used as a starting guess &quot;</span></div><div class="line">    <span class="stringliteral">&quot;for the next finer mesh. If false, then the iteration starts at &quot;</span></div><div class="line">    <span class="stringliteral">&quot;zero on every mesh.&quot;</span>);</div><div class="line">  prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;base mesh&quot;</span>,</div><div class="line">                    <span class="stringliteral">&quot;box&quot;</span>,</div><div class="line">                    <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;box|half sphere&quot;</span>),</div><div class="line">                    <span class="stringliteral">&quot;Select the shape of the domain: &#39;box&#39; or &#39;half sphere&#39;&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodePlasticityContactProblemcodeconstructor"></a> </p><h4>The <code>PlasticityContactProblem</code> constructor</h4>
<p>Given the declarations of member variables as well as the declarations of run-time parameters that are read from the input file, there is nothing surprising in this constructor. In the body we initialize the mesh refinement strategy and the output directory, creating such a directory if necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PlasticityContactProblem&lt;dim&gt;::PlasticityContactProblem(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">          (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">  , computing_timer(MPI_COMM_WORLD,</div><div class="line">                    pcout,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                    <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line"></div><div class="line">  , n_initial_global_refinements(</div><div class="line">      prm.get_integer(<span class="stringliteral">&quot;number of initial refinements&quot;</span>))</div><div class="line">  , triangulation(mpi_communicator)</div><div class="line">  , fe_degree(prm.get_integer(<span class="stringliteral">&quot;polynomial degree&quot;</span>))</div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree + 1)), dim)</div><div class="line">  , dof_handler(triangulation)</div><div class="line"></div><div class="line">  , e_modulus(200000)</div><div class="line">  , nu(0.3)</div><div class="line">  , gamma(0.01)</div><div class="line">  , sigma_0(400.0)</div><div class="line">  , constitutive_law(e_modulus, nu, sigma_0, gamma)</div><div class="line"></div><div class="line">  , base_mesh(prm.get(<span class="stringliteral">&quot;base mesh&quot;</span>))</div><div class="line">  , obstacle(prm.get(<span class="stringliteral">&quot;obstacle&quot;</span>) == <span class="stringliteral">&quot;read from file&quot;</span> ?</div><div class="line">               static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                 new EquationData::ChineseObstacle&lt;dim&gt;(</div><div class="line">                   <span class="stringliteral">&quot;obstacle.pbm&quot;</span>,</div><div class="line">                   (base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5))) :</div><div class="line">               static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                 new EquationData::SphereObstacle&lt;dim&gt;(</div><div class="line">                   base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5)))</div><div class="line"></div><div class="line">  , transfer_solution(prm.get_bool(<span class="stringliteral">&quot;transfer solution&quot;</span>))</div><div class="line">  , n_refinement_cycles(prm.get_integer(<span class="stringliteral">&quot;number of cycles&quot;</span>))</div><div class="line">  , current_refinement_cycle(0)</div><div class="line"></div><div class="line">{</div><div class="line">  std::string strat = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;refinement strategy&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">    refinement_strategy = RefinementStrategy::refine_global;</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;percentage&quot;</span>)</div><div class="line">    refinement_strategy = RefinementStrategy::refine_percentage;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  output_dir = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;output directory&quot;</span>);</div><div class="line">  <span class="keywordflow">if</span> (output_dir != <span class="stringliteral">&quot;&quot;</span> &amp;&amp; *(output_dir.rbegin()) != <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">    output_dir += <span class="stringliteral">&quot;/&quot;</span>;</div></div><!-- fragment --><p>If necessary, create a new directory for the output.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> ierr = mkdir(output_dir.c_str(), 0777);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(ierr == 0 || errno == EEXIST, <a class="code" href="group__Exceptions.html#gac29b5f3efd2b164642b8e0c49ad3ad27">ExcIO</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    Using output directory &#39;&quot;</span> &lt;&lt; output_dir &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    FE degree &quot;</span> &lt;&lt; fe_degree &lt;&lt; std::endl;</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;    transfer solution &quot;</span> &lt;&lt; (transfer_solution ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>)</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemmake_grid"></a> </p><h4>PlasticityContactProblem::make_grid</h4>
<p>The next block deals with constructing the starting mesh. We will use the following helper function and the first block of the <code>make_grid()</code> to construct a mesh that corresponds to a half sphere. deal.II has a function that creates such a mesh, but it is in the wrong location and facing the wrong direction, so we need to shift and rotate it a bit before using it.</p>
<p>For later reference, as described in the documentation of <a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball()</a>, the flat surface of the halfsphere has boundary indicator zero, while the remainder has boundary indicator one.</p>
<div class="fragment"><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> rotate_half_sphere(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;in)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> {in(2), in(1), -in(0)};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;half sphere&quot;</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0, 0, 0);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>     radius = 0.8;</div><div class="line">      <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(triangulation, center, radius);</div></div><!-- fragment --><p>Since we will attach a different manifold below, we immediately clear the default manifold description:</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;rotate_half_sphere, triangulation);</div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5), triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5));</div><div class="line">  <a class="code" href="namespaceGridTools.html#aa92034313ef924778e01beb3e24002dd">GridTools::copy_boundary_to_manifold_id</a>(triangulation);</div><div class="line">  triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, manifold_description);</div><div class="line">}</div></div><!-- fragment --><p>Alternatively, create a hypercube mesh. After creating it, assign boundary indicators as follows: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line">&gt;     _______</div><div class="line">&gt;    /  1    /|</div><div class="line">&gt;   /______ / |</div><div class="line">&gt;  |       | 8|</div><div class="line">&gt;  |   8   | /</div><div class="line">&gt;  |_______|/</div><div class="line">&gt;      6</div></div><!-- fragment --> </div><p> In other words, the boundary indicators of the sides of the cube are 8. The boundary indicator of the bottom is 6 and the top has indicator 1. We set these by looping over all cells of all faces and looking at coordinate values of the cell center, and will make use of these indicators later when evaluating which boundary will carry Dirichlet boundary conditions or will be subject to potential contact. (In the current case, the mesh contains only a single cell, and all of its faces are on the boundary, so both the loop over all cells and the query whether a face is on the boundary are, strictly speaking, unnecessary; we retain them simply out of habit: this kind of code can be found in many programs in essentially this form.)</p>
<div class="fragment"><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1(0, 0, 0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p2(1.0, 1.0, 1.0);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation, p1, p2);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p2[2]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(1);</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p1[0]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p2[0]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p1[1]) &lt; 1e-12 ||</div><div class="line">                  <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p2[1]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(8);</div><div class="line">              <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p1[2]) &lt; 1e-12)</div><div class="line">                face-&gt;set_boundary_id(6);</div><div class="line">            }</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsetup_system"></a> </p><h4>PlasticityContactProblem::setup_system</h4>
<p>The next piece in the puzzle is to set up the <a class="el" href="classDoFHandler.html">DoFHandler</a>, resize vectors and take care of various other status variables such as index sets and constraint matrices.</p>
<p>In the following, each group of operations is put into a brace-enclosed block that is being timed by the variable declared at the top of the block (the constructor of the <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable starts the timed section, the destructor that is called at the end of the block stops it again).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  <span class="comment">/* setup dofs and get index sets for locally owned and relevant dofs */</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: distribute DoFs&quot;</span>);</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">    locally_relevant_dofs.<a class="code" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a>();</div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler,</div><div class="line">                                            locally_relevant_dofs);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">/* setup hanging nodes and Dirichlet constraints */</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: constraints&quot;</span>);</div><div class="line">    constraints_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            constraints_hanging_nodes);</div><div class="line">    constraints_hanging_nodes.close();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">          &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    compute_dirichlet_constraints();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">/* initialization of vectors and the active set */</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: vectors&quot;</span>);</div><div class="line">    solution.reinit(locally_relevant_dofs, mpi_communicator);</div><div class="line">    newton_rhs.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">    fraction_of_plastic_q_points_per_cell.reinit(</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    active_set.clear();</div><div class="line">    active_set.set_size(dof_handler.n_dofs());</div><div class="line">  }</div></div><!-- fragment --><p>Finally, we set up sparsity patterns and matrices. We temporarily (ab)use the system matrix to also build the (diagonal) matrix that we use in eliminating degrees of freedom that are in contact with the obstacle, but we then immediately set the Newton matrix back to zero.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>                t(computing_timer, <span class="stringliteral">&quot;Setup: matrix&quot;</span>);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(locally_owned_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                    sp,</div><div class="line">                                    constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                    <span class="keyword">false</span>,</div><div class="line">                                    <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                      mpi_communicator));</div><div class="line">    sp.compress();</div><div class="line">    newton_matrix.reinit(sp);</div><div class="line"></div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix = newton_matrix;</div><div class="line"></div><div class="line">    assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start = (newton_rhs.local_range().first),</div><div class="line">                       end   = (newton_rhs.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = start; j &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++j)</div><div class="line">      diag_mass_matrix_vector(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">    diag_mass_matrix_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    mass_matrix = 0;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_dirichlet_constraints"></a> </p><h4>PlasticityContactProblem::compute_dirichlet_constraints</h4>
<p>This function, broken out of the preceding one, computes the constraints associated with Dirichlet-type boundary conditions and puts them into the <code>constraints_dirichlet_and_hanging_nodes</code> variable by merging with the constraints that come from hanging nodes.</p>
<p>As laid out in the introduction, we need to distinguish between two cases:</p><ul>
<li>If the domain is a box, we set the displacement to zero at the bottom, and allow vertical movement in z-direction along the sides. As shown in the <code>make_grid()</code> function, the former corresponds to boundary indicator 6, the latter to 8.</li>
<li>If the domain is a half sphere, then we impose zero displacement along the curved part of the boundary, associated with boundary indicator zero.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_dirichlet_constraints()</div><div class="line">{</div><div class="line">  constraints_dirichlet_and_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">  constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">    {</div></div><!-- fragment --><p>interpolate all components of the solution</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">  dof_handler,</div><div class="line">  6,</div><div class="line">  EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">  constraints_dirichlet_and_hanging_nodes,</div><div class="line">  <a class="code" href="classComponentMask.html">ComponentMask</a>());</div></div><!-- fragment --><p>interpolate x- and y-components of the solution (this is a bit mask, so apply operator| )</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        8,</div><div class="line">        EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">        constraints_dirichlet_and_hanging_nodes,</div><div class="line">        (fe.component_mask(x_displacement) |</div><div class="line">         fe.component_mask(y_displacement)));</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">      dof_handler,</div><div class="line">      0,</div><div class="line">      EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">      constraints_dirichlet_and_hanging_nodes,</div><div class="line">      <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">  constraints_dirichlet_and_hanging_nodes.close();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemassemble_mass_matrix_diagonal"></a> </p><h4>PlasticityContactProblem::assemble_mass_matrix_diagonal</h4>
<p>The next helper function computes the (diagonal) mass matrix that is used to determine the active set of the active set method we use in the contact algorithm. This matrix is of mass matrix type, but unlike the standard mass matrix, we can make it diagonal (even in the case of higher order elements) by using a quadrature formula that has its quadrature points at exactly the same locations as the interpolation points for the finite element are located. We achieve this by using a <a class="el" href="classQGaussLobatto.html">QGaussLobatto</a> quadrature formula here, along with initializing the finite element with a set of interpolation points derived from the same quadrature formula. The remainder of the function is relatively straightforward: we put the resulting matrix into the given argument; because we know the matrix is diagonal, it is sufficient to have a loop over only \(i\) and not over \(j\). Strictly speaking, we could even avoid multiplying the shape function's values at quadrature point <code>q_point</code> by itself because we know the shape value to be a vector with exactly one one which when dotted with itself yields one. Since this function is not time critical we add this term for clarity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">  TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">{</div><div class="line">  <a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">          {</div><div class="line">            fe_values_face.reinit(cell, face);</div><div class="line">            cell_matrix = 0;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                 ++q_point)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">                  (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                   fe_values_face[displacement].value(i, q_point) *</div><div class="line">                   fe_values_face.JxW(q_point));</div><div class="line"></div><div class="line">            cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a>(local_dof_indices[i],</div><div class="line">                              local_dof_indices[i],</div><div class="line">                              cell_matrix(i, i));</div><div class="line">          }</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemupdate_solution_and_constraints"></a> </p><h4>PlasticityContactProblem::update_solution_and_constraints</h4>
<p>The following function is the first function we call in each Newton iteration in the <code>solve_newton()</code> function. What it does is to project the solution onto the feasible set and update the active set for the degrees of freedom that touch or penetrate the obstacle.</p>
<p>In order to function, we first need to do some bookkeeping: We need to write into the solution vector (which we can only do with fully distributed vectors without ghost elements) and we need to read the Lagrange multiplier and the elements of the diagonal mass matrix from their respective vectors (which we can only do with vectors that do have ghost elements), so we create the respective vectors. We then also initialize the constraints object that will contain constraints from contact and all other sources, as well as an object that contains an index set of all locally owned degrees of freedom that are part of the contact:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">{</div><div class="line">  std::vector&lt;bool&gt; dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">  distributed_solution = solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                       mpi_communicator);</div><div class="line">  lambda = newton_rhs_uncondensed;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector_relevant(</div><div class="line">    locally_relevant_dofs, mpi_communicator);</div><div class="line">  diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;</div><div class="line"></div><div class="line"></div><div class="line">  all_constraints.reinit(locally_relevant_dofs);</div><div class="line">  active_set.clear();</div></div><!-- fragment --><p>The second part is a loop over all cells in which we look at each point where a degree of freedom is defined whether the active set condition is true and we need to add this degree of freedom to the active set of contact nodes. As we always do, if we want to evaluate functions at individual points, we do this with an <a class="el" href="classFEValues.html">FEValues</a> object (or, here, an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object since we need to check contact at the surface) with an appropriately chosen quadrature object. We create this face quadrature object by choosing the "support points" of the shape functions defined on the faces of cells (for more on support points, see this <a class="el" href="DEALGlossary.html#GlossSupport">glossary entry</a>). As a consequence, we have as many quadrature points as there are shape functions per face and looping over quadrature points is equivalent to looping over shape functions defined on a face. With this, the code looks as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim - 1&gt; face_quadrature(fe.get_unit_face_support_points());</div><div class="line"><a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>   fe_values_face(fe,</div><div class="line">                                 face_quadrature,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_face   = fe.n_dofs_per_face();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature.size();</div><div class="line"></div><div class="line">std::vector&lt;types::global_dof_index&gt; dof_indices(dofs_per_face);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (!cell-&gt;is_artificial())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">        {</div><div class="line">          fe_values_face.reinit(cell, face);</div><div class="line">          face-&gt;get_dof_indices(dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">               ++q_point)</div><div class="line">            {</div></div><!-- fragment --><p>At each quadrature point (i.e., at each support point of a degree of freedom located on the contact boundary), we then ask whether it is part of the z-displacement degrees of freedom and if we haven't encountered this degree of freedom yet (which can happen for those on the edges between faces), we need to evaluate the gap between the deformed object and the obstacle. If the active set condition is true, then we add a constraint to the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object that the next Newton update needs to satisfy, set the solution vector's corresponding element to the correct value, and add the index to the <a class="el" href="classIndexSet.html">IndexSet</a> object that stores which degree of freedom is part of the contact:</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component =</div><div class="line">        fe.face_system_to_component_index(q_point).first;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_z = dof_indices[q_point];</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((component == 2) &amp;&amp; (dof_touched[index_z] == <span class="keyword">false</span>))</div><div class="line">        {</div><div class="line">          dof_touched[index_z] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> this_support_point =</div><div class="line">            fe_values_face.quadrature_point(q_point);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value =</div><div class="line">            obstacle-&gt;value(this_support_point, 2);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> solution_here = solution(index_z);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> undeformed_gap =</div><div class="line">            obstacle_value - this_support_point(2);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> c = 100.0 * e_modulus;</div><div class="line">          <span class="keywordflow">if</span> ((lambda(index_z) /</div><div class="line">                   diag_mass_matrix_vector_relevant(index_z) +</div><div class="line">                 c * (solution_here - undeformed_gap) &gt;</div><div class="line">               0) &amp;&amp;</div><div class="line">              !constraints_hanging_nodes.is_constrained(index_z))</div><div class="line">            {</div><div class="line">              all_constraints.add_line(index_z);</div><div class="line">              all_constraints.set_inhomogeneity(index_z,</div><div class="line">                                                undeformed_gap);</div><div class="line">              distributed_solution(index_z) = undeformed_gap;</div><div class="line"></div><div class="line">              active_set.add_index(index_z);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>At the end of this function, we exchange data between processors updating those ghost elements in the <code>solution</code> variable that have been written by other processors. We then merge the Dirichlet constraints and those from hanging nodes into the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object that already contains the active set. We finish the function by outputting the total number of actively constrained degrees of freedom for which we sum over the number of actively constrained degrees of freedom owned by each of the processors. This number of locally owned constrained degrees of freedom is of course the number of elements of the intersection of the active set and the set of locally owned degrees of freedom, which we can get by using <code>operator&amp;</code> on two IndexSets:</p>
<div class="fragment"><div class="line">  distributed_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  solution = distributed_solution;</div><div class="line"></div><div class="line">  all_constraints.close();</div><div class="line">  all_constraints.merge(constraints_dirichlet_and_hanging_nodes);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;         Size of active set: &quot;</span></div><div class="line">        &lt;&lt; <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set &amp; locally_owned_dofs).n_elements(),</div><div class="line">                               mpi_communicator)</div><div class="line">        &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemassemble_newton_system"></a> </p><h4>PlasticityContactProblem::assemble_newton_system</h4>
<p>Given the complexity of the problem, it may come as a bit of a surprise that assembling the linear system we have to solve in each Newton iteration is actually fairly straightforward. The following function builds the Newton right hand side and Newton matrix. It looks fairly innocent because the heavy lifting happens in the call to <code>ConstitutiveLaw::get_linearized_stress_strain_tensors()</code> and in particular in <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, using the constraints we have previously computed.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_newton_system(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assembling&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_matrix = 0;</div><div class="line">        cell_rhs    = 0;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensor(n_q_points);</div><div class="line">        fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">          linearization_point, strain_tensor);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">            constitutive_law.get_linearized_stress_strain_tensors(</div><div class="line">              strain_tensor[q_point],</div><div class="line">              stress_strain_tensor_linearized,</div><div class="line">              stress_strain_tensor);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div></div><!-- fragment --><p>Having computed the stress-strain tensor and its linearization, we can now put together the parts of the matrix and right hand side. In both, we need the linearized stress-strain tensor times the symmetric gradient of \(\varphi_i\), i.e. the term \(I_\Pi\varepsilon(\varphi_i)\), so we introduce an abbreviation of this term. Recall that the matrix corresponds to the bilinear form \(A_{ij}=(I_\Pi\varepsilon(\varphi_i),\varepsilon(\varphi_j))\) in the notation of the accompanying publication, whereas the right hand side is \(F_i=([I_\Pi-P_\Pi C]\varepsilon(\varphi_i),\varepsilon(\mathbf u))\) where \(u\) is the current linearization points (typically the last solution). This might suggest that the right hand side will be zero if the material is completely elastic (where \(I_\Pi=P_\Pi\)) but this ignores the fact that the right hand side will also contain contributions from non-homogeneous constraints due to the contact.</p>
<p>The code block that follows this adds contributions that are due to boundary forces, should there be any.</p>
<div class="fragment"><div class="line">                <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_phi_i =</div><div class="line">                  stress_strain_tensor_linearized *</div><div class="line">                  fe_values[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (stress_phi_i *</div><div class="line">                     fe_values[displacement].symmetric_gradient(j, q_point) *</div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                cell_rhs(i) +=</div><div class="line">                  ((stress_phi_i -</div><div class="line">                    stress_strain_tensor *</div><div class="line">                      fe_values[displacement].symmetric_gradient(i,</div><div class="line">                                                                 q_point)) *</div><div class="line">                   strain_tensor[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              boundary_force.vector_value_list(</div><div class="line">                fe_values_face.get_quadrature_points(),</div><div class="line">                boundary_force_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) +=</div><div class="line">                      (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                       rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        all_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                   cell_rhs,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   newton_matrix,</div><div class="line">                                                   newton_rhs,</div><div class="line">                                                   <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line"></div><div class="line">  newton_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemcompute_nonlinear_residual"></a> </p><h4>PlasticityContactProblem::compute_nonlinear_residual</h4>
<p>The following function computes the nonlinear residual of the equation given the current solution (or any other linearization point). This is needed in the linear search algorithm where we need to try various linear combinations of previous and current (trial) solution to compute the (real, globalized) solution of the current Newton step.</p>
<p>That said, in a slight abuse of the name of the function, it actually does significantly more. For example, it also computes the vector that corresponds to the Newton residual but without eliminating constrained degrees of freedom. We need this vector to compute contact forces and, ultimately, to compute the next active set. Likewise, by keeping track of how many quadrature points we encounter on each cell that show plastic yielding, we also compute the <code>fraction_of_plastic_q_points_per_cell</code> vector that we can later output to visualize the plastic zone. In both of these cases, the results are not necessary as part of the line search, and so we may be wasting a small amount of time computing them. At the same time, this information appears as a natural by-product of what we need to do here anyway, and we want to collect it once at the end of each Newton step, so we may as well do it here.</p>
<p>The actual implementation of this function should be rather obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_nonlinear_residual(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim));</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  newton_rhs             = 0;</div><div class="line">  newton_rhs_uncondensed = 0;</div><div class="line"></div><div class="line">  fraction_of_plastic_q_points_per_cell = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensors(n_q_points);</div><div class="line">        fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">          linearization_point, strain_tensors);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span>              q_point_is_plastic =</div><div class="line">              constitutive_law.get_stress_strain_tensor(</div><div class="line">                strain_tensors[q_point], stress_strain_tensor);</div><div class="line">            <span class="keywordflow">if</span> (q_point_is_plastic)</div><div class="line">              ++fraction_of_plastic_q_points_per_cell(</div><div class="line">                cell-&gt;active_cell_index());</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                cell_rhs(i) -=</div><div class="line">                  (strain_tensors[q_point] * stress_strain_tensor *</div><div class="line">                   fe_values[displacement].symmetric_gradient(i, q_point) *</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                rhs_values = 0;</div><div class="line">                cell_rhs(i) += (fe_values[displacement].value(i, q_point) *</div><div class="line">                                rhs_values * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              boundary_force.vector_value_list(</div><div class="line">                fe_values_face.get_quadrature_points(),</div><div class="line">                boundary_force_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                    cell_rhs(i) +=</div><div class="line">                      (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                       rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(</div><div class="line">          cell_rhs, local_dof_indices, newton_rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">      }</div><div class="line"></div><div class="line">  fraction_of_plastic_q_points_per_cell /= quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  newton_rhs_uncondensed.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsolve_newton_system"></a> </p><h4>PlasticityContactProblem::solve_newton_system</h4>
<p>The last piece before we can discuss the actual Newton iteration on a single mesh is the solver for the linear systems. There are a couple of complications that slightly obscure the code, but mostly it is just setup then solve. Among the complications are:</p>
<ul>
<li>For the hanging nodes we have to apply the <a class="el" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">AffineConstraints::set_zero</a> function to newton_rhs. This is necessary if a hanging node with solution value \(x_0\) has one neighbor with value \(x_1\) which is in contact with the obstacle and one neighbor \(x_2\) which is not in contact. Because the update for the former will be prescribed, the hanging node constraint will have an inhomogeneity and will look like \(x_0 = x_1/2 + \text{gap}/2\). So the corresponding entries in the right-hand-side are non-zero with a meaningless value. These values we have to set to zero.</li>
<li>Like in <a class="el" href="step_40.html">step-40</a>, we need to shuffle between vectors that do and do not have ghost elements when solving or using the solution.</li>
</ul>
<p>The rest of the function is similar to <a class="el" href="step_40.html">step-40</a> and <a class="el" href="step_41.html">step-41</a> except that we use a BiCGStab solver instead of CG. This is due to the fact that for very small hardening parameters \(\gamma\), the linear system becomes almost semidefinite though still symmetric. BiCGStab appears to have an easier time with such linear systems.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">  distributed_solution = solution;</div><div class="line"></div><div class="line">  constraints_hanging_nodes.set_zero(distributed_solution);</div><div class="line">  constraints_hanging_nodes.set_zero(newton_rhs);</div><div class="line"></div><div class="line">  TrilinosWrappers::PreconditionAMG preconditioner;</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: setup preconditioner&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">    <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(dof_handler,</div><div class="line">                                     <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                     constant_modes);</div><div class="line"></div><div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> additional_data;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a>              = <span class="keyword">true</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a4a403dc7faf67ee0fcb6436d7b741687">n_cycles</a>              = 1;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a56500e96ab5ae9b84dd874b38283453b">w_cycle</a>               = <span class="keyword">false</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#ab9fc3e207a7c534094d514685e645c92">output_details</a>        = <span class="keyword">false</span>;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a>       = 2;</div><div class="line">    additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 1e-2;</div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(newton_matrix, additional_data);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: iterate&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> relative_accuracy = 1e-8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance =</div><div class="line">      relative_accuracy *</div><div class="line">      newton_matrix.residual(tmp, distributed_solution, newton_rhs);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(newton_matrix.m(), solver_tolerance);</div><div class="line">    <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line">    solver.solve(newton_matrix,</div><div class="line">                 distributed_solution,</div><div class="line">                 newton_rhs,</div><div class="line">                 preconditioner);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;         Error: &quot;</span> &lt;&lt; solver_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">          &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; Bicgstab iterations.&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  all_constraints.distribute(distributed_solution);</div><div class="line"></div><div class="line">  solution = distributed_solution;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemsolve_newton"></a> </p><h4>PlasticityContactProblem::solve_newton</h4>
<p>This is, finally, the function that implements the damped Newton method on the current mesh. There are two nested loops: the outer loop for the Newton iteration and the inner loop for the line search which will be used only if necessary. To obtain a good and reasonable starting value we solve an elastic problem in the very first Newton step on each mesh (or only on the first mesh if we transfer solutions between meshes). We do so by setting the yield stress to an unreasonably large value in these iterations and then setting it back to the correct value in subsequent iterations.</p>
<p>Other than this, the top part of this function should be reasonably obvious. We initialize the variable <code>previous_residual_norm</code> to the most negative value representable with double precision numbers so that the comparison whether the current residual is less than that of the previous step will always fail in the first step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton()</div><div class="line">{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_solution(locally_owned_dofs,</div><div class="line">                                             mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> residual(locally_owned_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp_vector(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_tmp_vector(</div><div class="line">    locally_relevant_dofs, mpi_communicator);</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> residual_norm;</div><div class="line">  <span class="keywordtype">double</span> previous_residual_norm = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> correct_sigma = sigma_0;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> old_active_set(active_set);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= 100; ++newton_step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (newton_step == 1 &amp;&amp;</div><div class="line">          ((transfer_solution &amp;&amp; current_refinement_cycle == 0) ||</div><div class="line">           !transfer_solution))</div><div class="line">        constitutive_law.set_sigma_0(1e+10);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == 2 || current_refinement_cycle &gt; 0 ||</div><div class="line">               !transfer_solution)</div><div class="line">        constitutive_law.set_sigma_0(correct_sigma);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Newton iteration &quot;</span> &lt;&lt; newton_step &lt;&lt; std::endl;</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      {</div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;update active set&quot;</span>);</div><div class="line">        update_solution_and_constraints();</div><div class="line">      }</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Assembling system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">      newton_matrix = 0;</div><div class="line">      newton_rhs    = 0;</div><div class="line">      assemble_newton_system(solution);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;      Solving system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">      solve_newton_system();</div></div><!-- fragment --><p>It gets a bit more hairy after we have computed the trial solution \(\tilde{\mathbf u}\) of the current Newton step. We handle a highly nonlinear problem so we have to damp Newton's method using a line search. To understand how we do this, recall that in our formulation, we compute a trial solution in each Newton step and not the update between old and new solution. Since the solution set is a convex set, we will use a line search that tries linear combinations of the previous and the trial solution to guarantee that the damped solution is in our solution set again. At most we apply 5 damping steps.</p>
<p>There are exceptions to when we use a line search. First, if this is the first Newton step on any mesh, then we don't have any point to compare the residual to, so we always accept a full step. Likewise, if this is the second Newton step on the first mesh (or the second on any mesh if we don't transfer solutions from mesh to mesh), then we have computed the first of these steps using just an elastic model (see how we set the yield stress sigma to an unreasonably large value above). In this case, the first Newton solution was a purely elastic one, the second one a plastic one, and any linear combination would not necessarily be expected to lie in the feasible set &ndash; so we just accept the solution we just got.</p>
<p>In either of these two cases, we bypass the line search and just update residual and other vectors as necessary.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ((newton_step == 1) ||</div><div class="line">    (transfer_solution &amp;&amp; newton_step == 2 &amp;&amp;</div><div class="line">     current_refinement_cycle == 0) ||</div><div class="line">    (!transfer_solution &amp;&amp; newton_step == 2))</div><div class="line">  {</div><div class="line">    compute_nonlinear_residual(solution);</div><div class="line">    old_solution = solution;</div><div class="line"></div><div class="line">    residual                     = newton_rhs;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                       end_res   = (residual.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">      <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">        residual(n) = 0;</div><div class="line"></div><div class="line">    residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;      Accepting Newton solution with residual: &quot;</span></div><div class="line">          &lt;&lt; residual_norm &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)</div><div class="line">      {</div><div class="line">        distributed_solution = solution;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.5, static_cast&lt;double&gt;(i));</div><div class="line">        tmp_vector         = old_solution;</div><div class="line">        tmp_vector.sadd(1 - alpha, alpha, distributed_solution);</div><div class="line"></div><div class="line">        <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Residual and lambda&quot;</span>);</div><div class="line"></div><div class="line">        locally_relevant_tmp_vector = tmp_vector;</div><div class="line">        compute_nonlinear_residual(locally_relevant_tmp_vector);</div><div class="line">        residual = newton_rhs;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                           end_res   = (residual.local_range().second);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">          <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">            residual(n) = 0;</div><div class="line"></div><div class="line">        residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">        residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">        pcout</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;      Residual of the non-contact part of the system: &quot;</span></div><div class="line">          &lt;&lt; residual_norm &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;         with a damping parameter alpha = &quot;</span> &lt;&lt; alpha</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (residual_norm &lt; previous_residual_norm)</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line"></div><div class="line">    solution     = tmp_vector;</div><div class="line">    old_solution = solution;</div><div class="line">  }</div><div class="line"></div><div class="line">previous_residual_norm = residual_norm;</div></div><!-- fragment --><p>The final step is to check for convergence. If the active set has not changed across all processors and the residual is less than a threshold of \(10^{-10}\), then we terminate the iteration on the current mesh:</p>
<div class="fragment"><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set == old_active_set) ? 0 : 1,</div><div class="line">                              mpi_communicator) == 0)</div><div class="line">        {</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;      Active set did not change!&quot;</span> &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">if</span> (residual_norm &lt; 1e-10)</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">      old_active_set = active_set;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemrefine_grid"></a> </p><h4>PlasticityContactProblem::refine_grid</h4>
<p>If you've made it this far into the deal.II tutorial, the following function refining the mesh should not pose any challenges to you any more. It refines the mesh, either globally or using the Kelly error estimator, and if so asked also transfers the solution from the previous to the next mesh. In the latter case, we also need to compute the active set and other quantities again, for which we need the information computed by <code>compute_nonlinear_residual()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (refinement_strategy == RefinementStrategy::refine_global)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">             triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">           cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">           ++cell)</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 2),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number</a>(</div><div class="line">        triangulation, estimated_error_per_cell, 0.3, 0.03);</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">    solution_transfer(dof_handler);</div><div class="line">  <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  setup_system();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                         mpi_communicator);</div><div class="line">      solution_transfer.interpolate(distributed_solution);</div></div><!-- fragment --><p>enforce constraints to make the interpolated solution conforming on the new mesh:</p>
<div class="fragment"><div class="line">      constraints_hanging_nodes.distribute(distributed_solution);</div><div class="line"></div><div class="line">      solution = distributed_solution;</div><div class="line">      compute_nonlinear_residual(solution);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemmove_mesh"></a> </p><h4>PlasticityContactProblem::move_mesh</h4>
<p>The remaining three functions before we get to <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> have to do with generating output. The following one is an attempt at showing the deformed body in its deformed configuration. To this end, this function takes a displacement vector field and moves every vertex of the (local part) of the mesh by the previously computed displacement. We will call this function with the current displacement field before we generate graphical output, and we will call it again after generating graphical output with the negative displacement field to undo the changes to the mesh so made.</p>
<p>The function itself is pretty straightforward. All we have to do is keep track which vertices we have already touched, as we encounter the same vertices multiple times as we loop over cells.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::move_mesh(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">          {</div><div class="line">            vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">              vertex_displacement[d] =</div><div class="line">                displacement(cell-&gt;vertex_dof_index(v, d));</div><div class="line"></div><div class="line">            cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">          }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemoutput_results"></a> </p><h4>PlasticityContactProblem::output_results</h4>
<p>Next is the function we use to actually generate graphical output. The function is a bit tedious, but not actually particularly complicated. It moves the mesh at the top (and moves it back at the end), then computes the contact forces along the contact surface. We can do so (as shown in the accompanying paper) by taking the untreated residual vector and identifying which degrees of freedom correspond to those with contact by asking whether they have an inhomogeneous constraints associated with them. As always, we need to be mindful that we can only write into completely distributed vectors (i.e., vectors without ghost elements) but that when we want to generate output, we need vectors that do indeed have ghost entries for all locally relevant degrees of freedom.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Graphical output&quot;</span>);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;      Writing graphical output... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  move_mesh(solution);</div></div><!-- fragment --><p>Calculation of the contact forces</p>
<div class="fragment"><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                 mpi_communicator);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                   end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">  <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">    distributed_lambda(n) =</div><div class="line">      newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                     mpi_communicator);</div><div class="line">lambda = distributed_lambda;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_active_set_vector(</div><div class="line">  locally_owned_dofs, mpi_communicator);</div><div class="line">distributed_active_set_vector = 0.;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">  distributed_active_set_vector[index] = 1.;</div><div class="line">distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(locally_relevant_dofs,</div><div class="line">                                                mpi_communicator);</div><div class="line">active_set_vector = distributed_active_set_vector;</div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  data_component_interpretation(</div><div class="line">    dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;displacement&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;contact_force&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector,</div><div class="line">                         std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;active_set&quot;</span>),</div><div class="line">                         <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                         data_component_interpretation);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">  subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fraction_of_plastic_q_points_per_cell,</div><div class="line">                         <span class="stringliteral">&quot;fraction_of_plastic_q_points&quot;</span>);</div><div class="line"></div><div class="line">data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div></div><!-- fragment --><p>In the remainder of the function, we generate one VTU file on every processor, indexed by the subdomain id of this processor. On the first processor, we then also create a <code>.pvtu</code> file that indexes <em>all</em> of the VTU files so that the entire set of output files can be read at once. These <code>.pvtu</code> are used by Paraview to describe an entire parallel computation's output files. We then do the same again for the competitor of Paraview, the VisIt visualization program, by creating a matching <code>.visit</code> file.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string pvtu_filename = data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    output_dir, <span class="stringliteral">&quot;solution&quot;</span>, current_refinement_cycle, mpi_communicator, 2);</div><div class="line">  pcout &lt;&lt; pvtu_filename &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(solution);</div><div class="line">  tmp *= -1;</div><div class="line">  move_mesh(tmp);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemoutput_contact_force"></a> </p><h4>PlasticityContactProblem::output_contact_force</h4>
<p>This last auxiliary function computes the contact force by calculating an integral over the contact pressure in z-direction over the contact area. For this purpose we set the contact pressure lambda to 0 for all inactive dofs (whether a degree of freedom is part of the contact is determined just as we did in the previous function). For all active dofs, lambda contains the quotient of the nonlinear residual (newton_rhs_uncondensed) and corresponding diagonal entry of the mass matrix (diag_mass_matrix_vector). Because it is not unlikely that hanging nodes show up in the contact area it is important to apply constraints_hanging_nodes.distribute to the distributed_lambda vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_contact_force()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                   mpi_communicator);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                     end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">    <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">      distributed_lambda(n) =</div><div class="line">        newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      distributed_lambda(n) = 0;</div><div class="line">  distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                       mpi_communicator);</div><div class="line">  lambda = distributed_lambda;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> contact_force = 0.0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">          {</div><div class="line">            fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">            std::vector&lt;Tensor&lt;1, dim&gt;&gt; lambda_values(n_face_q_points);</div><div class="line">            fe_values_face[displacement].get_function_values(lambda,</div><div class="line">                                                             lambda_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                 ++q_point)</div><div class="line">              contact_force +=</div><div class="line">                lambda_values[q_point][2] * fe_values_face.JxW(q_point);</div><div class="line">          }</div><div class="line">  contact_force = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(contact_force, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;Contact force = &quot;</span> &lt;&lt; contact_force &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="PlasticityContactProblemrun"></a> </p><h4>PlasticityContactProblem::run</h4>
<p>As in all other tutorial programs, the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function contains the overall logic. There is not very much to it here: in essence, it performs the loops over all mesh refinement cycles, and within each, hands things over to the Newton solver in <code>solve_newton()</code> on the current mesh and calls the function that creates graphical output for the so-computed solution. It then outputs some statistics concerning both run times and memory consumption that has been collected over the course of computations on this mesh.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PlasticityContactProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    computing_timer.reset();</div><div class="line">    <span class="keywordflow">for</span> (; current_refinement_cycle &lt; n_refinement_cycles;</div><div class="line">         ++current_refinement_cycle)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup&quot;</span>);</div><div class="line"></div><div class="line">          pcout &lt;&lt; std::endl;</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; current_refinement_cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (current_refinement_cycle == 0)</div><div class="line">            {</div><div class="line">              make_grid();</div><div class="line">              setup_system();</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: refine mesh&quot;</span>);</div><div class="line">              refine_grid();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        solve_newton();</div><div class="line"></div><div class="line">        output_results(current_refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line"></div><div class="line">        <a class="code" href="structUtilities_1_1System_1_1MemoryStats.html">Utilities::System::MemoryStats</a> stats;</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#a25db0fc07c298b5bef3d6f738283bd6d">Utilities::System::get_memory_stats</a>(stats);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Peak virtual memory used, resident in kB: &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a9cb487ac1831b7e5836be93859c1c2af">VmSize</a></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a39901417b9e6ebfa36d05bfb8a282aa2">VmRSS</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">          output_contact_force();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step42</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>There really isn't much to the <code>main()</code> function. It looks like they always do:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>Step42;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      PlasticityContactProblem&lt;3&gt;::declare_parameters(prm);</div><div class="line">      <span class="keywordflow">if</span> (argc != 2)</div><div class="line">        {</div><div class="line">          std::cerr &lt;&lt; <span class="stringliteral">&quot;*** Call this program as &lt;./step-42 input.prm&gt;&quot;</span></div><div class="line">                    &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(argv[1]);</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line">      {</div><div class="line">        PlasticityContactProblem&lt;3&gt; problem(prm);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-42/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>åå«è¿ä¸ªç¨åºçç®å½è¿åå«ä¸äºè¾å¥åæ°æä»¶ï¼å¯ä»¥ç¨æ¥åå»ºåç§ä¸åçæ¨¡æãä¾å¦ï¼ç¨ <code>p1_adaptive.prm</code> åæ°æä»¶ï¼ç¨çä½ä¸ºéç¢ç©ï¼ç¨çå­ä½ä¸ºé¢åï¼å¨16ä¸ªæ ¸å¿ä¸è¿è¡è¯¥ç¨åºä¼äº§çè¿æ ·çè¾åºã</p>
<div class="fragment"><div class="line">    Using output directory <span class="stringliteral">&#39;p1adaptive/&#39;</span></div><div class="line">    FE degree 1</div><div class="line">    transfer solution <span class="keyword">false</span></div><div class="line"></div><div class="line"></div><div class="line">Cycle 0:</div><div class="line">   Number of active cells: 512</div><div class="line">   Number of degrees of freedom: 2187</div><div class="line"></div><div class="line"></div><div class="line">  Newton iteration 1</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 1</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 173.076 -&gt; 1.64265e-06 in 7 Bicgstab iterations.</div><div class="line">      Accepting Newton solution with residual: 1.64265e-06</div><div class="line"></div><div class="line"></div><div class="line">   Newton iteration 2</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 1</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 57.3622 -&gt; 3.23721e-07 in 8 Bicgstab iterations.</div><div class="line">      Accepting Newton solution with residual: 24.9028</div><div class="line">      Active <span class="keyword">set</span> did not change!</div><div class="line"></div><div class="line"></div><div class="line">   Newton iteration 3</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 1</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 24.9028 -&gt; 9.94326e-08 in 7 Bicgstab iterations.</div><div class="line">      Residual of the non-contact part of the system: 1.63333</div><div class="line">         with a damping parameter alpha = 1</div><div class="line">      Active <span class="keyword">set</span> did not change!</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">  Newton iteration 6</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 1</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 1.43188e-07 -&gt; 3.56218e-16 in 8 Bicgstab iterations.</div><div class="line">      Residual of the non-contact part of the system: 4.298e-14</div><div class="line">         with a damping parameter alpha = 1</div><div class="line">      Active <span class="keyword">set</span> did not change!</div><div class="line">      Writing graphical output... p1_adaptive/solution-00.pvtu</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      1.13s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assembling                      |         6 |     0.463s |        41% |</div><div class="line">| Graphical output                |         1 |    0.0257s |       2.3% |</div><div class="line">| Residual and lambda             |         4 |    0.0754s |       6.7% |</div><div class="line">| Setup                           |         1 |     0.227s |        20% |</div><div class="line">| Setup: constraints              |         1 |    0.0347s |       3.1% |</div><div class="line">| Setup: distribute DoFs          |         1 |    0.0441s |       3.9% |</div><div class="line">| Setup: <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>                   |         1 |    0.0119s |       1.1% |</div><div class="line">| Setup: vectors                  |         1 |   0.00155s |      0.14% |</div><div class="line">| Solve                           |         6 |     0.246s |        22% |</div><div class="line">| Solve: iterate                  |         6 |    0.0631s |       5.6% |</div><div class="line">| Solve: setup preconditioner     |         6 |     0.167s |        15% |</div><div class="line">| update active <span class="keyword">set</span>               |         6 |    0.0401s |       3.6% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line">Peak <span class="keyword">virtual</span> memory used, resident in kB: 541884 77464</div><div class="line">Contact force = 37.3058</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">Cycle 3:</div><div class="line">   Number of active cells: 14652</div><div class="line">   Number of degrees of freedom: 52497</div><div class="line"></div><div class="line"></div><div class="line">   Newton iteration 1</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 145</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 296.309 -&gt; 2.72484e-06 in 10 Bicgstab iterations.</div><div class="line">      Accepting Newton solution with residual: 2.72484e-06</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">   Newton iteration 10</div><div class="line">      Updating active <span class="keyword">set</span>...</div><div class="line">         Size of active <span class="keyword">set</span>: 145</div><div class="line">      Assembling system...</div><div class="line">      Solving system...</div><div class="line">         Error: 2.71541e-07 -&gt; 1.5428e-15 in 27 Bicgstab iterations.</div><div class="line">      Residual of the non-contact part of the system: 1.89261e-13</div><div class="line">         with a damping parameter alpha = 1</div><div class="line">      Active <span class="keyword">set</span> did not change!</div><div class="line">      Writing graphical output... p1_adaptive/solution-03.pvtu</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      38.4s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assembling                      |        10 |      22.5s |        58% |</div><div class="line">| Graphical output                |         1 |     0.327s |      0.85% |</div><div class="line">| Residual and lambda             |         9 |      3.75s |       9.8% |</div><div class="line">| Setup                           |         1 |      4.83s |        13% |</div><div class="line">| Setup: constraints              |         1 |     0.578s |       1.5% |</div><div class="line">| Setup: distribute DoFs          |         1 |      0.71s |       1.8% |</div><div class="line">| Setup: <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>                   |         1 |     0.111s |      0.29% |</div><div class="line">| Setup: <a class="code" href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">refine</a> mesh              |         1 |      4.83s |        13% |</div><div class="line">| Setup: vectors                  |         1 |   0.00548s |     0.014% |</div><div class="line">| Solve                           |        10 |      5.49s |        14% |</div><div class="line">| Solve: iterate                  |        10 |       3.5s |       9.1% |</div><div class="line">| Solve: setup preconditioner     |        10 |      1.84s |       4.8% |</div><div class="line">| update active <span class="keyword">set</span>               |        10 |     0.662s |       1.7% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line">Peak <span class="keyword">virtual</span> memory used, resident in kB: 566052 105788</div><div class="line">Contact force = 56.794</div><div class="line"></div><div class="line"></div><div class="line">...</div></div><!-- fragment --><p>æ¯ä¸ªå¨æç»ææ¶çè¡¨æ ¼æ¾ç¤ºäºæè¿ä¸æ¬¡ç½æ ¼ç»åå¨æçè®¡ç®æ¶é´ï¼è¿äºæ°å­å½ç¶æ¯éå¯¹äº§çè¯¥è¾åºçæºå¨èè¨çï¼åç¨åºä¸åé¨åçè°ç¨æ¬¡æ°ï¼å¦è£éæè®¡ç®æ®å·®ãä¸é¢çä¸äºæ°å­å¯ä»¥éè¿å°è§£å³æ¹æ¡ä»ä¸ä¸ªç½æ ¼è½¬ç§»å°ä¸ä¸ä¸ªç½æ ¼æ¥æ¹åï¼æä»¬å¨è¿éæ²¡æè¡ä½¿è¿ä¸ªéé¡¹ãå½ç¶ï¼ä½ ä¹å¯ä»¥éè¿ä½¿ç¨æ´å¤çå¤çå¨æ¥ä½¿ç¨åºè¿è¡å¾æ´å¿«ï¼ç¹å«æ¯å¨åæçç»åå¨æä¸­ï¼éå¸¦çè®ºææ¾ç¤ºï¼è³å°æ1000ä¸ªåæ ¸çè¯å¥½æ©å±æ§ã</p>
<p>å¨ä¸ä¸ªå¸åçè¿è¡ä¸­ï¼ä½ å¯ä»¥çå°ï¼å¯¹äºæ¯ä¸ä¸ªç»åæ­¥éª¤ï¼æ´»å¨é&ndash;æ¥è§¦ç¹&ndash;é¦åè¢«è¿­ä»£åºæ¥ãä¹åï¼çé¡¿æ¹æ³åªéè¦è§£å³å¡æ§é®é¢ãå¯¹äºæ´ç»çç½æ ¼ï¼å¨æå4æ5æ¬¡çé¡¿è¿­ä»£ä¸­å¯ä»¥çå°äºæ¬¡æ¶æã</p>
<p>æä»¬ä¸ä¼å¨è¿éè¯¦ç»è®¨è®ºæ¯ä¸ªè¾å¥æä»¶çæåµãç¸åï¼è®©æä»¬åªå±ç¤ºè§£å³æ¹æ¡çå¾çï¼å¦æååæ ¼çæ­£äº¤ç¹ä¸ºé¶ï¼å¡æ§ä¸ç­å¼å¤äºæ´»å¨ç¶æï¼ååçå·¦åé¨åè¢«çç¥ï¼ã</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionColorbar.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionBall2.png" width="70%"/>
</div>
  </td><td valign="top">&#160;  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-42.CellConstitutionLi2.png" width="70%"/>
</div>
   </td></tr>
</table>
<p>å¾ä¸­æ¾ç¤ºäºéåºæ§ç»åä»¥åç»èå¨ä¸çæ¥è§¦è¿ç¨ä¸­çå¡åç¨åº¦ãè¯·è®°ä½ï¼æä»¬èèæ¯ä¸ªæ­£äº¤ç¹çåºååå·®é¨åçè§èï¼ä»¥æ¥çæ¯å¦æå¼¹æ§æå¡æ§è¡ä¸ºãèè²æå³çè¿ä¸ªåååªåå«å¼¹æ§æ­£äº¤ç¹ï¼ä¸æææ­£äº¤ç¹é½è¢«å¡åççº¢è²ååç¸åãå¨é¡¶é¢çä¸­é´&ndash;ç½æ ¼æç»çå°æ¹&ndash;éå¸¸ä»ç»å°çå¯ä»¥çå°ç±éç¢ç©å¼èµ·çå¹é·ãè¿æ¯ <code>move_mesh()</code> å½æ°çç»æãç¶èï¼ç±äºæä»¬å¨è¿éèèçéç¢ç©çåçéå¸¸å°ï¼æä»¥å¾é¾è¾¨å«è¿ç§ææï¼æä»¬å¯ä»¥ç©ç©å°ç½æ ¼çé¡¶ç¹æè®¡ç®åºçä½ç§»çåæ°è¿è¡ä½ç§»ã</p>
<p>å³äºä½¿ç¨è¯¥ç¨åºå¯ä»¥è·å¾çç»æçè¿ä¸æ­¥è®¨è®ºï¼è§æ¬é¡µé¢æä¸æ¹æå°çåºçç©ã</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h1>Possibilities for extensions</h1>
<p>åå¾å¸¸ä¸æ ·ï¼æå¤ç§å¯è½æ§æ¥æ©å±è¿ä¸ªç¨åºãä»ç®æ³çè§åº¦æ¥çï¼è¿ä¸ªç¨åºå¨åä½æ¶å·²ç»è¾¾å°äºæä»¬æè½è¾¾å°çç¨åº¦ï¼ä½¿ç¨äºæ¥è§¦ä¸ç­å¼ãå¡æ§éçº¿æ§åçº¿æ§æ±è§£å¨çæä½³å¯ç¨ç®æ³ãç¶èï¼å°±æ´ç°å®çæåµèè¨ï¼äººä»¬å¸æç¨è¿ä¸ªç¨åºåä¸äºäºæã </p><ul>
<li>
<p class="startli">å°ç¨åºä»éææ©å±å°åéææåµï¼ä¹è®¸å¯ä»¥éè¿éæ©ååæ¬§ææ¨¡å¼æ¥å®ç°æ¶é´ç¦»æ£åãä¸äºçè®ºç»æå¯ä»¥å¨JÃ¶rg Frohneçåå£«è®ºæä¸­æ¾å°ï¼<em>FEM-Simulation der Umformtechnik metallischer Oberfl&auml;chen im Mikrokosmos</em>ï¼å¾·å½é¡æ ¹å¤§å­¦ï¼2011ã</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">èèææ©æ¦åçæ¥è§¦é®é¢ä¹å°æ¯ä¸ä¸ªæè¶£çè¿æ­¥ãå¨å ä¹æ¯ä¸ªæºæ¢°è¿ç¨ä¸­ï¼æ©æ¦é½æå¾å¤§çå½±åã ä¸ºäºæ¨¡æè¿ç§æåµï¼æä»¬å¿é¡»èèå°æ¥è§¦é¢çåååºåãæ©æ¦ä¹ç»æä»¬çé®é¢å¢å äºå¦ä¸ä¸ªä¸ç­å¼ï¼å ä¸ºåªè¦åååºåä¸è¶è¿æä¸ªæéï¼èº«ä½åéç¢ç©éå¸¸ä¼ç²å¨ä¸èµ·ï¼è¶è¿è¿ä¸ªæéï¼ä¸¤ä¸ªèº«ä½å°±ä¼äºç¸æ»è¿ã</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">å¦ææä»¬å·²ç»æ¨¡æäºæ©æ¦æ§æ¥è§¦ï¼ä¸ä¸æ­¥è¦èèçæ¯æ¥è§¦åºçåç­ãç±ä¸¤ä¸ªç©ä½ä¹é´çæ©æ¦å¼èµ·çç­éä¼æé«å¯åå½¢ç©ä½çæ¸©åº¦ï¼å¹¶å¯¼è´ä¸äºææåæ°çååã</p>
<p class="endli"></p>
</li>
<li>
å¯¹äºæ¥è§¦ä»¥åå¡æ§ï¼å®æ½æ´ç²¾ç¡®çãä¸é®é¢ç¸éåºçè¯¯å·®ä¼°è®¡å¨å¯è½æ¯ææä¹çã </li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2012 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Joerg Frohne, Texas A&amp;M University and</span></div><div class="line"><span class="comment"> *                        University of Siegen, 2012, 2013</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2012, 2013</span></div><div class="line"><span class="comment"> *          Timo Heister, Texas A&amp;M University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparsity__tools_8h.html">deal.II/lac/sparsity_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__bicgstab_8h.html">deal.II/lac/solver_bicgstab.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__solver_8h.html">deal.II/lac/trilinos_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2tria_8h.html">deal.II/distributed/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2grid__refinement_8h.html">deal.II/distributed/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="distributed_2solution__transfer_8h.html">deal.II/distributed/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__field__function_8h.html">deal.II/numerics/fe_field_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cerrno&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step42</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ConstitutiveLaw</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ConstitutiveLaw(<span class="keyword">const</span> <span class="keywordtype">double</span> E,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> nu,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> sigma_0,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> gamma);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> set_sigma_0(<span class="keywordtype">double</span> sigma_zero);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> get_stress_strain_tensor(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> get_linearized_stress_strain_tensors(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> kappa;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> mu;</div><div class="line">    <span class="keywordtype">double</span>       sigma_0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_kappa;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_mu;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  ConstitutiveLaw&lt;dim&gt;::ConstitutiveLaw(<span class="keywordtype">double</span> E,</div><div class="line">                                        <span class="keywordtype">double</span> nu,</div><div class="line">                                        <span class="keywordtype">double</span> sigma_0,</div><div class="line">                                        <span class="keywordtype">double</span> gamma)</div><div class="line">    : kappa(E / (3 * (1 - 2 * nu)))</div><div class="line">    , mu(E / (2 * (1 + nu)))</div><div class="line">    , sigma_0(sigma_0)</div><div class="line">    , gamma(gamma)</div><div class="line">    , stress_strain_tensor_kappa(kappa *</div><div class="line">                                 <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                               <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()))</div><div class="line">    , stress_strain_tensor_mu(</div><div class="line">        2 * mu *</div><div class="line">        (<a class="code" href="symmetric__tensor_8h.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor</a>&lt;dim&gt;() - <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(<a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;(),</div><div class="line">                                                <a class="code" href="symmetric__tensor_8h.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a>&lt;dim&gt;()) /</div><div class="line">                                    3.0))</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::set_sigma_0(<span class="keywordtype">double</span> sigma_zero)</div><div class="line">  {</div><div class="line">    sigma_0 = sigma_zero;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> ConstitutiveLaw&lt;dim&gt;::get_stress_strain_tensor(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">    stress_tensor =</div><div class="line">      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor =</div><div class="line">      <a class="code" href="symmetric__tensor_8h.html#a022faa691137ee8c1f65dacc47d94a04">deviator</a>(stress_tensor);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">    stress_strain_tensor = stress_strain_tensor_mu;</div><div class="line">    <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">      }</div><div class="line"></div><div class="line">    stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (deviator_stress_tensor_norm &gt; sigma_0);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> ConstitutiveLaw&lt;dim&gt;::get_linearized_stress_strain_tensors(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> &amp;strain_tensor,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor_linearized,</div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> &amp;      stress_strain_tensor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim == 3, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_tensor;</div><div class="line">    stress_tensor =</div><div class="line">      (stress_strain_tensor_kappa + stress_strain_tensor_mu) * strain_tensor;</div><div class="line"></div><div class="line">    stress_strain_tensor            = stress_strain_tensor_mu;</div><div class="line">    stress_strain_tensor_linearized = stress_strain_tensor_mu;</div><div class="line"></div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> deviator_stress_tensor = <a class="code" href="symmetric__tensor_8h.html#a022faa691137ee8c1f65dacc47d94a04">deviator</a>(stress_tensor);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> deviator_stress_tensor_norm = deviator_stress_tensor.<a class="code" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (deviator_stress_tensor_norm &gt; sigma_0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta = sigma_0 / deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">        stress_strain_tensor_linearized *= (gamma + (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta);</div><div class="line">        deviator_stress_tensor /= deviator_stress_tensor_norm;</div><div class="line">        stress_strain_tensor_linearized -=</div><div class="line">          (1 - <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>) * beta * 2 * mu *</div><div class="line">          <a class="code" href="symmetric__tensor_8h.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a>(deviator_stress_tensor, deviator_stress_tensor);</div><div class="line">      }</div><div class="line"></div><div class="line">    stress_strain_tensor += stress_strain_tensor_kappa;</div><div class="line">    stress_strain_tensor_linearized += stress_strain_tensor_kappa;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>EquationData</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BoundaryForce : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BoundaryForce();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BoundaryForce&lt;dim&gt;::BoundaryForce()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BoundaryForce&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> BoundaryForce&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                          Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = BoundaryForce&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BoundaryValues();</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BoundaryValues&lt;dim&gt;::BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0.;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>SphereObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    SphereObstacle&lt;dim&gt;::SphereObstacle(<span class="keyword">const</span> <span class="keywordtype">double</span> z_surface)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">      , z_surface(z_surface)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> SphereObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (component == 0)</div><div class="line">        <span class="keywordflow">return</span> p(0);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 1)</div><div class="line">        <span class="keywordflow">return</span> p(1);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((p(0) - 0.5) * (p(0) - 0.5) + (p(1) - 0.5) * (p(1) - 0.5) &lt; 0.36)</div><div class="line">            <span class="keywordflow">return</span> (-std::sqrt(0.36 - (p(0) - 0.5) * (p(0) - 0.5) -</div><div class="line">                               (p(1) - 0.5) * (p(1) - 0.5)) +</div><div class="line">                    z_surface + 0.59);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">return</span> 1000;</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> SphereObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                           Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SphereObstacle&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>BitmapFile</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BitmapFile(<span class="keyword">const</span> std::string &amp;name);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      std::vector&lt;double&gt; obstacle_data;</div><div class="line">      <span class="keywordtype">double</span>              hx, hy;</div><div class="line">      <span class="keywordtype">int</span>                 nx, ny;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    BitmapFile&lt;dim&gt;::BitmapFile(<span class="keyword">const</span> std::string &amp;name)</div><div class="line">      : obstacle_data(0)</div><div class="line">      , hx(0)</div><div class="line">      , hy(0)</div><div class="line">      , nx(0)</div><div class="line">      , ny(0)</div><div class="line">    {</div><div class="line">      std::ifstream f(name);</div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(f,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(std::string(<span class="stringliteral">&quot;Can&#39;t read from file &lt;&quot;</span>) + name +</div><div class="line">                             <span class="stringliteral">&quot;&gt;!&quot;</span>));</div><div class="line"></div><div class="line">      std::string temp;</div><div class="line">      f &gt;&gt; temp &gt;&gt; nx &gt;&gt; ny;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(nx &gt; 0 &amp;&amp; ny &gt; 0, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid file format.&quot;</span>));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; nx * ny; ++k)</div><div class="line">        {</div><div class="line">          <span class="keywordtype">double</span> val;</div><div class="line">          f &gt;&gt; val;</div><div class="line">          obstacle_data.push_back(val);</div><div class="line">        }</div><div class="line"></div><div class="line">      hx = 1.0 / (nx - 1);</div><div class="line">      hy = 1.0 / (ny - 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD) == 0)</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Read obstacle from file &lt;&quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;Resolution of the scanned obstacle picture: &quot;</span> &lt;&lt; nx</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; x &quot;</span> &lt;&lt; ny &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_pixel_value(<span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      assert(i &gt;= 0 &amp;&amp; i &lt; nx);</div><div class="line">      assert(j &gt;= 0 &amp;&amp; j &lt; ny);</div><div class="line">      <span class="keywordflow">return</span> obstacle_data[nx * (ny - 1 - j) + i];</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> BitmapFile&lt;dim&gt;::get_value(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> ix = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(x / hx), 0), nx - 2);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> iy = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(static_cast&lt;int&gt;(y / hy), 0), ny - 2);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> xi  = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((x - ix * hx) / hx, 1.), 0.);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> eta = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>((y - iy * hy) / hy, 1.), 0.);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> ((1 - xi) * (1 - eta) * get_pixel_value(ix, iy) +</div><div class="line">              xi * (1 - eta) * get_pixel_value(ix + 1, iy) +</div><div class="line">              (1 - xi) * eta * get_pixel_value(ix, iy + 1) +</div><div class="line">              xi * eta * get_pixel_value(ix + 1, iy + 1));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>ChineseObstacle : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename, <span class="keyword">const</span> <span class="keywordtype">double</span> z_surface);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> BitmapFile&lt;dim&gt; input_obstacle;</div><div class="line">      <span class="keywordtype">double</span>                z_surface;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    ChineseObstacle&lt;dim&gt;::ChineseObstacle(<span class="keyword">const</span> std::string &amp;filename,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span>       z_surface)</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim)</div><div class="line">      , input_obstacle(filename)</div><div class="line">      , z_surface(z_surface)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">double</span> ChineseObstacle&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (component == 0)</div><div class="line">        <span class="keywordflow">return</span> p(0);</div><div class="line">      <span class="keywordflow">if</span> (component == 1)</div><div class="line">        <span class="keywordflow">return</span> p(1);</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (component == 2)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> (p(0) &gt;= 0.0 &amp;&amp; p(0) &lt;= 1.0 &amp;&amp; p(1) &gt;= 0.0 &amp;&amp; p(1) &lt;= 1.0)</div><div class="line">            <span class="keywordflow">return</span> z_surface + 0.999 - input_obstacle.get_value(p(0), p(1));</div><div class="line">        }</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">      <span class="keywordflow">return</span> 1e9; <span class="comment">// an unreasonable value; ignored in debug mode because of the</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> ChineseObstacle&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                            Vector&lt;double&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = ChineseObstacle&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace EquationData</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PlasticityContactProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PlasticityContactProblem(<span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm);</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> compute_dirichlet_constraints();</div><div class="line">    <span class="keywordtype">void</span> update_solution_and_constraints();</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">         assemble_mass_matrix_diagonal(TrilinosWrappers::SparseMatrix &amp;mass_matrix);</div><div class="line">    <span class="keywordtype">void</span> assemble_newton_system(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">    <span class="keywordtype">void</span> compute_nonlinear_residual(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point);</div><div class="line">    <span class="keywordtype">void</span> solve_newton_system();</div><div class="line">    <span class="keywordtype">void</span> solve_newton();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> move_mesh(<span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement) <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_contact_force() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classMPI__Comm.html">MPI_Comm</a>           mpi_communicator;</div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                        n_initial_global_refinements;</div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>      fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_hanging_nodes;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints_dirichlet_and_hanging_nodes;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> all_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a>      active_set;</div><div class="line">    Vector&lt;float&gt; fraction_of_plastic_q_points_per_cell;</div><div class="line"></div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix newton_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> newton_rhs_uncondensed;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>         e_modulus, nu, <a class="code" href="namespaceinternal_1_1QGaussLobatto.html#ac1aec52fdbb26c78e2d32fc0bed659c7">gamma</a>, sigma_0;</div><div class="line">    ConstitutiveLaw&lt;dim&gt; constitutive_law;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string                          base_mesh;</div><div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;const Function&lt;dim&gt;&gt; obstacle;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>RefinementStrategy</div><div class="line">    {</div><div class="line">      <span class="keyword">enum</span> value</div><div class="line">      {</div><div class="line">        refine_global,</div><div class="line">        refine_percentage,</div><div class="line">        refine_fix_dofs</div><div class="line">      };</div><div class="line">    };</div><div class="line">    <span class="keyword">typename</span> RefinementStrategy::value refinement_strategy;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>         transfer_solution;</div><div class="line">    std::string        output_dir;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_refinement_cycles;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       current_refinement_cycle;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::declare_parameters(<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">  {</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;polynomial degree&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;1&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">      <span class="stringliteral">&quot;Polynomial degree of the FE_Q finite element space, typically 1 or 2.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of initial refinements&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;2&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Number of initial global mesh refinement steps before &quot;</span></div><div class="line">                      <span class="stringliteral">&quot;the first computation.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;refinement strategy&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;percentage&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;global|percentage&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;Mesh refinement strategy:\n&quot;</span></div><div class="line">      <span class="stringliteral">&quot; global: one global refinement\n&quot;</span></div><div class="line">      <span class="stringliteral">&quot; percentage: a fixed percentage of cells gets refined using the Kelly estimator.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;number of cycles&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(),</div><div class="line">                      <span class="stringliteral">&quot;Number of adaptive mesh refinement cycles to run.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;obstacle&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;sphere&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;sphere|read from file&quot;</span>),</div><div class="line">      <span class="stringliteral">&quot;The name of the obstacle to use. This may either be &#39;sphere&#39; if we should &quot;</span></div><div class="line">      <span class="stringliteral">&quot;use a spherical obstacle, or &#39;read from file&#39; in which case the obstacle &quot;</span></div><div class="line">      <span class="stringliteral">&quot;will be read from a file named &#39;obstacle.pbm&#39; that is supposed to be in &quot;</span></div><div class="line">      <span class="stringliteral">&quot;ASCII PBM format.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;output directory&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">      <span class="stringliteral">&quot;Directory for output files (graphical output and benchmark &quot;</span></div><div class="line">      <span class="stringliteral">&quot;statistics). If empty, use the current directory.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(</div><div class="line">      <span class="stringliteral">&quot;transfer solution&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;false&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Bool.html">Patterns::Bool</a>(),</div><div class="line">      <span class="stringliteral">&quot;Whether the solution should be used as a starting guess &quot;</span></div><div class="line">      <span class="stringliteral">&quot;for the next finer mesh. If false, then the iteration starts at &quot;</span></div><div class="line">      <span class="stringliteral">&quot;zero on every mesh.&quot;</span>);</div><div class="line">    prm.<a class="code" href="classParameterHandler.html#a6d65f458be69e23a348221cb67fc411d">declare_entry</a>(<span class="stringliteral">&quot;base mesh&quot;</span>,</div><div class="line">                      <span class="stringliteral">&quot;box&quot;</span>,</div><div class="line">                      <a class="code" href="classPatterns_1_1Selection.html">Patterns::Selection</a>(<span class="stringliteral">&quot;box|half sphere&quot;</span>),</div><div class="line">                      <span class="stringliteral">&quot;Select the shape of the domain: &#39;box&#39; or &#39;half sphere&#39;&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  PlasticityContactProblem&lt;dim&gt;::PlasticityContactProblem(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</div><div class="line">    : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , pcout(<a class="code" href="namespacestd.html">std</a>::cout,</div><div class="line">            (<a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0))</div><div class="line">    , computing_timer(MPI_COMM_WORLD,</div><div class="line">                      pcout,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::never,</div><div class="line">                      <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line"></div><div class="line">    , n_initial_global_refinements(</div><div class="line">        prm.get_integer(<span class="stringliteral">&quot;number of initial refinements&quot;</span>))</div><div class="line">    , triangulation(mpi_communicator)</div><div class="line">    , fe_degree(prm.get_integer(<span class="stringliteral">&quot;polynomial degree&quot;</span>))</div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(<a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;1&gt;(fe_degree + 1)), dim)</div><div class="line">    , dof_handler(triangulation)</div><div class="line"></div><div class="line">    , e_modulus(200000)</div><div class="line">    , nu(0.3)</div><div class="line">    , gamma(0.01)</div><div class="line">    , sigma_0(400.0)</div><div class="line">    , constitutive_law(e_modulus, nu, sigma_0, gamma)</div><div class="line"></div><div class="line">    , base_mesh(prm.get(<span class="stringliteral">&quot;base mesh&quot;</span>))</div><div class="line">    , obstacle(prm.get(<span class="stringliteral">&quot;obstacle&quot;</span>) == <span class="stringliteral">&quot;read from file&quot;</span> ?</div><div class="line">                 static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                   new EquationData::ChineseObstacle&lt;dim&gt;(</div><div class="line">                     <span class="stringliteral">&quot;obstacle.pbm&quot;</span>,</div><div class="line">                     (base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5))) :</div><div class="line">                 static_cast&lt;const <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; *&gt;(</div><div class="line">                   new EquationData::SphereObstacle&lt;dim&gt;(</div><div class="line">                     base_mesh == <span class="stringliteral">&quot;box&quot;</span> ? 1.0 : 0.5)))</div><div class="line"></div><div class="line">    , transfer_solution(prm.get_bool(<span class="stringliteral">&quot;transfer solution&quot;</span>))</div><div class="line">    , n_refinement_cycles(prm.get_integer(<span class="stringliteral">&quot;number of cycles&quot;</span>))</div><div class="line">    , current_refinement_cycle(0)</div><div class="line"></div><div class="line">  {</div><div class="line">    std::string strat = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;refinement strategy&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">      refinement_strategy = RefinementStrategy::refine_global;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strat == <span class="stringliteral">&quot;percentage&quot;</span>)</div><div class="line">      refinement_strategy = RefinementStrategy::refine_percentage;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    output_dir = prm.<a class="code" href="classParameterHandler.html#a91cfbaca954f444047302446a4e87125">get</a>(<span class="stringliteral">&quot;output directory&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (output_dir != <span class="stringliteral">&quot;&quot;</span> &amp;&amp; *(output_dir.rbegin()) != <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">      output_dir += <span class="stringliteral">&quot;/&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> ierr = mkdir(output_dir.c_str(), 0777);</div><div class="line">        <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(ierr == 0 || errno == EEXIST, <a class="code" href="group__Exceptions.html#gac29b5f3efd2b164642b8e0c49ad3ad27">ExcIO</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    Using output directory &#39;&quot;</span> &lt;&lt; output_dir &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    FE degree &quot;</span> &lt;&lt; fe_degree &lt;&lt; std::endl;</div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;    transfer solution &quot;</span> &lt;&lt; (transfer_solution ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>)</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;3&gt;</a> rotate_half_sphere(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> &amp;in)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> {in(2), in(1), -in(0)};</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;half sphere&quot;</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(0, 0, 0);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>     radius = 0.8;</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">GridGenerator::half_hyper_ball</a>(triangulation, center, radius);</div><div class="line">        triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(&amp;rotate_half_sphere, triangulation);</div><div class="line">        <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5), triangulation);</div><div class="line"></div><div class="line">        <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> manifold_description(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5, 0.5));</div><div class="line">        <a class="code" href="namespaceGridTools.html#aa92034313ef924778e01beb3e24002dd">GridTools::copy_boundary_to_manifold_id</a>(triangulation);</div><div class="line">        triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, manifold_description);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1(0, 0, 0);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p2(1.0, 1.0, 1.0);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">GridGenerator::hyper_rectangle</a>(triangulation, p1, p2);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p2[2]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(1);</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p1[0]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[0] - p2[0]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p1[1]) &lt; 1e-12 ||</div><div class="line">                    <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[1] - p2[1]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(8);</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(face-&gt;center()[2] - p1[2]) &lt; 1e-12)</div><div class="line">                  face-&gt;set_boundary_id(6);</div><div class="line">              }</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(n_initial_global_refinements);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    <span class="comment">/* setup dofs and get index sets for locally owned and relevant dofs */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: distribute DoFs&quot;</span>);</div><div class="line">      dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">      locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">      locally_relevant_dofs.<a class="code" href="classIndexSet.html#a8a3d75a9cba3f1a50866691327aa7609">clear</a>();</div><div class="line">      <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler,</div><div class="line">                                              locally_relevant_dofs);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* setup hanging nodes and Dirichlet constraints */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: constraints&quot;</span>);</div><div class="line">      constraints_hanging_nodes.reinit(locally_relevant_dofs);</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              constraints_hanging_nodes);</div><div class="line">      constraints_hanging_nodes.close();</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      compute_dirichlet_constraints();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* initialization of vectors and the active set */</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: vectors&quot;</span>);</div><div class="line">      solution.reinit(locally_relevant_dofs, mpi_communicator);</div><div class="line">      newton_rhs.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      newton_rhs_uncondensed.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      diag_mass_matrix_vector.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line">      fraction_of_plastic_q_points_per_cell.reinit(</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">      active_set.clear();</div><div class="line">      active_set.set_size(dof_handler.n_dofs());</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>                t(computing_timer, <span class="stringliteral">&quot;Setup: matrix&quot;</span>);</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a> sp(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler,</div><div class="line">                                      sp,</div><div class="line">                                      constraints_dirichlet_and_hanging_nodes,</div><div class="line">                                      <span class="keyword">false</span>,</div><div class="line">                                      <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(</div><div class="line">                                        mpi_communicator));</div><div class="line">      sp.compress();</div><div class="line">      newton_matrix.reinit(sp);</div><div class="line"></div><div class="line"></div><div class="line">      TrilinosWrappers::SparseMatrix &amp;mass_matrix = newton_matrix;</div><div class="line"></div><div class="line">      assemble_mass_matrix_diagonal(mass_matrix);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start = (newton_rhs.local_range().first),</div><div class="line">                         end   = (newton_rhs.local_range().second);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = start; j &lt; <a class="code" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end</a>; ++j)</div><div class="line">        diag_mass_matrix_vector(j) = mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#abe41a4a1feb344a2281a85d138d679ee">diag_element</a>(j);</div><div class="line">      diag_mass_matrix_vector.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">      mass_matrix = 0;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_dirichlet_constraints()</div><div class="line">  {</div><div class="line">    constraints_dirichlet_and_hanging_nodes.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(locally_relevant_dofs);</div><div class="line">    constraints_dirichlet_and_hanging_nodes.merge(constraints_hanging_nodes);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          dof_handler,</div><div class="line">          6,</div><div class="line">          EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">          constraints_dirichlet_and_hanging_nodes,</div><div class="line">          <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> x_displacement(0);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> y_displacement(1);</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          dof_handler,</div><div class="line">          8,</div><div class="line">          EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">          constraints_dirichlet_and_hanging_nodes,</div><div class="line">          (fe.component_mask(x_displacement) |</div><div class="line">           fe.component_mask(y_displacement)));</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        dof_handler,</div><div class="line">        0,</div><div class="line">        EquationData::BoundaryValues&lt;dim&gt;(),</div><div class="line">        constraints_dirichlet_and_hanging_nodes,</div><div class="line">        <a class="code" href="classComponentMask.html">ComponentMask</a>());</div><div class="line"></div><div class="line">    constraints_dirichlet_and_hanging_nodes.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_mass_matrix_diagonal(</div><div class="line">    TrilinosWrappers::SparseMatrix &amp;mass_matrix)</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGaussLobatto.html">QGaussLobatto</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line">              cell_matrix = 0;</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, i) +=</div><div class="line">                    (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                     fe_values_face[displacement].value(i, q_point) *</div><div class="line">                     fe_values_face.JxW(q_point));</div><div class="line"></div><div class="line">              cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#ac2822f0aed012ede4516df69f53d0d13">add</a>(local_dof_indices[i],</div><div class="line">                                local_dof_indices[i],</div><div class="line">                                cell_matrix(i, i));</div><div class="line">            }</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a77ef7c7e43574dacfdbdd6d007708a38">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::update_solution_and_constraints()</div><div class="line">  {</div><div class="line">    std::vector&lt;bool&gt; dof_touched(dof_handler.n_dofs(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line">    distributed_solution = solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = newton_rhs_uncondensed;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> diag_mass_matrix_vector_relevant(</div><div class="line">      locally_relevant_dofs, mpi_communicator);</div><div class="line">    diag_mass_matrix_vector_relevant = diag_mass_matrix_vector;</div><div class="line"></div><div class="line"></div><div class="line">    all_constraints.reinit(locally_relevant_dofs);</div><div class="line">    active_set.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim - 1&gt; face_quadrature(fe.get_unit_face_support_points());</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a>   fe_values_face(fe,</div><div class="line">                                     face_quadrature,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_face   = fe.n_dofs_per_face();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature.size();</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; dof_indices(dofs_per_face);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (!cell-&gt;is_artificial())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line">              face-&gt;get_dof_indices(dof_indices);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component =</div><div class="line">                    fe.face_system_to_component_index(q_point).first;</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_z = dof_indices[q_point];</div><div class="line"></div><div class="line">                  <span class="keywordflow">if</span> ((component == 2) &amp;&amp; (dof_touched[index_z] == <span class="keyword">false</span>))</div><div class="line">                    {</div><div class="line">                      dof_touched[index_z] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> this_support_point =</div><div class="line">                        fe_values_face.quadrature_point(q_point);</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> obstacle_value =</div><div class="line">                        obstacle-&gt;value(this_support_point, 2);</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> solution_here = solution(index_z);</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> undeformed_gap =</div><div class="line">                        obstacle_value - this_support_point(2);</div><div class="line"></div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">double</span> c = 100.0 * e_modulus;</div><div class="line">                      <span class="keywordflow">if</span> ((lambda(index_z) /</div><div class="line">                               diag_mass_matrix_vector_relevant(index_z) +</div><div class="line">                             c * (solution_here - undeformed_gap) &gt;</div><div class="line">                           0) &amp;&amp;</div><div class="line">                          !constraints_hanging_nodes.is_constrained(index_z))</div><div class="line">                        {</div><div class="line">                          all_constraints.add_line(index_z);</div><div class="line">                          all_constraints.set_inhomogeneity(index_z,</div><div class="line">                                                            undeformed_gap);</div><div class="line">                          distributed_solution(index_z) = undeformed_gap;</div><div class="line"></div><div class="line">                          active_set.add_index(index_z);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">    distributed_solution.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    solution = distributed_solution;</div><div class="line"></div><div class="line">    all_constraints.close();</div><div class="line">    all_constraints.merge(constraints_dirichlet_and_hanging_nodes);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;         Size of active set: &quot;</span></div><div class="line">          &lt;&lt; <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set &amp; locally_owned_dofs).n_elements(),</div><div class="line">                                 mpi_communicator)</div><div class="line">          &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::assemble_newton_system(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Assembling&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim));</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          cell_matrix = 0;</div><div class="line">          cell_rhs    = 0;</div><div class="line"></div><div class="line">          std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensor(n_q_points);</div><div class="line">          fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">            linearization_point, strain_tensor);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            {</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor_linearized;</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">              constitutive_law.get_linearized_stress_strain_tensors(</div><div class="line">                strain_tensor[q_point],</div><div class="line">                stress_strain_tensor_linearized,</div><div class="line">                stress_strain_tensor);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2, dim&gt;</a> stress_phi_i =</div><div class="line">                    stress_strain_tensor_linearized *</div><div class="line">                    fe_values[displacement].symmetric_gradient(i, q_point);</div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (stress_phi_i *</div><div class="line">                       fe_values[displacement].symmetric_gradient(j, q_point) *</div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  cell_rhs(i) +=</div><div class="line">                    ((stress_phi_i -</div><div class="line">                      stress_strain_tensor *</div><div class="line">                        fe_values[displacement].symmetric_gradient(i,</div><div class="line">                                                                   q_point)) *</div><div class="line">                     strain_tensor[q_point] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">              {</div><div class="line">                fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">                boundary_force.vector_value_list(</div><div class="line">                  fe_values_face.get_quadrature_points(),</div><div class="line">                  boundary_force_values);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                     ++q_point)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                    rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                         rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          all_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                     cell_rhs,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     newton_matrix,</div><div class="line">                                                     newton_rhs,</div><div class="line">                                                     <span class="keyword">true</span>);</div><div class="line">        }</div><div class="line"></div><div class="line">    newton_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::compute_nonlinear_residual(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;linearization_point)</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell   = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> EquationData::BoundaryForce&lt;dim&gt; boundary_force;</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; boundary_force_values(n_face_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim));</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    newton_rhs             = 0;</div><div class="line">    newton_rhs_uncondensed = 0;</div><div class="line"></div><div class="line">    fraction_of_plastic_q_points_per_cell = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; strain_tensors(n_q_points);</div><div class="line">          fe_values[displacement].get_function_symmetric_gradients(</div><div class="line">            linearization_point, strain_tensors);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            {</div><div class="line">              <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stress_strain_tensor;</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">bool</span>              q_point_is_plastic =</div><div class="line">                constitutive_law.get_stress_strain_tensor(</div><div class="line">                  strain_tensors[q_point], stress_strain_tensor);</div><div class="line">              <span class="keywordflow">if</span> (q_point_is_plastic)</div><div class="line">                ++fraction_of_plastic_q_points_per_cell(</div><div class="line">                  cell-&gt;active_cell_index());</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  cell_rhs(i) -=</div><div class="line">                    (strain_tensors[q_point] * stress_strain_tensor *</div><div class="line">                     fe_values[displacement].symmetric_gradient(i, q_point) *</div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line"></div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                  rhs_values = 0;</div><div class="line">                  cell_rhs(i) += (fe_values[displacement].value(i, q_point) *</div><div class="line">                                  rhs_values * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">            <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">              {</div><div class="line">                fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">                boundary_force.vector_value_list(</div><div class="line">                  fe_values_face.get_quadrature_points(),</div><div class="line">                  boundary_force_values);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                     ++q_point)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> rhs_values;</div><div class="line">                    rhs_values[2] = boundary_force_values[q_point][2];</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      cell_rhs(i) +=</div><div class="line">                        (fe_values_face[displacement].value(i, q_point) *</div><div class="line">                         rhs_values * fe_values_face.JxW(q_point));</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints_dirichlet_and_hanging_nodes.distribute_local_to_global(</div><div class="line">            cell_rhs, local_dof_indices, newton_rhs);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            newton_rhs_uncondensed(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        }</div><div class="line"></div><div class="line">    fraction_of_plastic_q_points_per_cell /= quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    newton_rhs.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    newton_rhs_uncondensed.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line">    distributed_solution = solution;</div><div class="line"></div><div class="line">    constraints_hanging_nodes.set_zero(distributed_solution);</div><div class="line">    constraints_hanging_nodes.set_zero(newton_rhs);</div><div class="line"></div><div class="line">    TrilinosWrappers::PreconditionAMG preconditioner;</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: setup preconditioner&quot;</span>);</div><div class="line"></div><div class="line">      std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(dof_handler,</div><div class="line">                                       <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                       constant_modes);</div><div class="line"></div><div class="line">      <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> additional_data;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a>        = constant_modes;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a852e93b85f68573cd0eedfe62c0f6bdc">elliptic</a>              = <span class="keyword">true</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a4a403dc7faf67ee0fcb6436d7b741687">n_cycles</a>              = 1;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a56500e96ab5ae9b84dd874b38283453b">w_cycle</a>               = <span class="keyword">false</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#ab9fc3e207a7c534094d514685e645c92">output_details</a>        = <span class="keyword">false</span>;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a7bcc5fa85afdb96d90416e7bf182edd0">smoother_sweeps</a>       = 2;</div><div class="line">      additional_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a36b8fa00a7ce0a5ed1ab0cddd41e4f9f">aggregation_threshold</a> = 1e-2;</div><div class="line"></div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionAMG.html#af36504290094ae83e3d0ff50c03d548a">initialize</a>(newton_matrix, additional_data);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Solve: iterate&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> relative_accuracy = 1e-8;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> solver_tolerance =</div><div class="line">        relative_accuracy *</div><div class="line">        newton_matrix.residual(tmp, distributed_solution, newton_rhs);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(newton_matrix.m(), solver_tolerance);</div><div class="line">      <a class="code" href="classSolverBicgstab.html">SolverBicgstab&lt;TrilinosWrappers::MPI::Vector&gt;</a> solver(solver_control);</div><div class="line">      solver.solve(newton_matrix,</div><div class="line">                   distributed_solution,</div><div class="line">                   newton_rhs,</div><div class="line">                   preconditioner);</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;         Error: &quot;</span> &lt;&lt; solver_control.initial_value() &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_value() &lt;&lt; <span class="stringliteral">&quot; in &quot;</span></div><div class="line">            &lt;&lt; solver_control.last_step() &lt;&lt; <span class="stringliteral">&quot; Bicgstab iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    all_constraints.distribute(distributed_solution);</div><div class="line"></div><div class="line">    solution = distributed_solution;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::solve_newton()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_solution(locally_owned_dofs,</div><div class="line">                                               mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> residual(locally_owned_dofs,</div><div class="line">                                           mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp_vector(locally_owned_dofs,</div><div class="line">                                             mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> locally_relevant_tmp_vector(</div><div class="line">      locally_relevant_dofs, mpi_communicator);</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                       mpi_communicator);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> residual_norm;</div><div class="line">    <span class="keywordtype">double</span> previous_residual_norm = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> correct_sigma = sigma_0;</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> old_active_set(active_set);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newton_step = 1; newton_step &lt;= 100; ++newton_step)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (newton_step == 1 &amp;&amp;</div><div class="line">            ((transfer_solution &amp;&amp; current_refinement_cycle == 0) ||</div><div class="line">             !transfer_solution))</div><div class="line">          constitutive_law.set_sigma_0(1e+10);</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newton_step == 2 || current_refinement_cycle &gt; 0 ||</div><div class="line">                 !transfer_solution)</div><div class="line">          constitutive_law.set_sigma_0(correct_sigma);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Newton iteration &quot;</span> &lt;&lt; newton_step &lt;&lt; std::endl;</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Updating active set...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;update active set&quot;</span>);</div><div class="line">          update_solution_and_constraints();</div><div class="line">        }</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Assembling system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">        newton_matrix = 0;</div><div class="line">        newton_rhs    = 0;</div><div class="line">        assemble_newton_system(solution);</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;      Solving system... &quot;</span> &lt;&lt; std::endl;</div><div class="line">        solve_newton_system();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((newton_step == 1) ||</div><div class="line">            (transfer_solution &amp;&amp; newton_step == 2 &amp;&amp;</div><div class="line">             current_refinement_cycle == 0) ||</div><div class="line">            (!transfer_solution &amp;&amp; newton_step == 2))</div><div class="line">          {</div><div class="line">            compute_nonlinear_residual(solution);</div><div class="line">            old_solution = solution;</div><div class="line"></div><div class="line">            residual                     = newton_rhs;</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                               end_res   = (residual.local_range().second);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">              <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">                residual(n) = 0;</div><div class="line"></div><div class="line">            residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">            residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;      Accepting Newton solution with residual: &quot;</span></div><div class="line">                  &lt;&lt; residual_norm &lt;&lt; std::endl;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)</div><div class="line">              {</div><div class="line">                distributed_solution = solution;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.5, static_cast&lt;double&gt;(i));</div><div class="line">                tmp_vector         = old_solution;</div><div class="line">                tmp_vector.sadd(1 - alpha, alpha, distributed_solution);</div><div class="line"></div><div class="line">                <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Residual and lambda&quot;</span>);</div><div class="line"></div><div class="line">                locally_relevant_tmp_vector = tmp_vector;</div><div class="line">                compute_nonlinear_residual(locally_relevant_tmp_vector);</div><div class="line">                residual = newton_rhs;</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (residual.local_range().first),</div><div class="line">                                   end_res   = (residual.local_range().second);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">                  <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">                    residual(n) = 0;</div><div class="line"></div><div class="line">                residual.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">                residual_norm = residual.l2_norm();</div><div class="line"></div><div class="line">                pcout</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;      Residual of the non-contact part of the system: &quot;</span></div><div class="line">                  &lt;&lt; residual_norm &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;         with a damping parameter alpha = &quot;</span> &lt;&lt; alpha</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (residual_norm &lt; previous_residual_norm)</div><div class="line">                  <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            solution     = tmp_vector;</div><div class="line">            old_solution = solution;</div><div class="line">          }</div><div class="line"></div><div class="line">        previous_residual_norm = residual_norm;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>((active_set == old_active_set) ? 0 : 1,</div><div class="line">                                mpi_communicator) == 0)</div><div class="line">          {</div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;      Active set did not change!&quot;</span> &lt;&lt; std::endl;</div><div class="line">            <span class="keywordflow">if</span> (residual_norm &lt; 1e-10)</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line"></div><div class="line">        old_active_set = active_set;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (refinement_strategy == RefinementStrategy::refine_global)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell =</div><div class="line">               triangulation.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">             cell != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>();</div><div class="line">             ++cell)</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">        <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">          dof_handler,</div><div class="line">          <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 2),</div><div class="line">          std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">          solution,</div><div class="line">          estimated_error_per_cell);</div><div class="line"></div><div class="line">        <a class="code" href="namespaceparallel_1_1distributed_1_1GridRefinement.html#aa2ffb707a796ae6dedb75036606ef2e6">parallel::distributed::GridRefinement ::refine_and_coarsen_fixed_number</a>(</div><div class="line">          triangulation, estimated_error_per_cell, 0.3, 0.03);</div><div class="line">      }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a></div><div class="line">      solution_transfer(dof_handler);</div><div class="line">    <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">      solution_transfer.prepare_for_coarsening_and_refinement(solution);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (transfer_solution)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_solution(locally_owned_dofs,</div><div class="line">                                                           mpi_communicator);</div><div class="line">        solution_transfer.interpolate(distributed_solution);</div><div class="line"></div><div class="line">        constraints_hanging_nodes.distribute(distributed_solution);</div><div class="line"></div><div class="line">        solution = distributed_solution;</div><div class="line">        compute_nonlinear_residual(solution);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::move_mesh(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;displacement)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::vector&lt;bool&gt; vertex_touched(triangulation.<a class="code" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a>(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          <span class="keywordflow">if</span> (vertex_touched[cell-&gt;vertex_index(v)] == <span class="keyword">false</span>)</div><div class="line">            {</div><div class="line">              vertex_touched[cell-&gt;vertex_index(v)] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">              <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> vertex_displacement;</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">                vertex_displacement[d] =</div><div class="line">                  displacement(cell-&gt;vertex_dof_index(v, d));</div><div class="line"></div><div class="line">              cell-&gt;vertex(v) += vertex_displacement;</div><div class="line">            }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Graphical output&quot;</span>);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;      Writing graphical output... &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    move_mesh(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                       end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">      <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">        distributed_lambda(n) =</div><div class="line">          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = distributed_lambda;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_active_set_vector(</div><div class="line">      locally_owned_dofs, mpi_communicator);</div><div class="line">    distributed_active_set_vector = 0.;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> index : active_set)</div><div class="line">      distributed_active_set_vector[index] = 1.;</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> active_set_vector(locally_relevant_dofs,</div><div class="line">                                                    mpi_communicator);</div><div class="line">    active_set_vector = distributed_active_set_vector;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;displacement&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;contact_force&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(active_set_vector,</div><div class="line">                             std::vector&lt;std::string&gt;(dim, <span class="stringliteral">&quot;active_set&quot;</span>),</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i)</div><div class="line">      subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>();</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(fraction_of_plastic_q_points_per_cell,</div><div class="line">                             <span class="stringliteral">&quot;fraction_of_plastic_q_points&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string pvtu_filename = data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">      output_dir, <span class="stringliteral">&quot;solution&quot;</span>, current_refinement_cycle, mpi_communicator, 2);</div><div class="line">    pcout &lt;&lt; pvtu_filename &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp(solution);</div><div class="line">    tmp *= -1;</div><div class="line">    move_mesh(tmp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> PlasticityContactProblem&lt;dim&gt;::output_contact_force()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> distributed_lambda(locally_owned_dofs,</div><div class="line">                                                     mpi_communicator);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> start_res = (newton_rhs_uncondensed.local_range().first),</div><div class="line">                       end_res = (newton_rhs_uncondensed.local_range().second);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = start_res; n &lt; end_res; ++n)</div><div class="line">      <span class="keywordflow">if</span> (all_constraints.is_inhomogeneously_constrained(n))</div><div class="line">        distributed_lambda(n) =</div><div class="line">          newton_rhs_uncondensed(n) / diag_mass_matrix_vector(n);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        distributed_lambda(n) = 0;</div><div class="line">    distributed_lambda.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">    constraints_hanging_nodes.distribute(distributed_lambda);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> lambda(locally_relevant_dofs,</div><div class="line">                                         mpi_communicator);</div><div class="line">    lambda = distributed_lambda;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> contact_force = 0.0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt;   face_quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_values_face(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary() &amp;&amp; face-&gt;boundary_id() == 1)</div><div class="line">            {</div><div class="line">              fe_values_face.reinit(cell, face);</div><div class="line"></div><div class="line">              std::vector&lt;Tensor&lt;1, dim&gt;&gt; lambda_values(n_face_q_points);</div><div class="line">              fe_values_face[displacement].get_function_values(lambda,</div><div class="line">                                                               lambda_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_face_q_points;</div><div class="line">                   ++q_point)</div><div class="line">                contact_force +=</div><div class="line">                  lambda_values[q_point][2] * fe_values_face.JxW(q_point);</div><div class="line">            }</div><div class="line">    contact_force = <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a>(contact_force, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Contact force = &quot;</span> &lt;&lt; contact_force &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">PlasticityContactProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    computing_timer.reset();</div><div class="line">    <span class="keywordflow">for</span> (; current_refinement_cycle &lt; n_refinement_cycles;</div><div class="line">         ++current_refinement_cycle)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup&quot;</span>);</div><div class="line"></div><div class="line">          pcout &lt;&lt; std::endl;</div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; current_refinement_cycle &lt;&lt; <span class="charliteral">&#39;:&#39;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (current_refinement_cycle == 0)</div><div class="line">            {</div><div class="line">              make_grid();</div><div class="line">              setup_system();</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;Setup: refine mesh&quot;</span>);</div><div class="line">              refine_grid();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        solve_newton();</div><div class="line"></div><div class="line">        output_results(current_refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.print_summary();</div><div class="line">        computing_timer.reset();</div><div class="line"></div><div class="line">        <a class="code" href="structUtilities_1_1System_1_1MemoryStats.html">Utilities::System::MemoryStats</a> stats;</div><div class="line">        <a class="code" href="namespaceUtilities_1_1System.html#a25db0fc07c298b5bef3d6f738283bd6d">Utilities::System::get_memory_stats</a>(stats);</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Peak virtual memory used, resident in kB: &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a9cb487ac1831b7e5836be93859c1c2af">VmSize</a></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; stats.<a class="code" href="structUtilities_1_1System_1_1MemoryStats.html#a39901417b9e6ebfa36d05bfb8a282aa2">VmRSS</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (base_mesh == <span class="stringliteral">&quot;box&quot;</span>)</div><div class="line">          output_contact_force();</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step42</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">  <span class="keyword">using namespace </span>Step42;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <a class="code" href="classParameterHandler.html">ParameterHandler</a> prm;</div><div class="line">      PlasticityContactProblem&lt;3&gt;::declare_parameters(prm);</div><div class="line">      <span class="keywordflow">if</span> (argc != 2)</div><div class="line">        {</div><div class="line">          std::cerr &lt;&lt; <span class="stringliteral">&quot;*** Call this program as &lt;./step-42 input.prm&gt;&quot;</span></div><div class="line">                    &lt;&lt; std::endl;</div><div class="line">          <span class="keywordflow">return</span> 1;</div><div class="line">        }</div><div class="line"></div><div class="line">      prm.<a class="code" href="classParameterHandler.html#a0ddaa05c5463c6c0b7701e18005717a9">parse_input</a>(argv[1]);</div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line">      {</div><div class="line">        PlasticityContactProblem&lt;3&gt; problem(prm);</div><div class="line">        problem.run();</div><div class="line">      }</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
